{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","lib/Modeler.js","lib/NavigatedViewer.js","lib/Viewer.js","lib/core/index.js","lib/draw/PathMap.js","lib/draw/VdmlRenderer.js","lib/draw/index.js","lib/features/auto-resize/VdmlAutoResize.js","lib/features/auto-resize/VdmlAutoResizeProvider.js","lib/features/auto-resize/index.js","lib/features/context-pad/ContextPadProvider.js","lib/features/context-pad/index.js","lib/features/copy-paste/VdmlCopyPaste.js","lib/features/copy-paste/index.js","lib/features/distribute-elements/VdmlDistributeElements.js","lib/features/distribute-elements/index.js","lib/features/editor-actions/VdmlEditorActions.js","lib/features/editor-actions/index.js","lib/features/global-connect/VdmlGlobalConnect.js","lib/features/global-connect/index.js","lib/features/keyboard/VdmlKeyBindings.js","lib/features/keyboard/index.js","lib/features/label-editing/LabelEditingProvider.js","lib/features/label-editing/LabelUtil.js","lib/features/label-editing/cmd/UpdateLabelHandler.js","lib/features/label-editing/index.js","lib/features/modeling/ElementFactory.js","lib/features/modeling/Modeling.js","lib/features/modeling/VdmlFactory.js","lib/features/modeling/VdmlLayouter.js","lib/features/modeling/VdmlUpdater.js","lib/features/modeling/behavior/AppendBehavior.js","lib/features/modeling/behavior/CopyPasteBehavior.js","lib/features/modeling/behavior/CreateBoundaryEventBehavior.js","lib/features/modeling/behavior/CreateDataObjectBehavior.js","lib/features/modeling/behavior/CreateOnFlowBehavior.js","lib/features/modeling/behavior/CreateParticipantBehavior.js","lib/features/modeling/behavior/DataInputAssociationBehavior.js","lib/features/modeling/behavior/DeleteLaneBehavior.js","lib/features/modeling/behavior/ImportDockingFix.js","lib/features/modeling/behavior/LabelBehavior.js","lib/features/modeling/behavior/ModelingFeedback.js","lib/features/modeling/behavior/RemoveElementBehavior.js","lib/features/modeling/behavior/RemoveParticipantBehavior.js","lib/features/modeling/behavior/ReplaceConnectionBehavior.js","lib/features/modeling/behavior/ReplaceElementBehaviour.js","lib/features/modeling/behavior/ResizeLaneBehavior.js","lib/features/modeling/behavior/ToggleElementCollapseBehaviour.js","lib/features/modeling/behavior/UnclaimIdBehavior.js","lib/features/modeling/behavior/UnsetDefaultFlowBehavior.js","lib/features/modeling/behavior/UpdateFlowNodeRefsBehavior.js","lib/features/modeling/behavior/index.js","lib/features/modeling/behavior/util/GeometricUtil.js","lib/features/modeling/behavior/util/LabelLayoutUtil.js","lib/features/modeling/behavior/util/LineAttachmentUtil.js","lib/features/modeling/behavior/util/LineIntersect.js","lib/features/modeling/cmd/AddLaneHandler.js","lib/features/modeling/cmd/IdClaimHandler.js","lib/features/modeling/cmd/ResizeLaneHandler.js","lib/features/modeling/cmd/SplitLaneHandler.js","lib/features/modeling/cmd/UpdateCanvasRootHandler.js","lib/features/modeling/cmd/UpdateFlowNodeRefsHandler.js","lib/features/modeling/cmd/UpdatePropertiesHandler.js","lib/features/modeling/index.js","lib/features/modeling/util/LaneUtil.js","lib/features/modeling/util/ModelingUtil.js","lib/features/ordering/VdmlOrderingProvider.js","lib/features/ordering/index.js","lib/features/palette/PaletteProvider.js","lib/features/palette/index.js","lib/features/popup-menu/ReplaceMenuProvider.js","lib/features/popup-menu/index.js","lib/features/popup-menu/util/TypeUtil.js","lib/features/replace-preview/VdmlReplacePreview.js","lib/features/replace-preview/index.js","lib/features/replace/ReplaceOptions.js","lib/features/replace/VdmlReplace.js","lib/features/replace/index.js","lib/features/rules/VdmlRules.js","lib/features/rules/index.js","lib/features/search/VdmlSearchProvider.js","lib/features/search/index.js","lib/features/snapping/VdmlSnapping.js","lib/features/snapping/VdmlSnappingUtil.js","lib/features/snapping/index.js","lib/import/Importer.js","lib/import/Util.js","lib/import/VdmlImporter.js","lib/import/VdmlTreeWalker.js","lib/import/index.js","lib/util/DiUtil.js","lib/util/LabelUtil.js","lib/util/ModelUtil.js","lib/util/PoweredByUtil.js","node_modules/diagram-js-direct-editing/index.js","node_modules/diagram-js-direct-editing/lib/DirectEditing.js","node_modules/diagram-js-direct-editing/lib/TextBox.js","node_modules/diagram-js/index.js","node_modules/diagram-js/lib/Diagram.js","node_modules/diagram-js/lib/command/CommandInterceptor.js","node_modules/diagram-js/lib/command/CommandStack.js","node_modules/diagram-js/lib/command/index.js","node_modules/diagram-js/lib/core/Canvas.js","node_modules/diagram-js/lib/core/ElementFactory.js","node_modules/diagram-js/lib/core/ElementRegistry.js","node_modules/diagram-js/lib/core/EventBus.js","node_modules/diagram-js/lib/core/GraphicsFactory.js","node_modules/diagram-js/lib/core/index.js","node_modules/diagram-js/lib/draw/BaseRenderer.js","node_modules/diagram-js/lib/draw/DefaultRenderer.js","node_modules/diagram-js/lib/draw/Styles.js","node_modules/diagram-js/lib/draw/index.js","node_modules/diagram-js/lib/features/align-elements/AlignElements.js","node_modules/diagram-js/lib/features/align-elements/index.js","node_modules/diagram-js/lib/features/attach-support/AttachSupport.js","node_modules/diagram-js/lib/features/attach-support/index.js","node_modules/diagram-js/lib/features/auto-resize/AutoResize.js","node_modules/diagram-js/lib/features/auto-resize/AutoResizeProvider.js","node_modules/diagram-js/lib/features/auto-scroll/AutoScroll.js","node_modules/diagram-js/lib/features/auto-scroll/index.js","node_modules/diagram-js/lib/features/bendpoints/BendpointMove.js","node_modules/diagram-js/lib/features/bendpoints/BendpointSnapping.js","node_modules/diagram-js/lib/features/bendpoints/BendpointUtil.js","node_modules/diagram-js/lib/features/bendpoints/Bendpoints.js","node_modules/diagram-js/lib/features/bendpoints/ConnectionSegmentMove.js","node_modules/diagram-js/lib/features/bendpoints/index.js","node_modules/diagram-js/lib/features/change-support/ChangeSupport.js","node_modules/diagram-js/lib/features/change-support/index.js","node_modules/diagram-js/lib/features/clipboard/Clipboard.js","node_modules/diagram-js/lib/features/clipboard/index.js","node_modules/diagram-js/lib/features/connect/Connect.js","node_modules/diagram-js/lib/features/connect/index.js","node_modules/diagram-js/lib/features/context-pad/ContextPad.js","node_modules/diagram-js/lib/features/context-pad/index.js","node_modules/diagram-js/lib/features/copy-paste/CopyPaste.js","node_modules/diagram-js/lib/features/copy-paste/index.js","node_modules/diagram-js/lib/features/create/Create.js","node_modules/diagram-js/lib/features/create/index.js","node_modules/diagram-js/lib/features/distribute-elements/DistributeElements.js","node_modules/diagram-js/lib/features/distribute-elements/index.js","node_modules/diagram-js/lib/features/dragging/Dragging.js","node_modules/diagram-js/lib/features/dragging/HoverFix.js","node_modules/diagram-js/lib/features/dragging/index.js","node_modules/diagram-js/lib/features/editor-actions/EditorActions.js","node_modules/diagram-js/lib/features/editor-actions/index.js","node_modules/diagram-js/lib/features/global-connect/GlobalConnect.js","node_modules/diagram-js/lib/features/global-connect/index.js","node_modules/diagram-js/lib/features/hand-tool/HandTool.js","node_modules/diagram-js/lib/features/hand-tool/index.js","node_modules/diagram-js/lib/features/interaction-events/InteractionEvents.js","node_modules/diagram-js/lib/features/interaction-events/index.js","node_modules/diagram-js/lib/features/keyboard/Keyboard.js","node_modules/diagram-js/lib/features/keyboard/index.js","node_modules/diagram-js/lib/features/label-support/LabelSupport.js","node_modules/diagram-js/lib/features/label-support/index.js","node_modules/diagram-js/lib/features/lasso-tool/LassoTool.js","node_modules/diagram-js/lib/features/lasso-tool/index.js","node_modules/diagram-js/lib/features/modeling/Modeling.js","node_modules/diagram-js/lib/features/modeling/cmd/AlignElementsHandler.js","node_modules/diagram-js/lib/features/modeling/cmd/AppendShapeHandler.js","node_modules/diagram-js/lib/features/modeling/cmd/CreateConnectionHandler.js","node_modules/diagram-js/lib/features/modeling/cmd/CreateLabelHandler.js","node_modules/diagram-js/lib/features/modeling/cmd/CreateShapeHandler.js","node_modules/diagram-js/lib/features/modeling/cmd/DeleteConnectionHandler.js","node_modules/diagram-js/lib/features/modeling/cmd/DeleteElementsHandler.js","node_modules/diagram-js/lib/features/modeling/cmd/DeleteShapeHandler.js","node_modules/diagram-js/lib/features/modeling/cmd/DistributeElementsHandler.js","node_modules/diagram-js/lib/features/modeling/cmd/LayoutConnectionHandler.js","node_modules/diagram-js/lib/features/modeling/cmd/MoveConnectionHandler.js","node_modules/diagram-js/lib/features/modeling/cmd/MoveElementsHandler.js","node_modules/diagram-js/lib/features/modeling/cmd/MoveShapeHandler.js","node_modules/diagram-js/lib/features/modeling/cmd/NoopHandler.js","node_modules/diagram-js/lib/features/modeling/cmd/PasteHandler.js","node_modules/diagram-js/lib/features/modeling/cmd/ReconnectConnectionHandler.js","node_modules/diagram-js/lib/features/modeling/cmd/ReplaceShapeHandler.js","node_modules/diagram-js/lib/features/modeling/cmd/ResizeShapeHandler.js","node_modules/diagram-js/lib/features/modeling/cmd/SpaceToolHandler.js","node_modules/diagram-js/lib/features/modeling/cmd/ToggleShapeCollapseHandler.js","node_modules/diagram-js/lib/features/modeling/cmd/UpdateAttachmentHandler.js","node_modules/diagram-js/lib/features/modeling/cmd/UpdateWaypointsHandler.js","node_modules/diagram-js/lib/features/modeling/cmd/helper/AnchorsHelper.js","node_modules/diagram-js/lib/features/modeling/cmd/helper/MoveHelper.js","node_modules/diagram-js/lib/features/mouse-tracking/MouseTracking.js","node_modules/diagram-js/lib/features/mouse-tracking/index.js","node_modules/diagram-js/lib/features/move/Move.js","node_modules/diagram-js/lib/features/move/MovePreview.js","node_modules/diagram-js/lib/features/move/index.js","node_modules/diagram-js/lib/features/ordering/OrderingProvider.js","node_modules/diagram-js/lib/features/outline/Outline.js","node_modules/diagram-js/lib/features/outline/index.js","node_modules/diagram-js/lib/features/overlays/Overlays.js","node_modules/diagram-js/lib/features/overlays/index.js","node_modules/diagram-js/lib/features/palette/Palette.js","node_modules/diagram-js/lib/features/palette/index.js","node_modules/diagram-js/lib/features/popup-menu/PopupMenu.js","node_modules/diagram-js/lib/features/popup-menu/index.js","node_modules/diagram-js/lib/features/preview-support/PreviewSupport.js","node_modules/diagram-js/lib/features/preview-support/index.js","node_modules/diagram-js/lib/features/replace/Replace.js","node_modules/diagram-js/lib/features/replace/index.js","node_modules/diagram-js/lib/features/resize/Resize.js","node_modules/diagram-js/lib/features/resize/ResizeHandles.js","node_modules/diagram-js/lib/features/resize/ResizePreview.js","node_modules/diagram-js/lib/features/resize/ResizeUtil.js","node_modules/diagram-js/lib/features/resize/index.js","node_modules/diagram-js/lib/features/rules/RuleProvider.js","node_modules/diagram-js/lib/features/rules/Rules.js","node_modules/diagram-js/lib/features/rules/index.js","node_modules/diagram-js/lib/features/search-pad/SearchPad.js","node_modules/diagram-js/lib/features/search-pad/index.js","node_modules/diagram-js/lib/features/selection/Selection.js","node_modules/diagram-js/lib/features/selection/SelectionBehavior.js","node_modules/diagram-js/lib/features/selection/SelectionVisuals.js","node_modules/diagram-js/lib/features/selection/index.js","node_modules/diagram-js/lib/features/snapping/SnapContext.js","node_modules/diagram-js/lib/features/snapping/SnapUtil.js","node_modules/diagram-js/lib/features/snapping/Snapping.js","node_modules/diagram-js/lib/features/space-tool/SpaceTool.js","node_modules/diagram-js/lib/features/space-tool/SpaceToolPreview.js","node_modules/diagram-js/lib/features/space-tool/SpaceUtil.js","node_modules/diagram-js/lib/features/space-tool/index.js","node_modules/diagram-js/lib/features/tool-manager/ToolManager.js","node_modules/diagram-js/lib/features/tool-manager/index.js","node_modules/diagram-js/lib/features/tooltips/Tooltips.js","node_modules/diagram-js/lib/features/tooltips/index.js","node_modules/diagram-js/lib/features/touch/TouchFix.js","node_modules/diagram-js/lib/features/touch/TouchInteractionEvents.js","node_modules/diagram-js/lib/features/touch/index.js","node_modules/diagram-js/lib/i18n/translate/index.js","node_modules/diagram-js/lib/i18n/translate/translate.js","node_modules/diagram-js/lib/layout/BaseLayouter.js","node_modules/diagram-js/lib/layout/CroppingConnectionDocking.js","node_modules/diagram-js/lib/layout/LayoutUtil.js","node_modules/diagram-js/lib/layout/ManhattanLayout.js","node_modules/diagram-js/lib/model/index.js","node_modules/diagram-js/lib/navigation/movecanvas/MoveCanvas.js","node_modules/diagram-js/lib/navigation/movecanvas/index.js","node_modules/diagram-js/lib/navigation/touch/index.js","node_modules/diagram-js/lib/navigation/zoomscroll/ZoomScroll.js","node_modules/diagram-js/lib/navigation/zoomscroll/ZoomUtil.js","node_modules/diagram-js/lib/navigation/zoomscroll/index.js","node_modules/diagram-js/lib/util/AttachUtil.js","node_modules/diagram-js/lib/util/ClickTrap.js","node_modules/diagram-js/lib/util/Collections.js","node_modules/diagram-js/lib/util/CopyPasteUtil.js","node_modules/diagram-js/lib/util/Cursor.js","node_modules/diagram-js/lib/util/Elements.js","node_modules/diagram-js/lib/util/Event.js","node_modules/diagram-js/lib/util/Geometry.js","node_modules/diagram-js/lib/util/GraphicsUtil.js","node_modules/diagram-js/lib/util/IdGenerator.js","node_modules/diagram-js/lib/util/LineIntersection.js","node_modules/diagram-js/lib/util/Math.js","node_modules/diagram-js/lib/util/Mouse.js","node_modules/diagram-js/lib/util/Platform.js","node_modules/diagram-js/lib/util/PositionUtil.js","node_modules/diagram-js/lib/util/Removal.js","node_modules/diagram-js/lib/util/RenderUtil.js","node_modules/diagram-js/lib/util/Text.js","node_modules/diagram-js/node_modules/didi/lib/annotation.js","node_modules/diagram-js/node_modules/didi/lib/index.js","node_modules/diagram-js/node_modules/didi/lib/injector.js","node_modules/diagram-js/node_modules/didi/lib/module.js","node_modules/diagram-js/node_modules/eve/eve.js","node_modules/diagram-js/node_modules/hammerjs/hammer.js","node_modules/diagram-js/node_modules/snapsvg/dist/snap.svg.js","node_modules/diagram-js/vendor/snapsvg.js","node_modules/ids/index.js","node_modules/ids/node_modules/hat/index.js","node_modules/inherits/inherits_browser.js","node_modules/lodash/array/findIndex.js","node_modules/lodash/array/flatten.js","node_modules/lodash/array/last.js","node_modules/lodash/array/union.js","node_modules/lodash/array/uniq.js","node_modules/lodash/array/unique.js","node_modules/lodash/array/without.js","node_modules/lodash/chain/lodash.js","node_modules/lodash/collection/any.js","node_modules/lodash/collection/every.js","node_modules/lodash/collection/filter.js","node_modules/lodash/collection/find.js","node_modules/lodash/collection/forEach.js","node_modules/lodash/collection/groupBy.js","node_modules/lodash/collection/includes.js","node_modules/lodash/collection/map.js","node_modules/lodash/collection/reduce.js","node_modules/lodash/collection/reject.js","node_modules/lodash/collection/size.js","node_modules/lodash/collection/some.js","node_modules/lodash/collection/sortBy.js","node_modules/lodash/date/now.js","node_modules/lodash/function/bind.js","node_modules/lodash/function/debounce.js","node_modules/lodash/function/restParam.js","node_modules/lodash/internal/LazyWrapper.js","node_modules/lodash/internal/LodashWrapper.js","node_modules/lodash/internal/SetCache.js","node_modules/lodash/internal/arrayCopy.js","node_modules/lodash/internal/arrayEach.js","node_modules/lodash/internal/arrayEvery.js","node_modules/lodash/internal/arrayFilter.js","node_modules/lodash/internal/arrayMap.js","node_modules/lodash/internal/arrayPush.js","node_modules/lodash/internal/arrayReduce.js","node_modules/lodash/internal/arraySome.js","node_modules/lodash/internal/assignWith.js","node_modules/lodash/internal/baseAssign.js","node_modules/lodash/internal/baseCallback.js","node_modules/lodash/internal/baseClone.js","node_modules/lodash/internal/baseCompareAscending.js","node_modules/lodash/internal/baseCopy.js","node_modules/lodash/internal/baseCreate.js","node_modules/lodash/internal/baseDifference.js","node_modules/lodash/internal/baseEach.js","node_modules/lodash/internal/baseEvery.js","node_modules/lodash/internal/baseFilter.js","node_modules/lodash/internal/baseFind.js","node_modules/lodash/internal/baseFindIndex.js","node_modules/lodash/internal/baseFlatten.js","node_modules/lodash/internal/baseFor.js","node_modules/lodash/internal/baseForIn.js","node_modules/lodash/internal/baseForOwn.js","node_modules/lodash/internal/baseGet.js","node_modules/lodash/internal/baseIndexOf.js","node_modules/lodash/internal/baseIsEqual.js","node_modules/lodash/internal/baseIsEqualDeep.js","node_modules/lodash/internal/baseIsMatch.js","node_modules/lodash/internal/baseLodash.js","node_modules/lodash/internal/baseMap.js","node_modules/lodash/internal/baseMatches.js","node_modules/lodash/internal/baseMatchesProperty.js","node_modules/lodash/internal/baseMerge.js","node_modules/lodash/internal/baseMergeDeep.js","node_modules/lodash/internal/baseProperty.js","node_modules/lodash/internal/basePropertyDeep.js","node_modules/lodash/internal/baseReduce.js","node_modules/lodash/internal/baseSetData.js","node_modules/lodash/internal/baseSlice.js","node_modules/lodash/internal/baseSome.js","node_modules/lodash/internal/baseSortBy.js","node_modules/lodash/internal/baseToString.js","node_modules/lodash/internal/baseUniq.js","node_modules/lodash/internal/baseValues.js","node_modules/lodash/internal/bindCallback.js","node_modules/lodash/internal/bufferClone.js","node_modules/lodash/internal/cacheIndexOf.js","node_modules/lodash/internal/cachePush.js","node_modules/lodash/internal/compareAscending.js","node_modules/lodash/internal/composeArgs.js","node_modules/lodash/internal/composeArgsRight.js","node_modules/lodash/internal/createAggregator.js","node_modules/lodash/internal/createAssigner.js","node_modules/lodash/internal/createBaseEach.js","node_modules/lodash/internal/createBaseFor.js","node_modules/lodash/internal/createBindWrapper.js","node_modules/lodash/internal/createCache.js","node_modules/lodash/internal/createCtorWrapper.js","node_modules/lodash/internal/createFind.js","node_modules/lodash/internal/createFindIndex.js","node_modules/lodash/internal/createForEach.js","node_modules/lodash/internal/createHybridWrapper.js","node_modules/lodash/internal/createPartialWrapper.js","node_modules/lodash/internal/createReduce.js","node_modules/lodash/internal/createWrapper.js","node_modules/lodash/internal/equalArrays.js","node_modules/lodash/internal/equalByTag.js","node_modules/lodash/internal/equalObjects.js","node_modules/lodash/internal/getData.js","node_modules/lodash/internal/getFuncName.js","node_modules/lodash/internal/getLength.js","node_modules/lodash/internal/getMatchData.js","node_modules/lodash/internal/getNative.js","node_modules/lodash/internal/indexOfNaN.js","node_modules/lodash/internal/initCloneArray.js","node_modules/lodash/internal/initCloneByTag.js","node_modules/lodash/internal/initCloneObject.js","node_modules/lodash/internal/isArrayLike.js","node_modules/lodash/internal/isIndex.js","node_modules/lodash/internal/isIterateeCall.js","node_modules/lodash/internal/isKey.js","node_modules/lodash/internal/isLaziable.js","node_modules/lodash/internal/isLength.js","node_modules/lodash/internal/isObjectLike.js","node_modules/lodash/internal/isStrictComparable.js","node_modules/lodash/internal/mergeData.js","node_modules/lodash/internal/metaMap.js","node_modules/lodash/internal/pickByArray.js","node_modules/lodash/internal/pickByCallback.js","node_modules/lodash/internal/realNames.js","node_modules/lodash/internal/reorder.js","node_modules/lodash/internal/replaceHolders.js","node_modules/lodash/internal/setData.js","node_modules/lodash/internal/shimKeys.js","node_modules/lodash/internal/sortedUniq.js","node_modules/lodash/internal/toObject.js","node_modules/lodash/internal/toPath.js","node_modules/lodash/internal/wrapperClone.js","node_modules/lodash/lang/clone.js","node_modules/lodash/lang/isArguments.js","node_modules/lodash/lang/isArray.js","node_modules/lodash/lang/isFunction.js","node_modules/lodash/lang/isNative.js","node_modules/lodash/lang/isNumber.js","node_modules/lodash/lang/isObject.js","node_modules/lodash/lang/isPlainObject.js","node_modules/lodash/lang/isString.js","node_modules/lodash/lang/isTypedArray.js","node_modules/lodash/lang/toPlainObject.js","node_modules/lodash/object/assign.js","node_modules/lodash/object/has.js","node_modules/lodash/object/keys.js","node_modules/lodash/object/keysIn.js","node_modules/lodash/object/merge.js","node_modules/lodash/object/omit.js","node_modules/lodash/object/pairs.js","node_modules/lodash/object/pick.js","node_modules/lodash/object/transform.js","node_modules/lodash/object/values.js","node_modules/lodash/utility/identity.js","node_modules/lodash/utility/noop.js","node_modules/lodash/utility/property.js","node_modules/min-dom/lib/attr.js","node_modules/min-dom/lib/classes.js","node_modules/min-dom/lib/clear.js","node_modules/min-dom/lib/closest.js","node_modules/min-dom/lib/delegate.js","node_modules/min-dom/lib/domify.js","node_modules/min-dom/lib/event.js","node_modules/min-dom/lib/matches.js","node_modules/min-dom/lib/query.js","node_modules/min-dom/lib/remove.js","node_modules/min-dom/node_modules/component-classes/index.js","node_modules/min-dom/node_modules/component-classes/node_modules/component-indexof/index.js","node_modules/min-dom/node_modules/component-closest/index.js","node_modules/min-dom/node_modules/component-delegate/index.js","node_modules/min-dom/node_modules/component-event/index.js","node_modules/min-dom/node_modules/component-matches-selector/index.js","node_modules/min-dom/node_modules/component-query/index.js","node_modules/min-dom/node_modules/domify/index.js","node_modules/object-refs/index.js","node_modules/object-refs/lib/collection.js","node_modules/object-refs/lib/refs.js","node_modules/vdml-moddle/index.js","node_modules/vdml-moddle/lib/simple.js","node_modules/vdml-moddle/lib/vdml-moddle.js","node_modules/vdml-moddle/node_modules/lodash/function/defer.js","node_modules/vdml-moddle/node_modules/lodash/internal/baseDelay.js","node_modules/vdml-moddle/node_modules/moddle-xml/lib/common.js","node_modules/vdml-moddle/node_modules/moddle-xml/lib/reader.js","node_modules/vdml-moddle/node_modules/moddle-xml/lib/writer.js","node_modules/vdml-moddle/node_modules/moddle-xml/node_modules/sax/lib/sax.js","node_modules/vdml-moddle/node_modules/moddle-xml/node_modules/tiny-stack/lib/tiny-stack.js","node_modules/vdml-moddle/node_modules/moddle/index.js","node_modules/vdml-moddle/node_modules/moddle/lib/base.js","node_modules/vdml-moddle/node_modules/moddle/lib/descriptor-builder.js","node_modules/vdml-moddle/node_modules/moddle/lib/factory.js","node_modules/vdml-moddle/node_modules/moddle/lib/moddle.js","node_modules/vdml-moddle/node_modules/moddle/lib/ns.js","node_modules/vdml-moddle/node_modules/moddle/lib/properties.js","node_modules/vdml-moddle/node_modules/moddle/lib/registry.js","node_modules/vdml-moddle/node_modules/moddle/lib/types.js","node_modules/vdml-moddle/resources/vdml/json/dc.json","node_modules/vdml-moddle/resources/vdml/json/di.json","node_modules/vdml-moddle/resources/vdml/json/vdml.json","node_modules/vdml-moddle/resources/vdml/json/vdmldi.json"],"names":[],"mappings":";;;;;;;;;;;;AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1dA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpcA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChpDA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnDA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/pBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnJA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/dA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7GA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvKA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzuBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/eA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/JA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9PA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9bA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClFA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/IA;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtfA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACh8BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxcA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3EA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5KA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/RA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3YA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7DA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5BA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7RA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7cA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzNA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5fA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/RA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzTA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/PA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9aA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3RA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3DA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrGA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACriBA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClbA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9HA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjDA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpiBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5RA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3WA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzUA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjeA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/FA;AACA;AACA;AACA;;ACHA;AACA;AACA;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrCA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1PA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChDA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnlFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3/MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvEA;AACA;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7HA;AACA;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AC/GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACzFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxBA;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;;ACAA;;ACAA;;ACAA;;ACAA;;ACAA;;ACAA;AACA;AACA;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/LA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChHA;AACA;AACA;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9LA;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC/EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC1qBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACl4CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnHA;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACh2BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","'use strict';\r\n\r\nvar inherits = require(270);\r\n\r\nvar Ids = require(268);\r\n\r\nvar Viewer = require(3);\r\n\r\nvar NavigatedViewer = require(2);\r\n\r\nvar initialDiagram =\r\n  '<?xml version=\"1.0\" encoding=\"UTF-8\"?>' +\r\n  '<vdml:definitions xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" ' +\r\n                    'xmlns:vdml=\"http://www.omg.org/spec/VDML/20100524/MODEL\" ' +\r\n                    'xmlns:vdmldi=\"http://www.omg.org/spec/VDML/20100524/DI\" ' +\r\n                    'xmlns:dc=\"http://www.omg.org/spec/DD/20100524/DC\" ' +\r\n                    'targetNamespace=\"http://vdml.io/schema/vdml\" ' +\r\n                    'id=\"Definitions_1\">' +\r\n    '<vdml:process id=\"Process_1\" isExecutable=\"false\">' +\r\n      '<vdml:startEvent id=\"StartEvent_1\"/>' +\r\n    '</vdml:process>' +\r\n    '<vdmldi:VDMLDiagram id=\"VDMLDiagram_1\">' +\r\n      '<vdmldi:VDMLPlane id=\"VDMLPlane_1\" vdmlElement=\"Process_1\">' +\r\n        '<vdmldi:VDMLShape id=\"_VDMLShape_StartEvent_2\" vdmlElement=\"StartEvent_1\">' +\r\n          '<dc:Bounds height=\"36.0\" width=\"36.0\" x=\"173.0\" y=\"102.0\"/>' +\r\n        '</vdmldi:VDMLShape>' +\r\n      '</vdmldi:VDMLPlane>' +\r\n    '</vdmldi:VDMLDiagram>' +\r\n  '</vdml:definitions>';\r\n\r\n\r\n/**\r\n * A modeler for VDML 2.0 diagrams.\r\n *\r\n *\r\n * ## Extending the Modeler\r\n *\r\n * In order to extend the viewer pass extension modules to bootstrap via the\r\n * `additionalModules` option. An extension module is an object that exposes\r\n * named services.\r\n *\r\n * The following example depicts the integration of a simple\r\n * logging component that integrates with interaction events:\r\n *\r\n *\r\n * ```javascript\r\n *\r\n * // logging component\r\n * function InteractionLogger(eventBus) {\r\n *   eventBus.on('element.hover', function(event) {\r\n *     console.log()\r\n *   })\r\n * }\r\n *\r\n * InteractionLogger.$inject = [ 'eventBus' ]; // minification save\r\n *\r\n * // extension module\r\n * var extensionModule = {\r\n *   __init__: [ 'interactionLogger' ],\r\n *   interactionLogger: [ 'type', InteractionLogger ]\r\n * };\r\n *\r\n * // extend the viewer\r\n * var vdmlModeler = new Modeler({ additionalModules: [ extensionModule ] });\r\n * vdmlModeler.importXML(...);\r\n * ```\r\n *\r\n *\r\n * ## Customizing / Replacing Components\r\n *\r\n * You can replace individual diagram components by redefining them in override modules.\r\n * This works for all components, including those defined in the core.\r\n *\r\n * Pass in override modules via the `options.additionalModules` flag like this:\r\n *\r\n * ```javascript\r\n * function CustomContextPadProvider(contextPad) {\r\n *\r\n *   contextPad.registerProvider(this);\r\n *\r\n *   this.getContextPadEntries = function(element) {\r\n *     // no entries, effectively disable the context pad\r\n *     return {};\r\n *   };\r\n * }\r\n *\r\n * CustomContextPadProvider.$inject = [ 'contextPad' ];\r\n *\r\n * var overrideModule = {\r\n *   contextPadProvider: [ 'type', CustomContextPadProvider ]\r\n * };\r\n *\r\n * var vdmlModeler = new Modeler({ additionalModules: [ overrideModule ]});\r\n * ```\r\n *\r\n * @param {Object} [options] configuration options to pass to the viewer\r\n * @param {DOMElement} [options.container] the container to render the viewer in, defaults to body.\r\n * @param {String|Number} [options.width] the width of the viewer\r\n * @param {String|Number} [options.height] the height of the viewer\r\n * @param {Object} [options.moddleExtensions] extension packages to provide\r\n * @param {Array<didi.Module>} [options.modules] a list of modules to override the default modules\r\n * @param {Array<didi.Module>} [options.additionalModules] a list of modules to use with the default modules\r\n */\r\nfunction Modeler(options) {\r\n  Viewer.call(this, options);\r\n\r\n  // hook ID collection into the modeler\r\n  this.on('import.parse.complete', function(event) {\r\n    if (!event.error) {\r\n      this._collectIds(event.definitions, event.context);\r\n    }\r\n  }, this);\r\n\r\n  this.on('diagram.destroy', function() {\r\n    this.moddle.ids.clear();\r\n  }, this);\r\n}\r\n\r\ninherits(Modeler, Viewer);\r\n\r\nmodule.exports = Modeler;\r\n\r\nmodule.exports.Viewer = Viewer;\r\n\r\nmodule.exports.NavigatedViewer = NavigatedViewer;\r\n\r\n/**\r\n * Create a new diagram to start modeling.\r\n *\r\n * @param {Function} [done]\r\n */\r\nModeler.prototype.createDiagram = function(done) {\r\n  return this.importXML(initialDiagram, done);\r\n};\r\n\r\n/**\r\n * Create a moddle instance, attaching ids to it.\r\n *\r\n * @param {Object} options\r\n */\r\nModeler.prototype._createModdle = function(options) {\r\n  var moddle = Viewer.prototype._createModdle.call(this, options);\r\n\r\n  // attach ids to moddle to be able to track\r\n  // and validated ids in the VDML 2.0 XML document\r\n  // tree\r\n  moddle.ids = new Ids([ 32, 36, 1 ]);\r\n\r\n  return moddle;\r\n};\r\n\r\n/**\r\n * Collect ids processed during parsing of the\r\n * definitions object.\r\n *\r\n * @param {ModdleElement} definitions\r\n * @param {Context} context\r\n */\r\nModeler.prototype._collectIds = function(definitions, context) {\r\n\r\n  var moddle = definitions.$model,\r\n      ids = moddle.ids,\r\n      id;\r\n\r\n  // remove references from previous import\r\n  ids.clear();\r\n\r\n  for (id in context.elementsById) {\r\n    ids.claim(id, context.elementsById[id]);\r\n  }\r\n};\r\n\r\n\r\nModeler.prototype._interactionModules = [\r\n  // non-modeling components\r\n  require(237),\r\n  require(238),\r\n  require(241)\r\n];\r\n\r\nModeler.prototype._modelingModules = [\r\n  // modeling components\r\n  require(120),\r\n  require(126),\r\n  require(187),\r\n  require(205),\r\n  require(10),\r\n  require(18),\r\n  require(12),\r\n  require(22),\r\n  require(26),\r\n  require(64),\r\n  require(70),\r\n  require(75),\r\n  require(85)\r\n];\r\n\r\n\r\n// modules the modeler is composed of\r\n//\r\n// - viewer modules\r\n// - interaction modules\r\n// - modeling modules\r\n\r\nModeler.prototype._modules = [].concat(\r\n  Modeler.prototype._modules,\r\n  Modeler.prototype._interactionModules,\r\n  Modeler.prototype._modelingModules);\r\n","'use strict';\r\n\r\nvar inherits = require(270);\r\n\r\nvar Viewer = require(3);\r\n\r\n\r\n/**\r\n * A viewer that includes mouse navigation facilities\r\n *\r\n * @param {Object} options\r\n */\r\nfunction NavigatedViewer(options) {\r\n  Viewer.call(this, options);\r\n}\r\n\r\ninherits(NavigatedViewer, Viewer);\r\n\r\nmodule.exports = NavigatedViewer;\r\n\r\nNavigatedViewer.prototype._navigationModules = [\r\n  require(241),\r\n  require(237)\r\n];\r\n\r\nNavigatedViewer.prototype._modules = [].concat(\r\n  NavigatedViewer.prototype._modules,\r\n  NavigatedViewer.prototype._navigationModules);","/**\r\n * The code in the <project-logo></project-logo> area\r\n * must not be changed.\r\n *\r\n * @see http://vdml.io/license for more information.\r\n */\r\n'use strict';\r\n\r\nvar assign = require(410),\r\n    omit = require(415),\r\n    isString = require(407),\r\n    isNumber = require(404);\r\n\r\nvar domify = require(428),\r\n    domQuery = require(431),\r\n    domRemove = require(432);\r\n\r\nvar Diagram = require(98),\r\n    VdmlModdle = require(444);\r\n\r\n\r\nvar inherits = require(270);\r\n\r\nvar Importer = require(86);\r\n\r\n\r\nfunction checkValidationError(err) {\r\n\r\n  // check if we can help the user by indicating wrong VDML 2.0 xml\r\n  // (in case he or the exporting tool did not get that right)\r\n\r\n  var pattern = /unparsable content <([^>]+)> detected([/s/S]*)$/;\r\n  var match = pattern.exec(err.message);\r\n\r\n  if (match) {\r\n    err.message =\r\n      'unparsable content <' + match[1] + '> detected; ' +\r\n      'this may indicate an invalid VDML 2.0 diagram file' + match[2];\r\n  }\r\n\r\n  return err;\r\n}\r\n\r\nvar DEFAULT_OPTIONS = {\r\n  width: '100%',\r\n  height: '100%',\r\n  position: 'relative',\r\n  container: 'body'\r\n};\r\n\r\n\r\n/**\r\n * Ensure the passed argument is a proper unit (defaulting to px)\r\n */\r\nfunction ensureUnit(val) {\r\n  return val + (isNumber(val) ? 'px' : '');\r\n}\r\n\r\n/**\r\n * A viewer for VDML 2.0 diagrams.\r\n *\r\n * Have a look at {@link NavigatedViewer} or {@link Modeler} for bundles that include\r\n * additional features.\r\n *\r\n *\r\n * ## Extending the Viewer\r\n *\r\n * In order to extend the viewer pass extension modules to bootstrap via the\r\n * `additionalModules` option. An extension module is an object that exposes\r\n * named services.\r\n *\r\n * The following example depicts the integration of a simple\r\n * logging component that integrates with interaction events:\r\n *\r\n *\r\n * ```javascript\r\n *\r\n * // logging component\r\n * function InteractionLogger(eventBus) {\r\n *   eventBus.on('element.hover', function(event) {\r\n *     console.log()\r\n *   })\r\n * }\r\n *\r\n * InteractionLogger.$inject = [ 'eventBus' ]; // minification save\r\n *\r\n * // extension module\r\n * var extensionModule = {\r\n *   __init__: [ 'interactionLogger' ],\r\n *   interactionLogger: [ 'type', InteractionLogger ]\r\n * };\r\n *\r\n * // extend the viewer\r\n * var vdmlViewer = new Viewer({ additionalModules: [ extensionModule ] });\r\n * vdmlViewer.importXML(...);\r\n * ```\r\n *\r\n * @param {Object} [options] configuration options to pass to the viewer\r\n * @param {DOMElement} [options.container] the container to render the viewer in, defaults to body.\r\n * @param {String|Number} [options.width] the width of the viewer\r\n * @param {String|Number} [options.height] the height of the viewer\r\n * @param {Object} [options.moddleExtensions] extension packages to provide\r\n * @param {Array<didi.Module>} [options.modules] a list of modules to override the default modules\r\n * @param {Array<didi.Module>} [options.additionalModules] a list of modules to use with the default modules\r\n */\r\nfunction Viewer(options) {\r\n\r\n  options = assign({}, DEFAULT_OPTIONS, options);\r\n\r\n  this.moddle = this._createModdle(options);\r\n\r\n  this.container = this._createContainer(options);\r\n\r\n  /* <project-logo> */\r\n\r\n  addProjectLogo(this.container);\r\n\r\n  /* </project-logo> */\r\n\r\n  this._init(this.container, this.moddle, options);\r\n}\r\n\r\ninherits(Viewer, Diagram);\r\n\r\nmodule.exports = Viewer;\r\n\r\n\r\n/**\r\n * Parse and render a VDML 2.0 diagram.\r\n *\r\n * Once finished the viewer reports back the result to the\r\n * provided callback function with (err, warnings).\r\n *\r\n * ## Life-Cycle Events\r\n *\r\n * During import the viewer will fire life-cycle events:\r\n *\r\n *   * import.parse.start (about to read model from xml)\r\n *   * import.parse.complete (model read; may have worked or not)\r\n *   * import.render.start (graphical import start)\r\n *   * import.render.complete (graphical import finished)\r\n *   * import.done (everything done)\r\n *\r\n * You can use these events to hook into the life-cycle.\r\n *\r\n * @param {String} xml the VDML 2.0 xml\r\n * @param {Function} [done] invoked with (err, warnings=[])\r\n */\r\nViewer.prototype.importXML = function(xml, done) {\r\n\r\n  // done is optional\r\n  done = done || function() {};\r\n\r\n  var self = this;\r\n\r\n  // hook in pre-parse listeners +\r\n  // allow xml manipulation\r\n  xml = this._emit('import.parse.start', { xml: xml }) || xml;\r\n\r\n  this.moddle.fromXML(xml, 'vdml:Definitions', function(err, definitions, context) {\r\n\r\n    // hook in post parse listeners +\r\n    // allow definitions manipulation\r\n    definitions = self._emit('import.parse.complete', {\r\n      error: err,\r\n      definitions: definitions,\r\n      context: context\r\n    }) || definitions;\r\n\r\n    if (err) {\r\n      err = checkValidationError(err);\r\n\r\n      self._emit('import.done', { error: err });\r\n\r\n      return done(err);\r\n    }\r\n\r\n    var parseWarnings = context.warnings;\r\n\r\n    self.importDefinitions(definitions, function(err, importWarnings) {\r\n      var allWarnings = [].concat(parseWarnings, importWarnings || []);\r\n\r\n      self._emit('import.done', { error: err, warnings: allWarnings });\r\n\r\n      done(err, allWarnings);\r\n    });\r\n  });\r\n};\r\n\r\n/**\r\n * Export the currently displayed VDML 2.0 diagram as\r\n * a VDML 2.0 XML document.\r\n *\r\n * @param {Object} [options] export options\r\n * @param {Boolean} [options.format=false] output formated XML\r\n * @param {Boolean} [options.preamble=true] output preamble\r\n *\r\n * @param {Function} done invoked with (err, xml)\r\n */\r\nViewer.prototype.saveXML = function(options, done) {\r\n\r\n  if (!done) {\r\n    done = options;\r\n    options = {};\r\n  }\r\n\r\n  var definitions = this.definitions;\r\n\r\n  if (!definitions) {\r\n    return done(new Error('no definitions loaded'));\r\n  }\r\n\r\n  this.moddle.toXML(definitions, options, done);\r\n};\r\n\r\n/**\r\n * Export the currently displayed VDML 2.0 diagram as\r\n * an SVG image.\r\n *\r\n * @param {Object} [options]\r\n * @param {Function} done invoked with (err, svgStr)\r\n */\r\nViewer.prototype.saveSVG = function(options, done) {\r\n\r\n  if (!done) {\r\n    done = options;\r\n    options = {};\r\n  }\r\n\r\n  var canvas = this.get('canvas');\r\n\r\n  var contentNode = canvas.getDefaultLayer(),\r\n      defsNode = canvas._svg.select('defs');\r\n\r\n  var contents = contentNode.innerSVG(),\r\n      defs = (defsNode && defsNode.outerSVG()) || '';\r\n\r\n  var bbox = contentNode.getBBox();\r\n\r\n  var svg =\r\n    '<?xml version=\"1.0\" encoding=\"utf-8\"?>/n' +\r\n    '<!-- created with vdml-js / http://vdml.io -->/n' +\r\n    '<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">/n' +\r\n    '<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" ' +\r\n         'width=\"' + bbox.width + '\" height=\"' + bbox.height + '\" ' +\r\n         'viewBox=\"' + bbox.x + ' ' + bbox.y + ' ' + bbox.width + ' ' + bbox.height + '\" version=\"1.1\">' +\r\n      defs + contents +\r\n    '</svg>';\r\n\r\n  done(null, svg);\r\n};\r\n\r\n/**\r\n * Get a named diagram service.\r\n *\r\n * @example\r\n *\r\n * var elementRegistry = viewer.get('elementRegistry');\r\n * var startEventShape = elementRegistry.get('StartEvent_1');\r\n *\r\n * @param {String} name\r\n *\r\n * @return {Object} diagram service instance\r\n *\r\n * @method Viewer#get\r\n */\r\n\r\n/**\r\n * Invoke a function in the context of this viewer.\r\n *\r\n * @example\r\n *\r\n * viewer.invoke(function(elementRegistry) {\r\n *   var startEventShape = elementRegistry.get('StartEvent_1');\r\n * });\r\n *\r\n * @param {Function} fn to be invoked\r\n *\r\n * @return {Object} the functions return value\r\n *\r\n * @method Viewer#invoke\r\n */\r\n\r\n/**\r\n * Remove all drawn elements from the viewer.\r\n *\r\n * After calling this method the viewer can still\r\n * be reused for opening another diagram.\r\n *\r\n * @method Viewer#clear\r\n */\r\n\r\nViewer.prototype.importDefinitions = function(definitions, done) {\r\n\r\n  // use try/catch to not swallow synchronous exceptions\r\n  // that may be raised during model parsing\r\n  try {\r\n\r\n    if (this.definitions) {\r\n      // clear existing rendered diagram\r\n      this.clear();\r\n    }\r\n\r\n    // update definitions\r\n    this.definitions = definitions;\r\n\r\n    // perform graphical import\r\n    Importer.importVdmlDiagram(this, definitions, done);\r\n  } catch (e) {\r\n\r\n    // handle synchronous errors\r\n    done(e);\r\n  }\r\n};\r\n\r\nViewer.prototype.getModules = function() {\r\n  return this._modules;\r\n};\r\n\r\n/**\r\n * Destroy the viewer instance and remove all its\r\n * remainders from the document tree.\r\n */\r\nViewer.prototype.destroy = function() {\r\n\r\n  // diagram destroy\r\n  Diagram.prototype.destroy.call(this);\r\n\r\n  // dom detach\r\n  domRemove(this.container);\r\n};\r\n\r\n/**\r\n * Register an event listener\r\n *\r\n * Remove a previously added listener via {@link #off(event, callback)}.\r\n *\r\n * @param {String} event\r\n * @param {Number} [priority]\r\n * @param {Function} callback\r\n * @param {Object} [that]\r\n */\r\nViewer.prototype.on = function(event, priority, callback, target) {\r\n  return this.get('eventBus').on(event, priority, callback, target);\r\n};\r\n\r\n/**\r\n * De-register an event listener\r\n *\r\n * @param {String} event\r\n * @param {Function} callback\r\n */\r\nViewer.prototype.off = function(event, callback) {\r\n  this.get('eventBus').off(event, callback);\r\n};\r\n\r\n\r\nViewer.prototype._init = function(container, moddle, options) {\r\n\r\n  var baseModules = options.modules || this.getModules(),\r\n      additionalModules = options.additionalModules || [],\r\n      staticModules = [\r\n        {\r\n          vdmljs: [ 'value', this ],\r\n          moddle: [ 'value', moddle ]\r\n        }\r\n      ];\r\n\r\n  var diagramModules = [].concat(staticModules, baseModules, additionalModules);\r\n\r\n  var diagramOptions = assign(omit(options, 'additionalModules'), {\r\n    canvas: assign({}, options.canvas, { container: container }),\r\n    modules: diagramModules\r\n  });\r\n\r\n  // invoke diagram constructor\r\n  Diagram.call(this, diagramOptions);\r\n};\r\n\r\n/**\r\n * Emit an event on the underlying {@link EventBus}\r\n *\r\n * @param  {String} type\r\n * @param  {Object} event\r\n *\r\n * @return {Object} event processing result (if any)\r\n */\r\nViewer.prototype._emit = function(type, event) {\r\n  return this.get('eventBus').fire(type, event);\r\n};\r\n\r\nViewer.prototype._createContainer = function(options) {\r\n\r\n  var parent = options.container,\r\n      container;\r\n\r\n  // support jquery element\r\n  // unwrap it if passed\r\n  if (parent.get) {\r\n    parent = parent.get(0);\r\n  }\r\n\r\n  // support selector\r\n  if (isString(parent)) {\r\n    parent = domQuery(parent);\r\n  }\r\n\r\n  container = domify('<div class=\"bjs-container\"></div>');\r\n\r\n  assign(container.style, {\r\n    width: ensureUnit(options.width),\r\n    height: ensureUnit(options.height),\r\n    position: options.position\r\n  });\r\n\r\n  parent.appendChild(container);\r\n\r\n  return container;\r\n};\r\n\r\nViewer.prototype._createModdle = function(options) {\r\n  var moddleOptions = assign({}, this._moddleExtensions, options.moddleExtensions);\r\n\r\n  return new VdmlModdle(moddleOptions);\r\n};\r\n\r\n\r\n// modules the viewer is composed of\r\nViewer.prototype._modules = [\r\n  require(4),\r\n  require(229),\r\n  require(214),\r\n  require(192)\r\n];\r\n\r\n// default moddle extensions the viewer is composed of\r\nViewer.prototype._moddleExtensions = {};\r\n\r\n/* <project-logo> */\r\n\r\nvar PoweredBy = require(94),\r\n    domEvent = require(429);\r\n\r\n/**\r\n * Adds the project logo to the diagram container as\r\n * required by the vdml.io license.\r\n *\r\n * @see http://vdml.io/license\r\n *\r\n * @param {Element} container\r\n */\r\nfunction addProjectLogo(container) {\r\n  var logoData = PoweredBy.VDMLIO_LOGO;\r\n\r\n  var linkMarkup =\r\n    '<a href=\"http://vdml.io\" ' +\r\n       'target=\"_blank\" ' +\r\n       'class=\"bjs-powered-by\" ' +\r\n       'title=\"Powered by vdml.io\" ' +\r\n       'style=\"position: absolute; bottom: 15px; right: 15px; z-index: 100\">' +\r\n        '<img src=\"data:image/png;base64,' + logoData + '\">' +\r\n    '</a>';\r\n\r\n  var linkElement = domify(linkMarkup);\r\n\r\n  container.appendChild(linkElement);\r\n\r\n  domEvent.bind(linkElement, 'click', function(event) {\r\n    PoweredBy.open();\r\n\r\n    event.preventDefault();\r\n  });\r\n}\r\n\r\n/* </project-logo> */","module.exports = {\r\n  __depends__: [\r\n    require(7),\r\n    require(90)\r\n  ]\r\n};","'use strict';\r\n\r\nvar Snap = require(267);\r\n\r\n/**\r\n * Map containing SVG paths needed by BpmnRenderer.\r\n */\r\n\r\nfunction PathMap() {\r\n\r\n  /**\r\n   * Contains a map of path elements\r\n   *\r\n   * <h1>Path definition</h1>\r\n   * A parameterized path is defined like this:\r\n   * <pre>\r\n   * 'GATEWAY_PARALLEL': {\r\n   *   d: 'm {mx},{my} {e.x0},0 0,{e.x1} {e.x1},0 0,{e.y0} -{e.x1},0 0,{e.y1} ' +\r\n          '-{e.x0},0 0,-{e.y1} -{e.x1},0 0,-{e.y0} {e.x1},0 z',\r\n   *   height: 17.5,\r\n   *   width:  17.5,\r\n   *   heightElements: [2.5, 7.5],\r\n   *   widthElements: [2.5, 7.5]\r\n   * }\r\n   * </pre>\r\n   * <p>It's important to specify a correct <b>height and width</b> for the path as the scaling\r\n   * is based on the ratio between the specified height and width in this object and the\r\n   * height and width that is set as scale target (Note x,y coordinates will be scaled with\r\n   * individual ratios).</p>\r\n   * <p>The '<b>heightElements</b>' and '<b>widthElements</b>' array must contain the values that will be scaled.\r\n   * The scaling is based on the computed ratios.\r\n   * Coordinates on the y axis should be in the <b>heightElement</b>'s array, they will be scaled using\r\n   * the computed ratio coefficient.\r\n   * In the parameterized path the scaled values can be accessed through the 'e' object in {} brackets.\r\n   *   <ul>\r\n   *    <li>The values for the y axis can be accessed in the path string using {e.y0}, {e.y1}, ....</li>\r\n   *    <li>The values for the x axis can be accessed in the path string using {e.x0}, {e.x1}, ....</li>\r\n   *   </ul>\r\n   *   The numbers x0, x1 respectively y0, y1, ... map to the corresponding array index.\r\n   * </p>\r\n   */\r\n  this.pathMap = {\r\n    'EVENT_MESSAGE': {\r\n      d: 'm {mx},{my} l 0,{e.y1} l {e.x1},0 l 0,-{e.y1} z l {e.x0},{e.y0} l {e.x0},-{e.y0}',\r\n      height: 36,\r\n      width:  36,\r\n      heightElements: [6, 14],\r\n      widthElements: [10.5, 21]\r\n    },\r\n    'EVENT_SIGNAL': {\r\n      d: 'M {mx},{my} l {e.x0},{e.y0} l -{e.x1},0 Z',\r\n      height: 36,\r\n      width: 36,\r\n      heightElements: [18],\r\n      widthElements: [10, 20]\r\n    },\r\n    'EVENT_ESCALATION': {\r\n      d: 'M {mx},{my} l {e.x0},{e.y0} l -{e.x0},-{e.y1} l -{e.x0},{e.y1} Z',\r\n      height: 36,\r\n      width: 36,\r\n      heightElements: [20, 7],\r\n      widthElements: [8]\r\n    },\r\n    'EVENT_CONDITIONAL': {\r\n      d: 'M {e.x0},{e.y0} l {e.x1},0 l 0,{e.y2} l -{e.x1},0 Z ' +\r\n         'M {e.x2},{e.y3} l {e.x0},0 ' +\r\n         'M {e.x2},{e.y4} l {e.x0},0 ' +\r\n         'M {e.x2},{e.y5} l {e.x0},0 ' +\r\n         'M {e.x2},{e.y6} l {e.x0},0 ' +\r\n         'M {e.x2},{e.y7} l {e.x0},0 ' +\r\n         'M {e.x2},{e.y8} l {e.x0},0 ',\r\n      height: 36,\r\n      width:  36,\r\n      heightElements: [8.5, 14.5, 18, 11.5, 14.5, 17.5, 20.5, 23.5, 26.5],\r\n      widthElements:  [10.5, 14.5, 12.5]\r\n    },\r\n    'EVENT_LINK': {\r\n      d: 'm {mx},{my} 0,{e.y0} -{e.x1},0 0,{e.y1} {e.x1},0 0,{e.y0} {e.x0},-{e.y2} -{e.x0},-{e.y2} z',\r\n      height: 36,\r\n      width: 36,\r\n      heightElements: [4.4375, 6.75, 7.8125],\r\n      widthElements: [9.84375, 13.5]\r\n    },\r\n    'EVENT_ERROR': {\r\n      d: 'm {mx},{my} {e.x0},-{e.y0} {e.x1},-{e.y1} {e.x2},{e.y2} {e.x3},-{e.y3} -{e.x4},{e.y4} -{e.x5},-{e.y5} z',\r\n      height: 36,\r\n      width: 36,\r\n      heightElements: [0.023, 8.737, 8.151, 16.564, 10.591, 8.714],\r\n      widthElements: [0.085, 6.672, 6.97, 4.273, 5.337, 6.636]\r\n    },\r\n    'EVENT_CANCEL_45': {\r\n      d: 'm {mx},{my} -{e.x1},0 0,{e.x0} {e.x1},0 0,{e.y1} {e.x0},0 ' +\r\n        '0,-{e.y1} {e.x1},0 0,-{e.y0} -{e.x1},0 0,-{e.y1} -{e.x0},0 z',\r\n      height: 36,\r\n      width: 36,\r\n      heightElements: [4.75, 8.5],\r\n      widthElements: [4.75, 8.5]\r\n    },\r\n    'EVENT_COMPENSATION': {\r\n      d: 'm {mx},{my} {e.x0},-{e.y0} 0,{e.y1} z m {e.x1},-{e.y2} {e.x2},-{e.y3} 0,{e.y1} -{e.x2},-{e.y3} z',\r\n      height: 36,\r\n      width: 36,\r\n      heightElements: [6.5, 13, 0.4, 6.1],\r\n      widthElements: [9, 9.3, 8.7]\r\n    },\r\n    'EVENT_TIMER_WH': {\r\n      d: 'M {mx},{my} l {e.x0},-{e.y0} m -{e.x0},{e.y0} l {e.x1},{e.y1} ',\r\n      height: 36,\r\n      width:  36,\r\n      heightElements: [10, 2],\r\n      widthElements: [3, 7]\r\n    },\r\n    'EVENT_TIMER_LINE': {\r\n      d:  'M {mx},{my} ' +\r\n          'm {e.x0},{e.y0} l -{e.x1},{e.y1} ',\r\n      height: 36,\r\n      width:  36,\r\n      heightElements: [10, 3],\r\n      widthElements: [0, 0]\r\n    },\r\n    'EVENT_MULTIPLE': {\r\n      d:'m {mx},{my} {e.x1},-{e.y0} {e.x1},{e.y0} -{e.x0},{e.y1} -{e.x2},0 z',\r\n      height: 36,\r\n      width:  36,\r\n      heightElements: [6.28099, 12.56199],\r\n      widthElements: [3.1405, 9.42149, 12.56198]\r\n    },\r\n    'EVENT_PARALLEL_MULTIPLE': {\r\n      d:'m {mx},{my} {e.x0},0 0,{e.y1} {e.x1},0 0,{e.y0} -{e.x1},0 0,{e.y1} ' +\r\n        '-{e.x0},0 0,-{e.y1} -{e.x1},0 0,-{e.y0} {e.x1},0 z',\r\n      height: 36,\r\n      width:  36,\r\n      heightElements: [2.56228, 7.68683],\r\n      widthElements: [2.56228, 7.68683]\r\n    },\r\n    'GATEWAY_EXCLUSIVE': {\r\n      d:'m {mx},{my} {e.x0},{e.y0} {e.x1},{e.y0} {e.x2},0 {e.x4},{e.y2} ' +\r\n                    '{e.x4},{e.y1} {e.x2},0 {e.x1},{e.y3} {e.x0},{e.y3} ' +\r\n                    '{e.x3},0 {e.x5},{e.y1} {e.x5},{e.y2} {e.x3},0 z',\r\n      height: 17.5,\r\n      width:  17.5,\r\n      heightElements: [8.5, 6.5312, -6.5312, -8.5],\r\n      widthElements:  [6.5, -6.5, 3, -3, 5, -5]\r\n    },\r\n    'GATEWAY_PARALLEL': {\r\n      d:'m {mx},{my} 0,{e.y1} -{e.x1},0 0,{e.y0} {e.x1},0 0,{e.y1} {e.x0},0 ' +\r\n        '0,-{e.y1} {e.x1},0 0,-{e.y0} -{e.x1},0 0,-{e.y1} -{e.x0},0 z',\r\n      height: 30,\r\n      width:  30,\r\n      heightElements: [5, 12.5],\r\n      widthElements: [5, 12.5]\r\n    },\r\n    'GATEWAY_EVENT_BASED': {\r\n      d:'m {mx},{my} {e.x0},{e.y0} {e.x0},{e.y1} {e.x1},{e.y2} {e.x2},0 z',\r\n      height: 11,\r\n      width:  11,\r\n      heightElements: [-6, 6, 12, -12],\r\n      widthElements: [9, -3, -12]\r\n    },\r\n    'GATEWAY_COMPLEX': {\r\n      d:'m {mx},{my} 0,{e.y0} -{e.x0},-{e.y1} -{e.x1},{e.y2} {e.x0},{e.y1} -{e.x2},0 0,{e.y3} ' +\r\n        '{e.x2},0  -{e.x0},{e.y1} l {e.x1},{e.y2} {e.x0},-{e.y1} 0,{e.y0} {e.x3},0 0,-{e.y0} {e.x0},{e.y1} ' +\r\n        '{e.x1},-{e.y2} -{e.x0},-{e.y1} {e.x2},0 0,-{e.y3} -{e.x2},0 {e.x0},-{e.y1} -{e.x1},-{e.y2} ' +\r\n        '-{e.x0},{e.y1} 0,-{e.y0} -{e.x3},0 z',\r\n      height: 17.125,\r\n      width:  17.125,\r\n      heightElements: [4.875, 3.4375, 2.125, 3],\r\n      widthElements: [3.4375, 2.125, 4.875, 3]\r\n    },\r\n    'DATA_OBJECT_PATH': {\r\n      d:'m 0,0 {e.x1},0 {e.x0},{e.y0} 0,{e.y1} -{e.x2},0 0,-{e.y2} {e.x1},0 0,{e.y0} {e.x0},0',\r\n      height: 61,\r\n      width:  51,\r\n      heightElements: [10, 50, 60],\r\n      widthElements: [10, 40, 50, 60]\r\n    },\r\n    'DATA_OBJECT_COLLECTION_PATH': {\r\n      d:'m {mx}, {my} ' +\r\n        'm  0 15  l 0 -15 ' +\r\n        'm  4 15  l 0 -15 ' +\r\n        'm  4 15  l 0 -15 ',\r\n      height: 61,\r\n      width:  51,\r\n      heightElements: [12],\r\n      widthElements: [1, 6, 12, 15]\r\n    },\r\n    'DATA_ARROW': {\r\n      d:'m 5,9 9,0 0,-3 5,5 -5,5 0,-3 -9,0 z',\r\n      height: 61,\r\n      width:  51,\r\n      heightElements: [],\r\n      widthElements: []\r\n    },\r\n    'DATA_STORE': {\r\n      d:'m  {mx},{my} ' +\r\n        'l  0,{e.y2} ' +\r\n        'c  {e.x0},{e.y1} {e.x1},{e.y1}  {e.x2},0 ' +\r\n        'l  0,-{e.y2} ' +\r\n        'c -{e.x0},-{e.y1} -{e.x1},-{e.y1} -{e.x2},0' +\r\n        'c  {e.x0},{e.y1} {e.x1},{e.y1}  {e.x2},0 ' +\r\n        'm  -{e.x2},{e.y0}' +\r\n        'c  {e.x0},{e.y1} {e.x1},{e.y1} {e.x2},0' +\r\n        'm  -{e.x2},{e.y0}' +\r\n        'c  {e.x0},{e.y1} {e.x1},{e.y1}  {e.x2},0',\r\n      height: 61,\r\n      width:  61,\r\n      heightElements: [7, 10, 45],\r\n      widthElements:  [2, 58, 60]\r\n    },\r\n    'TEXT_ANNOTATION': {\r\n      d: 'm {mx}, {my} m 10,0 l -10,0 l 0,{e.y0} l 10,0',\r\n      height: 30,\r\n      width: 10,\r\n      heightElements: [30],\r\n      widthElements: [10]\r\n    },\r\n    'MARKER_SUB_PROCESS': {\r\n      d: 'm{mx},{my} m 7,2 l 0,10 m -5,-5 l 10,0',\r\n      height: 10,\r\n      width: 10,\r\n      heightElements: [],\r\n      widthElements: []\r\n    },\r\n    'MARKER_PARALLEL': {\r\n      d: 'm{mx},{my} m 3,2 l 0,10 m 3,-10 l 0,10 m 3,-10 l 0,10',\r\n      height: 10,\r\n      width: 10,\r\n      heightElements: [],\r\n      widthElements: []\r\n    },\r\n    'MARKER_SEQUENTIAL': {\r\n      d: 'm{mx},{my} m 0,3 l 10,0 m -10,3 l 10,0 m -10,3 l 10,0',\r\n      height: 10,\r\n      width: 10,\r\n      heightElements: [],\r\n      widthElements: []\r\n    },\r\n    'MARKER_COMPENSATION': {\r\n      d: 'm {mx},{my} 7,-5 0,10 z m 7.1,-0.3 6.9,-4.7 0,10 -6.9,-4.7 z',\r\n      height: 10,\r\n      width: 21,\r\n      heightElements: [],\r\n      widthElements: []\r\n    },\r\n    'MARKER_LOOP': {\r\n      d: 'm {mx},{my} c 3.526979,0 6.386161,-2.829858 6.386161,-6.320661 0,-3.490806 -2.859182,-6.320661 ' +\r\n        '-6.386161,-6.320661 -3.526978,0 -6.38616,2.829855 -6.38616,6.320661 0,1.745402 ' +\r\n        '0.714797,3.325567 1.870463,4.469381 0.577834,0.571908 1.265885,1.034728 2.029916,1.35457 ' +\r\n        'l -0.718163,-3.909793 m 0.718163,3.909793 -3.885211,0.802902',\r\n      height: 13.9,\r\n      width: 13.7,\r\n      heightElements: [],\r\n      widthElements: []\r\n    },\r\n    'MARKER_ADHOC': {\r\n      d: 'm {mx},{my} m 0.84461,2.64411 c 1.05533,-1.23780996 2.64337,-2.07882 4.29653,-1.97997996 2.05163,0.0805 ' +\r\n        '3.85579,1.15803 5.76082,1.79107 1.06385,0.34139996 2.24454,0.1438 3.18759,-0.43767 0.61743,-0.33642 ' +\r\n        '1.2775,-0.64078 1.7542,-1.17511 0,0.56023 0,1.12046 0,1.6807 -0.98706,0.96237996 -2.29792,1.62393996 ' +\r\n        '-3.6918,1.66181996 -1.24459,0.0927 -2.46671,-0.2491 -3.59505,-0.74812 -1.35789,-0.55965 ' +\r\n        '-2.75133,-1.33436996 -4.27027,-1.18121996 -1.37741,0.14601 -2.41842,1.13685996 -3.44288,1.96782996 z',\r\n      height: 4,\r\n      width: 15,\r\n      heightElements: [],\r\n      widthElements: []\r\n    },\r\n    'TASK_TYPE_SEND': {\r\n      d: 'm {mx},{my} l 0,{e.y1} l {e.x1},0 l 0,-{e.y1} z l {e.x0},{e.y0} l {e.x0},-{e.y0}',\r\n      height: 14,\r\n      width:  21,\r\n      heightElements: [6, 14],\r\n      widthElements: [10.5, 21]\r\n    },\r\n    'TASK_TYPE_SCRIPT': {\r\n      d: 'm {mx},{my} c 9.966553,-6.27276 -8.000926,-7.91932 2.968968,-14.938 l -8.802728,0 ' +\r\n        'c -10.969894,7.01868 6.997585,8.66524 -2.968967,14.938 z ' +\r\n        'm -7,-12 l 5,0 ' +\r\n        'm -4.5,3 l 4.5,0 ' +\r\n        'm -3,3 l 5,0' +\r\n        'm -4,3 l 5,0',\r\n      height: 15,\r\n      width:  12.6,\r\n      heightElements: [6, 14],\r\n      widthElements: [10.5, 21]\r\n    },\r\n    'TASK_TYPE_USER_1': {\r\n      d: 'm {mx},{my} c 0.909,-0.845 1.594,-2.049 1.594,-3.385 0,-2.554 -1.805,-4.62199999 ' +\r\n        '-4.357,-4.62199999 -2.55199998,0 -4.28799998,2.06799999 -4.28799998,4.62199999 0,1.348 ' +\r\n        '0.974,2.562 1.89599998,3.405 -0.52899998,0.187 -5.669,2.097 -5.794,4.7560005 v 6.718 ' +\r\n        'h 17 v -6.718 c 0,-2.2980005 -5.5279996,-4.5950005 -6.0509996,-4.7760005 z' +\r\n        'm -8,6 l 0,5.5 m 11,0 l 0,-5'\r\n    },\r\n    'TASK_TYPE_USER_2': {\r\n      d: 'm {mx},{my} m 2.162,1.009 c 0,2.4470005 -2.158,4.4310005 -4.821,4.4310005 ' +\r\n        '-2.66499998,0 -4.822,-1.981 -4.822,-4.4310005 '\r\n    },\r\n    'TASK_TYPE_USER_3': {\r\n      d: 'm {mx},{my} m -6.9,-3.80 c 0,0 2.25099998,-2.358 4.27399998,-1.177 2.024,1.181 4.221,1.537 ' +\r\n        '4.124,0.965 -0.098,-0.57 -0.117,-3.79099999 -4.191,-4.13599999 -3.57499998,0.001 ' +\r\n        '-4.20799998,3.36699999 -4.20699998,4.34799999 z'\r\n    },\r\n    'TASK_TYPE_MANUAL': {\r\n      d: 'm {mx},{my} c 0.234,-0.01 5.604,0.008 8.029,0.004 0.808,0 1.271,-0.172 1.417,-0.752 0.227,-0.898 ' +\r\n        '-0.334,-1.314 -1.338,-1.316 -2.467,-0.01 -7.886,-0.004 -8.108,-0.004 -0.014,-0.079 0.016,-0.533 0,-0.61 ' +\r\n        '0.195,-0.042 8.507,0.006 9.616,0.002 0.877,-0.007 1.35,-0.438 1.353,-1.208 0.003,-0.768 -0.479,-1.09 ' +\r\n        '-1.35,-1.091 -2.968,-0.002 -9.619,-0.013 -9.619,-0.013 v -0.591 c 0,0 5.052,-0.016 7.225,-0.016 ' +\r\n        '0.888,-0.002 1.354,-0.416 1.351,-1.193 -0.006,-0.761 -0.492,-1.196 -1.361,-1.196 -3.473,-0.005 ' +\r\n        '-10.86,-0.003 -11.0829995,-0.003 -0.022,-0.047 -0.045,-0.094 -0.069,-0.139 0.3939995,-0.319 ' +\r\n        '2.0409995,-1.626 2.4149995,-2.017 0.469,-0.4870005 0.519,-1.1650005 0.162,-1.6040005 -0.414,-0.511 ' +\r\n        '-0.973,-0.5 -1.48,-0.236 -1.4609995,0.764 -6.5999995,3.6430005 -7.7329995,4.2710005 -0.9,0.499 ' +\r\n        '-1.516,1.253 -1.882,2.19 -0.37000002,0.95 -0.17,2.01 -0.166,2.979 0.004,0.718 -0.27300002,1.345 ' +\r\n        '-0.055,2.063 0.629,2.087 2.425,3.312 4.859,3.318 4.6179995,0.014 9.2379995,-0.139 13.8569995,-0.158 ' +\r\n        '0.755,-0.004 1.171,-0.301 1.182,-1.033 0.012,-0.754 -0.423,-0.969 -1.183,-0.973 -1.778,-0.01 ' +\r\n        '-5.824,-0.004 -6.04,-0.004 10e-4,-0.084 0.003,-0.586 10e-4,-0.67 z'\r\n    },\r\n    'TASK_TYPE_INSTANTIATING_SEND': {\r\n      d: 'm {mx},{my} l 0,8.4 l 12.6,0 l 0,-8.4 z l 6.3,3.6 l 6.3,-3.6'\r\n    },\r\n    'TASK_TYPE_SERVICE': {\r\n      d: 'm {mx},{my} v -1.71335 c 0.352326,-0.0705 0.703932,-0.17838 1.047628,-0.32133 ' +\r\n        '0.344416,-0.14465 0.665822,-0.32133 0.966377,-0.52145 l 1.19431,1.18005 1.567487,-1.57688 ' +\r\n        '-1.195028,-1.18014 c 0.403376,-0.61394 0.683079,-1.29908 0.825447,-2.01824 l 1.622133,-0.01 ' +\r\n        'v -2.2196 l -1.636514,0.01 c -0.07333,-0.35153 -0.178319,-0.70024 -0.323564,-1.04372 ' +\r\n        '-0.145244,-0.34406 -0.321407,-0.6644 -0.522735,-0.96217 l 1.131035,-1.13631 -1.583305,-1.56293 ' +\r\n        '-1.129598,1.13589 c -0.614052,-0.40108 -1.302883,-0.68093 -2.022633,-0.82247 l 0.0093,-1.61852 ' +\r\n        'h -2.241173 l 0.0042,1.63124 c -0.353763,0.0736 -0.705369,0.17977 -1.049785,0.32371 -0.344415,0.14437 ' +\r\n        '-0.665102,0.32092 -0.9635006,0.52046 l -1.1698628,-1.15823 -1.5667691,1.5792 1.1684265,1.15669 ' +\r\n        'c -0.4026573,0.61283 -0.68308,1.29797 -0.8247287,2.01713 l -1.6588041,0.003 v 2.22174 ' +\r\n        'l 1.6724648,-0.006 c 0.073327,0.35077 0.1797598,0.70243 0.3242851,1.04472 0.1452428,0.34448 ' +\r\n        '0.3214064,0.6644 0.5227339,0.96066 l -1.1993431,1.19723 1.5840256,1.56011 1.1964668,-1.19348 ' +\r\n        'c 0.6140517,0.40346 1.3028827,0.68232 2.0233517,0.82331 l 7.19e-4,1.69892 h 2.226848 z ' +\r\n        'm 0.221462,-3.9957 c -1.788948,0.7502 -3.8576,-0.0928 -4.6097055,-1.87438 -0.7521065,-1.78321 ' +\r\n        '0.090598,-3.84627 1.8802645,-4.59604 1.78823,-0.74936 3.856881,0.0929 4.608987,1.87437 ' +\r\n        '0.752106,1.78165 -0.0906,3.84612 -1.879546,4.59605 z'\r\n    },\r\n    'TASK_TYPE_SERVICE_FILL': {\r\n      d: 'm {mx},{my} c -1.788948,0.7502 -3.8576,-0.0928 -4.6097055,-1.87438 -0.7521065,-1.78321 ' +\r\n        '0.090598,-3.84627 1.8802645,-4.59604 1.78823,-0.74936 3.856881,0.0929 4.608987,1.87437 ' +\r\n        '0.752106,1.78165 -0.0906,3.84612 -1.879546,4.59605 z'\r\n    },\r\n    'TASK_TYPE_BUSINESS_RULE_HEADER': {\r\n      d: 'm {mx},{my} 0,4 20,0 0,-4 z'\r\n    },\r\n    'TASK_TYPE_BUSINESS_RULE_MAIN': {\r\n      d: 'm {mx},{my} 0,12 20,0 0,-12 z' +\r\n        'm 0,8 l 20,0 ' +\r\n        'm -13,-4 l 0,8'\r\n    },\r\n    'MESSAGE_FLOW_MARKER': {\r\n      d: 'm {mx},{my} m -10.5 ,-7 l 0,14 l 21,0 l 0,-14 z l 10.5,6 l 10.5,-6'\r\n    }\r\n  };\r\n\r\n  this.getRawPath = function getRawPath(pathId) {\r\n    return this.pathMap[pathId].d;\r\n  };\r\n\r\n  /**\r\n   * Scales the path to the given height and width.\r\n   * <h1>Use case</h1>\r\n   * <p>Use case is to scale the content of elements (event, gateways) based\r\n   * on the element bounding box's size.\r\n   * </p>\r\n   * <h1>Why not transform</h1>\r\n   * <p>Scaling a path with transform() will also scale the stroke and IE does not support\r\n   * the option 'non-scaling-stroke' to prevent this.\r\n   * Also there are use cases where only some parts of a path should be\r\n   * scaled.</p>\r\n   *\r\n   * @param {String} pathId The ID of the path.\r\n   * @param {Object} param <p>\r\n   *   Example param object scales the path to 60% size of the container (data.width, data.height).\r\n   *   <pre>\r\n   *   {\r\n   *     xScaleFactor: 0.6,\r\n   *     yScaleFactor:0.6,\r\n   *     containerWidth: data.width,\r\n   *     containerHeight: data.height,\r\n   *     position: {\r\n   *       mx: 0.46,\r\n   *       my: 0.2,\r\n   *     }\r\n   *   }\r\n   *   </pre>\r\n   *   <ul>\r\n   *    <li>targetpathwidth = xScaleFactor * containerWidth</li>\r\n   *    <li>targetpathheight = yScaleFactor * containerHeight</li>\r\n   *    <li>Position is used to set the starting coordinate of the path. M is computed:\r\n    *    <ul>\r\n    *      <li>position.x * containerWidth</li>\r\n    *      <li>position.y * containerHeight</li>\r\n    *    </ul>\r\n    *    Center of the container <pre> position: {\r\n   *       mx: 0.5,\r\n   *       my: 0.5,\r\n   *     }</pre>\r\n   *     Upper left corner of the container\r\n   *     <pre> position: {\r\n   *       mx: 0.0,\r\n   *       my: 0.0,\r\n   *     }</pre>\r\n   *    </li>\r\n   *   </ul>\r\n   * </p>\r\n   *\r\n   */\r\n  this.getScaledPath = function getScaledPath(pathId, param) {\r\n    var rawPath = this.pathMap[pathId];\r\n\r\n    // positioning\r\n    // compute the start point of the path\r\n    var mx, my;\r\n\r\n    if (param.abspos) {\r\n      mx = param.abspos.x;\r\n      my = param.abspos.y;\r\n    } else {\r\n      mx = param.containerWidth * param.position.mx;\r\n      my = param.containerHeight * param.position.my;\r\n    }\r\n\r\n    var coordinates = {}; //map for the scaled coordinates\r\n    if (param.position) {\r\n\r\n      // path\r\n      var heightRatio = (param.containerHeight / rawPath.height) * param.yScaleFactor;\r\n      var widthRatio = (param.containerWidth / rawPath.width) * param.xScaleFactor;\r\n\r\n\r\n      //Apply height ratio\r\n      for (var heightIndex = 0; heightIndex < rawPath.heightElements.length; heightIndex++) {\r\n        coordinates['y' + heightIndex] = rawPath.heightElements[heightIndex] * heightRatio;\r\n      }\r\n\r\n      //Apply width ratio\r\n      for (var widthIndex = 0; widthIndex < rawPath.widthElements.length; widthIndex++) {\r\n        coordinates['x' + widthIndex] = rawPath.widthElements[widthIndex] * widthRatio;\r\n      }\r\n    }\r\n\r\n    //Apply value to raw path\r\n    var path = Snap.format(\r\n      rawPath.d, {\r\n        mx: mx,\r\n        my: my,\r\n        e: coordinates\r\n      }\r\n    );\r\n    return path;\r\n  };\r\n}\r\n\r\nmodule.exports = PathMap;\r\n","'use strict';\r\n\r\nvar inherits = require(270),\r\n    isObject = require(405),\r\n    assign = require(410),\r\n    forEach = require(283),\r\n    every = require(280),\r\n    includes = require(285),\r\n    some = require(290);\r\n\r\nvar BaseRenderer = require(109),\r\n    TextUtil = require(259),\r\n    DiUtil = require(91);\r\n\r\nvar is = require(93).is;\r\n\r\nvar RenderUtil = require(258);\r\n\r\nvar componentsToPath = RenderUtil.componentsToPath,\r\n    createLine = RenderUtil.createLine;\r\n\r\n\r\nvar TASK_BORDER_RADIUS = 10;\r\nvar INNER_OUTER_DIST = 3;\r\n\r\nvar LABEL_STYLE = {\r\n  fontFamily: 'Arial, sans-serif',\r\n  fontSize: '12px'\r\n};\r\n\r\n\r\nfunction VdmlRenderer(eventBus, styles, pathMap, priority) {\r\n\r\n  BaseRenderer.call(this, eventBus, priority);\r\n\r\n  var textUtil = new TextUtil({\r\n    style: LABEL_STYLE,\r\n    size: { width: 100 }\r\n  });\r\n\r\n  var markers = {};\r\n\r\n  var computeStyle = styles.computeStyle;\r\n\r\n  function addMarker(id, element) {\r\n    markers[id] = element;\r\n  }\r\n\r\n  function marker(id) {\r\n    return markers[id];\r\n  }\r\n\r\n  function initMarkers(svg) {\r\n\r\n    function createMarker(id, options) {\r\n      var attrs = assign({\r\n        fill: 'black',\r\n        strokeWidth: 1,\r\n        strokeLinecap: 'round',\r\n        strokeDasharray: 'none'\r\n      }, options.attrs);\r\n\r\n      var ref = options.ref || { x: 0, y: 0 };\r\n\r\n      var scale = options.scale || 1;\r\n\r\n      // fix for safari / chrome / firefox bug not correctly\r\n      // resetting stroke dash array\r\n      if (attrs.strokeDasharray === 'none') {\r\n        attrs.strokeDasharray = [10000, 1];\r\n      }\r\n\r\n      var marker = options.element\r\n                     .attr(attrs)\r\n                     .marker(0, 0, 20, 20, ref.x, ref.y)\r\n                     .attr({\r\n                       markerWidth: 20 * scale,\r\n                       markerHeight: 20 * scale\r\n                     });\r\n\r\n      return addMarker(id, marker);\r\n    }\r\n\r\n\r\n    createMarker('sequenceflow-end', {\r\n      element: svg.path('M 1 5 L 11 10 L 1 15 Z'),\r\n      ref: { x: 11, y: 10 },\r\n      scale: 0.5\r\n    });\r\n\r\n    createMarker('messageflow-start', {\r\n      element: svg.circle(6, 6, 3.5),\r\n      attrs: {\r\n        fill: 'white',\r\n        stroke: 'black'\r\n      },\r\n      ref: { x: 6, y: 6 }\r\n    });\r\n\r\n    createMarker('messageflow-end', {\r\n      element: svg.path('m 1 5 l 0 -3 l 7 3 l -7 3 z'),\r\n      attrs: {\r\n        fill: 'white',\r\n        stroke: 'black',\r\n        strokeLinecap: 'butt'\r\n      },\r\n      ref: { x: 8.5, y: 5 }\r\n    });\r\n\r\n    createMarker('association-start', {\r\n      element: svg.path('M 11 5 L 1 10 L 11 15'),\r\n      attrs: {\r\n        fill: 'none',\r\n        stroke: 'black',\r\n        strokeWidth: 1.5\r\n      },\r\n      ref: { x: 1, y: 10 },\r\n      scale: 0.5\r\n    });\r\n\r\n    createMarker('association-end', {\r\n      element: svg.path('M 1 5 L 11 10 L 1 15'),\r\n      attrs: {\r\n        fill: 'none',\r\n        stroke: 'black',\r\n        strokeWidth: 1.5\r\n      },\r\n      ref: { x: 12, y: 10 },\r\n      scale: 0.5\r\n    });\r\n\r\n    createMarker('conditional-flow-marker', {\r\n      element: svg.path('M 0 10 L 8 6 L 16 10 L 8 14 Z'),\r\n      attrs: {\r\n        fill: 'white',\r\n        stroke: 'black'\r\n      },\r\n      ref: { x: -1, y: 10 },\r\n      scale: 0.5\r\n    });\r\n\r\n    createMarker('conditional-default-flow-marker', {\r\n      element: svg.path('M 1 4 L 5 16'),\r\n      attrs: {\r\n        stroke: 'black'\r\n      },\r\n      ref: { x: -5, y: 10 },\r\n      scale: 0.5\r\n    });\r\n  }\r\n\r\n  function drawCircle(p, width, height, offset, attrs) {\r\n\r\n    if (isObject(offset)) {\r\n      attrs = offset;\r\n      offset = 0;\r\n    }\r\n\r\n    offset = offset || 0;\r\n\r\n    attrs = computeStyle(attrs, {\r\n      stroke: 'black',\r\n      strokeWidth: 2,\r\n      fill: 'white'\r\n    });\r\n\r\n    var cx = width / 2,\r\n        cy = height / 2;\r\n\r\n    return p.circle(cx, cy, Math.round((width + height) / 4 - offset)).attr(attrs);\r\n  }\r\n\r\n  function drawRect(p, width, height, r, offset, attrs) {\r\n\r\n    if (isObject(offset)) {\r\n      attrs = offset;\r\n      offset = 0;\r\n    }\r\n\r\n    offset = offset || 0;\r\n\r\n    attrs = computeStyle(attrs, {\r\n      stroke: 'black',\r\n      strokeWidth: 2,\r\n      fill: 'white'\r\n    });\r\n\r\n    return p.rect(offset, offset, width - offset * 2, height - offset * 2, r).attr(attrs);\r\n  }\r\n\r\n  function drawDiamond(p, width, height, attrs) {\r\n\r\n    var x_2 = width / 2;\r\n    var y_2 = height / 2;\r\n\r\n    var points = [x_2, 0, width, y_2, x_2, height, 0, y_2 ];\r\n\r\n    attrs = computeStyle(attrs, {\r\n      stroke: 'black',\r\n      strokeWidth: 2,\r\n      fill: 'white'\r\n    });\r\n\r\n    return p.polygon(points).attr(attrs);\r\n  }\r\n\r\n  function drawLine(p, waypoints, attrs) {\r\n    attrs = computeStyle(attrs, [ 'no-fill' ], {\r\n      stroke: 'black',\r\n      strokeWidth: 2,\r\n      fill: 'none'\r\n    });\r\n\r\n    return createLine(waypoints, attrs).appendTo(p);\r\n  }\r\n\r\n  function drawPath(p, d, attrs) {\r\n\r\n    attrs = computeStyle(attrs, [ 'no-fill' ], {\r\n      strokeWidth: 2,\r\n      stroke: 'black'\r\n    });\r\n\r\n    return p.path(d).attr(attrs);\r\n  }\r\n\r\n  function drawMarker(type, p, path, attrs) {\r\n    return drawPath(p, path, assign({ 'data-marker': type }, attrs));\r\n  }\r\n\r\n  function as(type) {\r\n    return function(p, element) {\r\n      return handlers[type](p, element);\r\n    };\r\n  }\r\n\r\n  function renderer(type) {\r\n    return handlers[type];\r\n  }\r\n\r\n  function renderEventContent(element, p) {\r\n\r\n    var event = getSemantic(element);\r\n    var isThrowing = isThrowEvent(event);\r\n\r\n    if (isTypedEvent(event, 'vdml:MessageEventDefinition')) {\r\n      return renderer('vdml:MessageEventDefinition')(p, element, isThrowing);\r\n    }\r\n\r\n    if (isTypedEvent(event, 'vdml:TimerEventDefinition')) {\r\n      return renderer('vdml:TimerEventDefinition')(p, element, isThrowing);\r\n    }\r\n\r\n    if (isTypedEvent(event, 'vdml:ConditionalEventDefinition')) {\r\n      return renderer('vdml:ConditionalEventDefinition')(p, element);\r\n    }\r\n\r\n    if (isTypedEvent(event, 'vdml:SignalEventDefinition')) {\r\n      return renderer('vdml:SignalEventDefinition')(p, element, isThrowing);\r\n    }\r\n\r\n    if (isTypedEvent(event, 'vdml:CancelEventDefinition') &&\r\n      isTypedEvent(event, 'vdml:TerminateEventDefinition', { parallelMultiple: false })) {\r\n      return renderer('vdml:MultipleEventDefinition')(p, element, isThrowing);\r\n    }\r\n\r\n    if (isTypedEvent(event, 'vdml:CancelEventDefinition') &&\r\n      isTypedEvent(event, 'vdml:TerminateEventDefinition', { parallelMultiple: true })) {\r\n      return renderer('vdml:ParallelMultipleEventDefinition')(p, element, isThrowing);\r\n    }\r\n\r\n    if (isTypedEvent(event, 'vdml:EscalationEventDefinition')) {\r\n      return renderer('vdml:EscalationEventDefinition')(p, element, isThrowing);\r\n    }\r\n\r\n    if (isTypedEvent(event, 'vdml:LinkEventDefinition')) {\r\n      return renderer('vdml:LinkEventDefinition')(p, element, isThrowing);\r\n    }\r\n\r\n    if (isTypedEvent(event, 'vdml:ErrorEventDefinition')) {\r\n      return renderer('vdml:ErrorEventDefinition')(p, element, isThrowing);\r\n    }\r\n\r\n    if (isTypedEvent(event, 'vdml:CancelEventDefinition')) {\r\n      return renderer('vdml:CancelEventDefinition')(p, element, isThrowing);\r\n    }\r\n\r\n    if (isTypedEvent(event, 'vdml:CompensateEventDefinition')) {\r\n      return renderer('vdml:CompensateEventDefinition')(p, element, isThrowing);\r\n    }\r\n\r\n    if (isTypedEvent(event, 'vdml:TerminateEventDefinition')) {\r\n      return renderer('vdml:TerminateEventDefinition')(p, element, isThrowing);\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  function renderLabel(p, label, options) {\r\n    return textUtil.createText(p, label || '', options).addClass('djs-label');\r\n  }\r\n\r\n  function renderEmbeddedLabel(p, element, align) {\r\n    var semantic = getSemantic(element);\r\n    return renderLabel(p, semantic.name, { box: element, align: align, padding: 5 });\r\n  }\r\n\r\n  function renderExternalLabel(p, element) {\r\n    var semantic = getSemantic(element);\r\n    var box = {\r\n      width: 90,\r\n      height: 30,\r\n      x: element.width / 2 + element.x,\r\n      y: element.height / 2 + element.y\r\n    };\r\n\r\n    return renderLabel(p, semantic.name, { box: box, style: { fontSize: '11px' } });\r\n  }\r\n\r\n  function renderLaneLabel(p, text, element) {\r\n    var textBox = renderLabel(p, text, {\r\n      box: { height: 30, width: element.height },\r\n      align: 'center-middle'\r\n    });\r\n\r\n    var top = -1 * element.height;\r\n    textBox.transform(\r\n      'rotate(270) ' +\r\n      'translate(' + top + ',' + 0 + ')'\r\n    );\r\n  }\r\n\r\n  function createPathFromConnection(connection) {\r\n    var waypoints = connection.waypoints;\r\n\r\n    var pathData = 'm  ' + waypoints[0].x + ',' + waypoints[0].y;\r\n    for (var i = 1; i < waypoints.length; i++) {\r\n      pathData += 'L' + waypoints[i].x + ',' + waypoints[i].y + ' ';\r\n    }\r\n    return pathData;\r\n  }\r\n\r\n  var handlers = this.handlers = {\r\n    'vdml:Event': function(p, element, attrs) {\r\n      return drawCircle(p, element.width, element.height,  attrs);\r\n    },\r\n    'vdml:StartEvent': function(p, element) {\r\n      var attrs = {};\r\n      var semantic = getSemantic(element);\r\n\r\n      if (!semantic.isInterrupting) {\r\n        attrs = {\r\n          strokeDasharray: '6',\r\n          strokeLinecap: 'round'\r\n        };\r\n      }\r\n\r\n      var circle = renderer('vdml:Event')(p, element, attrs);\r\n\r\n      renderEventContent(element, p);\r\n\r\n      return circle;\r\n    },\r\n    'vdml:MessageEventDefinition': function(p, element, isThrowing) {\r\n      var pathData = pathMap.getScaledPath('EVENT_MESSAGE', {\r\n        xScaleFactor: 0.9,\r\n        yScaleFactor: 0.9,\r\n        containerWidth: element.width,\r\n        containerHeight: element.height,\r\n        position: {\r\n          mx: 0.235,\r\n          my: 0.315\r\n        }\r\n      });\r\n\r\n      var fill = isThrowing ? 'black' : 'white';\r\n      var stroke = isThrowing ? 'white' : 'black';\r\n\r\n      var messagePath = drawPath(p, pathData, {\r\n        strokeWidth: 1,\r\n        fill: fill,\r\n        stroke: stroke\r\n      });\r\n\r\n      return messagePath;\r\n    },\r\n    'vdml:TimerEventDefinition': function(p, element) {\r\n\r\n      var circle = drawCircle(p, element.width, element.height, 0.2 * element.height, {\r\n        strokeWidth: 2\r\n      });\r\n\r\n      var pathData = pathMap.getScaledPath('EVENT_TIMER_WH', {\r\n        xScaleFactor: 0.75,\r\n        yScaleFactor: 0.75,\r\n        containerWidth: element.width,\r\n        containerHeight: element.height,\r\n        position: {\r\n          mx: 0.5,\r\n          my: 0.5\r\n        }\r\n      });\r\n\r\n      drawPath(p, pathData, {\r\n        strokeWidth: 2,\r\n        strokeLinecap: 'square'\r\n      });\r\n\r\n      for (var i = 0;i < 12;i++) {\r\n\r\n        var linePathData = pathMap.getScaledPath('EVENT_TIMER_LINE', {\r\n          xScaleFactor: 0.75,\r\n          yScaleFactor: 0.75,\r\n          containerWidth: element.width,\r\n          containerHeight: element.height,\r\n          position: {\r\n            mx: 0.5,\r\n            my: 0.5\r\n          }\r\n        });\r\n\r\n        var width = element.width / 2;\r\n        var height = element.height / 2;\r\n\r\n        drawPath(p, linePathData, {\r\n          strokeWidth: 1,\r\n          strokeLinecap: 'square',\r\n          transform: 'rotate(' + (i * 30) + ',' + height + ',' + width + ')'\r\n        });\r\n      }\r\n\r\n      return circle;\r\n    },\r\n    'vdml:EscalationEventDefinition': function(p, event, isThrowing) {\r\n      var pathData = pathMap.getScaledPath('EVENT_ESCALATION', {\r\n        xScaleFactor: 1,\r\n        yScaleFactor: 1,\r\n        containerWidth: event.width,\r\n        containerHeight: event.height,\r\n        position: {\r\n          mx: 0.5,\r\n          my: 0.2\r\n        }\r\n      });\r\n\r\n      var fill = isThrowing ? 'black' : 'none';\r\n\r\n      return drawPath(p, pathData, {\r\n        strokeWidth: 1,\r\n        fill: fill\r\n      });\r\n    },\r\n    'vdml:ConditionalEventDefinition': function(p, event) {\r\n      var pathData = pathMap.getScaledPath('EVENT_CONDITIONAL', {\r\n        xScaleFactor: 1,\r\n        yScaleFactor: 1,\r\n        containerWidth: event.width,\r\n        containerHeight: event.height,\r\n        position: {\r\n          mx: 0.5,\r\n          my: 0.222\r\n        }\r\n      });\r\n\r\n      return drawPath(p, pathData, {\r\n        strokeWidth: 1\r\n      });\r\n    },\r\n    'vdml:LinkEventDefinition': function(p, event, isThrowing) {\r\n      var pathData = pathMap.getScaledPath('EVENT_LINK', {\r\n        xScaleFactor: 1,\r\n        yScaleFactor: 1,\r\n        containerWidth: event.width,\r\n        containerHeight: event.height,\r\n        position: {\r\n          mx: 0.57,\r\n          my: 0.263\r\n        }\r\n      });\r\n\r\n      var fill = isThrowing ? 'black' : 'none';\r\n\r\n      return drawPath(p, pathData, {\r\n        strokeWidth: 1,\r\n        fill: fill\r\n      });\r\n    },\r\n    'vdml:ErrorEventDefinition': function(p, event, isThrowing) {\r\n      var pathData = pathMap.getScaledPath('EVENT_ERROR', {\r\n        xScaleFactor: 1.1,\r\n        yScaleFactor: 1.1,\r\n        containerWidth: event.width,\r\n        containerHeight: event.height,\r\n        position: {\r\n          mx: 0.2,\r\n          my: 0.722\r\n        }\r\n      });\r\n\r\n      var fill = isThrowing ? 'black' : 'none';\r\n\r\n      return drawPath(p, pathData, {\r\n        strokeWidth: 1,\r\n        fill: fill\r\n      });\r\n    },\r\n    'vdml:CancelEventDefinition': function(p, event, isThrowing) {\r\n      var pathData = pathMap.getScaledPath('EVENT_CANCEL_45', {\r\n        xScaleFactor: 1.0,\r\n        yScaleFactor: 1.0,\r\n        containerWidth: event.width,\r\n        containerHeight: event.height,\r\n        position: {\r\n          mx: 0.638,\r\n          my: -0.055\r\n        }\r\n      });\r\n\r\n      var fill = isThrowing ? 'black' : 'none';\r\n\r\n      return drawPath(p, pathData, {\r\n        strokeWidth: 1,\r\n        fill: fill\r\n      }).transform('rotate(45)');\r\n    },\r\n    'vdml:CompensateEventDefinition': function(p, event, isThrowing) {\r\n      var pathData = pathMap.getScaledPath('EVENT_COMPENSATION', {\r\n        xScaleFactor: 1,\r\n        yScaleFactor: 1,\r\n        containerWidth: event.width,\r\n        containerHeight: event.height,\r\n        position: {\r\n          mx: 0.22,\r\n          my: 0.5\r\n        }\r\n      });\r\n\r\n      var fill = isThrowing ? 'black' : 'none';\r\n\r\n      return drawPath(p, pathData, {\r\n        strokeWidth: 1,\r\n        fill: fill\r\n      });\r\n    },\r\n    'vdml:SignalEventDefinition': function(p, event, isThrowing) {\r\n      var pathData = pathMap.getScaledPath('EVENT_SIGNAL', {\r\n        xScaleFactor: 0.9,\r\n        yScaleFactor: 0.9,\r\n        containerWidth: event.width,\r\n        containerHeight: event.height,\r\n        position: {\r\n          mx: 0.5,\r\n          my: 0.2\r\n        }\r\n      });\r\n\r\n      var fill = isThrowing ? 'black' : 'none';\r\n\r\n      return drawPath(p, pathData, {\r\n        strokeWidth: 1,\r\n        fill: fill\r\n      });\r\n    },\r\n    'vdml:MultipleEventDefinition': function(p, event, isThrowing) {\r\n      var pathData = pathMap.getScaledPath('EVENT_MULTIPLE', {\r\n        xScaleFactor: 1.1,\r\n        yScaleFactor: 1.1,\r\n        containerWidth: event.width,\r\n        containerHeight: event.height,\r\n        position: {\r\n          mx: 0.222,\r\n          my: 0.36\r\n        }\r\n      });\r\n\r\n      var fill = isThrowing ? 'black' : 'none';\r\n\r\n      return drawPath(p, pathData, {\r\n        strokeWidth: 1,\r\n        fill: fill\r\n      });\r\n    },\r\n    'vdml:ParallelMultipleEventDefinition': function(p, event) {\r\n      var pathData = pathMap.getScaledPath('EVENT_PARALLEL_MULTIPLE', {\r\n        xScaleFactor: 1.2,\r\n        yScaleFactor: 1.2,\r\n        containerWidth: event.width,\r\n        containerHeight: event.height,\r\n        position: {\r\n          mx: 0.458,\r\n          my: 0.194\r\n        }\r\n      });\r\n\r\n      return drawPath(p, pathData, {\r\n        strokeWidth: 1\r\n      });\r\n    },\r\n    'vdml:EndEvent': function(p, element) {\r\n      var circle = renderer('vdml:Event')(p, element, {\r\n        strokeWidth: 4\r\n      });\r\n\r\n      renderEventContent(element, p, true);\r\n\r\n      return circle;\r\n    },\r\n    'vdml:TerminateEventDefinition': function(p, element) {\r\n      var circle = drawCircle(p, element.width, element.height, 8, {\r\n        strokeWidth: 4,\r\n        fill: 'black'\r\n      });\r\n\r\n      return circle;\r\n    },\r\n    'vdml:IntermediateEvent': function(p, element) {\r\n      var outer = renderer('vdml:Event')(p, element, { strokeWidth: 1 });\r\n      /* inner */ drawCircle(p, element.width, element.height, INNER_OUTER_DIST, { strokeWidth: 1, fill: 'none' });\r\n\r\n      renderEventContent(element, p);\r\n\r\n      return outer;\r\n    },\r\n    'vdml:IntermediateCatchEvent': as('vdml:IntermediateEvent'),\r\n    'vdml:IntermediateThrowEvent': as('vdml:IntermediateEvent'),\r\n\r\n    'vdml:Activity': function(p, element, attrs) {\r\n      return drawRect(p, element.width, element.height, TASK_BORDER_RADIUS, attrs);\r\n    },\r\n\r\n    'vdml:Collaboration': function(p, element, attrs) {\r\n      var rect = renderer('vdml:Activity')(p, element, attrs);\r\n      renderEmbeddedLabel(p, element, 'center-middle');\r\n      attachTaskMarkers(p, element);\r\n      return rect;\r\n    },\r\n    'vdml:ServiceTask': function(p, element) {\r\n      var task = renderer('vdml:Task')(p, element);\r\n\r\n      var pathDataBG = pathMap.getScaledPath('TASK_TYPE_SERVICE', {\r\n        abspos: {\r\n          x: 12,\r\n          y: 18\r\n        }\r\n      });\r\n\r\n      /* service bg */ drawPath(p, pathDataBG, {\r\n        strokeWidth: 1,\r\n        fill: 'none'\r\n      });\r\n\r\n      var fillPathData = pathMap.getScaledPath('TASK_TYPE_SERVICE_FILL', {\r\n        abspos: {\r\n          x: 17.2,\r\n          y: 18\r\n        }\r\n      });\r\n\r\n      /* service fill */ drawPath(p, fillPathData, {\r\n        strokeWidth: 0,\r\n        stroke: 'none',\r\n        fill: 'white'\r\n      });\r\n\r\n      var pathData = pathMap.getScaledPath('TASK_TYPE_SERVICE', {\r\n        abspos: {\r\n          x: 17,\r\n          y: 22\r\n        }\r\n      });\r\n\r\n      /* service */ drawPath(p, pathData, {\r\n        strokeWidth: 1,\r\n        fill: 'white'\r\n      });\r\n\r\n      return task;\r\n    },\r\n    'vdml:UserTask': function(p, element) {\r\n      var task = renderer('vdml:Task')(p, element);\r\n\r\n      var x = 15;\r\n      var y = 12;\r\n\r\n      var pathData = pathMap.getScaledPath('TASK_TYPE_USER_1', {\r\n        abspos: {\r\n          x: x,\r\n          y: y\r\n        }\r\n      });\r\n\r\n      /* user path */ drawPath(p, pathData, {\r\n        strokeWidth: 0.5,\r\n        fill: 'none'\r\n      });\r\n\r\n      var pathData2 = pathMap.getScaledPath('TASK_TYPE_USER_2', {\r\n        abspos: {\r\n          x: x,\r\n          y: y\r\n        }\r\n      });\r\n\r\n      /* user2 path */ drawPath(p, pathData2, {\r\n        strokeWidth: 0.5,\r\n        fill: 'none'\r\n      });\r\n\r\n      var pathData3 = pathMap.getScaledPath('TASK_TYPE_USER_3', {\r\n        abspos: {\r\n          x: x,\r\n          y: y\r\n        }\r\n      });\r\n\r\n      /* user3 path */ drawPath(p, pathData3, {\r\n        strokeWidth: 0.5,\r\n        fill: 'black'\r\n      });\r\n\r\n      return task;\r\n    },\r\n    'vdml:ManualTask': function(p, element) {\r\n      var task = renderer('vdml:Task')(p, element);\r\n\r\n      var pathData = pathMap.getScaledPath('TASK_TYPE_MANUAL', {\r\n        abspos: {\r\n          x: 17,\r\n          y: 15\r\n        }\r\n      });\r\n\r\n      /* manual path */ drawPath(p, pathData, {\r\n        strokeWidth: 0.25,\r\n        fill: 'white',\r\n        stroke: 'black'\r\n      });\r\n\r\n      return task;\r\n    },\r\n    'vdml:SendTask': function(p, element) {\r\n      var task = renderer('vdml:Task')(p, element);\r\n\r\n      var pathData = pathMap.getScaledPath('TASK_TYPE_SEND', {\r\n        xScaleFactor: 1,\r\n        yScaleFactor: 1,\r\n        containerWidth: 21,\r\n        containerHeight: 14,\r\n        position: {\r\n          mx: 0.285,\r\n          my: 0.357\r\n        }\r\n      });\r\n\r\n      /* send path */ drawPath(p, pathData, {\r\n        strokeWidth: 1,\r\n        fill: 'black',\r\n        stroke: 'white'\r\n      });\r\n\r\n      return task;\r\n    },\r\n    'vdml:ReceiveTask' : function(p, element) {\r\n      var semantic = getSemantic(element);\r\n\r\n      var task = renderer('vdml:Task')(p, element);\r\n      var pathData;\r\n\r\n      if (semantic.instantiate) {\r\n        drawCircle(p, 28, 28, 20 * 0.22, { strokeWidth: 1 });\r\n\r\n        pathData = pathMap.getScaledPath('TASK_TYPE_INSTANTIATING_SEND', {\r\n          abspos: {\r\n            x: 7.77,\r\n            y: 9.52\r\n          }\r\n        });\r\n      } else {\r\n\r\n        pathData = pathMap.getScaledPath('TASK_TYPE_SEND', {\r\n          xScaleFactor: 0.9,\r\n          yScaleFactor: 0.9,\r\n          containerWidth: 21,\r\n          containerHeight: 14,\r\n          position: {\r\n            mx: 0.3,\r\n            my: 0.4\r\n          }\r\n        });\r\n      }\r\n\r\n      /* receive path */ drawPath(p, pathData, {\r\n        strokeWidth: 1\r\n      });\r\n\r\n      return task;\r\n    },\r\n    'vdml:ScriptTask': function(p, element) {\r\n      var task = renderer('vdml:Task')(p, element);\r\n\r\n      var pathData = pathMap.getScaledPath('TASK_TYPE_SCRIPT', {\r\n        abspos: {\r\n          x: 15,\r\n          y: 20\r\n        }\r\n      });\r\n\r\n      /* script path */ drawPath(p, pathData, {\r\n        strokeWidth: 1\r\n      });\r\n\r\n      return task;\r\n    },\r\n    'vdml:BusinessRuleTask': function(p, element) {\r\n      var task = renderer('vdml:Task')(p, element);\r\n\r\n      var headerPathData = pathMap.getScaledPath('TASK_TYPE_BUSINESS_RULE_HEADER', {\r\n        abspos: {\r\n          x: 8,\r\n          y: 8\r\n        }\r\n      });\r\n\r\n      var businessHeaderPath = drawPath(p, headerPathData);\r\n      businessHeaderPath.attr({\r\n        strokeWidth: 1,\r\n        fill: 'AAA'\r\n      });\r\n\r\n      var headerData = pathMap.getScaledPath('TASK_TYPE_BUSINESS_RULE_MAIN', {\r\n        abspos: {\r\n          x: 8,\r\n          y: 8\r\n        }\r\n      });\r\n\r\n      var businessPath = drawPath(p, headerData);\r\n      businessPath.attr({\r\n        strokeWidth: 1\r\n      });\r\n\r\n      return task;\r\n    },\r\n    'vdml:SubProcess': function(p, element, attrs) {\r\n\r\n      attrs = assign({ fillOpacity: 0.95 }, attrs);\r\n\r\n      var rect = renderer('vdml:Activity')(p, element, attrs);\r\n\r\n      var expanded = DiUtil.isExpanded(element);\r\n\r\n      var isEventSubProcess = DiUtil.isEventSubProcess(element);\r\n\r\n      if (isEventSubProcess) {\r\n        rect.attr({\r\n          strokeDasharray: '1,2'\r\n        });\r\n      }\r\n\r\n      renderEmbeddedLabel(p, element, expanded ? 'center-top' : 'center-middle');\r\n\r\n      if (expanded) {\r\n        attachTaskMarkers(p, element);\r\n      } else {\r\n        attachTaskMarkers(p, element, ['SubProcessMarker']);\r\n      }\r\n\r\n      return rect;\r\n    },\r\n    'vdml:AdHocSubProcess': function(p, element) {\r\n      return renderer('vdml:SubProcess')(p, element);\r\n    },\r\n    'vdml:Transaction': function(p, element) {\r\n      var outer = renderer('vdml:SubProcess')(p, element);\r\n\r\n      var innerAttrs = styles.style([ 'no-fill', 'no-events' ]);\r\n\r\n      /* inner path */ drawRect(p, element.width, element.height, TASK_BORDER_RADIUS - 2, INNER_OUTER_DIST, innerAttrs);\r\n\r\n      return outer;\r\n    },\r\n    'vdml:CallActivity': function(p, element) {\r\n      return renderer('vdml:SubProcess')(p, element, {\r\n        strokeWidth: 5\r\n      });\r\n    },\r\n    'vdml:Participant': function(p, element) {\r\n\r\n      var lane = renderer('vdml:Lane')(p, element, {\r\n        fillOpacity: 0.95,\r\n        fill: 'White'\r\n      });\r\n\r\n      var expandedPool = DiUtil.isExpanded(element);\r\n\r\n      if (expandedPool) {\r\n        drawLine(p, [\r\n          { x: 30, y: 0 },\r\n          { x: 30, y: element.height }\r\n        ]);\r\n        var text = getSemantic(element).name;\r\n        renderLaneLabel(p, text, element);\r\n      } else {\r\n        // Collapsed pool draw text inline\r\n        var text2 = getSemantic(element).name;\r\n        renderLabel(p, text2, { box: element, align: 'center-middle' });\r\n      }\r\n\r\n      var participantMultiplicity = !!(getSemantic(element).participantMultiplicity);\r\n\r\n      if (participantMultiplicity) {\r\n        renderer('ParticipantMultiplicityMarker')(p, element);\r\n      }\r\n\r\n      return lane;\r\n    },\r\n    'vdml:Lane': function(p, element, attrs) {\r\n      var rect = drawRect(p, element.width, element.height, 0, attrs || {\r\n        fill: 'none'\r\n      });\r\n\r\n      var semantic = getSemantic(element);\r\n\r\n      if (semantic.$type === 'vdml:Lane') {\r\n        var text = semantic.name;\r\n        renderLaneLabel(p, text, element);\r\n      }\r\n\r\n      return rect;\r\n    },\r\n    'vdml:InclusiveGateway': function(p, element) {\r\n      var diamond = drawDiamond(p, element.width, element.height);\r\n\r\n      /* circle path */\r\n      drawCircle(p, element.width, element.height, element.height * 0.24, {\r\n        strokeWidth: 2.5,\r\n        fill: 'none'\r\n      });\r\n\r\n      return diamond;\r\n    },\r\n    'vdml:ExclusiveGateway': function(p, element) {\r\n      var diamond = drawDiamond(p, element.width, element.height);\r\n\r\n      var pathData = pathMap.getScaledPath('GATEWAY_EXCLUSIVE', {\r\n        xScaleFactor: 0.4,\r\n        yScaleFactor: 0.4,\r\n        containerWidth: element.width,\r\n        containerHeight: element.height,\r\n        position: {\r\n          mx: 0.32,\r\n          my: 0.3\r\n        }\r\n      });\r\n\r\n      if ((getDi(element).isMarkerVisible)) {\r\n        drawPath(p, pathData, {\r\n          strokeWidth: 1,\r\n          fill: 'black'\r\n        });\r\n      }\r\n\r\n      return diamond;\r\n    },\r\n    'vdml:ComplexGateway': function(p, element) {\r\n      var diamond = drawDiamond(p, element.width, element.height);\r\n\r\n      var pathData = pathMap.getScaledPath('GATEWAY_COMPLEX', {\r\n        xScaleFactor: 0.5,\r\n        yScaleFactor:0.5,\r\n        containerWidth: element.width,\r\n        containerHeight: element.height,\r\n        position: {\r\n          mx: 0.46,\r\n          my: 0.26\r\n        }\r\n      });\r\n\r\n      /* complex path */ drawPath(p, pathData, {\r\n        strokeWidth: 1,\r\n        fill: 'black'\r\n      });\r\n\r\n      return diamond;\r\n    },\r\n    'vdml:ParallelGateway': function(p, element) {\r\n      var diamond = drawDiamond(p, element.width, element.height);\r\n\r\n      var pathData = pathMap.getScaledPath('GATEWAY_PARALLEL', {\r\n        xScaleFactor: 0.6,\r\n        yScaleFactor:0.6,\r\n        containerWidth: element.width,\r\n        containerHeight: element.height,\r\n        position: {\r\n          mx: 0.46,\r\n          my: 0.2\r\n        }\r\n      });\r\n\r\n      /* parallel path */ drawPath(p, pathData, {\r\n        strokeWidth: 1,\r\n        fill: 'black'\r\n      });\r\n\r\n      return diamond;\r\n    },\r\n    'vdml:EventBasedGateway': function(p, element) {\r\n\r\n      var semantic = getSemantic(element);\r\n\r\n      var diamond = drawDiamond(p, element.width, element.height);\r\n\r\n      /* outer circle path */ drawCircle(p, element.width, element.height, element.height * 0.20, {\r\n        strokeWidth: 1,\r\n        fill: 'none'\r\n      });\r\n\r\n      var type = semantic.eventGatewayType;\r\n      var instantiate = !!semantic.instantiate;\r\n\r\n      function drawEvent() {\r\n\r\n        var pathData = pathMap.getScaledPath('GATEWAY_EVENT_BASED', {\r\n          xScaleFactor: 0.18,\r\n          yScaleFactor: 0.18,\r\n          containerWidth: element.width,\r\n          containerHeight: element.height,\r\n          position: {\r\n            mx: 0.36,\r\n            my: 0.44\r\n          }\r\n        });\r\n\r\n        /* event path */ drawPath(p, pathData, {\r\n          strokeWidth: 2,\r\n          fill: 'none'\r\n        });\r\n      }\r\n\r\n      if (type === 'Parallel') {\r\n\r\n        var pathData = pathMap.getScaledPath('GATEWAY_PARALLEL', {\r\n          xScaleFactor: 0.4,\r\n          yScaleFactor:0.4,\r\n          containerWidth: element.width,\r\n          containerHeight: element.height,\r\n          position: {\r\n            mx: 0.474,\r\n            my: 0.296\r\n          }\r\n        });\r\n\r\n        var parallelPath = drawPath(p, pathData);\r\n        parallelPath.attr({\r\n          strokeWidth: 1,\r\n          fill: 'none'\r\n        });\r\n      } else if (type === 'Exclusive') {\r\n\r\n        if (!instantiate) {\r\n          var innerCircle = drawCircle(p, element.width, element.height, element.height * 0.26);\r\n          innerCircle.attr({\r\n            strokeWidth: 1,\r\n            fill: 'none'\r\n          });\r\n        }\r\n\r\n        drawEvent();\r\n      }\r\n\r\n\r\n      return diamond;\r\n    },\r\n    'vdml:Gateway': function(p, element) {\r\n      return drawDiamond(p, element.width, element.height);\r\n    },\r\n    'vdml:SequenceFlow': function(p, element) {\r\n      var pathData = createPathFromConnection(element);\r\n      var path = drawPath(p, pathData, {\r\n        strokeLinejoin: 'round',\r\n        markerEnd: marker('sequenceflow-end')\r\n      });\r\n\r\n      var sequenceFlow = getSemantic(element);\r\n      var source = element.source.businessObject;\r\n\r\n      // conditional flow marker\r\n      if (sequenceFlow.conditionExpression && source.$instanceOf('vdml:Activity')) {\r\n        path.attr({\r\n          markerStart: marker('conditional-flow-marker')\r\n        });\r\n      }\r\n\r\n      // default marker\r\n      if (source.default && (source.$instanceOf('vdml:Gateway') || source.$instanceOf('vdml:Activity')) &&\r\n          source.default === sequenceFlow) {\r\n        path.attr({\r\n          markerStart: marker('conditional-default-flow-marker')\r\n        });\r\n      }\r\n\r\n      return path;\r\n    },\r\n    'vdml:Association': function(p, element, attrs) {\r\n\r\n      var semantic = getSemantic(element);\r\n\r\n      attrs = assign({\r\n        strokeDasharray: '0.5, 5',\r\n        strokeLinecap: 'round',\r\n        strokeLinejoin: 'round'\r\n      }, attrs || {});\r\n\r\n      if (semantic.associationDirection === 'One' ||\r\n          semantic.associationDirection === 'Both') {\r\n        attrs.markerEnd = marker('association-end');\r\n      }\r\n\r\n      if (semantic.associationDirection === 'Both') {\r\n        attrs.markerStart = marker('association-start');\r\n      }\r\n\r\n      return drawLine(p, element.waypoints, attrs);\r\n    },\r\n    'vdml:DataInputAssociation': function(p, element) {\r\n      return renderer('vdml:Association')(p, element, {\r\n        markerEnd: marker('association-end')\r\n      });\r\n    },\r\n    'vdml:DataOutputAssociation': function(p, element) {\r\n      return renderer('vdml:Association')(p, element, {\r\n        markerEnd: marker('association-end')\r\n      });\r\n    },\r\n    'vdml:MessageFlow': function(p, element) {\r\n\r\n      var semantic = getSemantic(element),\r\n          di = getDi(element);\r\n\r\n      var pathData = createPathFromConnection(element);\r\n      var path = drawPath(p, pathData, {\r\n        markerEnd: marker('messageflow-end'),\r\n        markerStart: marker('messageflow-start'),\r\n        strokeDasharray: '10, 12',\r\n        strokeLinecap: 'round',\r\n        strokeLinejoin: 'round',\r\n        strokeWidth: '1.5px'\r\n      });\r\n\r\n      if (semantic.messageRef) {\r\n        var midPoint = path.getPointAtLength(path.getTotalLength() / 2);\r\n\r\n        var markerPathData = pathMap.getScaledPath('MESSAGE_FLOW_MARKER', {\r\n          abspos: {\r\n            x: midPoint.x,\r\n            y: midPoint.y\r\n          }\r\n        });\r\n\r\n        var messageAttrs = { strokeWidth: 1 };\r\n\r\n        if (di.messageVisibleKind === 'initiating') {\r\n          messageAttrs.fill = 'white';\r\n          messageAttrs.stroke = 'black';\r\n        } else {\r\n          messageAttrs.fill = '#888';\r\n          messageAttrs.stroke = 'white';\r\n        }\r\n\r\n        drawPath(p, markerPathData, messageAttrs);\r\n      }\r\n\r\n      return path;\r\n    },\r\n    'vdml:DataObject': function(p, element) {\r\n      var pathData = pathMap.getScaledPath('DATA_OBJECT_PATH', {\r\n        xScaleFactor: 1,\r\n        yScaleFactor: 1,\r\n        containerWidth: element.width,\r\n        containerHeight: element.height,\r\n        position: {\r\n          mx: 0.474,\r\n          my: 0.296\r\n        }\r\n      });\r\n\r\n      var elementObject = drawPath(p, pathData, { fill: 'white' });\r\n\r\n      var semantic = getSemantic(element);\r\n\r\n      if (isCollection(semantic)) {\r\n        renderDataItemCollection(p, element);\r\n      }\r\n\r\n      return elementObject;\r\n    },\r\n    'vdml:DataObjectReference': as('vdml:DataObject'),\r\n    'vdml:DataInput': function(p, element) {\r\n\r\n      var arrowPathData = pathMap.getRawPath('DATA_ARROW');\r\n\r\n      // page\r\n      var elementObject = renderer('vdml:DataObject')(p, element);\r\n\r\n      /* input arrow path */ drawPath(p, arrowPathData, { strokeWidth: 1 });\r\n\r\n      return elementObject;\r\n    },\r\n    'vdml:DataOutput': function(p, element) {\r\n      var arrowPathData = pathMap.getRawPath('DATA_ARROW');\r\n\r\n      // page\r\n      var elementObject = renderer('vdml:DataObject')(p, element);\r\n\r\n      /* output arrow path */ drawPath(p, arrowPathData, {\r\n        strokeWidth: 1,\r\n        fill: 'black'\r\n      });\r\n\r\n      return elementObject;\r\n    },\r\n    'vdml:DataStoreReference': function(p, element) {\r\n      var DATA_STORE_PATH = pathMap.getScaledPath('DATA_STORE', {\r\n        xScaleFactor: 1,\r\n        yScaleFactor: 1,\r\n        containerWidth: element.width,\r\n        containerHeight: element.height,\r\n        position: {\r\n          mx: 0,\r\n          my: 0.133\r\n        }\r\n      });\r\n\r\n      var elementStore = drawPath(p, DATA_STORE_PATH, {\r\n        strokeWidth: 2,\r\n        fill: 'white'\r\n      });\r\n\r\n      return elementStore;\r\n    },\r\n    'vdml:BoundaryEvent': function(p, element) {\r\n\r\n      var semantic = getSemantic(element),\r\n          cancel = semantic.cancelActivity;\r\n\r\n      var attrs = {\r\n        strokeWidth: 1\r\n      };\r\n\r\n      if (!cancel) {\r\n        attrs.strokeDasharray = '6';\r\n        attrs.strokeLinecap = 'round';\r\n      }\r\n\r\n      var outer = renderer('vdml:Event')(p, element, attrs);\r\n      /* inner path */ drawCircle(p, element.width, element.height, INNER_OUTER_DIST, assign(attrs, { fill: 'none' }));\r\n\r\n      renderEventContent(element, p);\r\n\r\n      return outer;\r\n    },\r\n    'vdml:Group': function(p, element) {\r\n      return drawRect(p, element.width, element.height, TASK_BORDER_RADIUS, {\r\n        strokeWidth: 1,\r\n        strokeDasharray: '8,3,1,3',\r\n        fill: 'none',\r\n        pointerEvents: 'none'\r\n      });\r\n    },\r\n    'label': function(p, element) {\r\n      // Update external label size and bounds during rendering when\r\n      // we have the actual rendered bounds anyway.\r\n\r\n      var textElement = renderExternalLabel(p, element);\r\n\r\n      var textBBox = textElement.getBBox();\r\n\r\n      // update element.x so that the layouted text is still\r\n      // center alligned (newX = oldMidX - newWidth / 2)\r\n      element.x = Math.ceil(element.x + element.width / 2) - Math.ceil((textBBox.width / 2));\r\n\r\n      // take element width, height from actual bounds\r\n      element.width = Math.ceil(textBBox.width);\r\n      element.height = Math.ceil(textBBox.height);\r\n\r\n      // compensate bounding box x\r\n      textElement.attr({\r\n        transform: 'translate(' + (-1 * textBBox.x) + ',0)'\r\n      });\r\n\r\n      return textElement;\r\n    },\r\n    'vdml:TextAnnotation': function(p, element) {\r\n      var style = {\r\n        'fill': 'none',\r\n        'stroke': 'none'\r\n      };\r\n      var textElement = drawRect(p, element.width, element.height, 0, 0, style);\r\n      var textPathData = pathMap.getScaledPath('TEXT_ANNOTATION', {\r\n        xScaleFactor: 1,\r\n        yScaleFactor: 1,\r\n        containerWidth: element.width,\r\n        containerHeight: element.height,\r\n        position: {\r\n          mx: 0.0,\r\n          my: 0.0\r\n        }\r\n      });\r\n      drawPath(p, textPathData);\r\n\r\n      var text = getSemantic(element).text || '';\r\n      renderLabel(p, text, { box: element, align: 'left-middle', padding: 5 });\r\n\r\n      return textElement;\r\n    },\r\n    'ParticipantMultiplicityMarker': function(p, element) {\r\n      var markerPath = pathMap.getScaledPath('MARKER_PARALLEL', {\r\n        xScaleFactor: 1,\r\n        yScaleFactor: 1,\r\n        containerWidth: element.width,\r\n        containerHeight: element.height,\r\n        position: {\r\n          mx: ((element.width / 2) / element.width),\r\n          my: (element.height - 15) / element.height\r\n        }\r\n      });\r\n\r\n      drawMarker('participant-multiplicity', p, markerPath);\r\n    },\r\n    'SubProcessMarker': function(p, element) {\r\n      var markerRect = drawRect(p, 14, 14, 0, {\r\n        strokeWidth: 1\r\n      });\r\n\r\n      // Process marker is placed in the middle of the box\r\n      // therefore fixed values can be used here\r\n      markerRect.transform('translate(' + (element.width / 2 - 7.5) + ',' + (element.height - 20) + ')');\r\n\r\n      var markerPath = pathMap.getScaledPath('MARKER_SUB_PROCESS', {\r\n        xScaleFactor: 1.5,\r\n        yScaleFactor: 1.5,\r\n        containerWidth: element.width,\r\n        containerHeight: element.height,\r\n        position: {\r\n          mx: (element.width / 2 - 7.5) / element.width,\r\n          my: (element.height - 20) / element.height\r\n        }\r\n      });\r\n\r\n      drawMarker('sub-process', p, markerPath);\r\n    },\r\n    'ParallelMarker': function(p, element, position) {\r\n      var markerPath = pathMap.getScaledPath('MARKER_PARALLEL', {\r\n        xScaleFactor: 1,\r\n        yScaleFactor: 1,\r\n        containerWidth: element.width,\r\n        containerHeight: element.height,\r\n        position: {\r\n          mx: ((element.width / 2 + position.parallel) / element.width),\r\n          my: (element.height - 20) / element.height\r\n        }\r\n      });\r\n\r\n      drawMarker('parallel', p, markerPath);\r\n    },\r\n    'SequentialMarker': function(p, element, position) {\r\n      var markerPath = pathMap.getScaledPath('MARKER_SEQUENTIAL', {\r\n        xScaleFactor: 1,\r\n        yScaleFactor: 1,\r\n        containerWidth: element.width,\r\n        containerHeight: element.height,\r\n        position: {\r\n          mx: ((element.width / 2 + position.seq) / element.width),\r\n          my: (element.height - 19) / element.height\r\n        }\r\n      });\r\n\r\n      drawMarker('sequential', p, markerPath);\r\n    },\r\n    'CompensationMarker': function(p, element, position) {\r\n      var markerMath = pathMap.getScaledPath('MARKER_COMPENSATION', {\r\n        xScaleFactor: 1,\r\n        yScaleFactor: 1,\r\n        containerWidth: element.width,\r\n        containerHeight: element.height,\r\n        position: {\r\n          mx: ((element.width / 2 + position.compensation) / element.width),\r\n          my: (element.height - 13) / element.height\r\n        }\r\n      });\r\n\r\n      drawMarker('compensation', p, markerMath, { strokeWidth: 1 });\r\n    },\r\n    'LoopMarker': function(p, element, position) {\r\n      var markerPath = pathMap.getScaledPath('MARKER_LOOP', {\r\n        xScaleFactor: 1,\r\n        yScaleFactor: 1,\r\n        containerWidth: element.width,\r\n        containerHeight: element.height,\r\n        position: {\r\n          mx: ((element.width / 2 + position.loop) / element.width),\r\n          my: (element.height - 7) / element.height\r\n        }\r\n      });\r\n\r\n      drawMarker('loop', p, markerPath, {\r\n        strokeWidth: 1,\r\n        fill: 'none',\r\n        strokeLinecap: 'round',\r\n        strokeMiterlimit: 0.5\r\n      });\r\n    },\r\n    'AdhocMarker': function(p, element, position) {\r\n      var markerPath = pathMap.getScaledPath('MARKER_ADHOC', {\r\n        xScaleFactor: 1,\r\n        yScaleFactor: 1,\r\n        containerWidth: element.width,\r\n        containerHeight: element.height,\r\n        position: {\r\n          mx: ((element.width / 2 + position.adhoc) / element.width),\r\n          my: (element.height - 15) / element.height\r\n        }\r\n      });\r\n\r\n      drawMarker('adhoc', p, markerPath, {\r\n        strokeWidth: 1,\r\n        fill: 'black'\r\n      });\r\n    }\r\n  };\r\n\r\n  function attachTaskMarkers(p, element, taskMarkers) {\r\n    var obj = getSemantic(element);\r\n\r\n    var subprocess = includes(taskMarkers, 'SubProcessMarker');\r\n    var position;\r\n\r\n    if (subprocess) {\r\n      position = {\r\n        seq: -21,\r\n        parallel: -22,\r\n        compensation: -42,\r\n        loop: -18,\r\n        adhoc: 10\r\n      };\r\n    } else {\r\n      position = {\r\n        seq: -3,\r\n        parallel: -6,\r\n        compensation: -27,\r\n        loop: 0,\r\n        adhoc: 10\r\n      };\r\n    }\r\n\r\n    forEach(taskMarkers, function(marker) {\r\n      renderer(marker)(p, element, position);\r\n    });\r\n\r\n    if (obj.isForCompensation) {\r\n      renderer('CompensationMarker')(p, element, position);\r\n    }\r\n\r\n    if (obj.$type === 'vdml:AdHocSubProcess') {\r\n      renderer('AdhocMarker')(p, element, position);\r\n    }\r\n\r\n    var loopCharacteristics = obj.loopCharacteristics,\r\n        isSequential = loopCharacteristics && loopCharacteristics.isSequential;\r\n\r\n    if (loopCharacteristics) {\r\n\r\n      if (isSequential === undefined) {\r\n        renderer('LoopMarker')(p, element, position);\r\n      }\r\n\r\n      if (isSequential === false) {\r\n        renderer('ParallelMarker')(p, element, position);\r\n      }\r\n\r\n      if (isSequential === true) {\r\n        renderer('SequentialMarker')(p, element, position);\r\n      }\r\n    }\r\n  }\r\n\r\n  function renderDataItemCollection(p, element) {\r\n\r\n    var yPosition = (element.height - 16) / element.height;\r\n\r\n    var pathData = pathMap.getScaledPath('DATA_OBJECT_COLLECTION_PATH', {\r\n      xScaleFactor: 1,\r\n      yScaleFactor: 1,\r\n      containerWidth: element.width,\r\n      containerHeight: element.height,\r\n      position: {\r\n        mx: 0.451,\r\n        my: yPosition\r\n      }\r\n    });\r\n\r\n    /* collection path */ drawPath(p, pathData, {\r\n      strokeWidth: 2\r\n    });\r\n  }\r\n\r\n  // hook onto canvas init event to initialize\r\n  // connection start/end markers on svg\r\n  eventBus.on('canvas.init', function(event) {\r\n    initMarkers(event.svg);\r\n  });\r\n}\r\n\r\n\r\ninherits(VdmlRenderer, BaseRenderer);\r\n\r\nVdmlRenderer.$inject = [ 'eventBus', 'styles', 'pathMap' ];\r\n\r\nmodule.exports = VdmlRenderer;\r\n\r\n\r\nVdmlRenderer.prototype.canRender = function(element) {\r\n  return is(element, 'vdml:BaseElement');\r\n};\r\n\r\nVdmlRenderer.prototype.drawShape = function(visuals, element) {\r\n  var type = element.type;\r\n  var h = this.handlers[type];\r\n\r\n  /* jshint -W040 */\r\n  return h(visuals, element);\r\n};\r\n\r\nVdmlRenderer.prototype.drawConnection = function(visuals, element) {\r\n  var type = element.type;\r\n  var h = this.handlers[type];\r\n\r\n  /* jshint -W040 */\r\n  return h(visuals, element);\r\n};\r\n\r\nVdmlRenderer.prototype.getShapePath = function(element) {\r\n\r\n  if (is(element, 'vdml:Event')) {\r\n    return getCirclePath(element);\r\n  }\r\n\r\n  if (is(element, 'vdml:Activity')) {\r\n    return getRoundRectPath(element, TASK_BORDER_RADIUS);\r\n  }\r\n\r\n  if (is(element, 'vdml:Gateway')) {\r\n    return getDiamondPath(element);\r\n  }\r\n\r\n  return getRectPath(element);\r\n};\r\n\r\n\r\n///////// helper functions /////////////////////////////\r\n\r\n/**\r\n * Checks if eventDefinition of the given element matches with semantic type.\r\n *\r\n * @return {boolean} true if element is of the given semantic type\r\n */\r\nfunction isTypedEvent(event, eventDefinitionType, filter) {\r\n\r\n  function matches(definition, filter) {\r\n    return every(filter, function(val, key) {\r\n\r\n      // we want a == conversion here, to be able to catch\r\n      // undefined == false and friends\r\n      /* jshint -W116 */\r\n      return definition[key] == val;\r\n    });\r\n  }\r\n\r\n  return some(event.eventDefinitions, function(definition) {\r\n    return definition.$type === eventDefinitionType && matches(event, filter);\r\n  });\r\n}\r\n\r\nfunction isThrowEvent(event) {\r\n  return (event.$type === 'vdml:IntermediateThrowEvent') || (event.$type === 'vdml:EndEvent');\r\n}\r\n\r\nfunction isCollection(element) {\r\n  return element.isCollection ||\r\n        (element.elementObjectRef && element.elementObjectRef.isCollection);\r\n}\r\n\r\nfunction getDi(element) {\r\n  return element.businessObject.di;\r\n}\r\n\r\nfunction getSemantic(element) {\r\n  return element.businessObject;\r\n}\r\n\r\n\r\n\r\n/////// cropping path customizations /////////////////////////\r\n\r\nfunction getCirclePath(shape) {\r\n\r\n  var cx = shape.x + shape.width / 2,\r\n      cy = shape.y + shape.height / 2,\r\n      radius = shape.width / 2;\r\n\r\n  var circlePath = [\r\n    ['M', cx, cy],\r\n    ['m', 0, -radius],\r\n    ['a', radius, radius, 0, 1, 1, 0, 2 * radius],\r\n    ['a', radius, radius, 0, 1, 1, 0, -2 * radius],\r\n    ['z']\r\n  ];\r\n\r\n  return componentsToPath(circlePath);\r\n}\r\n\r\nfunction getRoundRectPath(shape, borderRadius) {\r\n\r\n  var x = shape.x,\r\n      y = shape.y,\r\n      width = shape.width,\r\n      height = shape.height;\r\n\r\n  var roundRectPath = [\r\n    ['M', x + borderRadius, y],\r\n    ['l', width - borderRadius * 2, 0],\r\n    ['a', borderRadius, borderRadius, 0, 0, 1, borderRadius, borderRadius],\r\n    ['l', 0, height - borderRadius * 2],\r\n    ['a', borderRadius, borderRadius, 0, 0, 1, -borderRadius, borderRadius],\r\n    ['l', borderRadius * 2 - width, 0],\r\n    ['a', borderRadius, borderRadius, 0, 0, 1, -borderRadius, -borderRadius],\r\n    ['l', 0, borderRadius * 2 - height],\r\n    ['a', borderRadius, borderRadius, 0, 0, 1, borderRadius, -borderRadius],\r\n    ['z']\r\n  ];\r\n\r\n  return componentsToPath(roundRectPath);\r\n}\r\n\r\nfunction getDiamondPath(shape) {\r\n\r\n  var width = shape.width,\r\n      height = shape.height,\r\n      x = shape.x,\r\n      y = shape.y,\r\n      halfWidth = width / 2,\r\n      halfHeight = height / 2;\r\n\r\n  var diamondPath = [\r\n    ['M', x + halfWidth, y],\r\n    ['l', halfWidth, halfHeight],\r\n    ['l', -halfWidth, halfHeight],\r\n    ['l', -halfWidth, -halfHeight],\r\n    ['z']\r\n  ];\r\n\r\n  return componentsToPath(diamondPath);\r\n}\r\n\r\nfunction getRectPath(shape) {\r\n  var x = shape.x,\r\n      y = shape.y,\r\n      width = shape.width,\r\n      height = shape.height;\r\n\r\n  var rectPath = [\r\n    ['M', x, y],\r\n    ['l', width, 0],\r\n    ['l', 0, height],\r\n    ['l', -width, 0],\r\n    ['z']\r\n  ];\r\n\r\n  return componentsToPath(rectPath);\r\n}\r\n","module.exports = {\r\n  __init__: [ 'vdmlRenderer' ],\r\n  vdmlRenderer: [ 'type', require(6) ],\r\n  pathMap: [ 'type', require(5) ]\r\n};\r\n","var AutoResize = require(117);\r\n\r\nvar inherits = require(270);\r\n\r\nvar is = require(93).is;\r\n\r\n/**\r\n * Sub class of the AutoResize module which implements a VDML\r\n * specific resize function.\r\n */\r\nfunction VdmlAutoResize(eventBus, elementRegistry, modeling, rules) {\r\n  AutoResize.call(this, eventBus, elementRegistry, modeling, rules);\r\n}\r\n\r\nVdmlAutoResize.$inject = [ 'eventBus', 'elementRegistry', 'modeling', 'rules' ];\r\n\r\ninherits(VdmlAutoResize, AutoResize);\r\n\r\nmodule.exports = VdmlAutoResize;\r\n\r\n\r\n/**\r\n * Resize shapes and lanes\r\n *\r\n * @param  {djs.model.Shape} target\r\n * @param  {Object} newBounds\r\n */\r\nVdmlAutoResize.prototype.resize = function(target, newBounds) {\r\n\r\n  if (is(target, 'vdml:Participant')) {\r\n    this._modeling.resizeLane(target, newBounds);\r\n  } else {\r\n    this._modeling.resizeShape(target, newBounds);\r\n  }\r\n};","'use strict';\r\n\r\nvar is = require(93).is;\r\n\r\nvar inherits = require(270);\r\n\r\nvar forEach = require(283);\r\n\r\nvar AutoResizeProvider = require(118);\r\n\r\n/**\r\n * This module is a provider for automatically resizing parent VDML elements\r\n */\r\nfunction VdmlAutoResizeProvider(eventBus, modeling) {\r\n  AutoResizeProvider.call(this, eventBus);\r\n\r\n  this._modeling = modeling;\r\n}\r\n\r\ninherits(VdmlAutoResizeProvider, AutoResizeProvider);\r\n\r\nVdmlAutoResizeProvider.$inject = [ 'eventBus', 'modeling' ];\r\n\r\nmodule.exports = VdmlAutoResizeProvider;\r\n\r\n\r\n/**\r\n * Check if the given target can be expanded\r\n *\r\n * @param  {djs.model.Shape} target\r\n *\r\n * @return {boolean}\r\n */\r\nVdmlAutoResizeProvider.prototype.canResize = function(elements, target) {\r\n\r\n  if (!is(target, 'vdml:Participant') && !is(target, 'vdml:Lane') && !(is(target, 'vdml:SubProcess'))) {\r\n    return false;\r\n  }\r\n\r\n  var canResize = true;\r\n\r\n  forEach(elements, function(element) {\r\n\r\n    if (is(element, 'vdml:Lane') || element.labelTarget) {\r\n      canResize = false;\r\n      return;\r\n    }\r\n  });\r\n\r\n  return canResize;\r\n};\r\n","module.exports = {\r\n  __init__: [ 'vdmlAutoResize', 'vdmlAutoResizeProvider' ],\r\n  vdmlAutoResize: [ 'type', require(8) ],\r\n  vdmlAutoResizeProvider: [ 'type', require(9) ]\r\n};\r\n","'use strict';\r\n\r\n\r\nvar assign = require(410),\r\n    forEach = require(283),\r\n    isArray = require(401),\r\n    is = require(93).is,\r\n    isExpanded = require(91).isExpanded,\r\n    isAny = require(66).isAny,\r\n    getChildLanes = require(65).getChildLanes,\r\n    isEventSubProcess = require(91).isEventSubProcess,\r\n    hasPrimaryModifier = require(254).hasPrimaryModifier;\r\n\r\n/**\r\n * A provider for VDML 2.0 elements context pad\r\n */\r\nfunction ContextPadProvider(eventBus, contextPad, modeling, elementFactory,\r\n                            connect, create, popupMenu,\r\n                            canvas, rules, translate) {\r\n\r\n  contextPad.registerProvider(this);\r\n\r\n  this._contextPad = contextPad;\r\n\r\n  this._modeling = modeling;\r\n\r\n  this._elementFactory = elementFactory;\r\n  this._connect = connect;\r\n  this._create = create;\r\n  this._popupMenu = popupMenu;\r\n  this._canvas  = canvas;\r\n  this._rules = rules;\r\n  this._translate = translate;\r\n\r\n\r\n  eventBus.on('create.end', 250, function(event) {\r\n    var shape = event.context.shape;\r\n\r\n    if (!hasPrimaryModifier(event)) {\r\n      return;\r\n    }\r\n\r\n    var entries = contextPad.getEntries(shape);\r\n\r\n    if (entries.replace) {\r\n      entries.replace.action.click(event, shape);\r\n    }\r\n  });\r\n}\r\n\r\nContextPadProvider.$inject = [\r\n  'eventBus',\r\n  'contextPad',\r\n  'modeling',\r\n  'elementFactory',\r\n  'connect',\r\n  'create',\r\n  'popupMenu',\r\n  'canvas',\r\n  'rules',\r\n  'translate'\r\n];\r\n\r\nmodule.exports = ContextPadProvider;\r\n\r\n\r\nContextPadProvider.prototype.getContextPadEntries = function(element) {\r\n\r\n  var contextPad = this._contextPad,\r\n      modeling = this._modeling,\r\n\r\n      elementFactory = this._elementFactory,\r\n      connect = this._connect,\r\n      create = this._create,\r\n      popupMenu = this._popupMenu,\r\n      canvas = this._canvas,\r\n      rules = this._rules,\r\n\r\n      translate = this._translate;\r\n\r\n  var actions = {};\r\n\r\n  if (element.type === 'label') {\r\n    return actions;\r\n  }\r\n\r\n  var businessObject = element.businessObject;\r\n\r\n  function startConnect(event, element, autoActivate) {\r\n    connect.start(event, element, autoActivate);\r\n  }\r\n\r\n  function removeElement(e) {\r\n    modeling.removeElements([ element ]);\r\n  }\r\n\r\n  function getReplaceMenuPosition(element) {\r\n\r\n    var Y_OFFSET = 5;\r\n\r\n    var diagramContainer = canvas.getContainer(),\r\n        pad = contextPad.getPad(element).html;\r\n\r\n    var diagramRect = diagramContainer.getBoundingClientRect(),\r\n        padRect = pad.getBoundingClientRect();\r\n\r\n    var top = padRect.top - diagramRect.top;\r\n    var left = padRect.left - diagramRect.left;\r\n\r\n    var pos = {\r\n      x: left,\r\n      y: top + padRect.height + Y_OFFSET\r\n    };\r\n\r\n    return pos;\r\n  }\r\n\r\n\r\n  /**\r\n   * Create an append action\r\n   *\r\n   * @param {String} type\r\n   * @param {String} className\r\n   * @param {String} [title]\r\n   * @param {Object} [options]\r\n   *\r\n   * @return {Object} descriptor\r\n   */\r\n  function appendAction(type, className, title, options) {\r\n\r\n    if (typeof title !== 'string') {\r\n      options = title;\r\n      title = translate('Append {type}', { type: type.replace(/^vdml/:/, '') });\r\n    }\r\n\r\n    function appendListener(event, element) {\r\n\r\n      var shape = elementFactory.createShape(assign({ type: type }, options));\r\n      create.start(event, shape, element);\r\n    }\r\n\r\n    return {\r\n      group: 'model',\r\n      className: className,\r\n      title: title,\r\n      action: {\r\n        dragstart: appendListener,\r\n        click: appendListener\r\n      }\r\n    };\r\n  }\r\n\r\n  function splitLaneHandler(count) {\r\n\r\n    return function(event, element) {\r\n      // actual split\r\n      modeling.splitLane(element, count);\r\n\r\n      // refresh context pad after split to\r\n      // get rid of split icons\r\n      contextPad.open(element, true);\r\n    };\r\n  }\r\n\r\n\r\n  if (isAny(businessObject, [ 'vdml:Lane', 'vdml:Participant' ]) && isExpanded(businessObject)) {\r\n\r\n    var childLanes = getChildLanes(element);\r\n\r\n    assign(actions, {\r\n      'lane-insert-above': {\r\n        group: 'lane-insert-above',\r\n        className: 'bpmn-icon-lane-insert-above',\r\n        title: translate('Add Lane above'),\r\n        action: {\r\n          click: function(event, element) {\r\n            modeling.addLane(element, 'top');\r\n          }\r\n        }\r\n      }\r\n    });\r\n\r\n    if (childLanes.length < 2) {\r\n\r\n      if (element.height >= 120) {\r\n        assign(actions, {\r\n          'lane-divide-two': {\r\n            group: 'lane-divide',\r\n            className: 'bpmn-icon-lane-divide-two',\r\n            title: translate('Divide into two Lanes'),\r\n            action: {\r\n              click: splitLaneHandler(2)\r\n            }\r\n          }\r\n        });\r\n      }\r\n\r\n      if (element.height >= 180) {\r\n        assign(actions, {\r\n          'lane-divide-three': {\r\n            group: 'lane-divide',\r\n            className: 'bpmn-icon-lane-divide-three',\r\n            title: translate('Divide into three Lanes'),\r\n            action: {\r\n              click: splitLaneHandler(3)\r\n            }\r\n          }\r\n        });\r\n      }\r\n    }\r\n\r\n    assign(actions, {\r\n      'lane-insert-below': {\r\n        group: 'lane-insert-below',\r\n        className: 'bpmn-icon-lane-insert-below',\r\n        title: translate('Add Lane below'),\r\n        action: {\r\n          click: function(event, element) {\r\n            modeling.addLane(element, 'bottom');\r\n          }\r\n        }\r\n      }\r\n    });\r\n\r\n  }\r\n\r\n  if (is(businessObject, 'vdml:FlowNode')) {\r\n\r\n    if (is(businessObject, 'vdml:EventBasedGateway')) {\r\n\r\n      assign(actions, {\r\n        'append.receive-task': appendAction('vdml:ReceiveTask', 'bpmn-icon-receive-task'),\r\n        'append.message-intermediate-event': appendAction('vdml:IntermediateCatchEvent',\r\n                                                  'bpmn-icon-intermediate-event-catch-message',\r\n                                                  { eventDefinitionType: 'vdml:MessageEventDefinition' }),\r\n        'append.timer-intermediate-event': appendAction('vdml:IntermediateCatchEvent',\r\n                                                  'bpmn-icon-intermediate-event-catch-timer',\r\n                                                  { eventDefinitionType: 'vdml:TimerEventDefinition' }),\r\n        'append.condtion-intermediate-event': appendAction('vdml:IntermediateCatchEvent',\r\n                                                  'bpmn-icon-intermediate-event-catch-condition',\r\n                                                  { eventDefinitionType: 'vdml:ConditionalEventDefinition' }),\r\n        'append.signal-intermediate-event': appendAction('vdml:IntermediateCatchEvent',\r\n                                                  'bpmn-icon-intermediate-event-catch-signal',\r\n                                                  { eventDefinitionType: 'vdml:SignalEventDefinition' })\r\n      });\r\n    } else\r\n\r\n    if (isEventType(businessObject, 'vdml:BoundaryEvent', 'vdml:CompensateEventDefinition')) {\r\n\r\n      assign(actions, {\r\n        'append.compensation-activity':\r\n            appendAction('vdml:Task', 'bpmn-icon-task', translate('Append compensation activity'), {\r\n              isForCompensation: true\r\n            })\r\n      });\r\n    } else\r\n\r\n    if (!is(businessObject, 'vdml:EndEvent') &&\r\n        !businessObject.isForCompensation &&\r\n        !isEventType(businessObject, 'vdml:IntermediateThrowEvent', 'vdml:LinkEventDefinition') &&\r\n        !isEventSubProcess(businessObject)) {\r\n\r\n      assign(actions, {\r\n        'append.end-event': appendAction('vdml:EndEvent', 'bpmn-icon-end-event-none'),\r\n        'append.gateway': appendAction('vdml:ExclusiveGateway', 'bpmn-icon-gateway-xor'),\r\n        'append.append-task': appendAction('vdml:Collaboration', 'bpmn-icon-task'),\r\n        'append.intermediate-event': appendAction('vdml:IntermediateThrowEvent',\r\n                                                  'bpmn-icon-intermediate-event-none')\r\n      });\r\n    }\r\n  }\r\n\r\n  var replaceMenu;\r\n\r\n  if (popupMenu._providers['vdml-replace']) {\r\n    replaceMenu = popupMenu.create('vdml-replace', element);\r\n  }\r\n\r\n  if (replaceMenu && !replaceMenu.isEmpty()) {\r\n\r\n    // Replace menu entry\r\n    assign(actions, {\r\n      'replace': {\r\n        group: 'edit',\r\n        className: 'bpmn-icon-screw-wrench',\r\n        title: translate('Change type'),\r\n        action: {\r\n          click: function(event, element) {\r\n            replaceMenu.open(assign(getReplaceMenuPosition(element), {\r\n              cursor: { x: event.x, y: event.y }\r\n            }), element);\r\n          }\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  if (isAny(businessObject, [\r\n    'vdml:FlowNode',\r\n    'vdml:InteractionNode',\r\n    'vdml:DataObjectReference',\r\n    'vdml:DataStoreReference'\r\n  ]) ) {\r\n\r\n    assign(actions, {\r\n      'append.text-annotation': appendAction('vdml:TextAnnotation', 'bpmn-icon-text-annotation'),\r\n\r\n      'connect': {\r\n        group: 'connect',\r\n        className: 'bpmn-icon-connection-multi',\r\n        title: translate('Connect using ' +\r\n                  (businessObject.isForCompensation ? '' : 'Sequence/MessageFlow or ') +\r\n                  'Association'),\r\n        action: {\r\n          click: startConnect,\r\n          dragstart: startConnect\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  if (isAny(businessObject, [ 'vdml:DataObjectReference', 'vdml:DataStoreReference' ])) {\r\n    assign(actions, {\r\n      'connect': {\r\n        group: 'connect',\r\n        className: 'bpmn-icon-connection-multi',\r\n        title: translate('Connect using DataInputAssociation'),\r\n        action: {\r\n          click: startConnect,\r\n          dragstart: startConnect\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  // delete element entry, only show if allowed by rules\r\n  var deleteAllowed = rules.allowed('elements.delete', { elements: [ element ] });\r\n\r\n  if (isArray(deleteAllowed)) {\r\n    // was the element returned as a deletion candidate?\r\n    deleteAllowed = deleteAllowed[0] === element;\r\n  }\r\n\r\n  if (deleteAllowed) {\r\n    assign(actions, {\r\n      'delete': {\r\n        group: 'edit',\r\n        className: 'bpmn-icon-trash',\r\n        title: translate('Remove'),\r\n        action: {\r\n          click: removeElement,\r\n          dragstart: removeElement\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  return actions;\r\n};\r\n\r\nfunction isEventType(eventBo, type, definition) {\r\n\r\n  var isType = eventBo.$instanceOf(type);\r\n  var isDefinition = false;\r\n\r\n  var definitions = eventBo.eventDefinitions || [];\r\n  forEach(definitions, function(def) {\r\n    if (def.$type === definition) {\r\n      isDefinition = true;\r\n    }\r\n  });\r\n\r\n  return isType && isDefinition;\r\n}\r\n","module.exports = {\r\n  __depends__: [\r\n    require(95),\r\n    require(134),\r\n    require(214),\r\n    require(132),\r\n    require(138),\r\n    require(72)\r\n  ],\r\n  __init__: [ 'contextPadProvider' ],\r\n  contextPadProvider: [ 'type', require(11) ]\r\n};","'use strict';\r\n\r\nvar ModelUtil = require(93),\r\n    getBusinessObject = ModelUtil.getBusinessObject,\r\n    is = ModelUtil.is;\r\n\r\nvar map = require(286),\r\n    forEach = require(283);\r\n\r\n\r\nfunction setProperties(descriptor, data, properties) {\r\n  forEach(properties, function(property) {\r\n    if (data[property] !== undefined) {\r\n      descriptor[property] = data[property];\r\n    }\r\n  });\r\n}\r\n\r\nfunction removeProperties(element, properties) {\r\n  forEach(properties, function(prop) {\r\n    if (element[prop]) {\r\n      delete element[prop];\r\n    }\r\n  });\r\n}\r\n\r\nfunction VdmlCopyPaste(vdmlFactory, eventBus, copyPaste, clipboard, moddle, canvas, vdmlRules) {\r\n\r\n  copyPaste.registerDescriptor(function(element, descriptor) {\r\n    var businessObject = getBusinessObject(element),\r\n        conditionExpression,\r\n        eventDefinitions;\r\n\r\n    descriptor.type = element.type;\r\n\r\n    if (element.type === 'label') {\r\n      return descriptor;\r\n    }\r\n\r\n    setProperties(descriptor, businessObject, [\r\n      'name',\r\n      'text',\r\n      'processRef',\r\n      'isInterrupting',\r\n      'isForCompensation',\r\n      'associationDirection',\r\n      'triggeredByEvent',\r\n      'cancelActivity'\r\n    ]);\r\n\r\n    if (businessObject.default) {\r\n      descriptor.default = businessObject.default.id;\r\n    }\r\n\r\n    if (businessObject.loopCharacteristics) {\r\n\r\n      descriptor.loopCharacteristics = {\r\n        type: businessObject.loopCharacteristics.$type,\r\n        isSequential: businessObject.loopCharacteristics.isSequential\r\n      };\r\n    }\r\n\r\n    setProperties(descriptor, businessObject.di, [ 'isExpanded' ]);\r\n\r\n    if (is(businessObject, 'vdml:SequenceFlow')) {\r\n      conditionExpression = businessObject.get('conditionExpression');\r\n\r\n      if (conditionExpression) {\r\n        descriptor.conditionExpression = {\r\n          type: conditionExpression.$type,\r\n          body: conditionExpression.body\r\n        };\r\n      }\r\n    }\r\n\r\n    eventDefinitions = businessObject.get('eventDefinitions') || [];\r\n\r\n    if (eventDefinitions.length) {\r\n      descriptor.eventDefinitions = map(eventDefinitions, function(defs) {\r\n        return defs.$type;\r\n      });\r\n    }\r\n\r\n    return descriptor;\r\n  });\r\n\r\n  eventBus.on('element.paste', function(context) {\r\n    var descriptor = context.descriptor,\r\n        createdElements = context.createdElements,\r\n        parent = descriptor.parent,\r\n        rootElement = canvas.getRootElement(),\r\n        businessObject,\r\n        newEventDefinition,\r\n        conditionExpression,\r\n        loopCharacteristics,\r\n        source,\r\n        target,\r\n        canConnect;\r\n\r\n    if (descriptor.type === 'label') {\r\n      return;\r\n    }\r\n\r\n    if (is(parent, 'vdml:Process')) {\r\n      descriptor.parent = is(rootElement, 'vdml:Collaboration') ? rootElement : parent;\r\n    }\r\n\r\n    if (descriptor.type === 'vdml:DataOutputAssociation' ||\r\n        descriptor.type === 'vdml:DataInputAssociation' ||\r\n        descriptor.type === 'vdml:MessageFlow') {\r\n      descriptor.parent = rootElement;\r\n    }\r\n\r\n    if (is(parent, 'vdml:Lane')) {\r\n      descriptor.parent = parent.parent;\r\n    }\r\n\r\n    // make sure that the correct type of connection is created\r\n    if (descriptor.waypoints) {\r\n      source = createdElements[descriptor.source];\r\n      target = createdElements[descriptor.target];\r\n\r\n      if (source && target) {\r\n        source = source.element;\r\n        target = target.element;\r\n      }\r\n\r\n      canConnect = vdmlRules.canConnect(source, target);\r\n\r\n      if (canConnect) {\r\n        descriptor.type = canConnect.type;\r\n      }\r\n    }\r\n\r\n    descriptor.businessObject = businessObject = vdmlFactory.create(descriptor.type);\r\n\r\n    if (descriptor.type === 'vdml:Participant' && descriptor.processRef) {\r\n      descriptor.processRef = businessObject.processRef = vdmlFactory.create('vdml:Process');\r\n    }\r\n\r\n    setProperties(businessObject, descriptor, [\r\n      'name',\r\n      'text',\r\n      'isExpanded',\r\n      'isInterrupting',\r\n      'cancelActivity',\r\n      'triggeredByEvent'\r\n    ]);\r\n\r\n    if (descriptor.loopCharacteristics) {\r\n      loopCharacteristics = descriptor.loopCharacteristics;\r\n\r\n      businessObject.loopCharacteristics = moddle.create(loopCharacteristics.type);\r\n\r\n      if (loopCharacteristics.isSequential) {\r\n        businessObject.loopCharacteristics.isSequential = true;\r\n      }\r\n\r\n      businessObject.loopCharacteristics.$parent = businessObject;\r\n    }\r\n\r\n    if (descriptor.conditionExpression) {\r\n      conditionExpression = descriptor.conditionExpression;\r\n\r\n      businessObject.conditionExpression = moddle.create(conditionExpression.type, { body: conditionExpression.body });\r\n\r\n      businessObject.conditionExpression.$parent = businessObject;\r\n    }\r\n\r\n    if (descriptor.eventDefinitions) {\r\n      businessObject.eventDefinitions = map(descriptor.eventDefinitions, function(type) {\r\n        newEventDefinition = moddle.create(type);\r\n\r\n        newEventDefinition.$parent = businessObject;\r\n\r\n        return newEventDefinition;\r\n      });\r\n    }\r\n\r\n    removeProperties(descriptor, [\r\n      'name',\r\n      'text',\r\n      'eventDefinitions',\r\n      'conditionExpression',\r\n      'loopCharacteristics',\r\n      'isInterrupting',\r\n      'cancelActivity',\r\n      'triggeredByEvent'\r\n    ]);\r\n  });\r\n}\r\n\r\n\r\nVdmlCopyPaste.$inject = [\r\n  'vdmlFactory',\r\n  'eventBus',\r\n  'copyPaste',\r\n  'clipboard',\r\n  'moddle',\r\n  'canvas',\r\n  'vdmlRules'\r\n];\r\n\r\nmodule.exports = VdmlCopyPaste;\r\n","module.exports = {\r\n  __depends__: [\r\n    require(136)\r\n  ],\r\n  __init__: [ 'vdmlCopyPaste' ],\r\n  vdmlCopyPaste: [ 'type', require(13) ]\r\n};\r\n","'use strict';\r\n\r\nvar filter = require(281);\r\n\r\nvar isAny = require(66).isAny;\r\n\r\n/**\r\n * Registers element exclude filters for elements that currently do \r\n * not support distribution.\r\n */\r\nfunction VdmlDistributeElements(distributeElements) {\r\n\r\n  distributeElements.registerFilter(function(elements) {\r\n    return filter(elements, function(element) {\r\n      var cannotDistribute = isAny(element, [\r\n        'vdml:Association',\r\n        'vdml:BoundaryEvent',\r\n        'vdml:DataInputAssociation',\r\n        'vdml:DataOutputAssociation',\r\n        'vdml:Lane',\r\n        'vdml:MessageFlow',\r\n        'vdml:Participant',\r\n        'vdml:SequenceFlow',\r\n        'vdml:TextAnnotation'\r\n      ]);\r\n\r\n      return !(element.labelTarget || cannotDistribute);\r\n    });\r\n  });\r\n}\r\n\r\nVdmlDistributeElements.$inject = [ 'distributeElements' ];\r\n\r\nmodule.exports = VdmlDistributeElements;\r\n","module.exports = {\r\n  __depends__: [\r\n    require(140)\r\n  ],\r\n  __init__: [ 'vdmlDistributeElements' ],\r\n  vdmlDistributeElements: [ 'type', require(15) ]\r\n};\r\n","'use strict';\r\n\r\nvar inherits = require(270);\r\n\r\nvar EditorActions = require(144);\r\n\r\nvar filter = require(281);\r\n\r\nvar is = require(93).is;\r\n\r\nvar getBBox = require(247).getBBox;\r\n\r\nfunction VdmlEditorActions(\r\n    injector,\r\n    canvas, elementRegistry, selection,\r\n    spaceTool,\r\n    lassoTool,\r\n    handTool,\r\n    globalConnect,\r\n    distributeElements,\r\n    alignElements,\r\n    directEditing,\r\n    searchPad,\r\n    modeling) {\r\n\r\n  injector.invoke(EditorActions, this);\r\n\r\n  this.register({\r\n    selectElements: function() {\r\n      // select all elements except for the invisible\r\n      // root element\r\n      var rootElement = canvas.getRootElement();\r\n\r\n      var elements = elementRegistry.filter(function(element) {\r\n        return element !== rootElement;\r\n      });\r\n\r\n      selection.select(elements);\r\n\r\n      return elements;\r\n    },\r\n    spaceTool: function() {\r\n      spaceTool.toggle();\r\n    },\r\n    lassoTool: function() {\r\n      lassoTool.toggle();\r\n    },\r\n    handTool: function() {\r\n      handTool.toggle();\r\n    },\r\n    globalConnectTool: function() {\r\n      globalConnect.toggle();\r\n    },\r\n    distributeElements: function(opts) {\r\n      var currentSelection = selection.get(),\r\n          type = opts.type;\r\n\r\n      if (currentSelection.length) {\r\n        distributeElements.trigger(currentSelection, type);\r\n      }\r\n    },\r\n    alignElements: function(opts) {\r\n      var currentSelection = selection.get(),\r\n          aligneableElements = [],\r\n          type = opts.type;\r\n\r\n      if (currentSelection.length) {\r\n        aligneableElements = filter(currentSelection, function(element) {\r\n          return !is(element, 'vdml:Lane');\r\n        });\r\n\r\n        alignElements.trigger(aligneableElements, type);\r\n      }\r\n    },\r\n    directEditing: function() {\r\n      var currentSelection = selection.get();\r\n\r\n      if (currentSelection.length) {\r\n        directEditing.activate(currentSelection[0]);\r\n      }\r\n    },\r\n    find: function() {\r\n      searchPad.toggle();\r\n    },\r\n    moveToOrigin: function() {\r\n      var rootElement = canvas.getRootElement(),\r\n          boundingBox,\r\n          elements;\r\n\r\n      if (is(rootElement, 'vdml:Collaboration')) {\r\n        elements = elementRegistry.filter(function(element) {\r\n          return is(element.parent, 'vdml:Collaboration');\r\n        });\r\n      } else {\r\n        elements = elementRegistry.filter(function(element) {\r\n          return element !== rootElement;\r\n        });\r\n      }\r\n\r\n      boundingBox = getBBox(elements);\r\n\r\n      modeling.moveElements(elements, { x: -boundingBox.x, y: -boundingBox.y }, rootElement);\r\n    }\r\n  });\r\n}\r\n\r\ninherits(VdmlEditorActions, EditorActions);\r\n\r\nVdmlEditorActions.$inject = [\r\n  'injector',\r\n  'canvas', 'elementRegistry', 'selection',\r\n  'spaceTool',\r\n  'lassoTool',\r\n  'handTool',\r\n  'globalConnect',\r\n  'distributeElements',\r\n  'alignElements',\r\n  'directEditing',\r\n  'searchPad',\r\n  'modeling'\r\n];\r\n\r\nmodule.exports = VdmlEditorActions;\r\n","module.exports = {\r\n  __depends__: [\r\n    require(114),\r\n    require(145),\r\n    require(149),\r\n    require(157),\r\n    require(221),\r\n    require(20),\r\n    require(14),\r\n    require(16),\r\n    require(20),\r\n    require(82),\r\n    require(64)\r\n  ],\r\n  editorActions: [ 'type', require(17) ]\r\n};\r\n","'use strict';\r\n\r\nvar isAny = require(66).isAny;\r\n\r\n/**\r\n * Extention of GlobalConnect tool that implements VDML specific rules about\r\n * connection start elements.\r\n */\r\nfunction VdmlGlobalConnect(globalConnect) {\r\n  globalConnect.registerProvider(this);\r\n}\r\n\r\nVdmlGlobalConnect.$inject = [ 'globalConnect' ];\r\n\r\nmodule.exports = VdmlGlobalConnect;\r\n\r\n\r\n/**\r\n * Checks if given element can be used for starting connection.\r\n *\r\n * @param  {Element} source\r\n * @return {Boolean}\r\n */\r\nVdmlGlobalConnect.prototype.canStartConnect = function(source) {\r\n\r\n  if (nonExistantOrLabel(source)) {\r\n    return null;\r\n  }\r\n\r\n  var businessObject = source.businessObject;\r\n\r\n  return isAny(businessObject, [\r\n    'vdml:FlowNode',\r\n    'vdml:InteractionNode',\r\n    'vdml:DataObjectReference',\r\n    'vdml:DataStoreReference'\r\n  ]);\r\n};\r\n\r\n\r\nfunction nonExistantOrLabel(element) {\r\n  return !element || isLabel(element);\r\n}\r\n\r\nfunction isLabel(element) {\r\n  return element.labelTarget;\r\n}\r\n\r\n\r\n","module.exports = {\r\n  __depends__: [\r\n    require(147)\r\n  ],\r\n  __init__: [ 'vdmlGlobalConnect' ],\r\n  vdmlGlobalConnect: [ 'type', require(19) ]\r\n};\r\n","'use strict';\r\n\r\n/**\r\n * VDML 2.0 specific key bindings.\r\n *\r\n * @param {Keyboard} keyboard\r\n * @param {EditorActions} editorActions\r\n */\r\nfunction VdmlKeyBindings(keyboard, editorActions) {\r\n\r\n  keyboard.addListener(function(key, modifiers) {\r\n\r\n    // ctrl + a -> select all elements\r\n    if (key === 65 && keyboard.isCmd(modifiers)) {\r\n      editorActions.trigger('selectElements');\r\n\r\n      return true;\r\n    }\r\n\r\n    // ctrl + f -> search labels\r\n    if (key === 70 && keyboard.isCmd(modifiers)) {\r\n      editorActions.trigger('find');\r\n\r\n      return true;\r\n    }\r\n\r\n    if (keyboard.hasModifier(modifiers)) {\r\n      return;\r\n    }\r\n\r\n    // s -> activate space tool\r\n    if (key === 83) {\r\n      editorActions.trigger('spaceTool');\r\n\r\n      return true;\r\n    }\r\n\r\n    // l -> activate lasso tool\r\n    if (key === 76) {\r\n      editorActions.trigger('lassoTool');\r\n\r\n      return true;\r\n    }\r\n\r\n    // h -> activate hand tool\r\n    if (key === 72) {\r\n      editorActions.trigger('handTool');\r\n\r\n      return true;\r\n    }\r\n\r\n    // c -> activate global connect tool\r\n    if (key === 67) {\r\n      editorActions.trigger('globalConnectTool');\r\n\r\n      return true;\r\n    }\r\n\r\n    // e -> activate direct editing\r\n    if (key === 69) {\r\n      editorActions.trigger('directEditing');\r\n\r\n      return true;\r\n    }\r\n  });\r\n}\r\n\r\nVdmlKeyBindings.$inject = [\r\n  'keyboard',\r\n  'editorActions'\r\n];\r\n\r\nmodule.exports = VdmlKeyBindings;","module.exports = {\r\n  __depends__: [\r\n    require(153)\r\n  ],\r\n  __init__: [ 'vdmlKeyBindings' ],\r\n  vdmlKeyBindings: [ 'type', require(21) ]\r\n};\r\n","'use strict';\r\n\r\nvar UpdateLabelHandler = require(25);\r\n\r\nvar LabelUtil = require(24);\r\n\r\nvar is = require(93).is,\r\n    isExpanded = require(91).isExpanded;\r\n\r\nvar LINE_HEIGHT = 14,\r\n    PADDING = 6;\r\n\r\nfunction LabelEditingProvider(eventBus, canvas, directEditing, commandStack) {\r\n\r\n  this._canvas = canvas;\r\n  this._commandStack = commandStack;\r\n\r\n  directEditing.registerProvider(this);\r\n\r\n  commandStack.registerHandler('element.updateLabel', UpdateLabelHandler);\r\n\r\n  // listen to dblclick on non-root elements\r\n  eventBus.on('element.dblclick', function(event) {\r\n    directEditing.activate(event.element);\r\n  });\r\n\r\n  // complete on followup canvas operation\r\n  eventBus.on([ 'element.mousedown', 'drag.init', 'canvas.viewbox.changed' ], function(event) {\r\n    directEditing.complete();\r\n  });\r\n\r\n  // cancel on command stack changes\r\n  eventBus.on([ 'commandStack.changed' ], function() {\r\n    directEditing.cancel();\r\n  });\r\n\r\n\r\n  if ('ontouchstart' in document.documentElement) {\r\n    // we deactivate automatic label editing on mobile devices\r\n    // as it breaks the user interaction workflow\r\n\r\n    // TODO(nre): we should temporarily focus the edited element here\r\n    // and release the focused viewport after the direct edit operation is finished\r\n  } else {\r\n    eventBus.on('create.end', 500, function(e) {\r\n\r\n      var element = e.shape,\r\n          canExecute = e.context.canExecute;\r\n\r\n      if (!canExecute) {\r\n        return;\r\n      }\r\n\r\n      if (is(element, 'vdml:Task') || is(element, 'vdml:TextAnnotation') ||\r\n          (is(element, 'vdml:SubProcess') && !isExpanded(element))) {\r\n\r\n        directEditing.activate(element);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nLabelEditingProvider.$inject = [ 'eventBus', 'canvas', 'directEditing', 'commandStack' ];\r\n\r\nmodule.exports = LabelEditingProvider;\r\n\r\n\r\n/**\r\n * Activate direct editing for activities and text annotations.\r\n *\r\n * @param  {djs.model.Base} element\r\n *\r\n * @return {Object} an object with properties bounds (position and size) and text\r\n */\r\nLabelEditingProvider.prototype.activate = function(element) {\r\n\r\n  var text = LabelUtil.getLabel(element);\r\n\r\n  if (text === undefined) {\r\n    return;\r\n  }\r\n\r\n  var properties = this.getEditingBBox(element);\r\n\r\n  properties.text = text;\r\n\r\n  return properties;\r\n};\r\n\r\n\r\n/**\r\n * Get the editing bounding box based on the element's size and position\r\n *\r\n * @param  {djs.model.Base} element\r\n *\r\n * @return {Object} an object containing information about position and size (fixed or minimum and/or maximum)\r\n */\r\nLabelEditingProvider.prototype.getEditingBBox = function(element) {\r\n  var canvas = this._canvas;\r\n\r\n  var target = element.label || element;\r\n\r\n  var bbox = canvas.getAbsoluteBBox(target);\r\n\r\n  var mid = {\r\n    x: bbox.x + bbox.width / 2,\r\n    y: bbox.y + bbox.height / 2\r\n  };\r\n\r\n  // default position\r\n  var bounds = { x: bbox.x, y: bbox.y };\r\n\r\n  var style = {},\r\n      zoom;\r\n\r\n  // adjust for expanded pools AND lanes\r\n  if ((is(element, 'vdml:Participant') && isExpanded(element)) || is(element, 'vdml:Lane')) {\r\n\r\n    bounds.width = 150;\r\n    bounds.minHeight = LINE_HEIGHT + PADDING;\r\n    bounds.maxHeight = LINE_HEIGHT * 2 + PADDING;\r\n    bounds.x = bbox.x - bounds.width / 2;\r\n    bounds.y = mid.y - bounds.minHeight / 2;\r\n  }\r\n\r\n\r\n  // internal labels for tasks and collapsed call activities, sub processes and participants\r\n  if (\r\n    is(element, 'vdml:Task') ||\r\n    (is(element, 'vdml:CallActivity') && !isExpanded(element)) ||\r\n    (is(element, 'vdml:SubProcess') && !isExpanded(element)) ||\r\n    (is(element, 'vdml:Participant') && !isExpanded(element))\r\n  ) {\r\n\r\n    zoom = canvas.zoom();\r\n\r\n    // fixed size for internal labels:\r\n    // on high zoom levels: text box size === bbox size\r\n    // on low zoom levels: text box size === bbox size at 100% zoom\r\n    // This ensures minimum bounds at low zoom levels\r\n    if (zoom > 1) {\r\n      bounds.width = bbox.width;\r\n      bounds.height = bbox.height;\r\n    } else {\r\n      bounds.width = bbox.width / zoom;\r\n      bounds.height = bbox.height / zoom;\r\n    }\r\n\r\n    // centering overlapping text box size at low zoom levels\r\n    if (zoom < 1) {\r\n      bounds.x = bbox.x - (bounds.width / 2 - bbox.width / 2);\r\n      bounds.y = bbox.y - (bounds.height / 2 - bbox.height / 2);\r\n    }\r\n\r\n  }\r\n\r\n\r\n  // internal labels for expanded sub processes\r\n  if (is(element, 'vdml:SubProcess') && isExpanded(element)) {\r\n\r\n    bounds.width = element.width;\r\n    bounds.maxHeight = 3 * LINE_HEIGHT + PADDING; // maximum 3 lines\r\n    bounds.x = mid.x - element.width / 2;\r\n  }\r\n\r\n\r\n  // external labels for events, data elements, gateways and connections\r\n  if (target.labelTarget) {\r\n\r\n    bounds.width = 150;\r\n    bounds.minHeight = LINE_HEIGHT + PADDING; // 1 line\r\n    bounds.x = mid.x - bounds.width / 2;\r\n  }\r\n\r\n\r\n  // text annotations\r\n  if (is(element, 'vdml:TextAnnotation')) {\r\n    bounds.minWidth = 100;\r\n    bounds.height = element.height;\r\n\r\n    style.textAlign = 'left';\r\n  }\r\n\r\n  return { bounds: bounds, style: style };\r\n};\r\n\r\n\r\nLabelEditingProvider.prototype.update = function(element, newLabel) {\r\n  this._commandStack.execute('element.updateLabel', {\r\n    element: element,\r\n    newLabel: newLabel\r\n  });\r\n};\r\n","'use strict';\r\n\r\nvar is = require(93).is;\r\n\r\nfunction getLabelAttr(semantic) {\r\n  if (is(semantic, 'vdml:FlowElement') ||\r\n      is(semantic, 'vdml:Participant') ||\r\n      is(semantic, 'vdml:Lane') ||\r\n      is(semantic, 'vdml:SequenceFlow') ||\r\n      is(semantic, 'vdml:MessageFlow')) {\r\n\r\n    return 'name';\r\n  }\r\n\r\n  if (is(semantic, 'vdml:TextAnnotation')) {\r\n    return 'text';\r\n  }\r\n}\r\n\r\nmodule.exports.getLabel = function(element) {\r\n  var semantic = element.businessObject,\r\n      attr = getLabelAttr(semantic);\r\n\r\n  if (attr) {\r\n    return semantic[attr] || '';\r\n  }\r\n};\r\n\r\n\r\nmodule.exports.setLabel = function(element, text, isExternal) {\r\n  var semantic = element.businessObject,\r\n      attr = getLabelAttr(semantic);\r\n\r\n  if (attr) {\r\n    semantic[attr] = text;\r\n  }\r\n\r\n  // show external label if not empty\r\n  if (isExternal) {\r\n    element.hidden = !text;\r\n  }\r\n\r\n  return element;\r\n};","'use strict';\r\n\r\nvar LabelUtil = require(24);\r\n\r\n\r\n/**\r\n * A handler that updates the text of a VDML element.\r\n */\r\nfunction UpdateLabelHandler() {\r\n\r\n  /**\r\n   * Set the label and return the changed elements.\r\n   *\r\n   * Element parameter can be label itself or connection (i.e. sequence flow).\r\n   *\r\n   * @param {djs.model.Base} element\r\n   * @param {String} text\r\n   */\r\n  function setText(element, text) {\r\n\r\n    // external label if present\r\n    var label = element.label || element;\r\n\r\n    var labelTarget = element.labelTarget || element;\r\n\r\n    LabelUtil.setLabel(label, text, labelTarget !== label);\r\n\r\n    return [ label, labelTarget ];\r\n  }\r\n\r\n  function execute(ctx) {\r\n    ctx.oldLabel = LabelUtil.getLabel(ctx.element);\r\n    return setText(ctx.element, ctx.newLabel);\r\n  }\r\n\r\n  function revert(ctx) {\r\n    return setText(ctx.element, ctx.oldLabel);\r\n  }\r\n\r\n  // API\r\n\r\n  this.execute = execute;\r\n  this.revert = revert;\r\n}\r\n\r\nmodule.exports = UpdateLabelHandler;","module.exports = {\r\n  __depends__: [\r\n    require(102),\r\n    require(128),\r\n    require(95)\r\n  ],\r\n  __init__: [ 'labelEditingProvider' ],\r\n  labelEditingProvider: [ 'type', require(23) ]\r\n};","'use strict';\r\n\r\nvar assign = require(410),\r\n    inherits = require(270);\r\n\r\nvar is = require(93).is;\r\n\r\nvar isExpanded = require(91).isExpanded;\r\n\r\nvar BaseElementFactory = require(104),\r\n    LabelUtil = require(92);\r\n\r\n/**\r\n * A vdml-aware factory for diagram-js shapes\r\n */\r\nfunction ElementFactory(vdmlFactory, moddle, translate) {\r\n  BaseElementFactory.call(this);\r\n\r\n  this._vdmlFactory = vdmlFactory;\r\n  this._moddle = moddle;\r\n  this._translate = translate;\r\n}\r\n\r\ninherits(ElementFactory, BaseElementFactory);\r\n\r\n\r\nElementFactory.$inject = [ 'vdmlFactory', 'moddle', 'translate' ];\r\n\r\nmodule.exports = ElementFactory;\r\n\r\nElementFactory.prototype.baseCreate = BaseElementFactory.prototype.create;\r\n\r\nElementFactory.prototype.create = function(elementType, attrs) {\r\n  // no special magic for labels,\r\n  // we assume their businessObjects have already been created\r\n  // and wired via attrs\r\n  if (elementType === 'label') {\r\n    return this.baseCreate(elementType, assign({ type: 'label' }, LabelUtil.DEFAULT_LABEL_SIZE, attrs));\r\n  }\r\n\r\n  return this.createVdmlElement(elementType, attrs);\r\n};\r\n\r\nElementFactory.prototype.createVdmlElement = function(elementType, attrs) {\r\n  var size,\r\n      translate = this._translate;\r\n\r\n  attrs = attrs || {};\r\n\r\n  var businessObject = attrs.businessObject;\r\n\r\n  if (!businessObject) {\r\n    if (!attrs.type) {\r\n      throw new Error(translate('no shape type specified'));\r\n    }\r\n\r\n    businessObject = this._vdmlFactory.create(attrs.type);\r\n  }\r\n\r\n  if (!businessObject.di) {\r\n    if (elementType === 'root') {\r\n      businessObject.di = this._vdmlFactory.createDiPlane(businessObject, [], {\r\n        id: businessObject.id + '_di'\r\n      });\r\n    } else\r\n    if (elementType === 'connection') {\r\n      businessObject.di = this._vdmlFactory.createDiEdge(businessObject, [], {\r\n        id: businessObject.id + '_di'\r\n      });\r\n    } else {\r\n      businessObject.di = this._vdmlFactory.createDiShape(businessObject, {}, {\r\n        id: businessObject.id + '_di'\r\n      });\r\n    }\r\n  }\r\n\r\n  if (attrs.processRef) {\r\n    businessObject.processRef = attrs.processRef;\r\n  }\r\n\r\n  if (attrs.isExpanded) {\r\n    businessObject.di.isExpanded = attrs.isExpanded;\r\n  }\r\n\r\n  if (is(businessObject, 'vdml:ExclusiveGateway')) {\r\n    businessObject.di.isMarkerVisible = true;\r\n  }\r\n\r\n  if (attrs.isInterrupting === false) {\r\n    businessObject.isInterrupting = false;\r\n  }\r\n\r\n  if (attrs.associationDirection) {\r\n    businessObject.associationDirection = attrs.associationDirection;\r\n  }\r\n\r\n  var eventDefinitions,\r\n      newEventDefinition;\r\n\r\n  if (attrs.eventDefinitionType) {\r\n    eventDefinitions = businessObject.get('eventDefinitions') || [];\r\n    newEventDefinition = this._moddle.create(attrs.eventDefinitionType);\r\n\r\n    eventDefinitions.push(newEventDefinition);\r\n\r\n    newEventDefinition.$parent = businessObject;\r\n    businessObject.eventDefinitions = eventDefinitions;\r\n  }\r\n\r\n  if (attrs.isForCompensation) {\r\n    businessObject.isForCompensation = true;\r\n  }\r\n\r\n  size = this._getDefaultSize(businessObject);\r\n\r\n  attrs = assign({\r\n    businessObject: businessObject,\r\n    id: businessObject.id\r\n  }, size, attrs);\r\n\r\n  return this.baseCreate(elementType, attrs);\r\n};\r\n\r\n\r\nElementFactory.prototype._getDefaultSize = function(semantic) {\r\n\r\n  if (is(semantic, 'vdml:SubProcess')) {\r\n\r\n    if (isExpanded(semantic)) {\r\n      return { width: 350, height: 200 };\r\n    } else {\r\n      return { width: 100, height: 80 };\r\n    }\r\n  }\r\n\r\n  if (is(semantic, 'vdml:Collaboration')) {\r\n    return { width: 100, height: 80 };\r\n  }\r\n\r\n  if (is(semantic, 'vdml:Gateway')) {\r\n    return { width: 50, height: 50 };\r\n  }\r\n\r\n  if (is(semantic, 'vdml:Event')) {\r\n    return { width: 36, height: 36 };\r\n  }\r\n\r\n  if (is(semantic, 'vdml:Participant')) {\r\n    if (!isExpanded(semantic)) {\r\n      return { width: 400, height: 100 };\r\n    } else {\r\n      return { width: 600, height: 250 };\r\n    }\r\n  }\r\n\r\n  if (is(semantic, 'vdml:Lane')) {\r\n    return { width: 400, height: 100 };\r\n  }\r\n\r\n  if (is(semantic, 'vdml:DataObjectReference')) {\r\n    return { width: 36, height: 50 };\r\n  }\r\n\r\n  if (is(semantic, 'vdml:DataStoreReference')) {\r\n    return { width: 50, height: 50 };\r\n  }\r\n\r\n  if (is(semantic, 'vdml:TextAnnotation')) {\r\n    return { width: 100, height: 30 };\r\n  }\r\n\r\n  return { width: 100, height: 80 };\r\n};\r\n\r\n\r\nElementFactory.prototype.createParticipantShape = function(collapsed) {\r\n\r\n  var attrs = { type: 'vdml:Participant' };\r\n\r\n  if (!collapsed) {\r\n    attrs.processRef = this._vdmlFactory.create('vdml:Process');\r\n  }\r\n\r\n  return this.createShape(attrs);\r\n};\r\n","'use strict';\r\nvar inherits = require(270);\r\n\r\nvar BaseModeling = require(158);\r\n\r\nvar UpdatePropertiesHandler = require(63),\r\n    UpdateCanvasRootHandler = require(61),\r\n    AddLaneHandler = require(57),\r\n    SplitLaneHandler = require(60),\r\n    ResizeLaneHandler = require(59),\r\n    UpdateFlowNodeRefsHandler = require(62),\r\n    IdClaimHandler = require(58);\r\n\r\n\r\n/**\r\n * VDML 2.0 modeling features activator\r\n *\r\n * @param {EventBus} eventBus\r\n * @param {ElementFactory} elementFactory\r\n * @param {CommandStack} commandStack\r\n * @param {VdmlRules} vdmlRules\r\n */\r\nfunction Modeling(eventBus, elementFactory, commandStack, vdmlRules) {\r\n  BaseModeling.call(this, eventBus, elementFactory, commandStack);\r\n\r\n  this._vdmlRules = vdmlRules;\r\n}\r\n\r\ninherits(Modeling, BaseModeling);\r\n\r\nModeling.$inject = [ 'eventBus', 'elementFactory', 'commandStack', 'vdmlRules' ];\r\n\r\nmodule.exports = Modeling;\r\n\r\n\r\nModeling.prototype.getHandlers = function() {\r\n  var handlers = BaseModeling.prototype.getHandlers.call(this);\r\n\r\n  handlers['element.updateProperties'] = UpdatePropertiesHandler;\r\n  handlers['canvas.updateRoot'] = UpdateCanvasRootHandler;\r\n  handlers['lane.add'] = AddLaneHandler;\r\n  handlers['lane.resize'] = ResizeLaneHandler;\r\n  handlers['lane.split'] = SplitLaneHandler;\r\n  handlers['lane.updateRefs'] = UpdateFlowNodeRefsHandler;\r\n  handlers['id.updateClaim'] = IdClaimHandler;\r\n\r\n  return handlers;\r\n};\r\n\r\n\r\nModeling.prototype.updateLabel = function(element, newLabel) {\r\n  this._commandStack.execute('element.updateLabel', {\r\n    element: element,\r\n    newLabel: newLabel\r\n  });\r\n};\r\n\r\n\r\nModeling.prototype.connect = function(source, target, attrs, hints) {\r\n\r\n  var vdmlRules = this._vdmlRules;\r\n\r\n  if (!attrs) {\r\n    attrs = vdmlRules.canConnect(source, target) || { type: 'vdml:Association' };\r\n  }\r\n\r\n    //return this.createConnection(source, target, attrs, source.parent, hints);\r\n  return this.createConnection(source, target, attrs, source, hints);\r\n};\r\n\r\n\r\nModeling.prototype.updateProperties = function(element, properties) {\r\n  this._commandStack.execute('element.updateProperties', {\r\n    element: element,\r\n    properties: properties\r\n  });\r\n};\r\n\r\nModeling.prototype.resizeLane = function(laneShape, newBounds, balanced) {\r\n  this._commandStack.execute('lane.resize', {\r\n    shape: laneShape,\r\n    newBounds: newBounds,\r\n    balanced: balanced\r\n  });\r\n};\r\n\r\nModeling.prototype.addLane = function(targetLaneShape, location) {\r\n  var context = {\r\n    shape: targetLaneShape,\r\n    location: location\r\n  };\r\n\r\n  this._commandStack.execute('lane.add', context);\r\n\r\n  return context.newLane;\r\n};\r\n\r\nModeling.prototype.splitLane = function(targetLane, count) {\r\n  this._commandStack.execute('lane.split', {\r\n    shape: targetLane,\r\n    count: count\r\n  });\r\n};\r\n\r\n/**\r\n * Transform the current diagram into a collaboration.\r\n *\r\n * @return {djs.model.Root} the new root element\r\n */\r\nModeling.prototype.makeCollaboration = function() {\r\n\r\n  var collaborationElement = this._create('root', {\r\n    type: 'vdml:Collaboration'\r\n  });\r\n\r\n  var context = {\r\n    newRoot: collaborationElement\r\n  };\r\n\r\n  this._commandStack.execute('canvas.updateRoot', context);\r\n\r\n  return collaborationElement;\r\n};\r\n\r\nModeling.prototype.updateLaneRefs = function(flowNodeShapes, laneShapes) {\r\n\r\n  this._commandStack.execute('lane.updateRefs', {\r\n    flowNodeShapes: flowNodeShapes,\r\n    laneShapes: laneShapes\r\n  });\r\n};\r\n\r\n/**\r\n * Transform the current diagram into a process.\r\n *\r\n * @return {djs.model.Root} the new root element\r\n */\r\nModeling.prototype.makeProcess = function() {\r\n\r\n  var processElement = this._create('root', {\r\n    type: 'vdml:Process'\r\n  });\r\n\r\n  var context = {\r\n    newRoot: processElement\r\n  };\r\n\r\n  this._commandStack.execute('canvas.updateRoot', context);\r\n};\r\n\r\n\r\nModeling.prototype.claimId = function(id, moddleElement) {\r\n  this._commandStack.execute('id.updateClaim', {\r\n    id: id,\r\n    element: moddleElement,\r\n    claiming: true\r\n  });\r\n};\r\n\r\n\r\nModeling.prototype.unclaimId = function(id, moddleElement) {\r\n  this._commandStack.execute('id.updateClaim', {\r\n    id: id,\r\n    element: moddleElement\r\n  });\r\n};\r\n","'use strict';\r\n\r\nvar map = require(286),\r\n    assign = require(410),\r\n    pick = require(417);\r\n\r\n\r\nfunction VdmlFactory(moddle) {\r\n  this._model = moddle;\r\n}\r\n\r\nVdmlFactory.$inject = [ 'moddle' ];\r\n\r\n\r\nVdmlFactory.prototype._needsId = function(element) {\r\n  return element.$instanceOf('vdml:RootElement') ||\r\n         element.$instanceOf('vdml:FlowElement') ||\r\n         element.$instanceOf('vdml:MessageFlow') ||\r\n         element.$instanceOf('vdml:DataAssociation') ||\r\n         element.$instanceOf('vdml:Artifact') ||\r\n         element.$instanceOf('vdml:Participant') ||\r\n         element.$instanceOf('vdml:Lane') ||\r\n         element.$instanceOf('vdml:Process') ||\r\n         element.$instanceOf('vdml:Collaboration') ||\r\n         element.$instanceOf('vdmldi:VDMLShape') ||\r\n         element.$instanceOf('vdmldi:VDMLEdge') ||\r\n         element.$instanceOf('vdmldi:VDMLDiagram') ||\r\n         element.$instanceOf('vdmldi:VDMLPlane') ||\r\n         element.$instanceOf('vdml:Property');\r\n};\r\n\r\nVdmlFactory.prototype._ensureId = function(element) {\r\n\r\n  // generate semantic ids for elements\r\n  // vdml:SequenceFlow -> SequenceFlow_ID\r\n  var prefix = (element.$type || '').replace(/^[^:]*:/g, '') + '_';\r\n\r\n  if (!element.id && this._needsId(element)) {\r\n    element.id = this._model.ids.nextPrefixed(prefix, element);\r\n  }\r\n};\r\n\r\n\r\nVdmlFactory.prototype.create = function(type, attrs) {\r\n  var element = this._model.create(type, attrs || {});\r\n\r\n  this._ensureId(element);\r\n\r\n  return element;\r\n};\r\n\r\n\r\nVdmlFactory.prototype.createDiLabel = function() {\r\n  return this.create('vdmldi:VDMLLabel', {\r\n    bounds: this.createDiBounds()\r\n  });\r\n};\r\n\r\n\r\nVdmlFactory.prototype.createDiShape = function(semantic, bounds, attrs) {\r\n\r\n  return this.create('vdmldi:VDMLShape', assign({\r\n    vdmlElement: semantic,\r\n    bounds: this.createDiBounds(bounds)\r\n  }, attrs));\r\n};\r\n\r\n\r\nVdmlFactory.prototype.createDiBounds = function(bounds) {\r\n  return this.create('dc:Bounds', bounds);\r\n};\r\n\r\n\r\nVdmlFactory.prototype.createDiWaypoints = function(waypoints) {\r\n  return map(waypoints, function(pos) {\r\n    return this.createDiWaypoint(pos);\r\n  }, this);\r\n};\r\n\r\nVdmlFactory.prototype.createDiWaypoint = function(point) {\r\n  return this.create('dc:Point', pick(point, [ 'x', 'y' ]));\r\n};\r\n\r\n\r\nVdmlFactory.prototype.createDiEdge = function(semantic, waypoints, attrs) {\r\n  return this.create('vdmldi:VDMLEdge', assign({\r\n    vdmlElement: semantic\r\n  }, attrs));\r\n};\r\n\r\nVdmlFactory.prototype.createDiPlane = function(semantic) {\r\n  return this.create('vdmldi:VDMLPlane', {\r\n    vdmlElement: semantic\r\n  });\r\n};\r\n\r\nmodule.exports = VdmlFactory;\r\n","'use strict';\r\n\r\nvar inherits = require(270);\r\n\r\nvar assign = require(410);\r\n\r\nvar BaseLayouter = require(231),\r\n    ManhattanLayout = require(234);\r\n\r\nvar LayoutUtil = require(233);\r\n\r\nvar isExpanded = require(91).isExpanded;\r\n\r\nvar getMid = LayoutUtil.getMid,\r\n    getOrientation = LayoutUtil.getOrientation;\r\n\r\nvar is = require(93).is;\r\n\r\n\r\nfunction VdmlLayouter() {}\r\n\r\ninherits(VdmlLayouter, BaseLayouter);\r\n\r\nmodule.exports = VdmlLayouter;\r\n\r\n\r\nVdmlLayouter.prototype.layoutConnection = function(connection, hints) {\r\n\r\n  hints = hints || {};\r\n\r\n  var source = connection.source,\r\n      target = connection.target,\r\n      waypoints = connection.waypoints,\r\n      start = hints.connectionStart,\r\n      end = hints.connectionEnd;\r\n\r\n  var manhattanOptions,\r\n      updatedWaypoints;\r\n\r\n  if (!start) {\r\n    start = getConnectionDocking(waypoints && waypoints[0], source);\r\n  }\r\n\r\n  if (!end) {\r\n    end = getConnectionDocking(waypoints && waypoints[waypoints.length - 1], target);\r\n  }\r\n\r\n  // TODO(nikku): support vertical modeling\r\n  // and invert preferredLayouts accordingly\r\n\r\n  if (is(connection, 'vdml:Association') ||\r\n      is(connection, 'vdml:DataAssociation')) {\r\n\r\n    if (waypoints && !isCompensationAssociation(connection)) {\r\n      return [].concat([ start ], waypoints.slice(1, -1), [ end ]);\r\n    }\r\n  }\r\n\r\n  // manhattan layout sequence / message flows\r\n  if (is(connection, 'vdml:MessageFlow')) {\r\n    manhattanOptions = {\r\n      preferredLayouts: [ 'v:v' ]\r\n    };\r\n\r\n    if (is(target, 'vdml:Participant')) {\r\n      manhattanOptions = {\r\n        preferredLayouts: [ 'straight', 'v:v' ]\r\n      };\r\n    }\r\n\r\n    if (isExpandedSubProcess(target)) {\r\n      manhattanOptions = {\r\n        preferredLayouts: [ 'straight', 'v:v' ]\r\n      };\r\n    }\r\n\r\n    if (isExpandedSubProcess(source) && is(target, 'vdml:FlowNode')) {\r\n      manhattanOptions = {\r\n        preferredLayouts: [ 'straight', 'v:v' ],\r\n        preserveDocking: isExpandedSubProcess(target) ? 'source' : 'target'\r\n      };\r\n    }\r\n\r\n    if (is(source, 'vdml:Participant') && is(target, 'vdml:FlowNode')) {\r\n      manhattanOptions = {\r\n        preferredLayouts: [ 'straight', 'v:v' ],\r\n        preserveDocking: 'target'\r\n      };\r\n    }\r\n\r\n    if (is(target, 'vdml:Event')) {\r\n      manhattanOptions = {\r\n        preferredLayouts: [ 'v:v' ]\r\n      };\r\n    }\r\n  } else\r\n\r\n\r\n  // layout all connection between flow elements h:h,\r\n  //\r\n  // except for\r\n  //\r\n  // (1) outgoing of BoundaryEvents -> layout h:v or v:h based on attach orientation\r\n  // (2) incoming / outgoing of Gateway -> v:h (outgoing), h:v (incoming)\r\n  //\r\n  if (is(connection, 'vdml:SequenceFlow') ||\r\n      isCompensationAssociation(connection)) {\r\n\r\n    // make sure boundary event connections do\r\n    // not look ugly =:>\r\n    if (is(source, 'vdml:BoundaryEvent')) {\r\n\r\n      var orientation = getAttachOrientation(source);\r\n\r\n      if (/left|right/.test(orientation)) {\r\n        manhattanOptions = {\r\n          preferredLayouts: [ 'h:v' ]\r\n        };\r\n      } else\r\n\r\n      if (/top|bottom/.test(orientation)) {\r\n        manhattanOptions = {\r\n          preferredLayouts: [ 'v:h' ]\r\n        };\r\n      }\r\n    } else\r\n\r\n    if (is(source, 'vdml:Gateway')) {\r\n\r\n      manhattanOptions = {\r\n        preferredLayouts: [ 'v:h' ]\r\n      };\r\n    } else\r\n\r\n    if (is(target, 'vdml:Gateway')) {\r\n\r\n      manhattanOptions = {\r\n        preferredLayouts: [ 'h:v' ]\r\n      };\r\n    }\r\n\r\n    // apply horizontal love <3\r\n    else {\r\n      manhattanOptions = {\r\n        preferredLayouts: [ 'h:h' ]\r\n      };\r\n    }\r\n  }\r\n\r\n  if (manhattanOptions) {\r\n\r\n    manhattanOptions = assign(manhattanOptions, hints);\r\n\r\n    updatedWaypoints =\r\n      ManhattanLayout.repairConnection(\r\n        source, target,\r\n        start, end,\r\n        waypoints,\r\n        manhattanOptions);\r\n  }\r\n\r\n  return updatedWaypoints || [ start, end ];\r\n};\r\n\r\n\r\nfunction getAttachOrientation(attachedElement) {\r\n\r\n  var hostElement = attachedElement.host,\r\n      padding = -10;\r\n\r\n  return getOrientation(getMid(attachedElement), hostElement, padding);\r\n}\r\n\r\n\r\nfunction getConnectionDocking(point, shape) {\r\n  return point ? (point.original || point) : getMid(shape);\r\n}\r\n\r\nfunction isCompensationAssociation(connection) {\r\n\r\n  var source = connection.source,\r\n      target = connection.target;\r\n\r\n  return is(target, 'vdml:Activity') &&\r\n         is(source, 'vdml:BoundaryEvent') &&\r\n         target.businessObject.isForCompensation;\r\n}\r\n\r\n\r\nfunction isExpandedSubProcess(element) {\r\n  return is(element, 'vdml:SubProcess') && isExpanded(element);\r\n}","'use strict';\r\n\r\nvar assign = require(410),\r\n    forEach = require(283),\r\n    inherits = require(270);\r\n\r\nvar Collections = require(244),\r\n    Model = require(235);\r\n\r\nvar getBusinessObject = require(93).getBusinessObject,\r\n    is = require(93).is;\r\n\r\nvar CommandInterceptor = require(100);\r\n\r\n/**\r\n * A handler responsible for updating the underlying VDML 2.0 XML + DI\r\n * once changes on the diagram happen\r\n */\r\nfunction VdmlUpdater(eventBus, vdmlFactory, connectionDocking, translate) {\r\n\r\n  CommandInterceptor.call(this, eventBus);\r\n\r\n  this._vdmlFactory = vdmlFactory;\r\n  this._translate = translate;\r\n\r\n  var self = this;\r\n\r\n\r\n\r\n  ////// connection cropping /////////////////////////\r\n\r\n  // crop connection ends during create/update\r\n  function cropConnection(e) {\r\n    var context = e.context,\r\n        connection;\r\n\r\n    if (!context.cropped) {\r\n      connection = context.connection;\r\n      connection.waypoints = connectionDocking.getCroppedWaypoints(connection);\r\n      context.cropped = true;\r\n    }\r\n  }\r\n\r\n  this.executed([\r\n    'connection.layout',\r\n    'connection.create',\r\n    'connection.reconnectEnd',\r\n    'connection.reconnectStart'\r\n  ], cropConnection);\r\n\r\n  this.reverted([ 'connection.layout' ], function(e) {\r\n    delete e.context.cropped;\r\n  });\r\n\r\n\r\n\r\n  ////// VDML + DI update /////////////////////////\r\n\r\n\r\n  // update parent\r\n  function updateParent(e) {\r\n    var context = e.context;\r\n\r\n    self.updateParent(context.shape || context.connection, context.oldParent);\r\n  }\r\n\r\n  function reverseUpdateParent(e) {\r\n    var context = e.context;\r\n\r\n    var element = context.shape || context.connection,\r\n        // oldParent is the (old) new parent, because we are undoing\r\n        oldParent = context.parent || context.newParent;\r\n\r\n    self.updateParent(element, oldParent);\r\n  }\r\n\r\n  this.executed([ 'shape.move',\r\n                  'shape.create',\r\n                  'shape.delete',\r\n                  'connection.create',\r\n                  'connection.move',\r\n                  'connection.delete' ], ifVdml(updateParent));\r\n\r\n  this.reverted([ 'shape.move',\r\n                  'shape.create',\r\n                  'shape.delete',\r\n                  'connection.create',\r\n                  'connection.move',\r\n                  'connection.delete' ], ifVdml(reverseUpdateParent));\r\n\r\n  /*\r\n   * ## Updating Parent\r\n   *\r\n   * When morphing a Process into a Collaboration or vice-versa,\r\n   * make sure that both the *semantic* and *di* parent of each element\r\n   * is updated.\r\n   *\r\n   */\r\n  function updateRoot(event) {\r\n    var context = event.context,\r\n        oldRoot = context.oldRoot,\r\n        children = oldRoot.children;\r\n\r\n    forEach(children, function(child) {\r\n      if (is(child, 'vdml:BaseElement')) {\r\n        self.updateParent(child);\r\n      }\r\n    });\r\n  }\r\n\r\n  this.executed([ 'canvas.updateRoot' ], updateRoot);\r\n  this.reverted([ 'canvas.updateRoot' ], updateRoot);\r\n\r\n\r\n  // update bounds\r\n  function updateBounds(e) {\r\n    var shape = e.context.shape;\r\n\r\n    if (!is(shape, 'vdml:BaseElement')) {\r\n      return;\r\n    }\r\n\r\n    self.updateBounds(shape);\r\n  }\r\n\r\n  this.executed([ 'shape.move', 'shape.create', 'shape.resize' ], ifVdml(function(event) {\r\n\r\n    // exclude labels because they're handled separately during shape.changed\r\n    if (event.context.shape.type === 'label') {\r\n      return;\r\n    }\r\n\r\n    updateBounds(event);\r\n  }));\r\n\r\n  this.reverted([ 'shape.move', 'shape.create', 'shape.resize' ], ifVdml(function(event) {\r\n\r\n    // exclude labels because they're handled separately during shape.changed\r\n    if (event.context.shape.type === 'label') {\r\n      return;\r\n    }\r\n\r\n    updateBounds(event);\r\n  }));\r\n\r\n  // Handle labels separately. This is necessary, because the label bounds have to be updated\r\n  // every time its shape changes, not only on move, create and resize.\r\n  eventBus.on('shape.changed', function(event) {\r\n    if (event.element.type === 'label') {\r\n      updateBounds({ context: { shape: event.element } });\r\n    }\r\n  });\r\n\r\n  // attach / detach connection\r\n  function updateConnection(e) {\r\n    self.updateConnection(e.context);\r\n  }\r\n\r\n  this.executed([\r\n    'connection.create',\r\n    'connection.move',\r\n    'connection.delete',\r\n    'connection.reconnectEnd',\r\n    'connection.reconnectStart'\r\n  ], ifVdml(updateConnection));\r\n\r\n  this.reverted([\r\n    'connection.create',\r\n    'connection.move',\r\n    'connection.delete',\r\n    'connection.reconnectEnd',\r\n    'connection.reconnectStart'\r\n  ], ifVdml(updateConnection));\r\n\r\n\r\n  // update waypoints\r\n  function updateConnectionWaypoints(e) {\r\n    self.updateConnectionWaypoints(e.context.connection);\r\n  }\r\n\r\n  this.executed([\r\n    'connection.layout',\r\n    'connection.move',\r\n    'connection.updateWaypoints',\r\n    'connection.reconnectEnd',\r\n    'connection.reconnectStart'\r\n  ], ifVdml(updateConnectionWaypoints));\r\n\r\n  this.reverted([\r\n    'connection.layout',\r\n    'connection.move',\r\n    'connection.updateWaypoints',\r\n    'connection.reconnectEnd',\r\n    'connection.reconnectStart'\r\n  ], ifVdml(updateConnectionWaypoints));\r\n\r\n\r\n  // update Default & Conditional flows\r\n  this.executed([\r\n    'connection.reconnectEnd',\r\n    'connection.reconnectStart'\r\n  ], ifVdml(function(e) {\r\n    var context = e.context,\r\n        connection = context.connection,\r\n        businessObject = getBusinessObject(connection),\r\n        oldSource = getBusinessObject(context.oldSource),\r\n        oldTarget = getBusinessObject(context.oldTarget),\r\n        newSource = getBusinessObject(connection.source),\r\n        newTarget = getBusinessObject(connection.target);\r\n\r\n    if (oldSource === newSource || oldTarget === newTarget) {\r\n      return;\r\n    }\r\n\r\n    // on reconnectStart -> default flow\r\n    if (oldSource && oldSource.default === businessObject) {\r\n      context.default = oldSource.default;\r\n      oldSource.default = undefined;\r\n    }\r\n\r\n    // on reconnectEnd -> default flow\r\n    if ((businessObject.sourceRef && businessObject.sourceRef.default) &&\r\n        !(is(newTarget, 'vdml:Activity') ||\r\n          is(newTarget, 'vdml:EndEvent') ||\r\n          is(newTarget, 'vdml:Gateway') ||\r\n          is(newTarget, 'vdml:IntermediateThrowEvent')) ) {\r\n      context.default = businessObject.sourceRef.default;\r\n      businessObject.sourceRef.default = undefined;\r\n    }\r\n\r\n    // on reconnectStart -> conditional flow\r\n    if (oldSource && (businessObject.conditionExpression) &&\r\n      !(is(newSource, 'vdml:Activity') ||\r\n        is(newSource, 'vdml:Gateway')) ) {\r\n      context.conditionExpression = businessObject.conditionExpression;\r\n      businessObject.conditionExpression = undefined;\r\n    }\r\n\r\n    // on reconnectEnd -> conditional flow\r\n    if (oldTarget && (businessObject.conditionExpression) &&\r\n        !(is(newTarget, 'vdml:Activity') ||\r\n          is(newTarget, 'vdml:EndEvent') ||\r\n          is(newTarget, 'vdml:Gateway') ||\r\n          is(newTarget, 'vdml:IntermediateThrowEvent')) ) {\r\n      context.conditionExpression = businessObject.conditionExpression;\r\n      businessObject.conditionExpression = undefined;\r\n    }\r\n  }));\r\n\r\n  this.reverted([\r\n    'connection.reconnectEnd',\r\n    'connection.reconnectStart'\r\n  ], ifVdml(function(e) {\r\n    var context = e.context,\r\n        connection = context.connection,\r\n        businessObject = getBusinessObject(connection),\r\n        newSource = getBusinessObject(connection.source);\r\n\r\n    // default flow\r\n    if (context.default) {\r\n      if (is(newSource, 'vdml:ExclusiveGateway') || is(newSource, 'vdml:InclusiveGateway') ||\r\n          is(newSource, 'vdml:Activity')) {\r\n        newSource.default = context.default;\r\n      }\r\n    }\r\n\r\n    // conditional flow\r\n    if (context.conditionExpression && is(newSource, 'vdml:Activity')) {\r\n      businessObject.conditionExpression = context.conditionExpression;\r\n    }\r\n  }));\r\n\r\n  // update attachments\r\n  function updateAttachment(e) {\r\n    self.updateAttachment(e.context);\r\n  }\r\n\r\n  this.executed([ 'element.updateAttachment' ], ifVdml(updateAttachment));\r\n  this.reverted([ 'element.updateAttachment' ], ifVdml(updateAttachment));\r\n}\r\n\r\ninherits(VdmlUpdater, CommandInterceptor);\r\n\r\nmodule.exports = VdmlUpdater;\r\n\r\nVdmlUpdater.$inject = [ 'eventBus', 'vdmlFactory', 'connectionDocking', 'translate' ];\r\n\r\n\r\n/////// implementation //////////////////////////////////\r\n\r\nVdmlUpdater.prototype.updateAttachment = function(context) {\r\n\r\n  var shape = context.shape,\r\n      businessObject = shape.businessObject,\r\n      host = shape.host;\r\n\r\n  businessObject.attachedToRef = host && host.businessObject;\r\n};\r\n\r\nVdmlUpdater.prototype.updateParent = function(element, oldParent) {\r\n  // do not update VDML 2.0 label parent\r\n  if (element instanceof Model.Label) {\r\n    return;\r\n  }\r\n\r\n  var parentShape = element.parent;\r\n\r\n  var businessObject = element.businessObject,\r\n      parentBusinessObject = parentShape && parentShape.businessObject,\r\n      parentDi = parentBusinessObject && parentBusinessObject.di;\r\n\r\n  if (is(element, 'vdml:FlowNode')) {\r\n    this.updateFlowNodeRefs(businessObject, parentBusinessObject, oldParent && oldParent.businessObject);\r\n  }\r\n\r\n  if (is(element, 'vdml:DataOutputAssociation')) {\r\n    if (element.source) {\r\n      parentBusinessObject = element.source.businessObject;\r\n    } else {\r\n      parentBusinessObject = null;\r\n    }\r\n  }\r\n\r\n  if (is(element, 'vdml:DataInputAssociation')) {\r\n    if (element.target) {\r\n      parentBusinessObject = element.target.businessObject;\r\n    } else {\r\n      parentBusinessObject = null;\r\n    }\r\n  }\r\n\r\n  this.updateSemanticParent(businessObject, parentBusinessObject);\r\n\r\n  if (is(element, 'vdml:DataObjectReference') && businessObject.dataObjectRef) {\r\n    this.updateSemanticParent(businessObject.dataObjectRef, parentBusinessObject);\r\n  }\r\n\r\n  this.updateDiParent(businessObject.di, parentDi);\r\n};\r\n\r\n\r\nVdmlUpdater.prototype.updateBounds = function(shape) {\r\n\r\n  var di = shape.businessObject.di;\r\n\r\n  var bounds = (shape instanceof Model.Label) ? this._getLabel(di).bounds : di.bounds;\r\n\r\n  assign(bounds, {\r\n    x: shape.x,\r\n    y: shape.y,\r\n    width: shape.width,\r\n    height: shape.height\r\n  });\r\n};\r\n\r\nVdmlUpdater.prototype.updateFlowNodeRefs = function(businessObject, newContainment, oldContainment) {\r\n\r\n  if (oldContainment === newContainment) {\r\n    return;\r\n  }\r\n\r\n  var oldRefs, newRefs;\r\n\r\n  if (is (oldContainment, 'vdml:Lane')) {\r\n    oldRefs = oldContainment.get('flowNodeRef');\r\n    Collections.remove(oldRefs, businessObject);\r\n  }\r\n\r\n  if (is(newContainment, 'vdml:Lane')) {\r\n    newRefs = newContainment.get('flowNodeRef');\r\n    Collections.add(newRefs, businessObject);\r\n  }\r\n};\r\n\r\nVdmlUpdater.prototype.updateDiParent = function(di, parentDi) {\r\n\r\n  if (parentDi && !is(parentDi, 'vdmldi:VDMLPlane')) {\r\n    parentDi = parentDi.$parent;\r\n  }\r\n\r\n  if (di.$parent === parentDi) {\r\n    return;\r\n  }\r\n\r\n  var planeElements = (parentDi || di.$parent).get('planeElement');\r\n\r\n  if (parentDi) {\r\n    planeElements.push(di);\r\n    di.$parent = parentDi;\r\n  } else {\r\n    Collections.remove(planeElements, di);\r\n    di.$parent = null;\r\n  }\r\n};\r\n\r\nfunction getDefinitions(element) {\r\n  while (element && !is(element, 'vdml:Definitions')) {\r\n    element = element.$parent;\r\n  }\r\n\r\n  return element;\r\n}\r\n\r\nVdmlUpdater.prototype.getLaneSet = function(container) {\r\n\r\n  var laneSet, laneSets;\r\n\r\n  // vdml:Lane\r\n  if (is(container, 'vdml:Lane')) {\r\n    laneSet = container.childLaneSet;\r\n\r\n    if (!laneSet) {\r\n      laneSet = this._vdmlFactory.create('vdml:LaneSet');\r\n      container.childLaneSet = laneSet;\r\n      laneSet.$parent = container;\r\n    }\r\n\r\n    return laneSet;\r\n  }\r\n\r\n  // vdml:Participant\r\n  if (is(container, 'vdml:Participant')) {\r\n    container = container.processRef;\r\n  }\r\n\r\n  // vdml:FlowElementsContainer\r\n  laneSets = container.get('laneSets');\r\n  laneSet = laneSets[0];\r\n\r\n  if (!laneSet) {\r\n    laneSet = this._vdmlFactory.create('vdml:LaneSet');\r\n    laneSet.$parent = container;\r\n    laneSets.push(laneSet);\r\n  }\r\n\r\n  return laneSet;\r\n};\r\n\r\nVdmlUpdater.prototype.updateSemanticParent = function(businessObject, newParent, visualParent) {\r\n\r\n  var containment,\r\n      translate = this._translate;\r\n\r\n  if (businessObject.$parent === newParent) {\r\n    return;\r\n  }\r\n\r\n  if (is(businessObject, 'vdml:Lane')) {\r\n\r\n    if (newParent) {\r\n      newParent = this.getLaneSet(newParent);\r\n    }\r\n\r\n    containment = 'lanes';\r\n  } else\r\n\r\n  if (is(businessObject, 'vdml:FlowElement')) {\r\n\r\n    if (newParent) {\r\n\r\n      if (is(newParent, 'vdml:Participant')) {\r\n        newParent = newParent.processRef;\r\n      } else\r\n\r\n      if (is(newParent, 'vdml:Lane')) {\r\n        do {\r\n          // unwrap Lane -> LaneSet -> (Lane | FlowElementsContainer)\r\n          newParent = newParent.$parent.$parent;\r\n        } while (is(newParent, 'vdml:Lane'));\r\n\r\n      }\r\n    }\r\n\r\n    containment = 'flowElements';\r\n\r\n  } else\r\n\r\n  if (is(businessObject, 'vdml:Artifact')) {\r\n\r\n    while (newParent &&\r\n           !is(newParent, 'vdml:Process') &&\r\n           !is(newParent, 'vdml:SubProcess') &&\r\n           !is(newParent, 'vdml:Collaboration')) {\r\n\r\n      if (is(newParent, 'vdml:Participant')) {\r\n        newParent = newParent.processRef;\r\n        break;\r\n      } else {\r\n        newParent = newParent.$parent;\r\n      }\r\n    }\r\n\r\n    containment = 'artifacts';\r\n  } else\r\n\r\n  if (is(businessObject, 'vdml:MessageFlow')) {\r\n    containment = 'messageFlows';\r\n\r\n  } else\r\n\r\n  if (is(businessObject, 'vdml:Participant')) {\r\n    containment = 'participants';\r\n\r\n    // make sure the participants process is properly attached / detached\r\n    // from the XML document\r\n\r\n    var process = businessObject.processRef,\r\n        definitions;\r\n\r\n    if (process) {\r\n      definitions = getDefinitions(businessObject.$parent || newParent);\r\n\r\n      if (businessObject.$parent) {\r\n        Collections.remove(definitions.get('rootElements'), process);\r\n        process.$parent = null;\r\n      }\r\n\r\n      if (newParent) {\r\n        Collections.add(definitions.get('rootElements'), process);\r\n        process.$parent = definitions;\r\n      }\r\n    }\r\n  } else\r\n\r\n  if (is(businessObject, 'vdml:DataOutputAssociation')) {\r\n    containment = 'dataOutputAssociations';\r\n  } else\r\n\r\n  if (is(businessObject, 'vdml:DataInputAssociation')) {\r\n    containment = 'dataInputAssociations';\r\n  }\r\n\r\n  if (!containment) {\r\n    throw new Error(translate(\r\n      'no parent for {element} in {parent}',\r\n      {\r\n        element: businessObject.id,\r\n        parent: newParent.id\r\n      }\r\n    ));\r\n  }\r\n\r\n  var children;\r\n\r\n  if (businessObject.$parent) {\r\n    // remove from old parent\r\n    children = businessObject.$parent.get(containment);\r\n    Collections.remove(children, businessObject);\r\n  }\r\n\r\n  if (!newParent) {\r\n    businessObject.$parent = null;\r\n  } else {\r\n    // add to new parent\r\n    children = newParent.get(containment);\r\n    children.push(businessObject);\r\n    businessObject.$parent = newParent;\r\n  }\r\n\r\n  if (visualParent) {\r\n    var diChildren = visualParent.get(containment);\r\n\r\n    Collections.remove(children, businessObject);\r\n\r\n    if (newParent) {\r\n\r\n      if (!diChildren) {\r\n        diChildren = [];\r\n        newParent.set(containment, diChildren);\r\n      }\r\n\r\n      diChildren.push(businessObject);\r\n    }\r\n  }\r\n};\r\n\r\n\r\nVdmlUpdater.prototype.updateConnectionWaypoints = function(connection) {\r\n  connection.businessObject.di.set('waypoint', this._vdmlFactory.createDiWaypoints(connection.waypoints));\r\n};\r\n\r\n\r\nVdmlUpdater.prototype.updateConnection = function(context) {\r\n\r\n  var connection = context.connection,\r\n      businessObject = getBusinessObject(connection),\r\n      newSource = getBusinessObject(connection.source),\r\n      newTarget = getBusinessObject(connection.target),\r\n      visualParent;\r\n\r\n  if (!is(businessObject, 'vdml:DataAssociation')) {\r\n\r\n    var inverseSet = is(businessObject, 'vdml:SequenceFlow');\r\n\r\n    if (businessObject.sourceRef !== newSource) {\r\n      if (inverseSet) {\r\n        Collections.remove(businessObject.sourceRef && businessObject.sourceRef.get('outgoing'), businessObject);\r\n\r\n        if (newSource && newSource.get('outgoing')) {\r\n          newSource.get('outgoing').push(businessObject);\r\n        }\r\n      }\r\n\r\n      businessObject.sourceRef = newSource;\r\n    }\r\n\r\n    if (businessObject.targetRef !== newTarget) {\r\n      if (inverseSet) {\r\n        Collections.remove(businessObject.targetRef && businessObject.targetRef.get('incoming'), businessObject);\r\n\r\n        if (newTarget && newTarget.get('incoming')) {\r\n          newTarget.get('incoming').push(businessObject);\r\n        }\r\n      }\r\n\r\n      businessObject.targetRef = newTarget;\r\n    }\r\n  } else\r\n\r\n  if (is(businessObject, 'vdml:DataInputAssociation')) {\r\n    // handle obnoxious isMany sourceRef\r\n    businessObject.get('sourceRef')[0] = newSource;\r\n\r\n    visualParent = context.parent || context.newParent || newTarget;\r\n\r\n    this.updateSemanticParent(businessObject, newTarget, parent.businessObject);\r\n  } else\r\n\r\n  if (is(businessObject, 'vdml:DataOutputAssociation')) {\r\n    visualParent = context.parent || context.newParent || newSource;\r\n\r\n    this.updateSemanticParent(businessObject, newSource, visualParent);\r\n\r\n    // targetRef = new target\r\n    businessObject.targetRef = newTarget;\r\n  }\r\n\r\n  this.updateConnectionWaypoints(connection);\r\n};\r\n\r\n\r\n/////// helpers /////////////////////////////////////////\r\n\r\nVdmlUpdater.prototype._getLabel = function(di) {\r\n  if (!di.label) {\r\n    di.label = this._vdmlFactory.createDiLabel();\r\n  }\r\n\r\n  return di.label;\r\n};\r\n\r\n\r\n/**\r\n * Make sure the event listener is only called\r\n * if the touched element is a VDML element.\r\n *\r\n * @param  {Function} fn\r\n * @return {Function} guarded function\r\n */\r\nfunction ifVdml(fn) {\r\n\r\n  return function(event) {\r\n\r\n    var context = event.context,\r\n        element = context.shape || context.connection;\r\n\r\n    if (is(element, 'vdml:BaseElement')) {\r\n      fn(event);\r\n    }\r\n  };\r\n}\r\n","'use strict';\r\n\r\nvar inherits = require(270);\r\n\r\nvar is = require(93).is;\r\n\r\nvar CommandInterceptor = require(100);\r\n\r\n\r\nfunction AppendBehavior(eventBus, elementFactory, vdmlRules) {\r\n\r\n  CommandInterceptor.call(this, eventBus);\r\n\r\n  // assign correct shape position unless already set\r\n\r\n  this.preExecute('shape.append', function(context) {\r\n\r\n    var source = context.source,\r\n        shape = context.shape;\r\n\r\n    if (!context.position) {\r\n\r\n      if (is(shape, 'vdml:TextAnnotation')) {\r\n        context.position = {\r\n          x: source.x + source.width / 2 + 75,\r\n          y: source.y - (50) - shape.height / 2\r\n        };\r\n      } else {\r\n        context.position = {\r\n          x: source.x + source.width + 80 + shape.width / 2,\r\n          y: source.y + source.height / 2\r\n        };\r\n      }\r\n    }\r\n  }, true);\r\n}\r\n\r\n\r\nAppendBehavior.$inject = [ 'eventBus', 'elementFactory', 'vdmlRules' ];\r\n\r\ninherits(AppendBehavior, CommandInterceptor);\r\n\r\nmodule.exports = AppendBehavior;","'use strict';\r\n\r\nvar inherits = require(270);\r\n\r\nvar forEach = require(283);\r\n\r\nvar is = require(93).is;\r\n\r\nvar CommandInterceptor = require(100);\r\n\r\n\r\nfunction CopyPasteBehavior(eventBus, modeling, canvas) {\r\n\r\n  CommandInterceptor.call(this, eventBus);\r\n\r\n  this.preExecute('elements.paste', 1500, function(context) {\r\n    var topParent = context.topParent;\r\n\r\n    // always grab the latest root\r\n    if (!topParent.parent) {\r\n      context.topParent = canvas.getRootElement();\r\n    }\r\n\r\n    if (is(topParent, 'vdml:Lane')) {\r\n      do {\r\n        // unwrap Lane -> LaneSet -> (Lane | FlowElementsContainer)\r\n        topParent = context.topParent = topParent.parent;\r\n\r\n      } while (is(topParent, 'vdml:Lane') || !is(topParent, 'vdml:Participant'));\r\n    }\r\n  }, true);\r\n\r\n  this.postExecute('elements.paste', function(context) {\r\n\r\n    var tree = context.tree,\r\n        createdElements = tree.createdElements;\r\n\r\n    forEach(createdElements, function(data) {\r\n      var element = data.element,\r\n          businessObject = element.businessObject,\r\n          descriptor = data.descriptor,\r\n          defaultFlow;\r\n\r\n      if ((is(businessObject, 'vdml:ExclusiveGateway') || is(businessObject, 'vdml:InclusiveGateway') ||\r\n           is(businessObject, 'vdml:Activity')) && descriptor.default) {\r\n\r\n        defaultFlow = createdElements[descriptor.default];\r\n\r\n        // if the default flow wasn't created, means that it wasn't copied\r\n        if (defaultFlow) {\r\n          defaultFlow = defaultFlow.element;\r\n        } else {\r\n          defaultFlow = undefined;\r\n        }\r\n\r\n        delete element.default;\r\n\r\n        modeling.updateProperties(element, { default: defaultFlow });\r\n      }\r\n    });\r\n  }, true);\r\n}\r\n\r\n\r\nCopyPasteBehavior.$inject = [ 'eventBus', 'modeling', 'canvas' ];\r\n\r\ninherits(CopyPasteBehavior, CommandInterceptor);\r\n\r\nmodule.exports = CopyPasteBehavior;\r\n","'use strict';\r\n\r\nvar inherits = require(270);\r\n\r\nvar CommandInterceptor = require(100);\r\n\r\nvar is = require(93).is;\r\n\r\n\r\n/**\r\n * VDML specific create boundary event behavior\r\n */\r\nfunction CreateBoundaryEventBehavior(eventBus, modeling, elementFactory, vdmlFactory) {\r\n\r\n  CommandInterceptor.call(this, eventBus);\r\n\r\n  /**\r\n   * replace intermediate event with boundary event when\r\n   * attaching it to a shape\r\n   */\r\n\r\n  this.preExecute('shape.create', function(context) {\r\n    var shape = context.shape,\r\n        host = context.host,\r\n        businessObject,\r\n        boundaryEvent;\r\n\r\n    var attrs = {\r\n      cancelActivity: true\r\n    };\r\n\r\n    if (host && is(shape, 'vdml:IntermediateThrowEvent')) {\r\n      attrs.attachedToRef = host.businessObject;\r\n\r\n      businessObject = vdmlFactory.create('vdml:BoundaryEvent', attrs);\r\n\r\n      boundaryEvent = {\r\n        type: 'vdml:BoundaryEvent',\r\n        businessObject: businessObject\r\n      };\r\n\r\n      context.shape = elementFactory.createShape(boundaryEvent);\r\n    }\r\n  }, true);\r\n}\r\n\r\nCreateBoundaryEventBehavior.$inject = [ 'eventBus', 'modeling', 'elementFactory', 'vdmlFactory' ];\r\n\r\ninherits(CreateBoundaryEventBehavior, CommandInterceptor);\r\n\r\nmodule.exports = CreateBoundaryEventBehavior;\r\n","'use strict';\r\n\r\nvar inherits = require(270);\r\n\r\nvar CommandInterceptor = require(100);\r\n\r\nvar is = require(93).is;\r\n\r\n/**\r\n * VDML specific create data object behavior\r\n */\r\nfunction CreateDataObjectBehavior(eventBus, vdmlFactory, moddle) {\r\n\r\n  CommandInterceptor.call(this, eventBus);\r\n\r\n  this.preExecute('shape.create', function(event) {\r\n\r\n    var context = event.context,\r\n        shape = context.shape;\r\n\r\n    if (is(shape, 'vdml:DataObjectReference') && shape.type !== 'label') {\r\n\r\n      // create a DataObject every time a DataObjectReference is created\r\n      var dataObject = vdmlFactory.create('vdml:DataObject');\r\n\r\n      // set the reference to the DataObject\r\n      shape.businessObject.dataObjectRef = dataObject;\r\n    }\r\n  });\r\n\r\n}\r\n\r\nCreateDataObjectBehavior.$inject = [ 'eventBus', 'vdmlFactory', 'moddle' ];\r\n\r\ninherits(CreateDataObjectBehavior, CommandInterceptor);\r\n\r\nmodule.exports = CreateDataObjectBehavior;\r\n","'use strict';\r\n\r\nvar inherits = require(270);\r\n\r\nvar assign = require(410);\r\n\r\nvar CommandInterceptor = require(100);\r\n\r\nvar getApproxIntersection = require(252).getApproxIntersection;\r\n\r\n\r\nfunction copy(obj) {\r\n  return assign({}, obj);\r\n}\r\n\r\nfunction CreateOnFlowBehavior(eventBus, vdmlRules, modeling) {\r\n\r\n  CommandInterceptor.call(this, eventBus);\r\n\r\n  /**\r\n   * Reconnect start / end of a connection after\r\n   * dropping an element on a flow.\r\n   */\r\n\r\n  this.preExecute('shape.create', function(context) {\r\n\r\n    var parent = context.parent,\r\n        shape = context.shape;\r\n\r\n    if (vdmlRules.canInsert(shape, parent)) {\r\n      context.targetFlow = parent;\r\n      context.parent = parent.parent;\r\n    }\r\n  }, true);\r\n\r\n\r\n  this.postExecute('shape.create', function(context) {\r\n\r\n    var shape = context.shape,\r\n        targetFlow = context.targetFlow,\r\n        position = context.position,\r\n        source,\r\n        target,\r\n        reconnected,\r\n        intersection,\r\n        waypoints,\r\n        waypointsBefore,\r\n        waypointsAfter,\r\n        dockingPoint;\r\n\r\n    if (targetFlow) {\r\n\r\n      waypoints = targetFlow.waypoints;\r\n\r\n\r\n      intersection = getApproxIntersection(waypoints, position);\r\n\r\n      if (intersection) {\r\n        waypointsBefore = waypoints.slice(0, intersection.index);\r\n        waypointsAfter = waypoints.slice(intersection.index + (intersection.bendpoint ? 1 : 0));\r\n\r\n        dockingPoint = intersection.bendpoint ? waypoints[intersection.index] : position;\r\n\r\n        waypointsBefore.push(copy(dockingPoint));\r\n        waypointsAfter.unshift(copy(dockingPoint));\r\n      }\r\n\r\n      source = targetFlow.source;\r\n      target = targetFlow.target;\r\n\r\n      if (vdmlRules.canConnect(source, shape, targetFlow)) {\r\n        // reconnect source -> inserted shape\r\n        modeling.reconnectEnd(targetFlow, shape, waypointsBefore || copy(position));\r\n\r\n        reconnected = true;\r\n      }\r\n\r\n      if (vdmlRules.canConnect(shape, target, targetFlow)) {\r\n\r\n        if (!reconnected) {\r\n          // reconnect inserted shape -> end\r\n          modeling.reconnectStart(targetFlow, shape, waypointsAfter || copy(position));\r\n        } else {\r\n          modeling.connect(shape, target, { type: targetFlow.type, waypoints: waypointsAfter });\r\n        }\r\n      }\r\n    }\r\n  }, true);\r\n}\r\n\r\ninherits(CreateOnFlowBehavior, CommandInterceptor);\r\n\r\nCreateOnFlowBehavior.$inject = [ 'eventBus', 'vdmlRules', 'modeling' ];\r\n\r\nmodule.exports = CreateOnFlowBehavior;\r\n","'use strict';\r\n\r\nvar inherits = require(270);\r\n\r\nvar CommandInterceptor = require(100);\r\n\r\nvar is = require(93).is;\r\n\r\n/**\r\n * VDML specific create participant behavior\r\n */\r\nfunction CreateParticipantBehavior(eventBus, modeling, elementFactory, vdmlFactory, canvas) {\r\n\r\n  CommandInterceptor.call(this, eventBus);\r\n\r\n  /**\r\n   * morph process into collaboration before adding\r\n   * participant onto collaboration\r\n   */\r\n\r\n  this.preExecute('shape.create', function(context) {\r\n\r\n    var parent = context.parent,\r\n        shape = context.shape,\r\n        position = context.position;\r\n\r\n    var rootElement = canvas.getRootElement();\r\n\r\n    if (is(parent, 'vdml:Process') && is(shape, 'vdml:Participant') && !is(rootElement, 'vdml:Collaboration')) {\r\n\r\n      // this is going to detach the process root\r\n      // and set the returned collaboration element\r\n      // as the new root element\r\n      var collaborationElement = modeling.makeCollaboration();\r\n\r\n      // monkey patch the create context\r\n      // so that the participant is being dropped\r\n      // onto the new collaboration root instead\r\n      context.position = position;\r\n      context.parent = collaborationElement;\r\n\r\n      context.processRoot = parent;\r\n    }\r\n  }, true);\r\n\r\n\r\n  this.execute('shape.create', function(context) {\r\n\r\n    var processRoot = context.processRoot,\r\n        shape = context.shape;\r\n\r\n    if (processRoot) {\r\n      context.oldProcessRef = shape.businessObject.processRef;\r\n\r\n      // assign the participant processRef\r\n      shape.businessObject.processRef = processRoot.businessObject;\r\n    }\r\n  }, true);\r\n\r\n\r\n  this.revert('shape.create', function(context) {\r\n    var processRoot = context.processRoot,\r\n        shape = context.shape;\r\n\r\n    if (processRoot) {\r\n      // assign the participant processRef\r\n      shape.businessObject.processRef = context.oldProcessRef;\r\n    }\r\n  }, true);\r\n\r\n\r\n  this.postExecute('shape.create', function(context) {\r\n\r\n    var processRoot = context.processRoot,\r\n        shape = context.shape;\r\n\r\n    if (processRoot) {\r\n      // process root is already detached at this point\r\n      var processChildren = processRoot.children.slice();\r\n      modeling.moveElements(processChildren, { x: 0, y: 0 }, shape);\r\n    }\r\n\r\n  }, true);\r\n\r\n}\r\n\r\nCreateParticipantBehavior.$inject = [ 'eventBus', 'modeling', 'elementFactory', 'vdmlFactory', 'canvas' ];\r\n\r\ninherits(CreateParticipantBehavior, CommandInterceptor);\r\n\r\nmodule.exports = CreateParticipantBehavior;\r\n","'use strict';\r\n\r\nvar inherits = require(270);\r\n\r\nvar CommandInterceptor = require(100);\r\n\r\nvar Collections = require(244);\r\n\r\nvar find = require(282);\r\n\r\nvar is = require(93).is;\r\n\r\nvar TARGET_REF_PLACEHOLDER_NAME = '__targetRef_placeholder';\r\n\r\n\r\n/**\r\n * This behavior makes sure we always set a fake\r\n * DataInputAssociation#targetRef as demanded by the VDML 2.0\r\n * XSD schema.\r\n *\r\n * The reference is set to a vdml:Property{ name: '__targetRef_placeholder' }\r\n * which is created on the fly and cleaned up afterwards if not needed\r\n * anymore.\r\n *\r\n * @param {EventBus} eventBus\r\n * @param {VdmlFactory} vdmlFactory\r\n */\r\nfunction DataInputAssociationBehavior(eventBus, vdmlFactory) {\r\n\r\n  CommandInterceptor.call(this, eventBus);\r\n\r\n\r\n  this.executed([\r\n    'connection.create',\r\n    'connection.delete',\r\n    'connection.move',\r\n    'connection.reconnectEnd'\r\n  ], ifDataInputAssociation(fixTargetRef));\r\n\r\n  this.reverted([\r\n    'connection.create',\r\n    'connection.delete',\r\n    'connection.move',\r\n    'connection.reconnectEnd'\r\n  ], ifDataInputAssociation(fixTargetRef));\r\n\r\n\r\n  function usesTargetRef(element, targetRef, removedConnection) {\r\n\r\n    var inputAssociations = element.get('dataInputAssociations');\r\n\r\n    return find(inputAssociations, function(association) {\r\n      return association !== removedConnection &&\r\n             association.targetRef === targetRef;\r\n    });\r\n  }\r\n\r\n  function getTargetRef(element, create) {\r\n\r\n    var properties = element.get('properties');\r\n\r\n    var targetRefProp = find(properties, function(p) {\r\n      return p.name === TARGET_REF_PLACEHOLDER_NAME;\r\n    });\r\n\r\n    if (!targetRefProp && create) {\r\n      targetRefProp = vdmlFactory.create('vdml:Property', {\r\n        name: TARGET_REF_PLACEHOLDER_NAME\r\n      });\r\n\r\n      Collections.add(properties, targetRefProp);\r\n    }\r\n\r\n    return targetRefProp;\r\n  }\r\n\r\n  function cleanupTargetRef(element, connection) {\r\n\r\n    var targetRefProp = getTargetRef(element);\r\n\r\n    if (!targetRefProp) {\r\n      return;\r\n    }\r\n\r\n    if (!usesTargetRef(element, targetRefProp, connection)) {\r\n      Collections.remove(element.get('properties'), targetRefProp);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Make sure targetRef is set to a valid property or\r\n   * `null` if the connection is detached.\r\n   *\r\n   * @param {Event} event\r\n   */\r\n  function fixTargetRef(event) {\r\n\r\n    var context = event.context,\r\n        connection = context.connection,\r\n        connectionBo = connection.businessObject,\r\n        target = connection.target,\r\n        targetBo = target && target.businessObject,\r\n        newTarget = context.newTarget,\r\n        newTargetBo = newTarget && newTarget.businessObject,\r\n        oldTarget = context.oldTarget || context.target,\r\n        oldTargetBo = oldTarget && oldTarget.businessObject;\r\n\r\n    var dataAssociation = connection.businessObject,\r\n        targetRefProp;\r\n\r\n    if (oldTargetBo && oldTargetBo !== targetBo) {\r\n      cleanupTargetRef(oldTargetBo, connectionBo);\r\n    }\r\n\r\n    if (newTargetBo && newTargetBo !== targetBo) {\r\n      cleanupTargetRef(newTargetBo, connectionBo);\r\n    }\r\n\r\n    if (targetBo) {\r\n      targetRefProp = getTargetRef(targetBo, true);\r\n      dataAssociation.targetRef = targetRefProp;\r\n    } else {\r\n      dataAssociation.targetRef = null;\r\n    }\r\n  }\r\n}\r\n\r\nDataInputAssociationBehavior.$inject = [ 'eventBus', 'vdmlFactory' ];\r\n\r\ninherits(DataInputAssociationBehavior, CommandInterceptor);\r\n\r\nmodule.exports = DataInputAssociationBehavior;\r\n\r\n\r\n/**\r\n * Only call the given function when the event\r\n * touches a vdml:DataInputAssociation.\r\n *\r\n * @param {Function} fn\r\n * @return {Function}\r\n */\r\nfunction ifDataInputAssociation(fn) {\r\n\r\n  return function(event) {\r\n    var context = event.context,\r\n        connection = context.connection;\r\n\r\n    if (is(connection, 'vdml:DataInputAssociation')) {\r\n      return fn(event);\r\n    }\r\n  };\r\n}","'use strict';\r\n\r\nvar inherits = require(270);\r\n\r\nvar CommandInterceptor = require(100);\r\n\r\nvar is = require(93).is;\r\n\r\nvar getChildLanes = require(65).getChildLanes;\r\n\r\nvar eachElement = require(247).eachElement;\r\n\r\n\r\nvar LOW_PRIORITY = 500;\r\n\r\n\r\n/**\r\n * VDML specific delete lane behavior\r\n */\r\nfunction DeleteLaneBehavior(eventBus, modeling, spaceTool) {\r\n\r\n  CommandInterceptor.call(this, eventBus);\r\n\r\n\r\n  function compensateLaneDelete(shape, oldParent) {\r\n\r\n    var siblings = getChildLanes(oldParent);\r\n\r\n    var topAffected = [];\r\n    var bottomAffected = [];\r\n\r\n    eachElement(siblings, function(element) {\r\n\r\n      if (element.y > shape.y) {\r\n        bottomAffected.push(element);\r\n      } else {\r\n        topAffected.push(element);\r\n      }\r\n\r\n      return element.children;\r\n    });\r\n\r\n    if (!siblings.length) {\r\n      return;\r\n    }\r\n\r\n    var offset;\r\n\r\n    if (bottomAffected.length && topAffected.length) {\r\n      offset = shape.height / 2;\r\n    } else {\r\n      offset = shape.height;\r\n    }\r\n\r\n    var topAdjustments,\r\n        bottomAdjustments;\r\n\r\n    if (topAffected.length) {\r\n      topAdjustments = spaceTool.calculateAdjustments(\r\n        topAffected, 'y', offset, shape.y - 10);\r\n\r\n      spaceTool.makeSpace(\r\n        topAdjustments.movingShapes,\r\n        topAdjustments.resizingShapes,\r\n        { x: 0, y: offset }, 's');\r\n    }\r\n\r\n    if (bottomAffected.length) {\r\n      bottomAdjustments = spaceTool.calculateAdjustments(\r\n        bottomAffected, 'y', -offset, shape.y + shape.height + 10);\r\n\r\n      spaceTool.makeSpace(\r\n        bottomAdjustments.movingShapes,\r\n        bottomAdjustments.resizingShapes,\r\n        { x: 0, y: -offset }, 'n');\r\n    }\r\n  }\r\n\r\n\r\n  /**\r\n   * Adjust sizes of other lanes after lane deletion\r\n   */\r\n  this.postExecuted('shape.delete', LOW_PRIORITY, function(event) {\r\n\r\n    var context = event.context,\r\n        hints = context.hints,\r\n        shape = context.shape,\r\n        oldParent = context.oldParent;\r\n\r\n    // only compensate lane deletes\r\n    if (!is(shape, 'vdml:Lane')) {\r\n      return;\r\n    }\r\n\r\n    // compensate root deletes only\r\n    if (hints && hints.nested) {\r\n      return;\r\n    }\r\n\r\n    compensateLaneDelete(shape, oldParent);\r\n  });\r\n}\r\n\r\nDeleteLaneBehavior.$inject = [ 'eventBus', 'modeling', 'spaceTool' ];\r\n\r\ninherits(DeleteLaneBehavior, CommandInterceptor);\r\n\r\nmodule.exports = DeleteLaneBehavior;","'use strict';\r\n\r\nvar getMid = require(233).getMid;\r\n\r\nvar lineIntersect = require(56);\r\n\r\n\r\n/**\r\n * Fix broken dockings after DI imports.\r\n *\r\n * @param {EventBus} eventBus\r\n */\r\nfunction ImportDockingFix(eventBus) {\r\n\r\n  function adjustDocking(startPoint, nextPoint, elementMid) {\r\n\r\n    var elementTop = {\r\n      x: elementMid.x,\r\n      y: elementMid.y - 50\r\n    };\r\n\r\n    var elementLeft = {\r\n      x: elementMid.x - 50,\r\n      y: elementMid.y\r\n    };\r\n\r\n    var verticalIntersect = lineIntersect(startPoint, nextPoint, elementMid, elementTop),\r\n        horizontalIntersect = lineIntersect(startPoint, nextPoint, elementMid, elementLeft);\r\n\r\n    // original is horizontal or vertical center cross intersection\r\n    var centerIntersect;\r\n\r\n    if (verticalIntersect && horizontalIntersect) {\r\n      if (getDistance(verticalIntersect, elementMid) > getDistance(horizontalIntersect, elementMid)) {\r\n        centerIntersect = horizontalIntersect;\r\n      } else {\r\n        centerIntersect = verticalIntersect;\r\n      }\r\n    } else {\r\n      centerIntersect = verticalIntersect || horizontalIntersect;\r\n    }\r\n\r\n    startPoint.original = centerIntersect;\r\n  }\r\n\r\n  function fixDockings(connection) {\r\n    var waypoints = connection.waypoints;\r\n\r\n    adjustDocking(\r\n      waypoints[0],\r\n      waypoints[1],\r\n      getMid(connection.source)\r\n    );\r\n\r\n    adjustDocking(\r\n      waypoints[waypoints.length - 1],\r\n      waypoints[waypoints.length - 2],\r\n      getMid(connection.target)\r\n    );\r\n  }\r\n\r\n  eventBus.on('vdmlElement.added', function(e) {\r\n\r\n    var element = e.element;\r\n\r\n    if (element.waypoints) {\r\n      fixDockings(element);\r\n    }\r\n  });\r\n}\r\n\r\nImportDockingFix.$inject = [ 'eventBus' ];\r\n\r\nmodule.exports = ImportDockingFix;\r\n\r\n\r\n/////// helpers //////////////////////////////////\r\n\r\nfunction getDistance(p1, p2) {\r\n  return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));\r\n}","'use strict';\r\n\r\nvar assign = require(410),\r\n    inherits = require(270);\r\n\r\nvar LabelUtil = require(92),\r\n    LabelLayoutUtil = require(54),\r\n    ModelUtil = require(93),\r\n    is = ModelUtil.is,\r\n    getBusinessObject = ModelUtil.getBusinessObject;\r\n\r\nvar hasExternalLabel = LabelUtil.hasExternalLabel,\r\n    getExternalLabelMid = LabelUtil.getExternalLabelMid,\r\n    getLabelAdjustment = LabelLayoutUtil.getLabelAdjustment;\r\n\r\nvar CommandInterceptor = require(100);\r\n\r\n\r\n/**\r\n * A component that makes sure that external labels are added\r\n * together with respective elements and properly updated (DI wise)\r\n * during move.\r\n *\r\n * @param {EventBus} eventBus\r\n * @param {Modeling} modeling\r\n * @param {VdmlFactory} vdmlFactory\r\n */\r\nfunction LabelSupport(eventBus, modeling, vdmlFactory) {\r\n\r\n  CommandInterceptor.call(this, eventBus);\r\n\r\n\r\n  ///// create external labels on shape creation\r\n\r\n  this.postExecute([ 'shape.create', 'connection.create' ], function(e) {\r\n    var context = e.context;\r\n\r\n    var element = context.shape || context.connection,\r\n        businessObject = element.businessObject;\r\n\r\n    var position;\r\n\r\n    if (hasExternalLabel(businessObject)) {\r\n      position = getExternalLabelMid(element);\r\n\r\n      modeling.createLabel(element, position, {\r\n        id: businessObject.id + '_label',\r\n        hidden: !businessObject.name,\r\n        businessObject: businessObject\r\n      });\r\n    }\r\n  });\r\n\r\n\r\n  ///// update di information on label creation\r\n\r\n  this.executed([ 'label.create' ], function(event) {\r\n\r\n    var element = event.context.shape,\r\n        businessObject,\r\n        di;\r\n\r\n    // we want to trigger on real labels only\r\n    if (!element.labelTarget) {\r\n      return;\r\n    }\r\n\r\n    // we want to trigger on VDML elements only\r\n    if (!is(element.labelTarget || element, 'vdml:BaseElement')) {\r\n      return;\r\n    }\r\n\r\n    businessObject = element.businessObject,\r\n    di = businessObject.di;\r\n\r\n\r\n    if (!di.label) {\r\n      di.label = vdmlFactory.create('vdmldi:VDMLLabel', {\r\n        bounds: vdmlFactory.create('dc:Bounds')\r\n      });\r\n    }\r\n\r\n    assign(di.label.bounds, {\r\n      x: element.x,\r\n      y: element.y,\r\n      width: element.width,\r\n      height: element.height\r\n    });\r\n  });\r\n\r\n\r\n  ///// update label position on connection change\r\n\r\n  function getHiddenLabelAdjustment(event) {\r\n\r\n    var context = event.context,\r\n        connection = context.connection,\r\n        label = connection.label;\r\n\r\n    var labelPosition = getExternalLabelMid(connection);\r\n\r\n    return {\r\n      x: labelPosition.x - label.x - label.width / 2,\r\n      y: labelPosition.y - label.y - label.height / 2\r\n    };\r\n  }\r\n\r\n  function getVisibleLabelAdjustment(event) {\r\n\r\n    var command = event.command,\r\n        context = event.context,\r\n        connection = context.connection,\r\n        label = connection.label,\r\n        hints = assign({}, context.hints),\r\n        newWaypoints = context.newWaypoints || connection.waypoints,\r\n        oldWaypoints = context.oldWaypoints;\r\n\r\n\r\n    if (typeof hints.startChanged === 'undefined') {\r\n      hints.startChanged = (command === 'connection.reconnectStart');\r\n    }\r\n\r\n    if (typeof hints.endChanged === 'undefined') {\r\n      hints.endChanged = (command === 'connection.reconnectEnd');\r\n    }\r\n\r\n    return getLabelAdjustment(label, newWaypoints, oldWaypoints, hints);\r\n  }\r\n\r\n  this.postExecute([\r\n    'connection.layout',\r\n    'connection.reconnectEnd',\r\n    'connection.reconnectStart',\r\n    'connection.updateWaypoints'\r\n  ], function(event) {\r\n\r\n    var label = event.context.connection.label,\r\n        labelAdjustment;\r\n\r\n    if (!label) {\r\n      return;\r\n    }\r\n\r\n    if (label.hidden) {\r\n      labelAdjustment = getHiddenLabelAdjustment(event);\r\n    } else {\r\n      labelAdjustment = getVisibleLabelAdjustment(event);\r\n    }\r\n\r\n    modeling.moveShape(label, labelAdjustment);\r\n  });\r\n\r\n\r\n  ////// keep label position on shape replace\r\n\r\n  this.postExecute([ 'shape.replace' ], function(event) {\r\n    var context = event.context,\r\n        newShape = context.newShape,\r\n        oldShape = context.oldShape;\r\n\r\n    var businessObject = getBusinessObject(newShape);\r\n\r\n    if (businessObject && hasExternalLabel(businessObject)) {\r\n      newShape.label.x = oldShape.label.x;\r\n      newShape.label.y = oldShape.label.y;\r\n    }\r\n  });\r\n\r\n}\r\n\r\ninherits(LabelSupport, CommandInterceptor);\r\n\r\nLabelSupport.$inject = [ 'eventBus', 'modeling', 'vdmlFactory' ];\r\n\r\nmodule.exports = LabelSupport;\r\n","'use strict';\r\n\r\nvar is = require(93).is;\r\n\r\nvar COLLAB_ERR_MSG = 'flow elements must be children of pools/participants',\r\n    PROCESS_ERR_MSG = 'participants cannot be pasted onto a non-empty process diagram';\r\n\r\nfunction ModelingFeedback(eventBus, tooltips, translate) {\r\n\r\n  function showError(position, message, timeout) {\r\n    tooltips.add({\r\n      position: {\r\n        x: position.x + 5,\r\n        y: position.y + 5\r\n      },\r\n      type: 'error',\r\n      timeout: timeout || 2000,\r\n      html: '<div>' + message + '</div>'\r\n    });\r\n  }\r\n\r\n  eventBus.on([ 'shape.move.rejected', 'create.rejected' ], function(event) {\r\n    var context = event.context,\r\n        shape = context.shape,\r\n        target = context.target;\r\n\r\n    if (is(target, 'vdml:Collaboration') && is(shape, 'vdml:FlowNode')) {\r\n      showError(event, translate(COLLAB_ERR_MSG));\r\n    }\r\n  });\r\n\r\n  eventBus.on([ 'elements.paste.rejected' ], function(event) {\r\n    var context = event.context,\r\n        position = context.position,\r\n        target = context.target;\r\n\r\n    if (is(target, 'vdml:Collaboration')) {\r\n      showError(position, translate(COLLAB_ERR_MSG));\r\n    }\r\n\r\n    if (is(target, 'vdml:Process')) {\r\n      showError(position, translate(PROCESS_ERR_MSG), 3000);\r\n    }\r\n  });\r\n}\r\n\r\n\r\nModelingFeedback.$inject = [ 'eventBus', 'tooltips', 'translate' ];\r\n\r\nmodule.exports = ModelingFeedback;\r\n","'use strict';\r\n\r\nvar inherits = require(270);\r\n\r\nvar CommandInterceptor = require(100);\r\n\r\nvar lineIntersect = require(56);\r\n\r\n\r\nfunction RemoveElementBehavior(eventBus, vdmlRules, modeling) {\r\n\r\n  CommandInterceptor.call(this, eventBus);\r\n\r\n  /**\r\n   * Combine sequence flows when deleting an element\r\n   * if there is one incoming and one outgoing\r\n   * sequence flow\r\n   */\r\n  this.preExecute('shape.delete', function(e) {\r\n\r\n    var shape = e.context.shape;\r\n\r\n    if (shape.incoming.length == 1 && shape.outgoing.length == 1) {\r\n\r\n      var inConnection = shape.incoming[0],\r\n          outConnection = shape.outgoing[0];\r\n\r\n\r\n      if (vdmlRules.canConnect(inConnection.source, outConnection.target, inConnection)) {\r\n\r\n        // compute new, combined waypoints\r\n        var newWaypoints = getNewWaypoints(inConnection.waypoints, outConnection.waypoints);\r\n\r\n        modeling.reconnectEnd(inConnection, outConnection.target, newWaypoints);\r\n      }\r\n    }\r\n  });\r\n\r\n}\r\n\r\ninherits(RemoveElementBehavior, CommandInterceptor);\r\n\r\nRemoveElementBehavior.$inject = [ 'eventBus', 'vdmlRules', 'modeling' ];\r\n\r\nmodule.exports = RemoveElementBehavior;\r\n\r\n\r\n///////// helpers //////////////////////////////\r\n\r\nfunction getDocking(point) {\r\n  return point.original || point;\r\n}\r\n\r\n\r\nfunction getNewWaypoints(inWaypoints, outWaypoints) {\r\n\r\n  var intersection = lineIntersect(\r\n    getDocking(inWaypoints[inWaypoints.length - 2]),\r\n    getDocking(inWaypoints[inWaypoints.length - 1]),\r\n    getDocking(outWaypoints[1]),\r\n    getDocking(outWaypoints[0]));\r\n\r\n  if (intersection) {\r\n    return [].concat(\r\n      inWaypoints.slice(0, inWaypoints.length - 1),\r\n      [ intersection ],\r\n      outWaypoints.slice(1));\r\n  } else {\r\n    return [\r\n      getDocking(inWaypoints[0]),\r\n      getDocking(outWaypoints[outWaypoints.length - 1])\r\n    ];\r\n  }\r\n}","'use strict';\r\n\r\nvar inherits = require(270);\r\n\r\nvar CommandInterceptor = require(100);\r\n\r\nvar is = require(93).is;\r\n\r\n\r\n/**\r\n * VDML specific remove behavior\r\n */\r\nfunction RemoveParticipantBehavior(eventBus, modeling) {\r\n\r\n  CommandInterceptor.call(this, eventBus);\r\n\r\n\r\n  /**\r\n   * morph collaboration diagram into process diagram\r\n   * after the last participant has been removed\r\n   */\r\n\r\n  this.preExecute('shape.delete', function(context) {\r\n\r\n    var shape = context.shape,\r\n        parent = shape.parent;\r\n\r\n    // activate the behavior if the shape to be removed\r\n    // is a participant\r\n    if (is(shape, 'vdml:Participant')) {\r\n      context.collaborationRoot = parent;\r\n    }\r\n  }, true);\r\n\r\n  this.postExecute('shape.delete', function(context) {\r\n\r\n    var collaborationRoot = context.collaborationRoot;\r\n\r\n    if (collaborationRoot && !collaborationRoot.businessObject.participants.length) {\r\n      // replace empty collaboration with process diagram\r\n      modeling.makeProcess();\r\n    }\r\n  }, true);\r\n\r\n}\r\n\r\nRemoveParticipantBehavior.$inject = [ 'eventBus', 'modeling' ];\r\n\r\ninherits(RemoveParticipantBehavior, CommandInterceptor);\r\n\r\nmodule.exports = RemoveParticipantBehavior;","'use strict';\r\n\r\nvar forEach = require(283),\r\n    find = require(282),\r\n    inherits = require(270);\r\n\r\nvar CommandInterceptor = require(100);\r\n\r\nvar is = require(93).is;\r\n\r\nfunction ReplaceConnectionBehavior(eventBus, modeling, vdmlRules) {\r\n\r\n  CommandInterceptor.call(this, eventBus);\r\n\r\n  function fixConnection(connection) {\r\n\r\n    var source = connection.source,\r\n        target = connection.target,\r\n        parent = connection.parent;\r\n\r\n    // do not do anything if connection\r\n    // is already deleted (may happen due to other\r\n    // behaviors plugged-in before)\r\n    if (!parent) {\r\n      return;\r\n    }\r\n\r\n    var replacementType,\r\n        remove;\r\n\r\n    /**\r\n     * Check if incoming or outgoing connections\r\n     * can stay or could be substituted with an\r\n     * appropriate replacement.\r\n     *\r\n     * This holds true for SequenceFlow <> MessageFlow.\r\n     */\r\n\r\n    if (is(connection, 'vdml:SequenceFlow')) {\r\n      if (!vdmlRules.canConnectSequenceFlow(source, target)) {\r\n        remove = true;\r\n      }\r\n\r\n      if (vdmlRules.canConnectMessageFlow(source, target)) {\r\n        replacementType = 'vdml:MessageFlow';\r\n      }\r\n    }\r\n\r\n    // transform message flows into sequence flows, if possible\r\n\r\n    if (is(connection, 'vdml:MessageFlow')) {\r\n\r\n      if (!vdmlRules.canConnectMessageFlow(source, target)) {\r\n        remove = true;\r\n      }\r\n\r\n      if (vdmlRules.canConnectSequenceFlow(source, target)) {\r\n        replacementType = 'vdml:SequenceFlow';\r\n      }\r\n    }\r\n\r\n    if (is(connection, 'vdml:Association') && !vdmlRules.canConnectAssociation(source, target)) {\r\n      remove = true;\r\n    }\r\n\r\n\r\n    // remove invalid connection,\r\n    // unless it has been removed already\r\n    if (remove) {\r\n      modeling.removeConnection(connection);\r\n    }\r\n\r\n    // replace SequenceFlow <> MessageFlow\r\n\r\n    if (replacementType) {\r\n      modeling.connect(source, target, {\r\n        type: replacementType,\r\n        waypoints: connection.waypoints.slice()\r\n      });\r\n    }\r\n  }\r\n\r\n  this.postExecuted('elements.move', function(context) {\r\n\r\n    var closure = context.closure,\r\n        allConnections = closure.allConnections;\r\n\r\n    forEach(allConnections, fixConnection);\r\n  }, true);\r\n\r\n  this.postExecuted([\r\n    'connection.reconnectStart',\r\n    'connection.reconnectEnd'\r\n  ], function(event) {\r\n\r\n    var connection = event.context.connection;\r\n\r\n    fixConnection(connection);\r\n  });\r\n\r\n  this.postExecuted('element.updateProperties', function(event) {\r\n    var context = event.context,\r\n        properties = context.properties,\r\n        element = context.element,\r\n        businessObject = element.businessObject,\r\n        connection;\r\n\r\n    // remove condition expression when morphing to default flow\r\n    if (properties.default) {\r\n      connection = find(element.outgoing, { id: element.businessObject.default.id });\r\n\r\n      if (connection) {\r\n        modeling.updateProperties(connection, { conditionExpression: undefined });\r\n      }\r\n    }\r\n\r\n    // remove default property from source when morphing to conditional flow\r\n    if (properties.conditionExpression && businessObject.sourceRef.default === businessObject) {\r\n      modeling.updateProperties(element.source, { default: undefined });\r\n    }\r\n  });\r\n}\r\n\r\ninherits(ReplaceConnectionBehavior, CommandInterceptor);\r\n\r\nReplaceConnectionBehavior.$inject = [ 'eventBus', 'modeling', 'vdmlRules' ];\r\n\r\nmodule.exports = ReplaceConnectionBehavior;\r\n","'use strict';\r\n\r\nvar inherits = require(270);\r\n\r\nvar CommandInterceptor = require(100);\r\n\r\nvar forEach = require(283);\r\n\r\nvar isEventSubProcess = require(91).isEventSubProcess;\r\nvar is = require(93).is;\r\n\r\n/**\r\n * Defines the behaviour of what happens to the elements inside a container\r\n * that morphs into another VDML element\r\n */\r\nfunction ReplaceElementBehaviour(eventBus, vdmlReplace, vdmlRules, elementRegistry, selection, modeling) {\r\n  CommandInterceptor.call(this, eventBus);\r\n\r\n  this._vdmlReplace = vdmlReplace;\r\n  this._elementRegistry = elementRegistry;\r\n  this._selection = selection;\r\n  this._modeling = modeling;\r\n\r\n  this.postExecuted([ 'elements.move' ], 500, function(event) {\r\n\r\n    var context = event.context,\r\n        target = context.newParent,\r\n        newHost = context.newHost,\r\n        elements = [];\r\n\r\n    forEach(context.closure.topLevel, function(topLevelElements) {\r\n      if (isEventSubProcess(topLevelElements)) {\r\n        elements = elements.concat(topLevelElements.children);\r\n      } else {\r\n        elements = elements.concat(topLevelElements);\r\n      }\r\n    });\r\n\r\n    // Change target to host when the moving element is a `vdml:BoundaryEvent`\r\n    if (elements.length === 1 && newHost) {\r\n      target = newHost;\r\n    }\r\n\r\n    var canReplace = vdmlRules.canReplace(elements, target);\r\n\r\n    if (canReplace) {\r\n      this.replaceElements(elements, canReplace.replacements, newHost);\r\n    }\r\n  }, this);\r\n\r\n  // update attachments if the host is replaced\r\n  this.postExecute([ 'shape.replace' ], 1500, function(e) {\r\n\r\n    var context = e.context,\r\n        oldShape = context.oldShape,\r\n        newShape = context.newShape,\r\n        attachers = oldShape.attachers,\r\n        canReplace;\r\n\r\n    if (attachers && attachers.length) {\r\n      canReplace = vdmlRules.canReplace(attachers, newShape);\r\n\r\n      this.replaceElements(attachers, canReplace.replacements);\r\n    }\r\n\r\n  }, this);\r\n\r\n  this.postExecuted( [ 'shape.replace' ], 1500, function(e) {\r\n    var context = e.context,\r\n        oldShape = context.oldShape,\r\n        newShape = context.newShape;\r\n\r\n    modeling.unclaimId(oldShape.businessObject.id, oldShape.businessObject);\r\n    modeling.updateProperties(newShape, { id: oldShape.id });\r\n  });\r\n}\r\n\r\ninherits(ReplaceElementBehaviour, CommandInterceptor);\r\n\r\n\r\nReplaceElementBehaviour.prototype.replaceElements = function(elements, newElements, newHost) {\r\n  var elementRegistry = this._elementRegistry,\r\n      vdmlReplace = this._vdmlReplace,\r\n      selection = this._selection,\r\n      modeling = this._modeling;\r\n\r\n  forEach(newElements, function(replacement) {\r\n\r\n    var newElement = {\r\n      type: replacement.newElementType\r\n    };\r\n\r\n    var oldElement = elementRegistry.get(replacement.oldElementId);\r\n\r\n    if (newHost && is(oldElement, 'vdml:BoundaryEvent')) {\r\n      modeling.updateAttachment(oldElement, null);\r\n    }\r\n\r\n    var idx = elements.indexOf(oldElement);\r\n\r\n    elements[idx] = vdmlReplace.replaceElement(oldElement, newElement, { select: false });\r\n\r\n    if (newHost && is(elements[idx], 'vdml:BoundaryEvent')) {\r\n      modeling.updateAttachment(elements[idx], newHost);\r\n    }\r\n  });\r\n\r\n  if (newElements) {\r\n    selection.select(elements);\r\n  }\r\n};\r\n\r\nReplaceElementBehaviour.$inject = [ 'eventBus', 'vdmlReplace', 'vdmlRules', 'elementRegistry',\r\n 'selection', 'modeling' ];\r\n\r\nmodule.exports = ReplaceElementBehaviour;\r\n","'use strict';\r\n\r\nvar is = require(93).is;\r\n\r\nvar roundBounds = require(233).roundBounds;\r\n\r\nvar hasPrimaryModifier = require(254).hasPrimaryModifier;\r\n\r\nvar SLIGHTLY_HIGHER_PRIORITY = 1001;\r\n\r\n\r\n/**\r\n * Invoke {@link Modeling#resizeLane} instead of\r\n * {@link Modeling#resizeShape} when resizing a Lane\r\n * or Participant shape.\r\n */\r\nfunction ResizeLaneBehavior(eventBus, modeling) {\r\n\r\n  eventBus.on('resize.start', SLIGHTLY_HIGHER_PRIORITY + 500, function(event) {\r\n    var context = event.context,\r\n        shape = context.shape;\r\n\r\n    if (is(shape, 'vdml:Lane') || is(shape, 'vdml:Participant')) {\r\n\r\n      // should we resize the opposite lane(s) in\r\n      // order to compensate for the resize operation?\r\n      context.balanced = !hasPrimaryModifier(event);\r\n    }\r\n  });\r\n\r\n  /**\r\n   * Intercept resize end and call resize lane function instead.\r\n   */\r\n  eventBus.on('resize.end', SLIGHTLY_HIGHER_PRIORITY, function(event) {\r\n    var context = event.context,\r\n        shape = context.shape,\r\n        canExecute = context.canExecute,\r\n        newBounds = context.newBounds;\r\n\r\n    if (is(shape, 'vdml:Lane') || is(shape, 'vdml:Participant')) {\r\n\r\n      if (canExecute) {\r\n        // ensure we have actual pixel values for new bounds\r\n        // (important when zoom level was > 1 during move)\r\n        newBounds = roundBounds(newBounds);\r\n\r\n        // perform the actual resize\r\n        modeling.resizeLane(shape, newBounds, context.balanced);\r\n      }\r\n\r\n      // stop propagation\r\n      return false;\r\n    }\r\n  });\r\n}\r\n\r\nResizeLaneBehavior.$inject = [ 'eventBus', 'modeling' ];\r\n\r\nmodule.exports = ResizeLaneBehavior;\r\n","'use strict';\r\n\r\nvar inherits = require(270);\r\n\r\nvar CommandInterceptor = require(100),\r\n    getBusinessObject = require(93).getBusinessObject,\r\n    is = require(93).is,\r\n    computeChildrenBBox = require(204).computeChildrenBBox;\r\n\r\n\r\nvar LOW_PRIORITY = 500;\r\n\r\n\r\nfunction ToggleElementCollapseBehaviour(eventBus, elementFactory, modeling, resize) {\r\n  CommandInterceptor.call(this, eventBus);\r\n\r\n\r\n  function hideEmptyLables(children) {\r\n    if (children.length) {\r\n      children.forEach(function(child) {\r\n        if (child.type === 'label' && !child.businessObject.name) {\r\n          child.hidden = true;\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  function expandedBounds(shape, defaultSize) {\r\n    var children = shape.children,\r\n        newBounds = defaultSize,\r\n        visibleElements,\r\n        visibleBBox;\r\n\r\n    visibleElements = filterVisible(children).concat([ shape ]);\r\n\r\n    visibleBBox = computeChildrenBBox(visibleElements);\r\n\r\n    if (visibleBBox) {\r\n      // center to visibleBBox with max(defaultSize, childrenBounds)\r\n      newBounds.width = Math.max(visibleBBox.width, newBounds.width);\r\n      newBounds.height = Math.max(visibleBBox.height, newBounds.height);\r\n\r\n      newBounds.x = visibleBBox.x + (visibleBBox.width - newBounds.width) / 2;\r\n      newBounds.y = visibleBBox.y + (visibleBBox.height - newBounds.height) / 2;\r\n    } else {\r\n      // center to collapsed shape with defaultSize\r\n      newBounds.x = shape.x + (shape.width - newBounds.width) / 2;\r\n      newBounds.y = shape.y + (shape.height - newBounds.height) / 2;\r\n    }\r\n\r\n    return newBounds;\r\n  }\r\n\r\n  function collapsedBounds(shape, defaultSize) {\r\n\r\n    return {\r\n      x: shape.x + (shape.width - defaultSize.width) / 2,\r\n      y: shape.y + (shape.height - defaultSize.height) / 2,\r\n      width: defaultSize.width,\r\n      height: defaultSize.height\r\n    };\r\n  }\r\n\r\n  this.executed([ 'shape.toggleCollapse' ], LOW_PRIORITY, function(e) {\r\n\r\n    var context = e.context,\r\n        shape = context.shape;\r\n\r\n    if (!is(shape, 'vdml:SubProcess')) {\r\n      return;\r\n    }\r\n\r\n    if (!shape.collapsed) {\r\n      // all children got made visible through djs, hide empty labels\r\n      hideEmptyLables(shape.children);\r\n\r\n      // remove collapsed marker\r\n      getBusinessObject(shape).di.isExpanded = true;\r\n    } else {\r\n      // place collapsed marker\r\n      getBusinessObject(shape).di.isExpanded = false;\r\n    }\r\n  });\r\n\r\n  this.reverted([ 'shape.toggleCollapse' ], LOW_PRIORITY, function(e) {\r\n\r\n    var context = e.context;\r\n    var shape = context.shape;\r\n\r\n\r\n    // revert removing/placing collapsed marker\r\n    if (!shape.collapsed) {\r\n      getBusinessObject(shape).di.isExpanded = true;\r\n\r\n    } else {\r\n      getBusinessObject(shape).di.isExpanded = false;\r\n    }\r\n  });\r\n\r\n  this.postExecuted([ 'shape.toggleCollapse' ], LOW_PRIORITY, function(e) {\r\n    var shape = e.context.shape,\r\n        defaultSize = elementFactory._getDefaultSize(shape),\r\n        newBounds;\r\n\r\n    if (shape.collapsed) {\r\n\r\n      // resize to default size of collapsed shapes\r\n      newBounds = collapsedBounds(shape, defaultSize);\r\n    } else {\r\n\r\n      // resize to bounds of max(visible children, defaultSize)\r\n      newBounds = expandedBounds(shape, defaultSize);\r\n    }\r\n\r\n    modeling.resizeShape(shape, newBounds);\r\n  });\r\n\r\n}\r\n\r\n\r\ninherits(ToggleElementCollapseBehaviour, CommandInterceptor);\r\n\r\nToggleElementCollapseBehaviour.$inject = [\r\n  'eventBus',\r\n  'elementFactory',\r\n  'modeling'\r\n];\r\n\r\nmodule.exports = ToggleElementCollapseBehaviour;\r\n\r\n\r\n\r\n/////// helpers ///////////////////////////\r\n\r\nfunction filterVisible(elements) {\r\n  return elements.filter(function(e) {\r\n    return !e.hidden;\r\n  });\r\n}","'use strict';\r\n\r\nvar forEach = require(283);\r\n\r\nvar inherits = require(270);\r\n\r\nvar CommandInterceptor = require(100);\r\n\r\nfunction UnclaimIdBehavior(eventBus, modeling) {\r\n\r\n  CommandInterceptor.call(this, eventBus);\r\n\r\n  this.preExecute('elements.delete', function(event) {\r\n    var context = event.context,\r\n        elements = context.elements;\r\n\r\n    forEach(elements, function(element) {\r\n      modeling.unclaimId(element.businessObject.id, element.businessObject);\r\n    });\r\n\r\n  });\r\n}\r\n\r\ninherits(UnclaimIdBehavior, CommandInterceptor);\r\n\r\nUnclaimIdBehavior.$inject = [ 'eventBus', 'modeling' ];\r\n\r\nmodule.exports = UnclaimIdBehavior;","'use strict';\r\n\r\nvar inherits = require(270);\r\n\r\nvar CommandInterceptor = require(100);\r\n\r\nvar is = require(93).is,\r\n    getBusinessObject = require(93).getBusinessObject;\r\n\r\n/**\r\n * A behavior that unsets the Default property of\r\n * sequence flow source on element delete, if the\r\n * removed element is the Gateway or Task's default flow.\r\n *\r\n * @param {EventBus} eventBus\r\n * @param {Modeling} modeling\r\n */\r\nfunction DeleteSequenceFlowBehavior(eventBus, modeling) {\r\n\r\n  CommandInterceptor.call(this, eventBus);\r\n\r\n\r\n  this.preExecute('connection.delete', function(event) {\r\n    var context = event.context,\r\n        connection = context.connection,\r\n        source = connection.source;\r\n\r\n    if (isDefaultFlow(connection, source)) {\r\n      modeling.updateProperties(source, {\r\n        'default': null\r\n      });\r\n    }\r\n  });\r\n}\r\n\r\ninherits(DeleteSequenceFlowBehavior, CommandInterceptor);\r\n\r\nDeleteSequenceFlowBehavior.$inject = [ 'eventBus', 'modeling' ];\r\n\r\nmodule.exports = DeleteSequenceFlowBehavior;\r\n\r\n\r\n/////// helpers ///////////////////////////\r\n\r\nfunction isDefaultFlow(connection, source) {\r\n\r\n  if (!is(connection, 'vdml:SequenceFlow')) {\r\n    return false;\r\n  }\r\n\r\n  var sourceBo = getBusinessObject(source),\r\n      sequenceFlow = getBusinessObject(connection);\r\n\r\n  return sourceBo.get('default') === sequenceFlow;\r\n}","'use strict';\r\n\r\n\r\nvar inherits = require(270);\r\n\r\nvar CommandInterceptor = require(100);\r\n\r\nvar is = require(93).is;\r\n\r\nvar LOW_PRIORITY = 500,\r\n    HIGH_PRIORITY = 5000;\r\n\r\n\r\n/**\r\n * VDML specific delete lane behavior\r\n */\r\nfunction UpdateFlowNodeRefsBehavior(eventBus, modeling, translate) {\r\n\r\n  CommandInterceptor.call(this, eventBus);\r\n\r\n  /**\r\n   * Ok, this is it:\r\n   *\r\n   * We have to update the Lane#flowNodeRefs _and_\r\n   * FlowNode#lanes with every FlowNode move/resize and\r\n   * Lane move/resize.\r\n   *\r\n   * We want to group that stuff to recompute containments\r\n   * as efficient as possible.\r\n   *\r\n   * Yea!\r\n   */\r\n\r\n  // the update context\r\n  var context;\r\n\r\n\r\n  function initContext() {\r\n    context = context || new UpdateContext();\r\n    context.enter();\r\n\r\n    return context;\r\n  }\r\n\r\n  function getContext() {\r\n    if (!context) {\r\n      throw new Error(translate('out of bounds release'));\r\n    }\r\n\r\n    return context;\r\n  }\r\n\r\n  function releaseContext() {\r\n\r\n    if (!context) {\r\n      throw new Error(translate('out of bounds release'));\r\n    }\r\n\r\n    var triggerUpdate = context.leave();\r\n\r\n    if (triggerUpdate) {\r\n      modeling.updateLaneRefs(context.flowNodes, context.lanes);\r\n\r\n      context = null;\r\n    }\r\n\r\n    return triggerUpdate;\r\n  }\r\n\r\n\r\n  var laneRefUpdateEvents = [\r\n    'spaceTool',\r\n    'lane.add',\r\n    'lane.resize',\r\n    'lane.split',\r\n    'elements.move',\r\n    'elements.delete',\r\n    'shape.create',\r\n    'shape.delete',\r\n    'shape.move',\r\n    'shape.resize'\r\n  ];\r\n\r\n\r\n  // listen to a lot of stuff to group lane updates\r\n\r\n  this.preExecute(laneRefUpdateEvents, HIGH_PRIORITY, function(event) {\r\n    initContext();\r\n  });\r\n\r\n  this.postExecuted(laneRefUpdateEvents, LOW_PRIORITY, function(event) {\r\n    releaseContext();\r\n  });\r\n\r\n\r\n  // Mark flow nodes + lanes that need an update\r\n\r\n  this.preExecute([\r\n    'shape.create',\r\n    'shape.move',\r\n    'shape.delete',\r\n    'shape.resize'\r\n  ], function(event) {\r\n\r\n    var context = event.context,\r\n        shape = context.shape;\r\n\r\n    var updateContext = getContext();\r\n\r\n    // no need to update labels\r\n    if (shape.labelTarget) {\r\n      return;\r\n    }\r\n\r\n    if (is(shape, 'vdml:Lane')) {\r\n      updateContext.addLane(shape);\r\n    }\r\n\r\n    if (is(shape, 'vdml:FlowNode')) {\r\n      updateContext.addFlowNode(shape);\r\n    }\r\n  });\r\n}\r\n\r\nUpdateFlowNodeRefsBehavior.$inject = [ 'eventBus', 'modeling' , 'translate'];\r\n\r\ninherits(UpdateFlowNodeRefsBehavior, CommandInterceptor);\r\n\r\nmodule.exports = UpdateFlowNodeRefsBehavior;\r\n\r\n\r\n\r\nfunction UpdateContext() {\r\n\r\n  this.flowNodes = [];\r\n  this.lanes = [];\r\n\r\n  this.counter = 0;\r\n\r\n  this.addLane = function(lane) {\r\n    this.lanes.push(lane);\r\n  };\r\n\r\n  this.addFlowNode = function(flowNode) {\r\n    this.flowNodes.push(flowNode);\r\n  };\r\n\r\n  this.enter = function() {\r\n    this.counter++;\r\n  };\r\n\r\n  this.leave = function() {\r\n    this.counter--;\r\n\r\n    return !this.counter;\r\n  };\r\n}","module.exports = {\r\n  __init__: [\r\n    'appendBehavior',\r\n    'copyPasteBehavior',\r\n    'createBoundaryEventBehavior',\r\n    'createDataObjectBehavior',\r\n    'createOnFlowBehavior',\r\n    'createParticipantBehavior',\r\n    'dataInputAssociationBehavior',\r\n    'deleteLaneBehavior',\r\n    'importDockingFix',\r\n    'labelBehavior',\r\n    'modelingFeedback',\r\n    'removeParticipantBehavior',\r\n    'replaceConnectionBehavior',\r\n    'replaceElementBehaviour',\r\n    'resizeLaneBehavior',\r\n    'unsetDefaultFlowBehavior',\r\n    'updateFlowNodeRefsBehavior',\r\n    'removeElementBehavior',\r\n    'unclaimIdBehavior',\r\n    'toggleElementCollapseBehaviour'\r\n  ],\r\n  appendBehavior: [ 'type', require(32) ],\r\n  copyPasteBehavior: [ 'type', require(33) ],\r\n  createBoundaryEventBehavior: [ 'type', require(34) ],\r\n  createDataObjectBehavior: [ 'type', require(35) ],\r\n  createOnFlowBehavior: [ 'type', require(36) ],\r\n  createParticipantBehavior: [ 'type', require(37) ],\r\n  dataInputAssociationBehavior: [ 'type', require(38) ],\r\n  deleteLaneBehavior: [ 'type', require(39) ],\r\n  importDockingFix: [ 'type', require(40) ],\r\n  labelBehavior: [ 'type', require(41) ],\r\n  modelingFeedback: [ 'type', require(42) ],\r\n  removeParticipantBehavior: [ 'type', require(44) ],\r\n  replaceConnectionBehavior: [ 'type', require(45) ],\r\n  replaceElementBehaviour: [ 'type', require(46) ],\r\n  resizeLaneBehavior: [ 'type', require(47) ],\r\n  unsetDefaultFlowBehavior: [ 'type', require(50) ],\r\n  updateFlowNodeRefsBehavior: [ 'type', require(51) ],\r\n  removeElementBehavior: [ 'type', require(43) ],\r\n  unclaimIdBehavior: [ 'type', require(49) ],\r\n  toggleElementCollapseBehaviour : [ 'type', require(48) ]\r\n};\r\n","'use strict';\r\n\r\n/**\r\n * Returns the length of a vector\r\n *\r\n * @param {Vector}\r\n * @return {Float}\r\n */\r\nfunction vectorLength(v) {\r\n  return Math.sqrt( Math.pow(v.x, 2) + Math.pow(v.y, 2) );\r\n}\r\n\r\nmodule.exports.vectorLength = vectorLength;\r\n\r\n/**\r\n * Calculates the angle between a line a the yAxis\r\n *\r\n * @param {Array}\r\n * @return {Float}\r\n */\r\nfunction getAngle(line) {\r\n  // return value is between 0, 180 and -180, -0\r\n  // @janstuemmel: maybe replace return a/b with b/a\r\n  return Math.atan( (line[1].y - line[0].y) / (line[1].x - line[0].x) );\r\n}\r\n\r\nmodule.exports.getAngle = getAngle;\r\n\r\n/**\r\n * Rotates a vector by a given angle\r\n *\r\n * @param {Vector}\r\n * @param {Float} Angle in radians\r\n * @return {Vector}\r\n */\r\nfunction rotateVector(vector, angle) {\r\n  return (!angle) ? vector : {\r\n    x: Math.cos(angle) * vector.x - Math.sin(angle) * vector.y,\r\n    y: Math.sin(angle) * vector.x + Math.cos(angle) * vector.y\r\n  };\r\n}\r\n\r\nmodule.exports.rotateVector = rotateVector;\r\n\r\n/**\r\n * Solves a 2D equation system\r\n * a + r*b = c, where a,b,c are 2D vectors\r\n *\r\n * @param {Vector}\r\n * @param {Vector}\r\n * @param {Vector}\r\n * @return {Float}\r\n */\r\nfunction solveLambaSystem(a, b, c) {\r\n\r\n  // the 2d system\r\n  var system = [\r\n    { n: a[0] - c[0], lambda: b[0] },\r\n    { n: a[1] - c[1], lambda: b[1] }\r\n  ];\r\n\r\n  // solve\r\n  var n = system[0].n * b[0] + system[1].n * b[1],\r\n      l = system[0].lambda * b[0] + system[1].lambda * b[1];\r\n\r\n  return -n/l;\r\n}\r\n\r\n/**\r\n * Position of perpendicular foot\r\n *\r\n * @param {Point}\r\n * @param [ {Point}, {Point} ] line defined throug two points\r\n * @return {Point} the perpendicular foot position\r\n */\r\nfunction perpendicularFoot(point, line) {\r\n\r\n  var a = line[0], b = line[1];\r\n\r\n  // relative position of b from a\r\n  var bd = { x: b.x - a.x, y: b.y - a.y };\r\n\r\n  // solve equation system to the parametrized vectors param real value\r\n  var r = solveLambaSystem( [ a.x, a.y ], [ bd.x, bd.y ], [ point.x, point.y ] );\r\n\r\n  return { x: a.x + r*bd.x, y: a.y + r*bd.y };\r\n\r\n}\r\n\r\nmodule.exports.perpendicularFoot = perpendicularFoot;\r\n\r\n/**\r\n * Calculates the distance between a point and a line\r\n *\r\n * @param {Point}\r\n * @param [ {Point}, {Point} ] line defined throug two points\r\n * @return {Float} distance\r\n */\r\nfunction getDistancePointLine(point, line) {\r\n\r\n  var pfPoint = perpendicularFoot(point, line);\r\n\r\n  // distance vector\r\n  var connectionVector = {\r\n    x: pfPoint.x - point.x,\r\n    y: pfPoint.y - point.y\r\n  };\r\n\r\n  return vectorLength(connectionVector);\r\n}\r\n\r\nmodule.exports.getDistancePointLine = getDistancePointLine;\r\n\r\n/**\r\n * Calculates the distance between two points\r\n *\r\n * @param {Point}\r\n * @param {Point}\r\n * @return {Float} distance\r\n */\r\nfunction getDistancePointPoint(point1, point2) {\r\n\r\n  return vectorLength({\r\n    x: point1.x - point2.x,\r\n    y: point1.y - point2.y\r\n  });\r\n}\r\n\r\nmodule.exports.getDistancePointPoint = getDistancePointPoint;\r\n","'use strict';\r\n\r\nvar GeometricUtil = require(53);\r\n\r\nvar getDistancePointPoint = require(53).getDistancePointPoint;\r\n\r\nvar getAttachment = require(55).getAttachment;\r\n\r\n\r\nfunction findNewLabelLineStartIndex(oldWaypoints, newWaypoints, attachment, hints) {\r\n\r\n  var index = attachment.segmentIndex;\r\n\r\n  var offset = newWaypoints.length - oldWaypoints.length;\r\n\r\n  // segmentMove happend\r\n  if (hints.segmentMove) {\r\n\r\n    var oldSegmentStartIndex = hints.segmentMove.segmentStartIndex,\r\n        newSegmentStartIndex = hints.segmentMove.newSegmentStartIndex;\r\n\r\n    // if label was on moved segment return new segment index\r\n    if (index === oldSegmentStartIndex) {\r\n      return newSegmentStartIndex;\r\n    }\r\n\r\n    // label is after new segment index\r\n    if (index >= newSegmentStartIndex) {\r\n      return (index+offset < newSegmentStartIndex) ? newSegmentStartIndex : index+offset;\r\n    }\r\n\r\n    // if label is before new segment index\r\n    return index;\r\n  }\r\n\r\n  // bendpointMove happend\r\n  if (hints.bendpointMove) {\r\n\r\n    var insert = hints.bendpointMove.insert,\r\n        bendpointIndex = hints.bendpointMove.bendpointIndex,\r\n        newIndex;\r\n\r\n    // waypoints length didnt change\r\n    if (offset === 0) {\r\n      return index;\r\n    }\r\n\r\n    // label behind new/removed bendpoint\r\n    if (index >= bendpointIndex) {\r\n      newIndex = insert ? index + 1 : index - 1;\r\n    }\r\n\r\n    // label before new/removed bendpoint\r\n    if (index < bendpointIndex) {\r\n\r\n      newIndex = index;\r\n\r\n      // decide label should take right or left segment\r\n      if (insert && attachment.type !== 'bendpoint' && bendpointIndex-1 === index) {\r\n\r\n        var rel = relativePositionMidWaypoint(newWaypoints, bendpointIndex);\r\n\r\n        if (rel < attachment.relativeLocation) {\r\n          newIndex++;\r\n        }\r\n      }\r\n    }\r\n\r\n    return newIndex;\r\n  }\r\n\r\n  // start/end changed\r\n  if (offset === 0) {\r\n    return index;\r\n  }\r\n\r\n  if (hints.connectionStart) {\r\n    return (index === 0) ? 0 : null;\r\n  }\r\n\r\n  if (hints.connectionEnd) {\r\n    return (index === oldWaypoints.length - 2) ? newWaypoints.length - 2 : null;\r\n  }\r\n\r\n  // if nothing fits, return null\r\n  return null;\r\n}\r\n\r\nmodule.exports.findNewLabelLineStartIndex = findNewLabelLineStartIndex;\r\n\r\n\r\n/**\r\n * Calculate the required adjustment (move delta) for the given label\r\n * after the connection waypoints got updated.\r\n *\r\n * @param {djs.model.Label} label\r\n * @param {Array<Point>} newWaypoints\r\n * @param {Array<Point>} oldWaypoints\r\n * @param {Object} hints\r\n *\r\n * @return {Point} delta\r\n */\r\nfunction getLabelAdjustment(label, newWaypoints, oldWaypoints, hints) {\r\n\r\n  var x = 0,\r\n      y = 0;\r\n\r\n  var labelPosition = getLabelMid(label);\r\n\r\n  // get closest attachment\r\n  var attachment = getAttachment(labelPosition, oldWaypoints),\r\n      oldLabelLineIndex = attachment.segmentIndex,\r\n      newLabelLineIndex = findNewLabelLineStartIndex(oldWaypoints, newWaypoints, attachment, hints);\r\n\r\n  if ( newLabelLineIndex === null ) {\r\n    return { x: x, y: y };\r\n  }\r\n\r\n  // should never happen\r\n  // TODO(@janstuemmel): throw an error here when connectionSegmentMove is refactored\r\n  if (newLabelLineIndex < 0 ||\r\n      newLabelLineIndex > newWaypoints.length - 2) {\r\n    return { x: x, y: y };\r\n  }\r\n\r\n  var oldLabelLine = getLine(oldWaypoints, oldLabelLineIndex),\r\n      newLabelLine = getLine(newWaypoints, newLabelLineIndex),\r\n      oldFoot = attachment.position;\r\n\r\n  var relativeFootPosition = getRelativeFootPosition(oldLabelLine, oldFoot),\r\n      angleDelta = getAngleDelta(oldLabelLine, newLabelLine);\r\n\r\n  // special rule if label on bendpoint\r\n  if (attachment.type === 'bendpoint') {\r\n\r\n    var offset = newWaypoints.length - oldWaypoints.length,\r\n        oldBendpointIndex = attachment.bendpointIndex,\r\n        oldBendpoint = oldWaypoints[oldBendpointIndex];\r\n\r\n    // bendpoint position hasnt changed, return same position\r\n    if (newWaypoints.indexOf(oldBendpoint) !== -1) {\r\n      return { x: x, y: y };\r\n    }\r\n\r\n    // new bendpoint and old bendpoint have same index, then just return the offset\r\n    if (offset === 0) {\r\n      var newBendpoint = newWaypoints[oldBendpointIndex];\r\n\r\n      return {\r\n        x: newBendpoint.x - attachment.position.x,\r\n        y: newBendpoint.y - attachment.position.y\r\n      };\r\n    }\r\n\r\n    // if bendpoints get removed\r\n    if (offset < 0 && oldBendpointIndex !== 0 && oldBendpointIndex < oldWaypoints.length - 1) {\r\n      relativeFootPosition = relativePositionMidWaypoint(oldWaypoints, oldBendpointIndex);\r\n    }\r\n  }\r\n\r\n  var newFoot = {\r\n    x: (newLabelLine[1].x - newLabelLine[0].x) * relativeFootPosition + newLabelLine[0].x,\r\n    y: (newLabelLine[1].y - newLabelLine[0].y) * relativeFootPosition + newLabelLine[0].y\r\n  };\r\n\r\n  // the rotated vector to label\r\n  var newLabelVector = GeometricUtil.rotateVector({\r\n    x: labelPosition.x - oldFoot.x,\r\n    y: labelPosition.y - oldFoot.y\r\n  }, angleDelta);\r\n\r\n  // the new relative position\r\n  x = newFoot.x + newLabelVector.x - labelPosition.x;\r\n  y = newFoot.y + newLabelVector.y - labelPosition.y;\r\n\r\n  return { x: x, y: y };\r\n}\r\n\r\nmodule.exports.getLabelAdjustment = getLabelAdjustment;\r\n\r\n\r\n//// HELPERS ///////\r\n\r\nfunction relativePositionMidWaypoint(waypoints, idx) {\r\n\r\n  var distanceSegment1 = getDistancePointPoint(waypoints[idx-1], waypoints[idx]),\r\n      distanceSegment2 = getDistancePointPoint(waypoints[idx], waypoints[idx+1]);\r\n\r\n  var relativePosition = distanceSegment1 / ( distanceSegment1 + distanceSegment2 );\r\n\r\n  return relativePosition;\r\n\r\n}\r\n\r\nfunction getLabelMid(label) {\r\n  return {\r\n    x: label.x + label.width / 2,\r\n    y: label.y + label.height / 2\r\n  };\r\n}\r\n\r\nfunction getAngleDelta(l1, l2) {\r\n  var a1 = GeometricUtil.getAngle(l1),\r\n      a2 = GeometricUtil.getAngle(l2);\r\n  return a2 - a1;\r\n}\r\n\r\nfunction getLine(waypoints, idx) {\r\n  return [ waypoints[idx], waypoints[idx+1] ];\r\n}\r\n\r\nfunction getRelativeFootPosition(line, foot) {\r\n  var length = getDistancePointPoint(line[0], line[1]),\r\n      lengthToFoot = getDistancePointPoint(line[0], foot);\r\n\r\n  return lengthToFoot / length;\r\n}\r\n","'use strict';\r\n\r\nvar sqrt = Math.sqrt,\r\n    min = Math.min,\r\n    max = Math.max;\r\n\r\n/**\r\n * Calculate the square (power to two) of a number.\r\n *\r\n * @param {Number} n\r\n *\r\n * @return {Number}\r\n */\r\nfunction sq(n) {\r\n  return Math.pow(n, 2);\r\n}\r\n\r\n/**\r\n * Get distance between two points.\r\n *\r\n * @param {Point} p1\r\n * @param {Point} p2\r\n *\r\n * @return {Number}\r\n */\r\nfunction getDistance(p1, p2) {\r\n  return sqrt(sq(p1.x - p2.x) + sq(p1.y - p2.y));\r\n}\r\n\r\n/**\r\n * Return the attachment of the given point on the specified line.\r\n *\r\n * The attachment is either a bendpoint (attached to the given point)\r\n * or segment (attached to a location on a line segment) attachment:\r\n *\r\n * ```javascript\r\n * var pointAttachment = {\r\n *   type: 'bendpoint',\r\n *   bendpointIndex: 3,\r\n *   position: { x: 10, y: 10 } // the attach point on the line\r\n * };\r\n *\r\n * var segmentAttachment = {\r\n *   type: 'segment',\r\n *   segmentIndex: 2,\r\n *   relativeLocation: 0.31, // attach point location between 0 (at start) and 1 (at end)\r\n *   position: { x: 10, y: 10 } // the attach point on the line\r\n * };\r\n * ```\r\n *\r\n * @param {Point} point\r\n * @param {Array<Point>} line\r\n *\r\n * @return {Object} attachment\r\n */\r\nfunction getAttachment(point, line) {\r\n\r\n  var idx = 0,\r\n      segmentStart,\r\n      segmentEnd,\r\n      segmentStartDistance,\r\n      segmentEndDistance,\r\n      attachmentPosition,\r\n      minDistance,\r\n      intersections,\r\n      attachment,\r\n      attachmentDistance,\r\n      closestAttachmentDistance,\r\n      closestAttachment;\r\n\r\n  for (idx = 0; idx < line.length - 1; idx++) {\r\n\r\n    segmentStart = line[idx];\r\n    segmentEnd = line[idx + 1];\r\n\r\n    if (pointsEqual(segmentStart, segmentEnd)) {\r\n      continue;\r\n    }\r\n\r\n    segmentStartDistance = getDistance(point, segmentStart);\r\n    segmentEndDistance = getDistance(point, segmentEnd);\r\n\r\n    minDistance = min(segmentStartDistance, segmentEndDistance);\r\n\r\n    intersections = getCircleSegmentIntersections(segmentStart, segmentEnd, point, minDistance);\r\n\r\n    if (intersections.length < 1) {\r\n      throw new Error('expected between [1, 2] circle -> line intersections');\r\n    }\r\n\r\n    // one intersection -> bendpoint attachment\r\n    if (intersections.length === 1) {\r\n      attachment = {\r\n        type: 'bendpoint',\r\n        position: intersections[0],\r\n        segmentIndex: idx,\r\n        bendpointIndex: pointsEqual(segmentStart, intersections[0]) ? idx : idx + 1\r\n      };\r\n    }\r\n\r\n    // two intersections -> segment attachment\r\n    if (intersections.length === 2) {\r\n\r\n      attachmentPosition = mid(intersections[0], intersections[1]);\r\n\r\n      attachment = {\r\n        type: 'segment',\r\n        position: attachmentPosition,\r\n        segmentIndex: idx,\r\n        relativeLocation: getDistance(segmentStart, attachmentPosition) / getDistance(segmentStart, segmentEnd)\r\n      };\r\n    }\r\n\r\n    attachmentDistance = getDistance(attachment.position, point);\r\n\r\n    if (!closestAttachment || closestAttachmentDistance > attachmentDistance) {\r\n      closestAttachment = attachment;\r\n      closestAttachmentDistance = attachmentDistance;\r\n    }\r\n  }\r\n\r\n  return closestAttachment;\r\n}\r\n\r\nmodule.exports.getAttachment = getAttachment;\r\n\r\n/**\r\n * Gets the intersection between a circle and a line segment.\r\n *\r\n * @param {Point} s1 segment start\r\n * @param {Point} s2 segment end\r\n * @param {Point} cc circle center\r\n * @param {Number} cr circle radius\r\n *\r\n * @return {Array<Point>} intersections\r\n */\r\nfunction getCircleSegmentIntersections(s1, s2, cc, cr) {\r\n\r\n  // silently round values\r\n  s1 = roundPoint(s1);\r\n  s2 = roundPoint(s2);\r\n  cc = roundPoint(cc);\r\n  cr = min(getDistance(s1, cc), getDistance(s2, cc));\r\n\r\n  var baX = s2.x - s1.x;\r\n  var baY = s2.y - s1.y;\r\n  var caX = cc.x - s1.x;\r\n  var caY = cc.y - s1.y;\r\n\r\n  var a = baX * baX + baY * baY;\r\n  var bBy2 = baX * caX + baY * caY;\r\n  var c = caX * caX + caY * caY - cr * cr;\r\n\r\n  var pBy2 = bBy2 / a;\r\n  var q = c / a;\r\n\r\n  var disc = pBy2 * pBy2 - q;\r\n  if (disc < 0) {\r\n    return [];\r\n  }\r\n\r\n  // if disc == 0 ... dealt with later\r\n  var tmpSqrt = sqrt(disc);\r\n  var abScalingFactor1 = -pBy2 + tmpSqrt;\r\n  var abScalingFactor2 = -pBy2 - tmpSqrt;\r\n\r\n  var i1 = {\r\n    x: round(s1.x - baX * abScalingFactor1),\r\n    y: round(s1.y - baY * abScalingFactor1)\r\n  };\r\n\r\n  if (disc === 0) { // abScalingFactor1 == abScalingFactor2\r\n    return [ i1 ];\r\n  }\r\n\r\n  var i2 = {\r\n    x: round(s1.x - baX * abScalingFactor2),\r\n    y: round(s1.y - baY * abScalingFactor2)\r\n  };\r\n\r\n  return [ i1, i2 ].filter(function(p) {\r\n    return isPointInSegment(p, s1, s2);\r\n  });\r\n}\r\n\r\n\r\nfunction isPointInSegment(p, segmentStart, segmentEnd) {\r\n  return (\r\n    fenced(p.x, segmentStart.x, segmentEnd.x) &&\r\n    fenced(p.y, segmentStart.y, segmentEnd.y)\r\n  );\r\n}\r\n\r\nfunction fenced(n, rangeStart, rangeEnd) {\r\n  return min(rangeStart, rangeEnd) <= n && n <= max(rangeStart, rangeEnd);\r\n}\r\n\r\n/**\r\n * Calculate mid of two points.\r\n *\r\n * @param {Point} p1\r\n * @param {Point} p2\r\n *\r\n * @return {Point}\r\n */\r\nfunction mid(p1, p2) {\r\n\r\n  return {\r\n    x: (p1.x + p2.x) / 2,\r\n    y: (p1.y + p2.y) / 2\r\n  };\r\n}\r\n\r\nfunction round(n) {\r\n  return Math.round(n * 1000) / 1000;\r\n}\r\n\r\nfunction roundPoint(p) {\r\n  return {\r\n    x: round(p.x),\r\n    y: round(p.y)\r\n  };\r\n}\r\n\r\nfunction pointsEqual(p1, p2) {\r\n  return p1.x === p2.x && p1.y === p2.y;\r\n}\r\n","'use strict';\r\n\r\n/**\r\n * Returns the intersection between two line segments a and b.\r\n *\r\n * @param {Point} l1s\r\n * @param {Point} l1e\r\n * @param {Point} l2s\r\n * @param {Point} l2e\r\n *\r\n * @return {Point}\r\n */\r\nmodule.exports = function lineIntersect(l1s, l1e, l2s, l2e) {\r\n  // if the lines intersect, the result contains the x and y of the\r\n  // intersection (treating the lines as infinite) and booleans for\r\n  // whether line segment 1 or line segment 2 contain the point\r\n  var denominator, a, b, c, numerator;\r\n\r\n  denominator = ((l2e.y - l2s.y) * (l1e.x - l1s.x)) - ((l2e.x - l2s.x) * (l1e.y - l1s.y));\r\n\r\n  if (denominator == 0) {\r\n    return null;\r\n  }\r\n\r\n  a = l1s.y - l2s.y;\r\n  b = l1s.x - l2s.x;\r\n  numerator = ((l2e.x - l2s.x) * a) - ((l2e.y - l2s.y) * b);\r\n\r\n  c = numerator / denominator;\r\n\r\n  // if we cast these lines infinitely in\r\n  // both directions, they intersect here\r\n  return {\r\n    x: Math.round(l1s.x + (c * (l1e.x - l1s.x))),\r\n    y: Math.round(l1s.y + (c * (l1e.y - l1s.y)))\r\n  };\r\n};","'use strict';\r\n\r\nvar filter = require(281);\r\n\r\nvar Elements = require(247);\r\n\r\nvar getLanesRoot = require(65).getLanesRoot,\r\n    getChildLanes = require(65).getChildLanes,\r\n    LANE_INDENTATION = require(65).LANE_INDENTATION;\r\n\r\n/**\r\n * A handler that allows us to add a new lane\r\n * above or below an existing one.\r\n *\r\n * @param {Modeling} modeling\r\n */\r\nfunction AddLaneHandler(modeling, spaceTool) {\r\n  this._modeling = modeling;\r\n  this._spaceTool = spaceTool;\r\n}\r\n\r\nAddLaneHandler.$inject = [ 'modeling', 'spaceTool' ];\r\n\r\nmodule.exports = AddLaneHandler;\r\n\r\n\r\nAddLaneHandler.prototype.preExecute = function(context) {\r\n\r\n  var spaceTool = this._spaceTool,\r\n      modeling = this._modeling;\r\n\r\n  var shape = context.shape,\r\n      location = context.location;\r\n\r\n  var lanesRoot = getLanesRoot(shape);\r\n\r\n  var isRoot = lanesRoot === shape,\r\n      laneParent = isRoot ? shape : shape.parent;\r\n\r\n  var existingChildLanes = getChildLanes(laneParent);\r\n\r\n  // (0) add a lane if we currently got none and are adding to root\r\n  if (!existingChildLanes.length) {\r\n    modeling.createShape({ type: 'vdml:Lane' }, {\r\n      x: shape.x + LANE_INDENTATION,\r\n      y: shape.y,\r\n      width: shape.width - LANE_INDENTATION,\r\n      height: shape.height\r\n    }, laneParent);\r\n  }\r\n\r\n  // (1) collect affected elements to create necessary space\r\n  var allAffected = [];\r\n\r\n  Elements.eachElement(lanesRoot, function(element) {\r\n    allAffected.push(element);\r\n\r\n    if (element === shape) {\r\n      return [];\r\n    }\r\n\r\n    return filter(element.children, function(c) {\r\n      return c !== shape;\r\n    });\r\n  });\r\n\r\n  var offset = location === 'top' ? -120 : 120,\r\n      lanePosition = location === 'top' ? shape.y : shape.y + shape.height,\r\n      spacePos = lanePosition + (location === 'top' ? 10 : -10),\r\n      direction = location === 'top' ? 'n' : 's';\r\n\r\n  var adjustments = spaceTool.calculateAdjustments(allAffected, 'y', offset, spacePos);\r\n\r\n  spaceTool.makeSpace(adjustments.movingShapes, adjustments.resizingShapes, { x: 0, y: offset }, direction);\r\n\r\n  // (2) create new lane at open space\r\n  context.newLane = modeling.createShape({ type: 'vdml:Lane' }, {\r\n    x: shape.x + (isRoot ? LANE_INDENTATION : 0),\r\n    y: lanePosition - (location === 'top' ? 120 : 0),\r\n    width: shape.width - (isRoot ? LANE_INDENTATION : 0),\r\n    height: 120\r\n  }, laneParent);\r\n};\r\n","'use strict';\r\n\r\n\r\nfunction IdClaimHandler(moddle) {\r\n  this._moddle = moddle;\r\n}\r\n\r\nIdClaimHandler.$inject = [ 'moddle' ];\r\n\r\nmodule.exports = IdClaimHandler;\r\n\r\n\r\nIdClaimHandler.prototype.execute = function(context) {\r\n  var ids = this._moddle.ids,\r\n      id = context.id,\r\n      element = context.element,\r\n      claiming = context.claiming;\r\n\r\n  if (claiming) {\r\n    ids.claim(id, element);\r\n  } else {\r\n    ids.unclaim(id);\r\n  }\r\n};\r\n\r\n/**\r\n * Command revert implementation.\r\n */\r\nIdClaimHandler.prototype.revert = function(context) {\r\n  var ids = this._moddle.ids,\r\n      id = context.id,\r\n      element = context.element,\r\n      claiming = context.claiming;\r\n\r\n  if (claiming) {\r\n    ids.unclaim(id);\r\n  } else {\r\n    ids.claim(id, element);\r\n  }\r\n};\r\n\r\n","'use strict';\r\n\r\nvar is = require(93).is;\r\n\r\nvar getLanesRoot = require(65).getLanesRoot,\r\n    computeLanesResize = require(65).computeLanesResize;\r\n\r\nvar eachElement = require(247).eachElement;\r\n\r\nvar asTRBL = require(233).asTRBL,\r\n    substractTRBL = require(204).substractTRBL;\r\n\r\n\r\n/**\r\n * A handler that resizes a lane.\r\n *\r\n * @param {Modeling} modeling\r\n */\r\nfunction ResizeLaneHandler(modeling, spaceTool) {\r\n  this._modeling = modeling;\r\n  this._spaceTool = spaceTool;\r\n}\r\n\r\nResizeLaneHandler.$inject = [ 'modeling', 'spaceTool' ];\r\n\r\nmodule.exports = ResizeLaneHandler;\r\n\r\n\r\nResizeLaneHandler.prototype.preExecute = function(context) {\r\n\r\n  var shape = context.shape,\r\n      newBounds = context.newBounds,\r\n      balanced = context.balanced;\r\n\r\n  if (balanced !== false) {\r\n    this.resizeBalanced(shape, newBounds);\r\n  } else {\r\n    this.resizeSpace(shape, newBounds);\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Resize balanced, adjusting next / previous lane sizes.\r\n *\r\n * @param {djs.model.Shape} shape\r\n * @param {Bounds} newBounds\r\n */\r\nResizeLaneHandler.prototype.resizeBalanced = function(shape, newBounds) {\r\n\r\n  var modeling = this._modeling;\r\n\r\n  var resizeNeeded = computeLanesResize(shape, newBounds);\r\n\r\n  // resize the lane\r\n  modeling.resizeShape(shape, newBounds);\r\n\r\n  // resize other lanes as needed\r\n  resizeNeeded.forEach(function(r) {\r\n    modeling.resizeShape(r.shape, r.newBounds);\r\n  });\r\n};\r\n\r\n\r\n/**\r\n * Resize, making actual space and moving below / above elements.\r\n *\r\n * @param {djs.model.Shape} shape\r\n * @param {Bounds} newBounds\r\n */\r\nResizeLaneHandler.prototype.resizeSpace = function(shape, newBounds) {\r\n  var spaceTool = this._spaceTool;\r\n\r\n  var shapeTrbl = asTRBL(shape),\r\n      newTrbl = asTRBL(newBounds);\r\n\r\n  var trblDiff = substractTRBL(newTrbl, shapeTrbl);\r\n\r\n  var lanesRoot = getLanesRoot(shape);\r\n\r\n  var allAffected = [],\r\n      allLanes = [];\r\n\r\n  eachElement(lanesRoot, function(element) {\r\n    allAffected.push(element);\r\n\r\n    if (is(element, 'vdml:Lane') || is(element, 'vdml:Participant')) {\r\n      allLanes.push(element);\r\n    }\r\n\r\n    return element.children;\r\n  });\r\n\r\n  var change,\r\n      spacePos,\r\n      direction,\r\n      offset,\r\n      adjustments;\r\n\r\n  if (trblDiff.bottom || trblDiff.top) {\r\n\r\n    change = trblDiff.bottom || trblDiff.top;\r\n    spacePos = shape.y + (trblDiff.bottom ? shape.height : 0) + (trblDiff.bottom ? -10 : 10);\r\n    direction = trblDiff.bottom ? 's' : 'n';\r\n\r\n    offset = trblDiff.top > 0 || trblDiff.bottom < 0 ? -change : change;\r\n\r\n    adjustments = spaceTool.calculateAdjustments(allAffected, 'y', offset, spacePos);\r\n\r\n    spaceTool.makeSpace(adjustments.movingShapes, adjustments.resizingShapes, { x: 0, y: change }, direction);\r\n  }\r\n\r\n\r\n  if (trblDiff.left || trblDiff.right) {\r\n\r\n    change = trblDiff.right || trblDiff.left;\r\n    spacePos = shape.x + (trblDiff.right ? shape.width : 0) + (trblDiff.right ? -10 : 100);\r\n    direction = trblDiff.right ? 'e' : 'w';\r\n\r\n    offset = trblDiff.left > 0 || trblDiff.right < 0 ? -change : change;\r\n\r\n    adjustments = spaceTool.calculateAdjustments(allLanes, 'x', offset, spacePos);\r\n\r\n    spaceTool.makeSpace(adjustments.movingShapes, adjustments.resizingShapes, { x: change, y: 0 }, direction);\r\n  }\r\n};","'use strict';\r\n\r\nvar getChildLanes = require(65).getChildLanes;\r\n\r\nvar LANE_INDENTATION = require(65).LANE_INDENTATION;\r\n\r\n/**\r\n * A handler that splits a lane into a number of sub-lanes,\r\n * creating new sub lanes, if neccessary.\r\n *\r\n * @param {Modeling} modeling\r\n */\r\nfunction SplitLaneHandler(modeling, translate) {\r\n  this._modeling = modeling;\r\n  this._translate = translate;\r\n}\r\n\r\nSplitLaneHandler.$inject = [ 'modeling', 'translate'];\r\n\r\nmodule.exports = SplitLaneHandler;\r\n\r\n\r\nSplitLaneHandler.prototype.preExecute = function(context) {\r\n\r\n  var modeling = this._modeling,\r\n      translate = this._translate;\r\n\r\n  var shape = context.shape,\r\n      newLanesCount = context.count;\r\n\r\n  var childLanes = getChildLanes(shape),\r\n      existingLanesCount = childLanes.length;\r\n\r\n  if (existingLanesCount > newLanesCount) {\r\n    throw new Error(translate('more than {count} child lanes', { count: newLanesCount }));\r\n  }\r\n\r\n  var newLanesHeight = Math.round(shape.height / newLanesCount);\r\n\r\n  // Iterate from top to bottom in child lane order,\r\n  // resizing existing lanes and creating new ones\r\n  // so that they split the parent proportionally.\r\n  //\r\n  // Due to rounding related errors, the bottom lane\r\n  // needs to take up all the remaining space.\r\n  var laneY,\r\n      laneHeight,\r\n      laneBounds,\r\n      newLaneAttrs,\r\n      idx;\r\n\r\n  for (idx = 0; idx < newLanesCount; idx++) {\r\n\r\n    laneY = shape.y + idx * newLanesHeight;\r\n\r\n    // if bottom lane\r\n    if (idx === newLanesCount - 1) {\r\n      laneHeight = shape.height - (newLanesHeight * idx);\r\n    } else {\r\n      laneHeight = newLanesHeight;\r\n    }\r\n\r\n    laneBounds = {\r\n      x: shape.x + LANE_INDENTATION,\r\n      y: laneY,\r\n      width: shape.width - LANE_INDENTATION,\r\n      height: laneHeight\r\n    };\r\n\r\n    if (idx < existingLanesCount) {\r\n      // resize existing lane\r\n      modeling.resizeShape(childLanes[idx], laneBounds);\r\n    } else {\r\n      // create a new lane at position\r\n      newLaneAttrs = {\r\n        type: 'vdml:Lane'\r\n      };\r\n\r\n      modeling.createShape(newLaneAttrs, laneBounds, shape);\r\n    }\r\n  }\r\n};\r\n","'use strict';\r\n\r\nvar Collections = require(244);\r\n\r\n\r\nfunction UpdateCanvasRootHandler(canvas, modeling) {\r\n  this._canvas = canvas;\r\n  this._modeling = modeling;\r\n}\r\n\r\nUpdateCanvasRootHandler.$inject = [ 'canvas', 'modeling' ];\r\n\r\nmodule.exports = UpdateCanvasRootHandler;\r\n\r\n\r\nUpdateCanvasRootHandler.prototype.execute = function(context) {\r\n\r\n  var canvas = this._canvas;\r\n\r\n  var newRoot = context.newRoot,\r\n      newRootBusinessObject = newRoot.businessObject,\r\n      oldRoot = canvas.getRootElement(),\r\n      oldRootBusinessObject = oldRoot.businessObject,\r\n      vdmlDefinitions = oldRootBusinessObject.$parent,\r\n      diPlane = oldRootBusinessObject.di;\r\n\r\n  // (1) replace process old <> new root\r\n  canvas.setRootElement(newRoot, true);\r\n\r\n  // (2) update root elements\r\n  Collections.add(vdmlDefinitions.rootElements, newRootBusinessObject);\r\n  newRootBusinessObject.$parent = vdmlDefinitions;\r\n\r\n  Collections.remove(vdmlDefinitions.rootElements, oldRootBusinessObject);\r\n  oldRootBusinessObject.$parent = null;\r\n\r\n  // (3) wire di\r\n  oldRootBusinessObject.di = null;\r\n\r\n  diPlane.vdmlElement = newRootBusinessObject;\r\n  newRootBusinessObject.di = diPlane;\r\n\r\n  context.oldRoot = oldRoot;\r\n\r\n  // TODO(nikku): return changed elements?\r\n  // return [ newRoot, oldRoot ];\r\n};\r\n\r\n\r\nUpdateCanvasRootHandler.prototype.revert = function(context) {\r\n\r\n  var canvas = this._canvas;\r\n\r\n  var newRoot = context.newRoot,\r\n      newRootBusinessObject = newRoot.businessObject,\r\n      oldRoot = context.oldRoot,\r\n      oldRootBusinessObject = oldRoot.businessObject,\r\n      vdmlDefinitions = newRootBusinessObject.$parent,\r\n      diPlane = newRootBusinessObject.di;\r\n\r\n  // (1) replace process old <> new root\r\n  canvas.setRootElement(oldRoot, true);\r\n\r\n  // (2) update root elements\r\n  Collections.remove(vdmlDefinitions.rootElements, newRootBusinessObject);\r\n  newRootBusinessObject.$parent = null;\r\n\r\n  Collections.add(vdmlDefinitions.rootElements, oldRootBusinessObject);\r\n  oldRootBusinessObject.$parent = vdmlDefinitions;\r\n\r\n  // (3) wire di\r\n  newRootBusinessObject.di = null;\r\n\r\n  diPlane.vdmlElement = oldRootBusinessObject;\r\n  oldRootBusinessObject.di = diPlane;\r\n\r\n  // TODO(nikku): return changed elements?\r\n  // return [ newRoot, oldRoot ];\r\n};","'use strict';\r\n\r\nvar collectLanes = require(65).collectLanes;\r\n\r\nvar getLanesRoot = require(65).getLanesRoot;\r\n\r\nvar is = require(93).is;\r\n\r\nvar Collections = require(244);\r\n\r\nvar asTRBL = require(233).asTRBL;\r\n\r\nvar FLOW_NODE_REFS_ATTR = 'flowNodeRef',\r\n    LANES_ATTR = 'lanes';\r\n\r\n/**\r\n * A handler that updates lane refs on changed elements\r\n */\r\nfunction UpdateFlowNodeRefsHandler(elementRegistry) {\r\n  this._elementRegistry = elementRegistry;\r\n}\r\n\r\nUpdateFlowNodeRefsHandler.$inject = [ 'elementRegistry' ];\r\n\r\nmodule.exports = UpdateFlowNodeRefsHandler;\r\n\r\n\r\nUpdateFlowNodeRefsHandler.prototype.computeUpdates = function(flowNodeShapes, laneShapes) {\r\n\r\n  var handledNodes = {};\r\n\r\n  var updates = [];\r\n\r\n  var participantCache = {};\r\n\r\n  var allFlowNodeShapes = [];\r\n\r\n  function isInLaneShape(element, laneShape) {\r\n\r\n    var laneTrbl = asTRBL(laneShape);\r\n\r\n    var elementMid = {\r\n      x: element.x + element.width / 2,\r\n      y: element.y + element.height / 2\r\n    };\r\n\r\n    return elementMid.x > laneTrbl.left &&\r\n           elementMid.x < laneTrbl.right &&\r\n           elementMid.y > laneTrbl.top &&\r\n           elementMid.y < laneTrbl.bottom;\r\n  }\r\n\r\n  function addFlowNodeShape(flowNodeShape) {\r\n    if (!handledNodes[flowNodeShape.id]) {\r\n      allFlowNodeShapes.push(flowNodeShape);\r\n      handledNodes[flowNodeShape.id] = flowNodeShape;\r\n    }\r\n  }\r\n\r\n  function getAllLaneShapes(flowNodeShape) {\r\n\r\n    var root = getLanesRoot(flowNodeShape);\r\n\r\n    if (!participantCache[root.id]) {\r\n      participantCache[root.id] = collectLanes(root);\r\n    }\r\n\r\n    return participantCache[root.id];\r\n  }\r\n\r\n  function getNewLanes(flowNodeShape) {\r\n    if (!flowNodeShape.parent) {\r\n      return [];\r\n    }\r\n\r\n    var allLaneShapes = getAllLaneShapes(flowNodeShape);\r\n\r\n    return allLaneShapes.filter(function(l) {\r\n      return isInLaneShape(flowNodeShape, l);\r\n    }).map(function(shape) {\r\n      return shape.businessObject;\r\n    });\r\n  }\r\n\r\n  laneShapes.forEach(function(laneShape) {\r\n    var root = getLanesRoot(laneShape);\r\n\r\n    if (!root || handledNodes[root.id]) {\r\n      return;\r\n    }\r\n\r\n    var children = root.children.filter(function(c) {\r\n      return is(c, 'vdml:FlowNode');\r\n    });\r\n\r\n    children.forEach(addFlowNodeShape);\r\n\r\n    handledNodes[root.id] = root;\r\n  });\r\n\r\n  flowNodeShapes.forEach(addFlowNodeShape);\r\n\r\n\r\n  allFlowNodeShapes.forEach(function(flowNodeShape) {\r\n\r\n    var flowNode = flowNodeShape.businessObject;\r\n\r\n    var lanes = flowNode.get(LANES_ATTR);\r\n    if (!lanes) {\r\n        return;\r\n    }\r\n    var remove = lanes.slice();\r\n    var add = getNewLanes(flowNodeShape);\r\n\r\n    updates.push({ flowNode: flowNode, remove: remove, add: add });\r\n  });\r\n\r\n  laneShapes.forEach(function(laneShape) {\r\n\r\n    var lane = laneShape.businessObject;\r\n\r\n    // lane got removed XX-)\r\n    if (!laneShape.parent) {\r\n      lane.get(FLOW_NODE_REFS_ATTR).forEach(function(flowNode) {\r\n        updates.push({ flowNode: flowNode, remove: [ lane ], add: [] });\r\n      });\r\n    }\r\n  });\r\n\r\n  return updates;\r\n};\r\n\r\nUpdateFlowNodeRefsHandler.prototype.execute = function(context) {\r\n\r\n  var updates = context.updates;\r\n\r\n  if (!updates) {\r\n    updates = context.updates = this.computeUpdates(context.flowNodeShapes, context.laneShapes);\r\n  }\r\n\r\n\r\n  updates.forEach(function(update) {\r\n\r\n    var flowNode = update.flowNode,\r\n        lanes = flowNode.get(LANES_ATTR);\r\n\r\n    // unwire old\r\n    update.remove.forEach(function(oldLane) {\r\n      Collections.remove(lanes, oldLane);\r\n      Collections.remove(oldLane.get(FLOW_NODE_REFS_ATTR), flowNode);\r\n    });\r\n\r\n    // wire new\r\n    update.add.forEach(function(newLane) {\r\n      Collections.add(lanes, newLane);\r\n      Collections.add(newLane.get(FLOW_NODE_REFS_ATTR), flowNode);\r\n    });\r\n  });\r\n\r\n  // TODO(nikku): return changed elements\r\n  // return [ ... ];\r\n};\r\n\r\n\r\nUpdateFlowNodeRefsHandler.prototype.revert = function(context) {\r\n\r\n  var updates = context.updates;\r\n\r\n  updates.forEach(function(update) {\r\n\r\n    var flowNode = update.flowNode,\r\n        lanes = flowNode.get(LANES_ATTR);\r\n\r\n    // unwire new\r\n    update.add.forEach(function(newLane) {\r\n      Collections.remove(lanes, newLane);\r\n      Collections.remove(newLane.get(FLOW_NODE_REFS_ATTR), flowNode);\r\n    });\r\n\r\n    // wire old\r\n    update.remove.forEach(function(oldLane) {\r\n      Collections.add(lanes, oldLane);\r\n      Collections.add(oldLane.get(FLOW_NODE_REFS_ATTR), flowNode);\r\n    });\r\n  });\r\n\r\n  // TODO(nikku): return changed elements\r\n  // return [ ... ];\r\n};","'use strict';\r\n\r\nvar reduce = require(418),\r\n    keys = require(412),\r\n    forEach = require(283),\r\n    assign = require(410);\r\n\r\nvar getBusinessObject = require(93).getBusinessObject;\r\n\r\nvar DEFAULT_FLOW = 'default',\r\n    NAME = 'name',\r\n    ID = 'id';\r\n\r\n\r\n/**\r\n * A handler that implements a VDML 2.0 property update.\r\n *\r\n * This should be used to set simple properties on elements with\r\n * an underlying VDML business object.\r\n *\r\n * Use respective diagram-js provided handlers if you would\r\n * like to perform automated modeling.\r\n */\r\nfunction UpdatePropertiesHandler(elementRegistry, moddle, translate) {\r\n  this._elementRegistry = elementRegistry;\r\n  this._moddle = moddle;\r\n  this._translate = translate;\r\n}\r\n\r\nUpdatePropertiesHandler.$inject = [ 'elementRegistry', 'moddle', 'translate' ];\r\n\r\nmodule.exports = UpdatePropertiesHandler;\r\n\r\n\r\n////// api /////////////////////////////////////////////\r\n\r\n/**\r\n * Updates a VDML element with a list of new properties\r\n *\r\n * @param {Object} context\r\n * @param {djs.model.Base} context.element the element to update\r\n * @param {Object} context.properties a list of properties to set on the element's\r\n *                                    businessObject (the VDML model element)\r\n *\r\n * @return {Array<djs.model.Base>} the updated element\r\n */\r\nUpdatePropertiesHandler.prototype.execute = function(context) {\r\n\r\n  var element = context.element,\r\n      changed = [ element],\r\n      translate = this._translate;\r\n\r\n  if (!element) {\r\n    throw new Error(translate('element required'));\r\n  }\r\n\r\n  var elementRegistry = this._elementRegistry,\r\n      ids = this._moddle.ids;\r\n\r\n  var businessObject = element.businessObject,\r\n      properties = unwrapBusinessObjects(context.properties),\r\n      oldProperties = context.oldProperties || getProperties(businessObject, keys(properties));\r\n\r\n  if (isIdChange(properties, businessObject)) {\r\n    ids.unclaim(businessObject[ID]);\r\n\r\n    elementRegistry.updateId(element, properties[ID]);\r\n\r\n    ids.claim(properties[ID], businessObject);\r\n  }\r\n\r\n  // correctly indicate visual changes on default flow updates\r\n  if (DEFAULT_FLOW in properties) {\r\n\r\n    if (properties[DEFAULT_FLOW]) {\r\n      changed.push(elementRegistry.get(properties[DEFAULT_FLOW].id));\r\n    }\r\n\r\n    if (businessObject[DEFAULT_FLOW]) {\r\n      changed.push(elementRegistry.get(businessObject[DEFAULT_FLOW].id));\r\n    }\r\n  }\r\n\r\n  if (NAME in properties && element.label) {\r\n    changed.push(element.label);\r\n\r\n    // show the label\r\n    element.label.hidden = !properties[NAME];\r\n  }\r\n\r\n  // update properties\r\n  setProperties(businessObject, properties);\r\n\r\n  // store old values\r\n  context.oldProperties = oldProperties;\r\n  context.changed = changed;\r\n\r\n  // indicate changed on objects affected by the update\r\n  return changed;\r\n};\r\n\r\n/**\r\n * Reverts the update on a VDML elements properties.\r\n *\r\n * @param  {Object} context\r\n *\r\n * @return {djs.model.Base} the updated element\r\n */\r\nUpdatePropertiesHandler.prototype.revert = function(context) {\r\n\r\n  var element = context.element,\r\n      properties = context.properties,\r\n      oldProperties = context.oldProperties,\r\n      businessObject = element.businessObject,\r\n      elementRegistry = this._elementRegistry,\r\n      ids = this._moddle.ids;\r\n\r\n  // update properties\r\n  setProperties(businessObject, oldProperties);\r\n\r\n  if (isIdChange(properties, businessObject)) {\r\n    ids.unclaim(properties[ID]);\r\n\r\n    elementRegistry.updateId(element, oldProperties[ID]);\r\n\r\n    ids.claim(oldProperties[ID], businessObject);\r\n  }\r\n\r\n  return context.changed;\r\n};\r\n\r\n\r\nfunction isIdChange(properties, businessObject) {\r\n  return ID in properties && properties[ID] !== businessObject[ID];\r\n}\r\n\r\n\r\nfunction getProperties(businessObject, propertyNames) {\r\n  return reduce(propertyNames, function(result, key) {\r\n    result[key] = businessObject.get(key);\r\n    return result;\r\n  }, {});\r\n}\r\n\r\n\r\nfunction setProperties(businessObject, properties) {\r\n  forEach(properties, function(value, key) {\r\n    businessObject.set(key, value);\r\n  });\r\n}\r\n\r\n\r\nvar referencePropertyNames = [ 'default' ];\r\n\r\n/**\r\n * Make sure we unwrap the actual business object\r\n * behind diagram element that may have been\r\n * passed as arguments.\r\n *\r\n * @param  {Object} properties\r\n *\r\n * @return {Object} unwrappedProps\r\n */\r\nfunction unwrapBusinessObjects(properties) {\r\n\r\n  var unwrappedProps = assign({}, properties);\r\n\r\n  referencePropertyNames.forEach(function(name) {\r\n    if (name in properties) {\r\n      unwrappedProps[name] = getBusinessObject(unwrappedProps[name]);\r\n    }\r\n  });\r\n\r\n  return unwrappedProps;\r\n}","module.exports = {\r\n  __init__: [ 'modeling', 'vdmlUpdater' ],\r\n  __depends__: [\r\n    require(52),\r\n    require(26),\r\n    require(80),\r\n    require(68),\r\n    require(78),\r\n    require(102),\r\n    require(225),\r\n    require(155),\r\n    require(116),\r\n    require(214),\r\n    require(128),\r\n    require(221)\r\n  ],\r\n  vdmlFactory: [ 'type', require(29) ],\r\n  vdmlUpdater: [ 'type', require(31) ],\r\n  elementFactory: [ 'type', require(27) ],\r\n  modeling: [ 'type', require(28) ],\r\n  layouter: [ 'type', require(30) ],\r\n  connectionDocking: [ 'type', require(232) ]\r\n};\r\n","'use strict';\r\n\r\nvar is = require(93).is;\r\n\r\nvar getParent = require(66).getParent;\r\n\r\nvar asTRBL = require(233).asTRBL,\r\n    substractTRBL = require(204).substractTRBL,\r\n    resizeTRBL = require(204).resizeTRBL;\r\n\r\nvar abs = Math.abs;\r\n\r\n\r\nfunction getTRBLResize(oldBounds, newBounds) {\r\n  return substractTRBL(asTRBL(newBounds), asTRBL(oldBounds));\r\n}\r\n\r\n\r\nvar LANE_PARENTS = [\r\n  'vdml:Participant',\r\n  'vdml:Process',\r\n  'vdml:SubProcess'\r\n];\r\n\r\nvar LANE_INDENTATION = 30;\r\n\r\nmodule.exports.LANE_INDENTATION = LANE_INDENTATION;\r\n\r\n\r\n/**\r\n * Collect all lane shapes in the given paren\r\n *\r\n * @param  {djs.model.Shape} shape\r\n * @param  {Array<djs.model.Base>} [collectedShapes]\r\n *\r\n * @return {Array<djs.model.Base>}\r\n */\r\nfunction collectLanes(shape, collectedShapes) {\r\n\r\n  collectedShapes = collectedShapes || [];\r\n\r\n  shape.children.filter(function(s) {\r\n    if (is(s, 'vdml:Lane')) {\r\n      collectLanes(s, collectedShapes);\r\n\r\n      collectedShapes.push(s);\r\n    }\r\n  });\r\n\r\n  return collectedShapes;\r\n}\r\n\r\nmodule.exports.collectLanes = collectLanes;\r\n\r\n/**\r\n * Return the lane children of the given element.\r\n *\r\n * @param {djs.model.Shape} shape\r\n *\r\n * @return {Array<djs.model.Shape>}\r\n */\r\nfunction getChildLanes(shape) {\r\n  return shape.children.filter(function(c) {\r\n    return is(c, 'vdml:Lane');\r\n  });\r\n}\r\n\r\nmodule.exports.getChildLanes = getChildLanes;\r\n\r\n/**\r\n * Return the root element containing the given lane shape\r\n *\r\n * @param {djs.model.Shape} shape\r\n *\r\n * @return {djs.model.Shape}\r\n */\r\nfunction getLanesRoot(shape) {\r\n  return getParent(shape, LANE_PARENTS) || shape;\r\n}\r\n\r\nmodule.exports.getLanesRoot = getLanesRoot;\r\n\r\n\r\n/**\r\n * Compute the required resize operations for lanes\r\n * adjacent to the given shape, assuming it will be\r\n * resized to the given new bounds.\r\n *\r\n * @param {djs.model.Shape} shape\r\n * @param {Bounds} newBounds\r\n *\r\n * @return {Array<Object>}\r\n */\r\nfunction computeLanesResize(shape, newBounds) {\r\n\r\n  var rootElement = getLanesRoot(shape);\r\n\r\n  var initialShapes = is(rootElement, 'vdml:Process') ? [] : [ rootElement ];\r\n\r\n  var allLanes = collectLanes(rootElement, initialShapes),\r\n      shapeTrbl = asTRBL(shape),\r\n      shapeNewTrbl = asTRBL(newBounds),\r\n      trblResize = getTRBLResize(shape, newBounds),\r\n      resizeNeeded = [];\r\n\r\n  allLanes.forEach(function(other) {\r\n\r\n    if (other === shape) {\r\n      return;\r\n    }\r\n\r\n    var topResize = 0,\r\n        rightResize = trblResize.right,\r\n        bottomResize = 0,\r\n        leftResize = trblResize.left;\r\n\r\n    var otherTrbl = asTRBL(other);\r\n\r\n    if (trblResize.top) {\r\n      if (abs(otherTrbl.bottom - shapeTrbl.top) < 10) {\r\n        bottomResize = shapeNewTrbl.top - otherTrbl.bottom;\r\n      }\r\n\r\n      if (abs(otherTrbl.top - shapeTrbl.top) < 5) {\r\n        topResize = shapeNewTrbl.top - otherTrbl.top;\r\n      }\r\n    }\r\n\r\n    if (trblResize.bottom) {\r\n      if (abs(otherTrbl.top - shapeTrbl.bottom) < 10) {\r\n        topResize = shapeNewTrbl.bottom - otherTrbl.top;\r\n      }\r\n\r\n      if (abs(otherTrbl.bottom - shapeTrbl.bottom) < 5) {\r\n        bottomResize = shapeNewTrbl.bottom - otherTrbl.bottom;\r\n      }\r\n    }\r\n\r\n    if (topResize || rightResize || bottomResize || leftResize) {\r\n\r\n      resizeNeeded.push({\r\n        shape: other,\r\n        newBounds: resizeTRBL(other, {\r\n          top: topResize,\r\n          right: rightResize,\r\n          bottom: bottomResize,\r\n          left: leftResize\r\n        })\r\n      });\r\n    }\r\n\r\n  });\r\n\r\n  return resizeNeeded;\r\n}\r\n\r\nmodule.exports.computeLanesResize = computeLanesResize;\r\n","'use strict';\r\n\r\nvar any = require(279);\r\n\r\nvar is = require(93).is;\r\n\r\n\r\nfunction getParents(element) {\r\n\r\n  var parents = [];\r\n\r\n  while (element) {\r\n    element = element.parent;\r\n\r\n    if (element) {\r\n      parents.push(element);\r\n    }\r\n  }\r\n\r\n  return parents;\r\n}\r\n\r\nmodule.exports.getParents = getParents;\r\n\r\n\r\n/**\r\n * Return true if element has any of the given types.\r\n *\r\n * @param {djs.model.Base} element\r\n * @param {Array<String>} types\r\n *\r\n * @return {Boolean}\r\n */\r\nfunction isAny(element, types) {\r\n  return any(types, function(t) {\r\n    return is(element, t);\r\n  });\r\n}\r\n\r\nmodule.exports.isAny = isAny;\r\n\r\n\r\n/**\r\n * Return the parent of the element with any of the given types.\r\n *\r\n * @param {djs.model.Base} element\r\n * @param {String|Array<String>} anyType\r\n *\r\n * @return {djs.model.Base}\r\n */\r\nfunction getParent(element, anyType) {\r\n\r\n  if (typeof anyType === 'string') {\r\n    anyType = [ anyType ];\r\n  }\r\n\r\n  while ((element = element.parent)) {\r\n    if (isAny(element, anyType)) {\r\n      return element;\r\n    }\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nmodule.exports.getParent = getParent;\r\n","'use strict';\r\n\r\nvar inherits = require(270);\r\n\r\nvar OrderingProvider = require(188);\r\n\r\nvar isAny = require(66).isAny;\r\n\r\nvar findIndex = require(271);\r\n\r\nvar find = require(282);\r\n\r\n\r\n/**\r\n * a simple ordering provider that makes sure:\r\n *\r\n * (1) elements are ordered by a {level} property\r\n * (2) elements with {alwaysOnTop} are always added to the root\r\n */\r\nfunction VdmlOrderingProvider(eventBus, translate) {\r\n\r\n  OrderingProvider.call(this, eventBus);\r\n\r\n  var orders = [\r\n    { type: 'vdml:SubProcess', order: { level: 6 } },\r\n    {\r\n      type: 'vdml:SequenceFlow',\r\n      order: {\r\n        level: 5,\r\n        containers: [\r\n          'vdml:Participant',\r\n          'vdml:FlowElementsContainer'\r\n        ]\r\n      }\r\n    },\r\n    { type: 'vdml:DataInputAssociation', order: { level: 9, containers: [ 'vdml:Collaboration', 'vdml:Process' ] } },\r\n    { type: 'vdml:DataOutputAssociation', order: { level: 9, containers: [ 'vdml:Collaboration', 'vdml:Process' ] } },\r\n    { type: 'vdml:MessageFlow', order: { level: 9, containers: [ 'vdml:Collaboration' ] } },\r\n    {\r\n      type: 'vdml:Association',\r\n      order: {\r\n        level: 6,\r\n        containers: [\r\n          'vdml:Participant',\r\n          'vdml:FlowElementsContainer',\r\n          'vdml:Collaboration'\r\n        ]\r\n      }\r\n    },\r\n    { type: 'vdml:BoundaryEvent', order: { level: 8 } },\r\n    { type: 'vdml:Participant', order: { level: -2 } },\r\n    { type: 'vdml:Lane', order: { level: -1 } }\r\n  ];\r\n\r\n  function computeOrder(element) {\r\n    if (element.labelTarget) {\r\n      return { level: 10 };\r\n    }\r\n\r\n    var entry = find(orders, function(o) {\r\n      return isAny(element, [ o.type ]);\r\n    });\r\n\r\n    return entry && entry.order || { level: 1 };\r\n  }\r\n\r\n  function getOrder(element) {\r\n\r\n    var order = element.order;\r\n\r\n    if (!order) {\r\n      element.order = order = computeOrder(element);\r\n    }\r\n\r\n    return order;\r\n  }\r\n\r\n  function findActualParent(element, newParent, containers) {\r\n\r\n    var actualParent = newParent;\r\n\r\n    while (actualParent) {\r\n\r\n      if (isAny(actualParent, containers)) {\r\n        break;\r\n      }\r\n\r\n      actualParent = actualParent.parent;\r\n    }\r\n\r\n    if (!actualParent) {\r\n      throw new Error(translate('no parent for {element} in {parent}', {\r\n        element: element.id,\r\n        parent: newParent.id\r\n      }));\r\n    }\r\n\r\n    return actualParent;\r\n  }\r\n\r\n  this.getOrdering = function(element, newParent) {\r\n\r\n    var elementOrder = getOrder(element);\r\n\r\n\r\n    if (elementOrder.containers) {\r\n      newParent = findActualParent(element, newParent, elementOrder.containers);\r\n    }\r\n\r\n\r\n    var currentIndex = newParent.children.indexOf(element);\r\n\r\n    var insertIndex = findIndex(newParent.children, function(child) {\r\n\r\n      // do not compare with labels, they are created\r\n      // in the wrong order (right after elements) during import and\r\n      // mess up the positioning.\r\n      if (!element.labelTarget && child.labelTarget) {\r\n        return false;\r\n      }\r\n\r\n      return elementOrder.level < getOrder(child).level;\r\n    });\r\n\r\n\r\n    // if the element is already in the child list at\r\n    // a smaller index, we need to adjust the inser index.\r\n    // this takes into account that the element is being removed\r\n    // before being re-inserted\r\n    if (insertIndex !== -1) {\r\n      if (currentIndex !== -1 && currentIndex < insertIndex) {\r\n        insertIndex -= 1;\r\n      }\r\n    }\r\n\r\n    return {\r\n      index: insertIndex,\r\n      parent: newParent\r\n    };\r\n  };\r\n}\r\n\r\nVdmlOrderingProvider.$inject = [ 'eventBus', 'translate' ];\r\n\r\ninherits(VdmlOrderingProvider, OrderingProvider);\r\n\r\nmodule.exports = VdmlOrderingProvider;\r\n","module.exports = {\r\n  __init__: [ 'vdmlOrderingProvider' ],\r\n  __depends__: [\r\n    require(229)\r\n  ],\r\n  vdmlOrderingProvider: [ 'type', require(67) ]\r\n};","'use strict';\r\n\r\nvar assign = require(410);\r\n\r\n/**\r\n * A palette provider for VDML 2.0 elements.\r\n */\r\nfunction PaletteProvider(palette, create, elementFactory, spaceTool, lassoTool, handTool, globalConnect, translate) {\r\n\r\n  this._palette = palette;\r\n  this._create = create;\r\n  this._elementFactory = elementFactory;\r\n  this._spaceTool = spaceTool;\r\n  this._lassoTool = lassoTool;\r\n  this._handTool = handTool;\r\n  this._globalConnect = globalConnect;\r\n  this._translate = translate;\r\n\r\n  palette.registerProvider(this);\r\n}\r\n\r\nmodule.exports = PaletteProvider;\r\n\r\nPaletteProvider.$inject = [\r\n  'palette',\r\n  'create',\r\n  'elementFactory',\r\n  'spaceTool',\r\n  'lassoTool',\r\n  'handTool',\r\n  'globalConnect',\r\n  'translate'\r\n];\r\n\r\n\r\nPaletteProvider.prototype.getPaletteEntries = function(element) {\r\n\r\n  var actions  = {},\r\n      create = this._create,\r\n      elementFactory = this._elementFactory,\r\n      spaceTool = this._spaceTool,\r\n      lassoTool = this._lassoTool,\r\n      handTool = this._handTool,\r\n      globalConnect = this._globalConnect,\r\n      translate = this._translate;\r\n\r\n  function createAction(type, group, className, title, options) {\r\n      debugger;\r\n\r\n      function createListener(event) {\r\n          debugger;\r\n      var shape = elementFactory.createShape(assign({ type: type }, options));\r\n\r\n      if (options) {\r\n        shape.businessObject.di.isExpanded = options.isExpanded;\r\n      }\r\n\r\n      create.start(event, shape);\r\n    }\r\n\r\n    var shortType = type.replace(/^vdml/:/, '');\r\n\r\n    return {\r\n      group: group,\r\n      className: className,\r\n      title: title || translate('Create {type}', { type: shortType }),\r\n      action: {\r\n        dragstart: createListener,\r\n        click: createListener\r\n      }\r\n    };\r\n  }\r\n\r\n  function createParticipant(event, collapsed) {\r\n    create.start(event, elementFactory.createParticipantShape(collapsed));\r\n  }\r\n\r\n  assign(actions, {\r\n    'hand-tool': {\r\n      group: 'tools',\r\n      className: 'bpmn-icon-hand-tool',\r\n      title: translate('Activate the hand tool'),\r\n      action: {\r\n        click: function(event) {\r\n          handTool.activateHand(event);\r\n        }\r\n      }\r\n    },\r\n    'lasso-tool': {\r\n      group: 'tools',\r\n      className: 'bpmn-icon-lasso-tool',\r\n      title: translate('Activate the lasso tool'),\r\n      action: {\r\n        click: function(event) {\r\n          lassoTool.activateSelection(event);\r\n        }\r\n      }\r\n    },\r\n    'space-tool': {\r\n      group: 'tools',\r\n      className: 'bpmn-icon-space-tool',\r\n      title: translate('Activate the create/remove space tool'),\r\n      action: {\r\n        click: function(event) {\r\n          spaceTool.activateSelection(event);\r\n        }\r\n      }\r\n    },\r\n    'global-connect-tool': {\r\n      group: 'tools',\r\n      className: 'bpmn-icon-connection-multi',\r\n      title: translate('Activate the global connect tool'),\r\n      action: {\r\n        click: function(event) {\r\n          globalConnect.toggle(event);\r\n        }\r\n      }\r\n    },\r\n    'tool-separator': {\r\n      group: 'tools',\r\n      separator: true\r\n    },\r\n    /*'create.start-event': createAction(\r\n      'vdml:StartEvent', 'event', 'bpmn-icon-start-event-none'\r\n    ),\r\n    'create.intermediate-event': createAction('vdml:IntermediateThrowEvent', 'event',\r\n      'bpmn-icon-intermediate-event-none', translate('Create IntermediateThrowEvent/BoundaryEvent')\r\n    ),\r\n    'create.end-event': createAction(\r\n      'vdml:EndEvent', 'event', 'bpmn-icon-end-event-none'\r\n    ),\r\n    'create.exclusive-gateway': createAction(\r\n      'vdml:ExclusiveGateway', 'gateway', 'bpmn-icon-gateway-xor'\r\n    ),*/\r\n    'create.task': createAction(\r\n      'vdml:Collaboration', 'collaboration', 'bpmn-icon-task'\r\n    ),\r\n    /*'create.data-object': createAction(\r\n      'vdml:DataObjectReference', 'data-object', 'bpmn-icon-data-object'\r\n    ),\r\n    'create.data-store': createAction(\r\n      'vdml:DataStoreReference', 'data-store', 'bpmn-icon-data-store'\r\n    ),\r\n    'create.subprocess-expanded': createAction(\r\n      'vdml:SubProcess', 'activity', 'bpmn-icon-subprocess-expanded', translate('Create expanded SubProcess'),\r\n      { isExpanded: true }\r\n    ),\r\n    'create.participant-expanded': {\r\n      group: 'collaboration',\r\n      className: 'bpmn-icon-participant',\r\n      title: translate('Create Pool/Participant'),\r\n      action: {\r\n        dragstart: createParticipant,\r\n        click: createParticipant\r\n      }\r\n    }*/\r\n  });\r\n\r\n  return actions;\r\n};\r\n","module.exports = {\r\n  __depends__: [\r\n    require(194),\r\n    require(138),\r\n    require(221),\r\n    require(157),\r\n    require(149),\r\n    require(229),\r\n    require(20)\r\n  ],\r\n  __init__: [ 'paletteProvider' ],\r\n  paletteProvider: [ 'type', require(69) ]\r\n};\r\n","'use strict';\r\n\r\nvar is = require(93).is,\r\n    isEventSubProcess = require(91).isEventSubProcess,\r\n    getBusinessObject = require(93).getBusinessObject,\r\n    isExpanded = require(91).isExpanded,\r\n    isDifferentType = require(73).isDifferentType;\r\n\r\nvar forEach = require(283),\r\n    filter = require(281),\r\n    reject = require(288);\r\n\r\nvar replaceOptions = require(76);\r\n\r\n\r\n/**\r\n * This module is an element agnostic replace menu provider for the popup menu.\r\n */\r\nfunction ReplaceMenuProvider(popupMenu, modeling, moddle, vdmlReplace, rules, translate) {\r\n\r\n  this._popupMenu = popupMenu;\r\n  this._modeling = modeling;\r\n  this._moddle = moddle;\r\n  this._vdmlReplace = vdmlReplace;\r\n  this._rules = rules;\r\n  this._translate = translate;\r\n\r\n  this.register();\r\n}\r\n\r\nReplaceMenuProvider.$inject = [ 'popupMenu', 'modeling', 'moddle', 'vdmlReplace', 'rules', 'translate' ];\r\n\r\n\r\n/**\r\n * Register replace menu provider in the popup menu\r\n */\r\nReplaceMenuProvider.prototype.register = function() {\r\n  this._popupMenu.registerProvider('vdml-replace', this);\r\n};\r\n\r\n\r\n/**\r\n * Get all entries from replaceOptions for the given element and apply filters\r\n * on them. Get for example only elements, which are different from the current one.\r\n *\r\n * @param {djs.model.Base} element\r\n *\r\n * @return {Array<Object>} a list of menu entry items\r\n */\r\nReplaceMenuProvider.prototype.getEntries = function(element) {\r\n\r\n  var businessObject = element.businessObject;\r\n\r\n  var rules = this._rules;\r\n\r\n  var entries;\r\n\r\n  if (!rules.allowed('shape.replace', { element: element })) {\r\n    return [];\r\n  }\r\n\r\n  var differentType = isDifferentType(element);\r\n\r\n  // start events outside event sub processes\r\n  if (is(businessObject, 'vdml:StartEvent') && !isEventSubProcess(businessObject.$parent)) {\r\n\r\n    entries = filter(replaceOptions.START_EVENT, differentType);\r\n\r\n    return this._createEntries(element, entries);\r\n  }\r\n\r\n  // expanded/collapsed pools\r\n  if (is(businessObject, 'vdml:Participant')) {\r\n\r\n    entries = filter(replaceOptions.PARTICIPANT, function(entry) {\r\n      return isExpanded(businessObject) !== entry.target.isExpanded;\r\n    });\r\n\r\n    return this._createEntries(element, entries);\r\n  }\r\n\r\n  // start events inside event sub processes\r\n  if (is(businessObject, 'vdml:StartEvent') && isEventSubProcess(businessObject.$parent)) {\r\n\r\n    entries = filter(replaceOptions.EVENT_SUB_PROCESS_START_EVENT, function(entry) {\r\n\r\n      var target = entry.target;\r\n\r\n      var isInterrupting = target.isInterrupting !== false;\r\n\r\n      var isInterruptingEqual = getBusinessObject(element).isInterrupting === isInterrupting;\r\n\r\n      // filters elements which types and event definition are equal but have have different interrupting types\r\n      return differentType(entry) || !differentType(entry) && !isInterruptingEqual;\r\n\r\n    });\r\n\r\n    return this._createEntries(element, entries);\r\n  }\r\n\r\n  // end events\r\n  if (is(businessObject, 'vdml:EndEvent')) {\r\n\r\n    entries = filter(replaceOptions.END_EVENT, function(entry) {\r\n      var target = entry.target;\r\n\r\n      // hide cancel end events outside transactions\r\n      if (target.eventDefinitionType == 'vdml:CancelEventDefinition' && !is(businessObject.$parent, 'vdml:Transaction')) {\r\n        return false;\r\n      }\r\n\r\n      return differentType(entry);\r\n    });\r\n\r\n    return this._createEntries(element, entries);\r\n  }\r\n\r\n  // boundary events\r\n  if (is(businessObject, 'vdml:BoundaryEvent')) {\r\n\r\n    entries = filter(replaceOptions.BOUNDARY_EVENT, function(entry) {\r\n\r\n      var target = entry.target;\r\n\r\n      if (target.eventDefinition == 'vdml:CancelEventDefinition' &&\r\n         !is(businessObject.attachedToRef, 'vdml:Transaction')) {\r\n        return false;\r\n      }\r\n      var cancelActivity = target.cancelActivity !== false;\r\n\r\n      var isCancelActivityEqual = businessObject.cancelActivity == cancelActivity;\r\n\r\n      return differentType(entry) || !differentType(entry) && !isCancelActivityEqual;\r\n    });\r\n\r\n    return this._createEntries(element, entries);\r\n  }\r\n\r\n  // intermediate events\r\n  if (is(businessObject, 'vdml:IntermediateCatchEvent') ||\r\n      is(businessObject, 'vdml:IntermediateThrowEvent')) {\r\n\r\n    entries = filter(replaceOptions.INTERMEDIATE_EVENT, differentType);\r\n\r\n    return this._createEntries(element, entries);\r\n  }\r\n\r\n  // gateways\r\n  if (is(businessObject, 'vdml:Gateway')) {\r\n\r\n    entries = filter(replaceOptions.GATEWAY, differentType);\r\n\r\n    return this._createEntries(element, entries);\r\n  }\r\n\r\n  // transactions\r\n  if (is(businessObject, 'vdml:Transaction')) {\r\n\r\n    entries = filter(replaceOptions.TRANSACTION, differentType);\r\n\r\n    return this._createEntries(element, entries);\r\n  }\r\n\r\n  // expanded event sub processes\r\n  if (isEventSubProcess(businessObject) && isExpanded(businessObject)) {\r\n\r\n    entries = filter(replaceOptions.EVENT_SUB_PROCESS, differentType);\r\n\r\n    return this._createEntries(element, entries);\r\n  }\r\n\r\n  // expanded sub processes\r\n  if (is(businessObject, 'vdml:SubProcess') && isExpanded(businessObject)) {\r\n\r\n    entries = filter(replaceOptions.SUBPROCESS_EXPANDED, differentType);\r\n\r\n    return this._createEntries(element, entries);\r\n  }\r\n\r\n  // collapsed ad hoc sub processes\r\n  if (is(businessObject, 'vdml:AdHocSubProcess') && !isExpanded(businessObject)) {\r\n\r\n    entries = filter(replaceOptions.TASK, function(entry) {\r\n\r\n      var target = entry.target;\r\n\r\n      var isTargetSubProcess = target.type === 'vdml:SubProcess';\r\n\r\n      var isTargetExpanded = target.isExpanded === true;\r\n\r\n      return isDifferentType(element, target) && ( !isTargetSubProcess || isTargetExpanded );\r\n    });\r\n\r\n    return this._createEntries(element, entries);\r\n  }\r\n\r\n  // sequence flows\r\n  if (is(businessObject, 'vdml:SequenceFlow')) {\r\n    return this._createSequenceFlowEntries(element, replaceOptions.SEQUENCE_FLOW);\r\n  }\r\n\r\n  // flow nodes\r\n  if (is(businessObject, 'vdml:FlowNode')) {\r\n    entries = filter(replaceOptions.TASK, differentType);\r\n\r\n    // collapsed SubProcess can not be replaced with itself\r\n    if (is(businessObject, 'vdml:SubProcess') && !isExpanded(businessObject)) {\r\n      entries = reject(entries, function(entry) {\r\n        return entry.label === 'Sub Process (collapsed)';\r\n      });\r\n    }\r\n\r\n    return this._createEntries(element, entries);\r\n  }\r\n\r\n  return [];\r\n};\r\n\r\n\r\n/**\r\n * Get a list of header items for the given element. This includes buttons\r\n * for multi instance markers and for the ad hoc marker.\r\n *\r\n * @param {djs.model.Base} element\r\n *\r\n * @return {Array<Object>} a list of menu entry items\r\n */\r\nReplaceMenuProvider.prototype.getHeaderEntries = function(element) {\r\n\r\n  var headerEntries = [];\r\n\r\n  if (is(element, 'vdml:Activity') && !isEventSubProcess(element)) {\r\n    headerEntries = headerEntries.concat(this._getLoopEntries(element));\r\n  }\r\n\r\n  if (is(element, 'vdml:SubProcess') &&\r\n      !is(element, 'vdml:Transaction') &&\r\n      !isEventSubProcess(element)) {\r\n    headerEntries.push(this._getAdHocEntry(element));\r\n  }\r\n\r\n  return headerEntries;\r\n};\r\n\r\n\r\n/**\r\n * Creates an array of menu entry objects for a given element and filters the replaceOptions\r\n * according to a filter function.\r\n *\r\n * @param  {djs.model.Base} element\r\n * @param  {Object} replaceOptions\r\n *\r\n * @return {Array<Object>} a list of menu items\r\n */\r\nReplaceMenuProvider.prototype._createEntries = function(element, replaceOptions) {\r\n  var menuEntries = [];\r\n\r\n  var self = this;\r\n\r\n  forEach(replaceOptions, function(definition) {\r\n    var entry = self._createMenuEntry(definition, element);\r\n\r\n    menuEntries.push(entry);\r\n  });\r\n\r\n  return menuEntries;\r\n};\r\n\r\n/**\r\n * Creates an array of menu entry objects for a given sequence flow.\r\n *\r\n * @param  {djs.model.Base} element\r\n * @param  {Object} replaceOptions\r\n\r\n * @return {Array<Object>} a list of menu items\r\n */\r\nReplaceMenuProvider.prototype._createSequenceFlowEntries = function(element, replaceOptions) {\r\n\r\n  var businessObject = getBusinessObject(element);\r\n\r\n  var menuEntries = [];\r\n\r\n  var modeling = this._modeling,\r\n      moddle = this._moddle;\r\n\r\n  var self = this;\r\n\r\n  forEach(replaceOptions, function(entry) {\r\n\r\n    switch (entry.actionName) {\r\n    case 'replace-with-default-flow':\r\n      if (businessObject.sourceRef.default !== businessObject &&\r\n            (is(businessObject.sourceRef, 'vdml:ExclusiveGateway') ||\r\n             is(businessObject.sourceRef, 'vdml:InclusiveGateway') ||\r\n             is(businessObject.sourceRef, 'vdml:ComplexGateway') ||\r\n             is(businessObject.sourceRef, 'vdml:Activity'))) {\r\n\r\n        menuEntries.push(self._createMenuEntry(entry, element, function() {\r\n          modeling.updateProperties(element.source, { default: businessObject });\r\n        }));\r\n      }\r\n      break;\r\n    case 'replace-with-conditional-flow':\r\n      if (!businessObject.conditionExpression && is(businessObject.sourceRef, 'vdml:Activity')) {\r\n\r\n        menuEntries.push(self._createMenuEntry(entry, element, function() {\r\n          var conditionExpression = moddle.create('vdml:FormalExpression', { body: '' });\r\n\r\n          modeling.updateProperties(element, { conditionExpression: conditionExpression });\r\n        }));\r\n      }\r\n      break;\r\n    default:\r\n        // default flows\r\n      if (is(businessObject.sourceRef, 'vdml:Activity') && businessObject.conditionExpression) {\r\n        return menuEntries.push(self._createMenuEntry(entry, element, function() {\r\n          modeling.updateProperties(element, { conditionExpression: undefined });\r\n        }));\r\n      }\r\n        // conditional flows\r\n      if ((is(businessObject.sourceRef, 'vdml:ExclusiveGateway') ||\r\n           is(businessObject.sourceRef, 'vdml:InclusiveGateway') ||\r\n           is(businessObject.sourceRef, 'vdml:ComplexGateway') ||\r\n           is(businessObject.sourceRef, 'vdml:Activity')) &&\r\n           businessObject.sourceRef.default === businessObject) {\r\n\r\n        return menuEntries.push(self._createMenuEntry(entry, element, function() {\r\n          modeling.updateProperties(element.source, { default: undefined });\r\n        }));\r\n      }\r\n    }\r\n  });\r\n\r\n  return menuEntries;\r\n};\r\n\r\n\r\n/**\r\n * Creates and returns a single menu entry item.\r\n *\r\n * @param  {Object} definition a single replace options definition object\r\n * @param  {djs.model.Base} element\r\n * @param  {Function} [action] an action callback function which gets called when\r\n *                             the menu entry is being triggered.\r\n *\r\n * @return {Object} menu entry item\r\n */\r\nReplaceMenuProvider.prototype._createMenuEntry = function(definition, element, action) {\r\n  var translate = this._translate;\r\n  var replaceElement = this._vdmlReplace.replaceElement;\r\n\r\n  var replaceAction = function() {\r\n    return replaceElement(element, definition.target);\r\n  };\r\n\r\n  action = action || replaceAction;\r\n\r\n  var menuEntry = {\r\n    label: translate(definition.label),\r\n    className: definition.className,\r\n    id: definition.actionName,\r\n    action: action\r\n  };\r\n\r\n  return menuEntry;\r\n};\r\n\r\n/**\r\n * Get a list of menu items containing buttons for multi instance markers\r\n *\r\n * @param  {djs.model.Base} element\r\n *\r\n * @return {Array<Object>} a list of menu items\r\n */\r\nReplaceMenuProvider.prototype._getLoopEntries = function(element) {\r\n\r\n  var self = this;\r\n  var translate = this._translate;\r\n\r\n  function toggleLoopEntry(event, entry) {\r\n    var loopCharacteristics;\r\n\r\n    if (entry.active) {\r\n      loopCharacteristics = undefined;\r\n    } else {\r\n      loopCharacteristics = self._moddle.create(entry.options.loopCharacteristics);\r\n\r\n      if (entry.options.isSequential) {\r\n        loopCharacteristics.isSequential = entry.options.isSequential;\r\n      }\r\n    }\r\n    self._modeling.updateProperties(element, { loopCharacteristics: loopCharacteristics });\r\n  }\r\n\r\n  var businessObject = getBusinessObject(element),\r\n      loopCharacteristics = businessObject.loopCharacteristics;\r\n\r\n  var isSequential,\r\n      isLoop,\r\n      isParallel;\r\n\r\n  if (loopCharacteristics) {\r\n    isSequential = loopCharacteristics.isSequential;\r\n    isLoop = loopCharacteristics.isSequential === undefined;\r\n    isParallel = loopCharacteristics.isSequential !== undefined && !loopCharacteristics.isSequential;\r\n  }\r\n\r\n\r\n  var loopEntries = [\r\n    {\r\n      id: 'toggle-parallel-mi',\r\n      className: 'bpmn-icon-parallel-mi-marker',\r\n      title: translate('Parallel Multi Instance'),\r\n      active: isParallel,\r\n      action: toggleLoopEntry,\r\n      options: {\r\n        loopCharacteristics: 'vdml:MultiInstanceLoopCharacteristics',\r\n        isSequential: false\r\n      }\r\n    },\r\n    {\r\n      id: 'toggle-sequential-mi',\r\n      className: 'bpmn-icon-sequential-mi-marker',\r\n      title: translate('Sequential Multi Instance'),\r\n      active: isSequential,\r\n      action: toggleLoopEntry,\r\n      options: {\r\n        loopCharacteristics: 'vdml:MultiInstanceLoopCharacteristics',\r\n        isSequential: true\r\n      }\r\n    },\r\n    {\r\n      id: 'toggle-loop',\r\n      className: 'bpmn-icon-loop-marker',\r\n      title: translate('Loop'),\r\n      active: isLoop,\r\n      action: toggleLoopEntry,\r\n      options: {\r\n        loopCharacteristics: 'vdml:StandardLoopCharacteristics'\r\n      }\r\n    }\r\n  ];\r\n  return loopEntries;\r\n};\r\n\r\n\r\n/**\r\n * Get the menu items containing a button for the ad hoc marker\r\n *\r\n * @param  {djs.model.Base} element\r\n *\r\n * @return {Object} a menu item\r\n */\r\nReplaceMenuProvider.prototype._getAdHocEntry = function(element) {\r\n  var translate = this._translate;\r\n  var businessObject = getBusinessObject(element);\r\n\r\n  var isAdHoc = is(businessObject, 'vdml:AdHocSubProcess');\r\n\r\n  var replaceElement = this._vdmlReplace.replaceElement;\r\n\r\n  var adHocEntry = {\r\n    id: 'toggle-adhoc',\r\n    className: 'bpmn-icon-ad-hoc-marker',\r\n    title: translate('Ad-hoc'),\r\n    active: isAdHoc,\r\n    action: function(event, entry) {\r\n      if (isAdHoc) {\r\n        return replaceElement(element, { type: 'vdml:SubProcess' });\r\n      } else {\r\n        return replaceElement(element, { type: 'vdml:AdHocSubProcess' });\r\n      }\r\n    }\r\n  };\r\n\r\n  return adHocEntry;\r\n};\r\n\r\nmodule.exports = ReplaceMenuProvider;\r\n","module.exports = {\r\n  __depends__: [\r\n    require(196),\r\n    require(78)\r\n  ],\r\n  __init__: [ 'replaceMenuProvider' ],\r\n  replaceMenuProvider: [ 'type', require(71) ]\r\n};","'use strict';\r\n\r\nvar getBusinessObject = require(93).getBusinessObject;\r\nvar isExpanded = require(91).isExpanded;\r\n\r\n/**\r\n * Returns true, if an element is from a different type\r\n * than a target definition. Takes into account the type,\r\n * event definition type and triggeredByEvent property.\r\n *\r\n * @param {djs.model.Base} element\r\n *\r\n * @return {Boolean}\r\n */\r\nfunction isDifferentType(element) {\r\n\r\n  return function(entry) {\r\n    var target = entry.target;\r\n\r\n    var businessObject = getBusinessObject(element),\r\n        eventDefinition = businessObject.eventDefinitions && businessObject.eventDefinitions[0];\r\n\r\n    var isTypeEqual = businessObject.$type === target.type;\r\n\r\n    var isEventDefinitionEqual = (\r\n      (eventDefinition && eventDefinition.$type) === target.eventDefinitionType\r\n    );\r\n\r\n    var isTriggeredByEventEqual = (\r\n      businessObject.triggeredByEvent === target.triggeredByEvent\r\n    );\r\n\r\n    var isExpandedEqual = (\r\n        target.isExpanded === undefined ||\r\n        target.isExpanded === isExpanded(businessObject)\r\n    );\r\n\r\n    return !isTypeEqual || !isEventDefinitionEqual || !isTriggeredByEventEqual || !isExpandedEqual;\r\n  };\r\n}\r\n\r\nmodule.exports.isDifferentType = isDifferentType;","'use strict';\r\n\r\nvar CommandInterceptor = require(100);\r\n\r\nvar inherits = require(270);\r\n\r\nvar assign = require(410),\r\n    forEach = require(283);\r\n\r\nvar LOW_PRIORITY = 250;\r\n\r\nfunction VdmlReplacePreview(eventBus, elementRegistry, elementFactory, canvas, previewSupport) {\r\n\r\n  CommandInterceptor.call(this, eventBus);\r\n\r\n  /**\r\n   * Replace the visuals of all elements in the context which can be replaced\r\n   *\r\n   * @param  {Object} context\r\n   */\r\n  function replaceVisual(context) {\r\n\r\n    var replacements = context.canExecute.replacements;\r\n\r\n    forEach(replacements, function(replacement) {\r\n\r\n      var id = replacement.oldElementId;\r\n\r\n      var newElement = {\r\n        type: replacement.newElementType\r\n      };\r\n\r\n      // if the visual of the element is already replaced\r\n      if (context.visualReplacements[id]) {\r\n        return;\r\n      }\r\n\r\n      var element = elementRegistry.get(id);\r\n\r\n      assign(newElement, { x: element.x, y: element.y });\r\n\r\n      // create a temporary shape\r\n      var tempShape = elementFactory.createShape(newElement);\r\n\r\n      canvas.addShape(tempShape, element.parent);\r\n\r\n      // select the original SVG element related to the element and hide it\r\n      var gfx = context.dragGroup.select('[data-element-id=' + element.id + ']');\r\n\r\n      if (gfx) {\r\n        gfx.attr({ display: 'none' });\r\n      }\r\n\r\n      // clone the gfx of the temporary shape and add it to the drag group\r\n      var dragger = previewSupport.addDragger(tempShape, context.dragGroup);\r\n\r\n      context.visualReplacements[id] = dragger;\r\n\r\n      canvas.removeShape(tempShape);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Restore the original visuals of the previously replaced elements\r\n   *\r\n   * @param  {Object} context\r\n   */\r\n  function restoreVisual(context) {\r\n\r\n    var visualReplacements = context.visualReplacements;\r\n\r\n    forEach(visualReplacements, function(dragger, id) {\r\n\r\n      var originalGfx = context.dragGroup.select('[data-element-id=' + id + ']');\r\n\r\n      if (originalGfx) {\r\n        originalGfx.attr({ display: 'inline' });\r\n      }\r\n\r\n      dragger.remove();\r\n\r\n      if (visualReplacements[id]) {\r\n        delete visualReplacements[id];\r\n      }\r\n    });\r\n  }\r\n\r\n  eventBus.on('shape.move.move', LOW_PRIORITY, function(event) {\r\n\r\n    var context = event.context,\r\n        canExecute = context.canExecute;\r\n\r\n    if (!context.visualReplacements) {\r\n      context.visualReplacements = {};\r\n    }\r\n\r\n    if (canExecute.replacements) {\r\n      replaceVisual(context);\r\n    } else {\r\n      restoreVisual(context);\r\n    }\r\n  });\r\n}\r\n\r\nVdmlReplacePreview.$inject = [ 'eventBus', 'elementRegistry', 'elementFactory', 'canvas', 'previewSupport' ];\r\n\r\ninherits(VdmlReplacePreview, CommandInterceptor);\r\n\r\nmodule.exports = VdmlReplacePreview;\r\n","module.exports = {\r\n  __depends__: [ require(198) ],\r\n  __init__: [ 'vdmlReplacePreview' ],\r\n  vdmlReplacePreview: [ 'type', require(74) ]\r\n};\r\n","'use strict';\r\n\r\nmodule.exports.START_EVENT = [\r\n  {\r\n    label: 'Start Event',\r\n    actionName: 'replace-with-none-start',\r\n    className: 'bpmn-icon-start-event-none',\r\n    target: {\r\n      type: 'vdml:StartEvent'\r\n    }\r\n  },\r\n  {\r\n    label: 'Intermediate Throw Event',\r\n    actionName: 'replace-with-none-intermediate-throwing',\r\n    className: 'bpmn-icon-intermediate-event-none',\r\n    target: {\r\n      type: 'vdml:IntermediateThrowEvent'\r\n    }\r\n  },\r\n  {\r\n    label: 'End Event',\r\n    actionName: 'replace-with-none-end',\r\n    className: 'bpmn-icon-end-event-none',\r\n    target: {\r\n      type: 'vdml:EndEvent'\r\n    }\r\n  },\r\n  {\r\n    label: 'Message Start Event',\r\n    actionName: 'replace-with-message-start',\r\n    className: 'bpmn-icon-start-event-message',\r\n    target: {\r\n      type: 'vdml:StartEvent',\r\n      eventDefinitionType: 'vdml:MessageEventDefinition'\r\n    }\r\n  },\r\n  {\r\n    label: 'Timer Start Event',\r\n    actionName: 'replace-with-timer-start',\r\n    className: 'bpmn-icon-start-event-timer',\r\n    target: {\r\n      type: 'vdml:StartEvent',\r\n      eventDefinitionType: 'vdml:TimerEventDefinition'\r\n    }\r\n  },\r\n  {\r\n    label: 'Conditional Start Event',\r\n    actionName: 'replace-with-conditional-start',\r\n    className: 'bpmn-icon-start-event-condition',\r\n    target: {\r\n      type: 'vdml:StartEvent',\r\n      eventDefinitionType: 'vdml:ConditionalEventDefinition'\r\n    }\r\n  },\r\n  {\r\n    label: 'Signal Start Event',\r\n    actionName: 'replace-with-signal-start',\r\n    className: 'bpmn-icon-start-event-signal',\r\n    target: {\r\n      type: 'vdml:StartEvent',\r\n      eventDefinitionType: 'vdml:SignalEventDefinition'\r\n    }\r\n  }\r\n];\r\n\r\nmodule.exports.INTERMEDIATE_EVENT = [\r\n  {\r\n    label: 'Start Event',\r\n    actionName: 'replace-with-none-start',\r\n    className: 'bpmn-icon-start-event-none',\r\n    target: {\r\n      type: 'vdml:StartEvent'\r\n    }\r\n  },\r\n  {\r\n    label: 'Intermediate Throw Event',\r\n    actionName: 'replace-with-none-intermediate-throw',\r\n    className: 'bpmn-icon-intermediate-event-none',\r\n    target: {\r\n      type: 'vdml:IntermediateThrowEvent'\r\n    }\r\n  },\r\n  {\r\n    label: 'End Event',\r\n    actionName: 'replace-with-none-end',\r\n    className: 'bpmn-icon-end-event-none',\r\n    target: {\r\n      type: 'vdml:EndEvent'\r\n    }\r\n  },\r\n  {\r\n    label: 'Message Intermediate Catch Event',\r\n    actionName: 'replace-with-message-intermediate-catch',\r\n    className: 'bpmn-icon-intermediate-event-catch-message',\r\n    target: {\r\n      type: 'vdml:IntermediateCatchEvent',\r\n      eventDefinitionType: 'vdml:MessageEventDefinition'\r\n    }\r\n  },\r\n  {\r\n    label: 'Message Intermediate Throw Event',\r\n    actionName: 'replace-with-message-intermediate-throw',\r\n    className: 'bpmn-icon-intermediate-event-throw-message',\r\n    target: {\r\n      type: 'vdml:IntermediateThrowEvent',\r\n      eventDefinitionType: 'vdml:MessageEventDefinition'\r\n    }\r\n  },\r\n  {\r\n    label: 'Timer Intermediate Catch Event',\r\n    actionName: 'replace-with-timer-intermediate-catch',\r\n    className: 'bpmn-icon-intermediate-event-catch-timer',\r\n    target: {\r\n      type: 'vdml:IntermediateCatchEvent',\r\n      eventDefinitionType: 'vdml:TimerEventDefinition'\r\n    }\r\n  },\r\n  {\r\n    label: 'Escalation Intermediate Throw Event',\r\n    actionName: 'replace-with-escalation-intermediate-throw',\r\n    className: 'bpmn-icon-intermediate-event-throw-escalation',\r\n    target: {\r\n      type: 'vdml:IntermediateThrowEvent',\r\n      eventDefinitionType: 'vdml:EscalationEventDefinition'\r\n    }\r\n  },\r\n  {\r\n    label: 'Conditional Intermediate Catch Event',\r\n    actionName: 'replace-with-conditional-intermediate-catch',\r\n    className: 'bpmn-icon-intermediate-event-catch-condition',\r\n    target: {\r\n      type: 'vdml:IntermediateCatchEvent',\r\n      eventDefinitionType: 'vdml:ConditionalEventDefinition'\r\n    }\r\n  },\r\n  {\r\n    label: 'Link Intermediate Catch Event',\r\n    actionName: 'replace-with-link-intermediate-catch',\r\n    className: 'bpmn-icon-intermediate-event-catch-link',\r\n    target: {\r\n      type: 'vdml:IntermediateCatchEvent',\r\n      eventDefinitionType: 'vdml:LinkEventDefinition'\r\n    }\r\n  },\r\n  {\r\n    label: 'Link Intermediate Throw Event',\r\n    actionName: 'replace-with-link-intermediate-throw',\r\n    className: 'bpmn-icon-intermediate-event-throw-link',\r\n    target: {\r\n      type: 'vdml:IntermediateThrowEvent',\r\n      eventDefinitionType: 'vdml:LinkEventDefinition'\r\n    }\r\n  },\r\n  {\r\n    label: 'Compensation Intermediate Throw Event',\r\n    actionName: 'replace-with-compensation-intermediate-throw',\r\n    className: 'bpmn-icon-intermediate-event-throw-compensation',\r\n    target: {\r\n      type: 'vdml:IntermediateThrowEvent',\r\n      eventDefinitionType: 'vdml:CompensateEventDefinition'\r\n    }\r\n  },\r\n  {\r\n    label: 'Signal Intermediate Catch Event',\r\n    actionName: 'replace-with-signal-intermediate-catch',\r\n    className: 'bpmn-icon-intermediate-event-catch-signal',\r\n    target: {\r\n      type: 'vdml:IntermediateCatchEvent',\r\n      eventDefinitionType: 'vdml:SignalEventDefinition'\r\n    }\r\n  },\r\n  {\r\n    label: 'Signal Intermediate Throw Event',\r\n    actionName: 'replace-with-signal-intermediate-throw',\r\n    className: 'bpmn-icon-intermediate-event-throw-signal',\r\n    target: {\r\n      type: 'vdml:IntermediateThrowEvent',\r\n      eventDefinitionType: 'vdml:SignalEventDefinition'\r\n    }\r\n  }\r\n];\r\n\r\nmodule.exports.END_EVENT = [\r\n  {\r\n    label: 'Start Event',\r\n    actionName: 'replace-with-none-start',\r\n    className: 'bpmn-icon-start-event-none',\r\n    target: {\r\n      type: 'vdml:StartEvent'\r\n    }\r\n  },\r\n  {\r\n    label: 'Intermediate Throw Event',\r\n    actionName: 'replace-with-none-intermediate-throw',\r\n    className: 'bpmn-icon-intermediate-event-none',\r\n    target: {\r\n      type: 'vdml:IntermediateThrowEvent'\r\n    }\r\n  },\r\n  {\r\n    label: 'End Event',\r\n    actionName: 'replace-with-none-end',\r\n    className: 'bpmn-icon-end-event-none',\r\n    target: {\r\n      type: 'vdml:EndEvent'\r\n    }\r\n  },\r\n  {\r\n    label: 'Message End Event',\r\n    actionName: 'replace-with-message-end',\r\n    className: 'bpmn-icon-end-event-message',\r\n    target: {\r\n      type: 'vdml:EndEvent',\r\n      eventDefinitionType: 'vdml:MessageEventDefinition'\r\n    }\r\n  },\r\n  {\r\n    label: 'Escalation End Event',\r\n    actionName: 'replace-with-escalation-end',\r\n    className: 'bpmn-icon-end-event-escalation',\r\n    target: {\r\n      type: 'vdml:EndEvent',\r\n      eventDefinitionType: 'vdml:EscalationEventDefinition'\r\n    }\r\n  },\r\n  {\r\n    label: 'Error End Event',\r\n    actionName: 'replace-with-error-end',\r\n    className: 'bpmn-icon-end-event-error',\r\n    target: {\r\n      type: 'vdml:EndEvent',\r\n      eventDefinitionType: 'vdml:ErrorEventDefinition'\r\n    }\r\n  },\r\n  {\r\n    label: 'Cancel End Event',\r\n    actionName: 'replace-with-cancel-end',\r\n    className: 'bpmn-icon-end-event-cancel',\r\n    target: {\r\n      type: 'vdml:EndEvent',\r\n      eventDefinitionType: 'vdml:CancelEventDefinition'\r\n    }\r\n  },\r\n  {\r\n    label: 'Compensation End Event',\r\n    actionName: 'replace-with-compensation-end',\r\n    className: 'bpmn-icon-end-event-compensation',\r\n    target: {\r\n      type: 'vdml:EndEvent',\r\n      eventDefinitionType: 'vdml:CompensateEventDefinition'\r\n    }\r\n  },\r\n  {\r\n    label: 'Signal End Event',\r\n    actionName: 'replace-with-signal-end',\r\n    className: 'bpmn-icon-end-event-signal',\r\n    target: {\r\n      type: 'vdml:EndEvent',\r\n      eventDefinitionType: 'vdml:SignalEventDefinition'\r\n    }\r\n  },\r\n  {\r\n    label: 'Terminate End Event',\r\n    actionName: 'replace-with-terminate-end',\r\n    className: 'bpmn-icon-end-event-terminate',\r\n    target: {\r\n      type: 'vdml:EndEvent',\r\n      eventDefinitionType: 'vdml:TerminateEventDefinition'\r\n    }\r\n  }\r\n];\r\n\r\nmodule.exports.GATEWAY = [\r\n  {\r\n    label: 'Exclusive Gateway',\r\n    actionName: 'replace-with-exclusive-gateway',\r\n    className: 'bpmn-icon-gateway-xor',\r\n    target: {\r\n      type: 'vdml:ExclusiveGateway'\r\n    }\r\n  },\r\n  {\r\n    label: 'Parallel Gateway',\r\n    actionName: 'replace-with-parallel-gateway',\r\n    className: 'bpmn-icon-gateway-parallel',\r\n    target: {\r\n      type: 'vdml:ParallelGateway'\r\n    }\r\n  },\r\n  {\r\n    label: 'Inclusive Gateway',\r\n    actionName: 'replace-with-inclusive-gateway',\r\n    className: 'bpmn-icon-gateway-or',\r\n    target: {\r\n      type: 'vdml:InclusiveGateway'\r\n    }\r\n  },\r\n  {\r\n    label: 'Complex Gateway',\r\n    actionName: 'replace-with-complex-gateway',\r\n    className: 'bpmn-icon-gateway-complex',\r\n    target: {\r\n      type: 'vdml:ComplexGateway'\r\n    }\r\n  },\r\n  {\r\n    label: 'Event based Gateway',\r\n    actionName: 'replace-with-event-based-gateway',\r\n    className: 'bpmn-icon-gateway-eventbased',\r\n    target: {\r\n      type: 'vdml:EventBasedGateway',\r\n      instantiate: false,\r\n      eventGatewayType: 'Exclusive'\r\n    }\r\n  }\r\n  // Gateways deactivated until https://github.com/vdml-io/vdml-js/issues/194\r\n  // {\r\n  //   label: 'Event based instantiating Gateway',\r\n  //   actionName: 'replace-with-exclusive-event-based-gateway',\r\n  //   className: 'bpmn-icon-exclusive-event-based',\r\n  //   target: {\r\n  //     type: 'vdml:EventBasedGateway'\r\n  //   },\r\n  //   options: {\r\n  //     businessObject: { instantiate: true, eventGatewayType: 'Exclusive' }\r\n  //   }\r\n  // },\r\n  // {\r\n  //   label: 'Parallel Event based instantiating Gateway',\r\n  //   actionName: 'replace-with-parallel-event-based-instantiate-gateway',\r\n  //   className: 'bpmn-icon-parallel-event-based-instantiate-gateway',\r\n  //   target: {\r\n  //     type: 'vdml:EventBasedGateway'\r\n  //   },\r\n  //   options: {\r\n  //     businessObject: { instantiate: true, eventGatewayType: 'Parallel' }\r\n  //   }\r\n  // }\r\n];\r\n\r\nmodule.exports.SUBPROCESS_EXPANDED = [\r\n  {\r\n    label: 'Transaction',\r\n    actionName: 'replace-with-transaction',\r\n    className: 'bpmn-icon-transaction',\r\n    target: {\r\n      type: 'vdml:Transaction',\r\n      isExpanded: true\r\n    }\r\n  },\r\n  {\r\n    label: 'Event Sub Process',\r\n    actionName: 'replace-with-event-subprocess',\r\n    className: 'bpmn-icon-event-subprocess-expanded',\r\n    target: {\r\n      type: 'vdml:SubProcess',\r\n      triggeredByEvent: true,\r\n      isExpanded: true\r\n    }\r\n  },\r\n  {\r\n    label: 'Sub Process (collapsed)',\r\n    actionName: 'replace-with-collapsed-subprocess',\r\n    className: 'bpmn-icon-subprocess-collapsed',\r\n    target: {\r\n      type: 'vdml:SubProcess',\r\n      isExpanded: false\r\n    }\r\n  }\r\n];\r\n\r\nmodule.exports.TRANSACTION = [\r\n  {\r\n    label: 'Sub Process',\r\n    actionName: 'replace-with-subprocess',\r\n    className: 'bpmn-icon-subprocess-expanded',\r\n    target: {\r\n      type: 'vdml:SubProcess',\r\n      isExpanded: true\r\n    }\r\n  },\r\n  {\r\n    label: 'Event Sub Process',\r\n    actionName: 'replace-with-event-subprocess',\r\n    className: 'bpmn-icon-event-subprocess-expanded',\r\n    target: {\r\n      type: 'vdml:SubProcess',\r\n      triggeredByEvent: true,\r\n      isExpanded: true\r\n    }\r\n  }\r\n];\r\n\r\nmodule.exports.EVENT_SUB_PROCESS = [\r\n  {\r\n    label: 'Sub Process',\r\n    actionName: 'replace-with-subprocess',\r\n    className: 'bpmn-icon-subprocess-expanded',\r\n    target: {\r\n      type: 'vdml:SubProcess',\r\n      isExpanded: true\r\n    }\r\n  },\r\n  {\r\n    label: 'Transaction',\r\n    actionName: 'replace-with-transaction',\r\n    className: 'bpmn-icon-transaction',\r\n    target: {\r\n      type: 'vdml:Transaction',\r\n      isExpanded: true\r\n    }\r\n  }\r\n];\r\n\r\nmodule.exports.TASK = [\r\n  {\r\n    label: 'Task',\r\n    actionName: 'replace-with-task',\r\n    className: 'bpmn-icon-task',\r\n    target: {\r\n      type: 'vdml:Task'\r\n    }\r\n  },\r\n  {\r\n    label: 'Send Task',\r\n    actionName: 'replace-with-send-task',\r\n    className: 'bpmn-icon-send',\r\n    target: {\r\n      type: 'vdml:SendTask'\r\n    }\r\n  },\r\n  {\r\n    label: 'Receive Task',\r\n    actionName: 'replace-with-receive-task',\r\n    className: 'bpmn-icon-receive',\r\n    target: {\r\n      type: 'vdml:ReceiveTask'\r\n    }\r\n  },\r\n  {\r\n    label: 'User Task',\r\n    actionName: 'replace-with-user-task',\r\n    className: 'bpmn-icon-user',\r\n    target: {\r\n      type: 'vdml:UserTask'\r\n    }\r\n  },\r\n  {\r\n    label: 'Manual Task',\r\n    actionName: 'replace-with-manual-task',\r\n    className: 'bpmn-icon-manual',\r\n    target: {\r\n      type: 'vdml:ManualTask'\r\n    }\r\n  },\r\n  {\r\n    label: 'Business Rule Task',\r\n    actionName: 'replace-with-rule-task',\r\n    className: 'bpmn-icon-business-rule',\r\n    target: {\r\n      type: 'vdml:BusinessRuleTask'\r\n    }\r\n  },\r\n  {\r\n    label: 'Service Task',\r\n    actionName: 'replace-with-service-task',\r\n    className: 'bpmn-icon-service',\r\n    target: {\r\n      type: 'vdml:ServiceTask'\r\n    }\r\n  },\r\n  {\r\n    label: 'Script Task',\r\n    actionName: 'replace-with-script-task',\r\n    className: 'bpmn-icon-script',\r\n    target: {\r\n      type: 'vdml:ScriptTask'\r\n    }\r\n  },\r\n  {\r\n    label: 'Call Activity',\r\n    actionName: 'replace-with-call-activity',\r\n    className: 'bpmn-icon-call-activity',\r\n    target: {\r\n      type: 'vdml:CallActivity'\r\n    }\r\n  },\r\n  {\r\n    label: 'Sub Process (collapsed)',\r\n    actionName: 'replace-with-collapsed-subprocess',\r\n    className: 'bpmn-icon-subprocess-collapsed',\r\n    target: {\r\n      type: 'vdml:SubProcess',\r\n      isExpanded: false\r\n    }\r\n  },\r\n  {\r\n    label: 'Sub Process (expanded)',\r\n    actionName: 'replace-with-expanded-subprocess',\r\n    className: 'bpmn-icon-subprocess-expanded',\r\n    target: {\r\n      type: 'vdml:SubProcess',\r\n      isExpanded: true\r\n    }\r\n  }\r\n];\r\n\r\nmodule.exports.BOUNDARY_EVENT = [\r\n  {\r\n    label: 'Message Boundary Event',\r\n    actionName: 'replace-with-message-boundary',\r\n    className: 'bpmn-icon-intermediate-event-catch-message',\r\n    target: {\r\n      type: 'vdml:BoundaryEvent',\r\n      eventDefinitionType: 'vdml:MessageEventDefinition'\r\n    }\r\n  },\r\n  {\r\n    label: 'Timer Boundary Event',\r\n    actionName: 'replace-with-timer-boundary',\r\n    className: 'bpmn-icon-intermediate-event-catch-timer',\r\n    target: {\r\n      type: 'vdml:BoundaryEvent',\r\n      eventDefinitionType: 'vdml:TimerEventDefinition'\r\n    }\r\n  },\r\n  {\r\n    label: 'Escalation Boundary Event',\r\n    actionName: 'replace-with-escalation-boundary',\r\n    className: 'bpmn-icon-intermediate-event-catch-escalation',\r\n    target: {\r\n      type: 'vdml:BoundaryEvent',\r\n      eventDefinitionType: 'vdml:EscalationEventDefinition'\r\n    }\r\n  },\r\n  {\r\n    label: 'Conditional Boundary Event',\r\n    actionName: 'replace-with-conditional-boundary',\r\n    className: 'bpmn-icon-intermediate-event-catch-condition',\r\n    target: {\r\n      type: 'vdml:BoundaryEvent',\r\n      eventDefinitionType: 'vdml:ConditionalEventDefinition'\r\n    }\r\n  },\r\n  {\r\n    label: 'Error Boundary Event',\r\n    actionName: 'replace-with-error-boundary',\r\n    className: 'bpmn-icon-intermediate-event-catch-error',\r\n    target: {\r\n      type: 'vdml:BoundaryEvent',\r\n      eventDefinitionType: 'vdml:ErrorEventDefinition'\r\n    }\r\n  },\r\n  {\r\n    label: 'Cancel Boundary Event',\r\n    actionName: 'replace-with-cancel-boundary',\r\n    className: 'bpmn-icon-intermediate-event-catch-cancel',\r\n    target: {\r\n      type: 'vdml:BoundaryEvent',\r\n      eventDefinitionType: 'vdml:CancelEventDefinition'\r\n    }\r\n  },\r\n  {\r\n    label: 'Signal Boundary Event',\r\n    actionName: 'replace-with-signal-boundary',\r\n    className: 'bpmn-icon-intermediate-event-catch-signal',\r\n    target: {\r\n      type: 'vdml:BoundaryEvent',\r\n      eventDefinitionType: 'vdml:SignalEventDefinition'\r\n    }\r\n  },\r\n  {\r\n    label: 'Compensation Boundary Event',\r\n    actionName: 'replace-with-compensation-boundary',\r\n    className: 'bpmn-icon-intermediate-event-catch-compensation',\r\n    target: {\r\n      type: 'vdml:BoundaryEvent',\r\n      eventDefinitionType: 'vdml:CompensateEventDefinition'\r\n    }\r\n  },\r\n  {\r\n    label: 'Message Boundary Event (non-interrupting)',\r\n    actionName: 'replace-with-non-interrupting-message-boundary',\r\n    className: 'bpmn-icon-intermediate-event-catch-non-interrupting-message',\r\n    target: {\r\n      type: 'vdml:BoundaryEvent',\r\n      eventDefinitionType: 'vdml:MessageEventDefinition',\r\n      cancelActivity: false\r\n    }\r\n  },\r\n  {\r\n    label: 'Timer Boundary Event (non-interrupting)',\r\n    actionName: 'replace-with-non-interrupting-timer-boundary',\r\n    className: 'bpmn-icon-intermediate-event-catch-non-interrupting-timer',\r\n    target: {\r\n      type: 'vdml:BoundaryEvent',\r\n      eventDefinitionType: 'vdml:TimerEventDefinition',\r\n      cancelActivity: false\r\n    }\r\n  },\r\n  {\r\n    label: 'Escalation Boundary Event (non-interrupting)',\r\n    actionName: 'replace-with-non-interrupting-escalation-boundary',\r\n    className: 'bpmn-icon-intermediate-event-catch-non-interrupting-escalation',\r\n    target: {\r\n      type: 'vdml:BoundaryEvent',\r\n      eventDefinitionType: 'vdml:EscalationEventDefinition',\r\n      cancelActivity: false\r\n    }\r\n  },\r\n  {\r\n    label: 'Conditional Boundary Event (non-interrupting)',\r\n    actionName: 'replace-with-non-interrupting-conditional-boundary',\r\n    className: 'bpmn-icon-intermediate-event-catch-non-interrupting-condition',\r\n    target: {\r\n      type: 'vdml:BoundaryEvent',\r\n      eventDefinitionType: 'vdml:ConditionalEventDefinition',\r\n      cancelActivity: false\r\n    }\r\n  },\r\n  {\r\n    label: 'Signal Boundary Event (non-interrupting)',\r\n    actionName: 'replace-with-non-interrupting-signal-boundary',\r\n    className: 'bpmn-icon-intermediate-event-catch-non-interrupting-signal',\r\n    target: {\r\n      type: 'vdml:BoundaryEvent',\r\n      eventDefinitionType: 'vdml:SignalEventDefinition',\r\n      cancelActivity: false\r\n    }\r\n  }\r\n];\r\n\r\nmodule.exports.EVENT_SUB_PROCESS_START_EVENT = [\r\n  {\r\n    label: 'Message Start Event',\r\n    actionName: 'replace-with-message-start',\r\n    className: 'bpmn-icon-start-event-message',\r\n    target: {\r\n      type: 'vdml:StartEvent',\r\n      eventDefinitionType: 'vdml:MessageEventDefinition'\r\n    }\r\n  },\r\n  {\r\n    label: 'Timer Start Event',\r\n    actionName: 'replace-with-timer-start',\r\n    className: 'bpmn-icon-start-event-timer',\r\n    target: {\r\n      type: 'vdml:StartEvent',\r\n      eventDefinitionType: 'vdml:TimerEventDefinition'\r\n    }\r\n  },\r\n  {\r\n    label: 'Conditional Start Event',\r\n    actionName: 'replace-with-conditional-start',\r\n    className: 'bpmn-icon-start-event-condition',\r\n    target: {\r\n      type: 'vdml:StartEvent',\r\n      eventDefinitionType: 'vdml:ConditionalEventDefinition'\r\n    }\r\n  },\r\n  {\r\n    label: 'Signal Start Event',\r\n    actionName: 'replace-with-signal-start',\r\n    className: 'bpmn-icon-start-event-signal',\r\n    target: {\r\n      type: 'vdml:StartEvent',\r\n      eventDefinitionType: 'vdml:SignalEventDefinition'\r\n    }\r\n  },\r\n  {\r\n    label: 'Error Start Event',\r\n    actionName: 'replace-with-error-start',\r\n    className: 'bpmn-icon-start-event-error',\r\n    target: {\r\n      type: 'vdml:StartEvent',\r\n      eventDefinitionType: 'vdml:ErrorEventDefinition'\r\n    }\r\n  },\r\n  {\r\n    label: 'Escalation Start Event',\r\n    actionName: 'replace-with-escalation-start',\r\n    className: 'bpmn-icon-start-event-escalation',\r\n    target: {\r\n      type: 'vdml:StartEvent',\r\n      eventDefinitionType: 'vdml:EscalationEventDefinition'\r\n    }\r\n  },\r\n  {\r\n    label: 'Compensation Start Event',\r\n    actionName: 'replace-with-compensation-start',\r\n    className: 'bpmn-icon-start-event-compensation',\r\n    target: {\r\n      type: 'vdml:StartEvent',\r\n      eventDefinitionType: 'vdml:CompensateEventDefinition'\r\n    }\r\n  },\r\n  {\r\n    label: 'Message Start Event (non-interrupting)',\r\n    actionName: 'replace-with-non-interrupting-message-start',\r\n    className: 'bpmn-icon-start-event-non-interrupting-message',\r\n    target: {\r\n      type: 'vdml:StartEvent',\r\n      eventDefinitionType: 'vdml:MessageEventDefinition',\r\n      isInterrupting: false\r\n    }\r\n  },\r\n  {\r\n    label: 'Timer Start Event (non-interrupting)',\r\n    actionName: 'replace-with-non-interrupting-timer-start',\r\n    className: 'bpmn-icon-start-event-non-interrupting-timer',\r\n    target: {\r\n      type: 'vdml:StartEvent',\r\n      eventDefinitionType: 'vdml:TimerEventDefinition',\r\n      isInterrupting: false\r\n    }\r\n  },\r\n  {\r\n    label: 'Conditional Start Event (non-interrupting)',\r\n    actionName: 'replace-with-non-interrupting-conditional-start',\r\n    className: 'bpmn-icon-start-event-non-interrupting-condition',\r\n    target: {\r\n      type: 'vdml:StartEvent',\r\n      eventDefinitionType: 'vdml:ConditionalEventDefinition',\r\n      isInterrupting: false\r\n    }\r\n  },\r\n  {\r\n    label: 'Signal Start Event (non-interrupting)',\r\n    actionName: 'replace-with-non-interrupting-signal-start',\r\n    className: 'bpmn-icon-start-event-non-interrupting-signal',\r\n    target: {\r\n      type: 'vdml:StartEvent',\r\n      eventDefinitionType: 'vdml:SignalEventDefinition',\r\n      isInterrupting: false\r\n    }\r\n  },\r\n  {\r\n    label: 'Escalation Start Event (non-interrupting)',\r\n    actionName: 'replace-with-non-interrupting-escalation-start',\r\n    className: 'bpmn-icon-start-event-non-interrupting-escalation',\r\n    target: {\r\n      type: 'vdml:StartEvent',\r\n      eventDefinitionType: 'vdml:EscalationEventDefinition',\r\n      isInterrupting: false\r\n    }\r\n  }\r\n];\r\n\r\nmodule.exports.SEQUENCE_FLOW = [\r\n  {\r\n    label: 'Sequence Flow',\r\n    actionName: 'replace-with-sequence-flow',\r\n    className: 'bpmn-icon-connection'\r\n  },\r\n  {\r\n    label: 'Default Flow',\r\n    actionName: 'replace-with-default-flow',\r\n    className: 'bpmn-icon-default-flow'\r\n  },\r\n  {\r\n    label: 'Conditional Flow',\r\n    actionName: 'replace-with-conditional-flow',\r\n    className: 'bpmn-icon-conditional-flow'\r\n  }\r\n];\r\n\r\nmodule.exports.PARTICIPANT = [\r\n  {\r\n    label: 'Expanded Pool',\r\n    actionName: 'replace-with-expanded-pool',\r\n    className: 'bpmn-icon-participant',\r\n    target: {\r\n      type: 'vdml:Participant',\r\n      isExpanded: true\r\n    }\r\n  },\r\n  {\r\n    label: 'Collapsed Pool',\r\n    actionName: 'replace-with-collapsed-pool',\r\n    // TODO(@janstuemmel): maybe design new icon\r\n    className: 'bpmn-icon-lane',\r\n    target: {\r\n      type: 'vdml:Participant',\r\n      isExpanded: false\r\n    }\r\n  }\r\n];\r\n","'use strict';\r\n\r\nvar pick = require(417),\r\n    assign = require(410),\r\n    has = require(411);\r\n\r\nvar is = require(93).is,\r\n    isExpanded = require(91).isExpanded,\r\n    isEventSubProcess = require(91).isEventSubProcess;\r\n\r\nvar CUSTOM_PROPERTIES = [\r\n  'cancelActivity',\r\n  'instantiate',\r\n  'eventGatewayType',\r\n  'triggeredByEvent',\r\n  'isInterrupting'\r\n];\r\n\r\nfunction toggeling(element, target) {\r\n\r\n  var oldCollapsed = has(element, 'collapsed') ?\r\n                     element.collapsed : !isExpanded(element);\r\n\r\n  var targetCollapsed;\r\n\r\n  if (has(target, 'collapsed') || has(target, 'isExpanded')) {\r\n    // property is explicitly set so use it\r\n    targetCollapsed = has(target, 'collapsed') ?\r\n                      target.collapsed : !target.isExpanded;\r\n  } else {\r\n    // keep old state\r\n    targetCollapsed = oldCollapsed;\r\n  }\r\n\r\n  if (oldCollapsed !== targetCollapsed) {\r\n    element.collapsed = oldCollapsed;\r\n    return true;\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\n\r\n/**\r\n * This module takes care of replacing VDML elements\r\n */\r\nfunction VdmlReplace(vdmlFactory, replace, selection, modeling) {\r\n\r\n  /**\r\n   * Prepares a new business object for the replacement element\r\n   * and triggers the replace operation.\r\n   *\r\n   * @param  {djs.model.Base} element\r\n   * @param  {Object} target\r\n   * @param  {Object} [hints]\r\n   *\r\n   * @return {djs.model.Base} the newly created element\r\n   */\r\n  function replaceElement(element, target, hints) {\r\n\r\n    hints = hints || {};\r\n\r\n    var type = target.type,\r\n        oldBusinessObject = element.businessObject;\r\n\r\n\r\n\r\n    if (is(oldBusinessObject, 'vdml:SubProcess')) {\r\n      if (type === 'vdml:SubProcess') {\r\n        if (toggeling(element, target)) {\r\n          // expanding or collapsing process\r\n          modeling.toggleCollapse(element);\r\n\r\n          return element;\r\n        }\r\n      }\r\n    }\r\n\r\n\r\n    var newBusinessObject = vdmlFactory.create(type);\r\n\r\n    var newElement = {\r\n      type: type,\r\n      businessObject: newBusinessObject\r\n    };\r\n\r\n    // initialize custom VDML extensions\r\n    if (target.eventDefinitionType) {\r\n      newElement.eventDefinitionType = target.eventDefinitionType;\r\n    }\r\n\r\n    // initialize special properties defined in target definition\r\n    assign(newBusinessObject, pick(target, CUSTOM_PROPERTIES));\r\n\r\n\r\n    if (is(oldBusinessObject, 'vdml:Activity')) {\r\n\r\n      if (is(oldBusinessObject, 'vdml:SubProcess')) {\r\n        // no toggeling, so keep old state\r\n        newElement.isExpanded = isExpanded(oldBusinessObject);\r\n      }\r\n      // else if property is explicitly set, use it\r\n      else if (has(target, 'isExpanded')) {\r\n        newElement.isExpanded = target.isExpanded;\r\n      }\r\n\r\n      // TODO: need also to respect min/max Size\r\n      // copy size, from an expanded subprocess to an expanded alternative subprocess\r\n      // except vdml:Task, because Task is always expanded\r\n      if ((isExpanded(oldBusinessObject) && !is(oldBusinessObject, 'vdml:Task')) && target.isExpanded) {\r\n        newElement.width = element.width;\r\n        newElement.height = element.height;\r\n      }\r\n\r\n    }\r\n\r\n    // transform collapsed/expanded pools\r\n    if (is(oldBusinessObject, 'vdml:Participant')) {\r\n\r\n        // create expanded pool\r\n      if (target.isExpanded === true) {\r\n        newBusinessObject.processRef = vdmlFactory.create('vdml:Process');\r\n      } else {\r\n          // remove children when transforming to collapsed pool\r\n        hints.moveChildren = false;\r\n      }\r\n\r\n        // apply same size\r\n      newElement.width = element.width;\r\n      newElement.height = element.height;\r\n    }\r\n\r\n    newBusinessObject.name = oldBusinessObject.name;\r\n\r\n    // retain loop characteristics if the target element is not an event sub process\r\n    if (!isEventSubProcess(newBusinessObject)) {\r\n      newBusinessObject.loopCharacteristics = oldBusinessObject.loopCharacteristics;\r\n    }\r\n\r\n    // retain default flow's reference between inclusive <-> exclusive gateways and activities\r\n    if ((is(oldBusinessObject, 'vdml:ExclusiveGateway') || is(oldBusinessObject, 'vdml:InclusiveGateway') ||\r\n         is(oldBusinessObject, 'vdml:Activity')) &&\r\n        (is(newBusinessObject, 'vdml:ExclusiveGateway') || is(newBusinessObject, 'vdml:InclusiveGateway') ||\r\n         is(newBusinessObject, 'vdml:Activity')))\r\n    {\r\n      newBusinessObject.default = oldBusinessObject.default;\r\n    }\r\n\r\n    if (oldBusinessObject.isForCompensation) {\r\n      newBusinessObject.isForCompensation = true;\r\n    }\r\n\r\n    newElement = replace.replaceElement(element, newElement, hints);\r\n\r\n    if (hints.select !== false) {\r\n      selection.select(newElement);\r\n    }\r\n\r\n    return newElement;\r\n  }\r\n\r\n  this.replaceElement = replaceElement;\r\n}\r\n\r\nVdmlReplace.$inject = [ 'vdmlFactory', 'replace', 'selection', 'modeling' ];\r\n\r\nmodule.exports = VdmlReplace;\r\n","module.exports = {\r\n  __depends__: [\r\n    require(200),\r\n    require(214)\r\n  ],\r\n  vdmlReplace: [ 'type', require(77) ]\r\n};","'use strict';\r\n\r\nvar find = require(282),\r\n    any = require(279),\r\n    every = require(280),\r\n    filter = require(281),\r\n    forEach = require(283),\r\n    inherits = require(270);\r\n\r\nvar getParents = require(66).getParents,\r\n    is = require(93).is,\r\n    isAny = require(66).isAny,\r\n    getBusinessObject = require(93).getBusinessObject,\r\n    isExpanded = require(91).isExpanded,\r\n    isEventSubProcess = require(91).isEventSubProcess,\r\n    isInterrupting = require(91).isInterrupting;\r\n\r\n\r\nvar RuleProvider = require(206);\r\n\r\nvar isBoundaryAttachment = require(84).getBoundaryAttachment;\r\n\r\n/**\r\n * VDML specific modeling rule\r\n */\r\nfunction VdmlRules(eventBus) {\r\n  RuleProvider.call(this, eventBus);\r\n}\r\n\r\ninherits(VdmlRules, RuleProvider);\r\n\r\nVdmlRules.$inject = [ 'eventBus' ];\r\n\r\nmodule.exports = VdmlRules;\r\n\r\nVdmlRules.prototype.init = function() {\r\n\r\n  this.addRule('connection.create', function(context) {\r\n    var source = context.source,\r\n        target = context.target;\r\n\r\n    return canConnect(source, target);\r\n  });\r\n\r\n  this.addRule('connection.reconnectStart', function(context) {\r\n\r\n    var connection = context.connection,\r\n        source = context.hover || context.source,\r\n        target = connection.target;\r\n\r\n    return canConnect(source, target, connection);\r\n  });\r\n\r\n  this.addRule('connection.reconnectEnd', function(context) {\r\n\r\n    var connection = context.connection,\r\n        source = connection.source,\r\n        target = context.hover || context.target;\r\n\r\n    return canConnect(source, target, connection);\r\n  });\r\n\r\n  this.addRule('connection.updateWaypoints', function(context) {\r\n    // OK! but visually ignore\r\n    return null;\r\n  });\r\n\r\n  this.addRule('shape.resize', function(context) {\r\n\r\n    var shape = context.shape,\r\n        newBounds = context.newBounds;\r\n\r\n    return canResize(shape, newBounds);\r\n  });\r\n\r\n  this.addRule('elements.move', function(context) {\r\n\r\n    var target = context.target,\r\n        shapes = context.shapes,\r\n        position = context.position;\r\n\r\n    return canAttach(shapes, target, null, position) ||\r\n           canReplace(shapes, target, position) ||\r\n           canMove(shapes, target, position);\r\n  });\r\n\r\n  this.addRule([ 'shape.create', 'shape.append' ], function(context) {\r\n    var target = context.target,\r\n        shape = context.shape,\r\n        source = context.source,\r\n        position = context.position;\r\n\r\n    return canAttach([ shape ], target, source, position) || canCreate(shape, target, source, position);\r\n  });\r\n\r\n  this.addRule('element.copy', function(context) {\r\n    var collection = context.collection,\r\n        element = context.element;\r\n\r\n    return canCopy(collection, element);\r\n  });\r\n\r\n  this.addRule('element.paste', function(context) {\r\n    var parent = context.parent,\r\n        element = context.element,\r\n        position = context.position,\r\n        source = context.source,\r\n        target = context.target;\r\n\r\n    if (source || target) {\r\n      return canConnect(source, target);\r\n    }\r\n\r\n    return canAttach([ element ], parent, null, position) || canCreate(element, parent, null, position);\r\n  });\r\n\r\n  this.addRule('elements.paste', function(context) {\r\n    var tree = context.tree,\r\n        target = context.target;\r\n\r\n    return canPaste(tree, target);\r\n  });\r\n\r\n  this.addRule([ 'elements.delete' ], function(context) {\r\n\r\n    // do not allow deletion of labels\r\n    return filter(context.elements, function(e) {\r\n      return !isLabel(e);\r\n    });\r\n  });\r\n};\r\n\r\nVdmlRules.prototype.canConnectMessageFlow = canConnectMessageFlow;\r\n\r\nVdmlRules.prototype.canConnectSequenceFlow = canConnectSequenceFlow;\r\n\r\nVdmlRules.prototype.canConnectDataAssociation = canConnectDataAssociation;\r\n\r\nVdmlRules.prototype.canConnectAssociation = canConnectAssociation;\r\n\r\nVdmlRules.prototype.canMove = canMove;\r\n\r\nVdmlRules.prototype.canAttach = canAttach;\r\n\r\nVdmlRules.prototype.canReplace = canReplace;\r\n\r\nVdmlRules.prototype.canDrop = canDrop;\r\n\r\nVdmlRules.prototype.canInsert = canInsert;\r\n\r\nVdmlRules.prototype.canCreate = canCreate;\r\n\r\nVdmlRules.prototype.canConnect = canConnect;\r\n\r\nVdmlRules.prototype.canResize = canResize;\r\n\r\nVdmlRules.prototype.canCopy = canCopy;\r\n\r\n/**\r\n * Utility functions for rule checking\r\n */\r\n\r\nfunction nonExistantOrLabel(element) {\r\n  return !element || isLabel(element);\r\n}\r\n\r\nfunction isSame(a, b) {\r\n  return a === b;\r\n}\r\n\r\nfunction getOrganizationalParent(element) {\r\n\r\n  var bo = getBusinessObject(element);\r\n\r\n  while (bo && !is(bo, 'vdml:Process')) {\r\n    if (is(bo, 'vdml:Participant')) {\r\n      return bo.processRef || bo;\r\n    }\r\n\r\n    bo = bo.$parent;\r\n  }\r\n\r\n  return bo;\r\n}\r\n\r\nfunction isTextAnnotation(element) {\r\n  return is(element, 'vdml:TextAnnotation');\r\n}\r\n\r\nfunction isCompensationBoundary(element) {\r\n  return is(element, 'vdml:BoundaryEvent') &&\r\n         hasEventDefinition(element, 'vdml:CompensateEventDefinition');\r\n}\r\n\r\nfunction isForCompensation(e) {\r\n  return getBusinessObject(e).isForCompensation;\r\n}\r\n\r\nfunction isSameOrganization(a, b) {\r\n  var parentA = getOrganizationalParent(a),\r\n      parentB = getOrganizationalParent(b);\r\n\r\n  return parentA === parentB;\r\n}\r\n\r\nfunction isMessageFlowSource(element) {\r\n  return is(element, 'vdml:InteractionNode') &&\r\n        !isForCompensation(element) && (\r\n            !is(element, 'vdml:Event') || (\r\n              is(element, 'vdml:ThrowEvent') &&\r\n              hasEventDefinitionOrNone(element, 'vdml:MessageEventDefinition')\r\n            )\r\n  );\r\n}\r\n\r\nfunction isMessageFlowTarget(element) {\r\n  return is(element, 'vdml:InteractionNode') &&\r\n        !isForCompensation(element) && (\r\n            !is(element, 'vdml:Event') || (\r\n              is(element, 'vdml:CatchEvent') &&\r\n              hasEventDefinitionOrNone(element, 'vdml:MessageEventDefinition')\r\n            )\r\n  );\r\n}\r\n\r\nfunction getScopeParent(element) {\r\n\r\n  var bo = getBusinessObject(element);\r\n\r\n  if (is(bo, 'vdml:Participant')) {\r\n    return null;\r\n  }\r\n\r\n  while (bo) {\r\n    bo = bo.$parent;\r\n\r\n    if (is(bo, 'vdml:FlowElementsContainer')) {\r\n      return bo;\r\n    }\r\n  }\r\n\r\n  return bo;\r\n}\r\n\r\nfunction isSameScope(a, b) {\r\n  var scopeParentA = getScopeParent(a),\r\n      scopeParentB = getScopeParent(b);\r\n\r\n  return scopeParentA && (scopeParentA === scopeParentB);\r\n}\r\n\r\nfunction hasEventDefinition(element, eventDefinition) {\r\n  var bo = getBusinessObject(element);\r\n\r\n  return !!find(bo.eventDefinitions || [], function(definition) {\r\n    return is(definition, eventDefinition);\r\n  });\r\n}\r\n\r\nfunction hasEventDefinitionOrNone(element, eventDefinition) {\r\n  var bo = getBusinessObject(element);\r\n\r\n  return (bo.eventDefinitions || []).every(function(definition) {\r\n    return is(definition, eventDefinition);\r\n  });\r\n}\r\n\r\nfunction isSequenceFlowSource(element) {\r\n  return is(element, 'vdml:FlowNode') &&\r\n        !is(element, 'vdml:EndEvent') &&\r\n        !isEventSubProcess(element) &&\r\n        !(is(element, 'vdml:IntermediateThrowEvent') &&\r\n          hasEventDefinition(element, 'vdml:LinkEventDefinition')\r\n        ) &&\r\n        !isCompensationBoundary(element) &&\r\n        !isForCompensation(element);\r\n}\r\n\r\nfunction isSequenceFlowTarget(element) {\r\n  return is(element, 'vdml:FlowNode') &&\r\n        !is(element, 'vdml:StartEvent') &&\r\n        !is(element, 'vdml:BoundaryEvent') &&\r\n        !isEventSubProcess(element) &&\r\n        !(is(element, 'vdml:IntermediateCatchEvent') &&\r\n          hasEventDefinition(element, 'vdml:LinkEventDefinition')\r\n        ) &&\r\n        !isForCompensation(element);\r\n\r\n}\r\n\r\nfunction isEventBasedTarget(element) {\r\n  return is(element, 'vdml:ReceiveTask') || (\r\n         is(element, 'vdml:IntermediateCatchEvent') && (\r\n           hasEventDefinition(element, 'vdml:MessageEventDefinition') ||\r\n           hasEventDefinition(element, 'vdml:TimerEventDefinition') ||\r\n           hasEventDefinition(element, 'vdml:ConditionalEventDefinition') ||\r\n           hasEventDefinition(element, 'vdml:SignalEventDefinition')\r\n         )\r\n  );\r\n}\r\n\r\nfunction isLabel(element) {\r\n  return element.labelTarget;\r\n}\r\n\r\nfunction isConnection(element) {\r\n  return element.waypoints;\r\n}\r\n\r\nfunction isParent(possibleParent, element) {\r\n  var allParents = getParents(element);\r\n  return allParents.indexOf(possibleParent) !== -1;\r\n}\r\n\r\nfunction canConnect(source, target, connection) {\r\n\r\n  if (nonExistantOrLabel(source) || nonExistantOrLabel(target)) {\r\n    return null;\r\n  }\r\n\r\n  // See https://github.com/vdml-io/vdml-js/issues/178\r\n  // as a workround we disallow connections with same\r\n  // target and source element.\r\n  // This rule must be removed if a auto layout for this\r\n  // connections is implemented.\r\n  if (isSame(source, target)) {\r\n    return false;\r\n  }\r\n\r\n  if (!is(connection, 'vdml:DataAssociation')) {\r\n\r\n    if (canConnectMessageFlow(source, target)) {\r\n      return { type: 'vdml:MessageFlow' };\r\n    }\r\n\r\n    if (canConnectSequenceFlow(source, target)) {\r\n      return { type: 'vdml:SequenceFlow' };\r\n    }\r\n  }\r\n\r\n  var connectDataAssociation = canConnectDataAssociation(source, target);\r\n\r\n  if (connectDataAssociation) {\r\n    return connectDataAssociation;\r\n  }\r\n\r\n  if (isCompensationBoundary(source) && isForCompensation(target)) {\r\n    return {\r\n      type: 'vdml:Association',\r\n      associationDirection: 'One'\r\n    };\r\n  }\r\n\r\n  if (is(connection, 'vdml:Association') && canConnectAssociation(source, target)) {\r\n\r\n    return {\r\n      type: 'vdml:Association'\r\n    };\r\n  }\r\n\r\n  if (isTextAnnotation(source) || isTextAnnotation(target)) {\r\n\r\n    return {\r\n      type: 'vdml:Association'\r\n    };\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\n/**\r\n * Can an element be dropped into the target element\r\n *\r\n * @return {Boolean}\r\n */\r\nfunction canDrop(element, target, position) {\r\n\r\n  // can move labels everywhere\r\n  if (isLabel(element) && !isConnection(target)) {\r\n    return true;\r\n  }\r\n\r\n  // disallow to create elements on collapsed pools\r\n  if (is(target, 'vdml:Participant') && !isExpanded(target)) {\r\n    return false;\r\n  }\r\n\r\n  // allow to create new participants on\r\n  // on existing collaboration and process diagrams\r\n  if (is(element, 'vdml:Participant')) {\r\n    return is(target, 'vdml:EcoMap');\r\n  }\r\n\r\n  // allow creating lanes on participants and other lanes only\r\n  if (is(element, 'vdml:Lane')) {\r\n    return is(target, 'vdml:Participant') || is(target, 'vdml:Lane');\r\n  }\r\n\r\n  if (is(element, 'vdml:BoundaryEvent')) {\r\n    return false;\r\n  }\r\n\r\n  // drop flow elements onto flow element containers\r\n  // and participants\r\n  if (is(element, 'vdml:FlowElement') || is(element, 'vdml:DataAssociation')) {\r\n    if (is(target, 'vdml:FlowElementsContainer')) {\r\n      return isExpanded(target);\r\n    }\r\n\r\n    return isAny(target, [ 'vdml:Participant', 'vdml:Lane' ]);\r\n  }\r\n\r\n  if (is(element, 'vdml:Artifact')) {\r\n    return isAny(target, [\r\n      'vdml:Collaboration',\r\n      'vdml:Lane',\r\n      'vdml:Participant',\r\n      'vdml:Process',\r\n      'vdml:SubProcess' ]);\r\n  }\r\n\r\n  if (is(element, 'vdml:MessageFlow')) {\r\n    return is(target, 'vdml:Collaboration')\r\n      || element.source.parent == target\r\n      || element.target.parent == target;\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\nfunction canPaste(tree, target) {\r\n  var topLevel = tree[0],\r\n      participants;\r\n\r\n  if (is(target, 'vdml:Collaboration')) {\r\n    return every(topLevel, function(e) {\r\n      return e.type === 'vdml:Participant';\r\n    });\r\n  }\r\n\r\n  if (is(target, 'vdml:Process')) {\r\n    participants = any(topLevel, function(e) {\r\n      return e.type === 'vdml:Participant';\r\n    });\r\n\r\n    return !(participants && target.children.length > 0);\r\n  }\r\n\r\n  // disallow to create elements on collapsed pools\r\n  if (is(target, 'vdml:Participant') && !isExpanded(target)) {\r\n    return false;\r\n  }\r\n\r\n  if (is(target, 'vdml:FlowElementsContainer')) {\r\n    return isExpanded(target);\r\n  }\r\n\r\n  return isAny(target, [\r\n    'vdml:Collaboration',\r\n    'vdml:Lane',\r\n    'vdml:Participant',\r\n    'vdml:Process',\r\n    'vdml:SubProcess' ]);\r\n}\r\n\r\nfunction isBoundaryEvent(element) {\r\n  return !isLabel(element) && is(element, 'vdml:BoundaryEvent');\r\n}\r\n\r\nfunction isLane(element) {\r\n  return is(element, 'vdml:Lane');\r\n}\r\n\r\n/**\r\n * We treat IntermediateThrowEvents as boundary events during create,\r\n * this must be reflected in the rules.\r\n */\r\nfunction isBoundaryCandidate(element) {\r\n  return isBoundaryEvent(element) ||\r\n        (is(element, 'vdml:IntermediateThrowEvent') && !element.parent);\r\n}\r\n\r\n\r\nfunction canAttach(elements, target, source, position) {\r\n\r\n  if (!Array.isArray(elements)) {\r\n    elements = [ elements ];\r\n  }\r\n\r\n  // disallow appending as boundary event\r\n  if (source) {\r\n    return false;\r\n  }\r\n\r\n  // only (re-)attach one element at a time\r\n  if (elements.length !== 1) {\r\n    return false;\r\n  }\r\n\r\n  var element = elements[0];\r\n\r\n  // do not attach labels\r\n  if (isLabel(element)) {\r\n    return false;\r\n  }\r\n\r\n  // only handle boundary events\r\n  if (!isBoundaryCandidate(element)) {\r\n    return false;\r\n  }\r\n\r\n  // allow default move operation\r\n  if (!target) {\r\n    return true;\r\n  }\r\n\r\n  // disallow drop on event sub processes\r\n  if (isEventSubProcess(target)) {\r\n    return false;\r\n  }\r\n\r\n  // only allow drop on non compensation activities\r\n  if (!is(target, 'vdml:Activity') || isForCompensation(target)) {\r\n    return false;\r\n  }\r\n\r\n  // only attach to subprocess border\r\n  if (position && !isBoundaryAttachment(position, target)) {\r\n    return false;\r\n  }\r\n\r\n  return 'attach';\r\n}\r\n\r\n\r\n/**\r\n * Defines how to replace elements for a given target.\r\n *\r\n * Returns an array containing all elements which will be replaced.\r\n *\r\n * @example\r\n *\r\n *  [{ id: 'IntermediateEvent_2',\r\n *     type: 'vdml:StartEvent'\r\n *   },\r\n *   { id: 'IntermediateEvent_5',\r\n *     type: 'vdml:EndEvent'\r\n *   }]\r\n *\r\n * @param  {Array} elements\r\n * @param  {Object} target\r\n *\r\n * @return {Object} an object containing all elements which have to be replaced\r\n */\r\nfunction canReplace(elements, target, position) {\r\n\r\n  if (!target) {\r\n    return false;\r\n  }\r\n\r\n  var canExecute = {\r\n    replacements: []\r\n  };\r\n\r\n  forEach(elements, function(element) {\r\n\r\n    // replace a non-interrupting start event by a blank interrupting start event\r\n    // when the target is not an event sub process\r\n    if (!isEventSubProcess(target)) {\r\n\r\n      if (is(element, 'vdml:StartEvent') &&\r\n          !isInterrupting(element) &&\r\n          element.type !== 'label' &&\r\n          canDrop(element, target)) {\r\n\r\n        canExecute.replacements.push({\r\n          oldElementId: element.id,\r\n          newElementType: 'vdml:StartEvent'\r\n        });\r\n      }\r\n    }\r\n\r\n    if (!is(target, 'vdml:Transaction')) {\r\n      if (hasEventDefinition(element, 'vdml:CancelEventDefinition') &&\r\n          element.type !== 'label') {\r\n\r\n        if (is(element, 'vdml:EndEvent') && canDrop(element, target)) {\r\n          canExecute.replacements.push({\r\n            oldElementId: element.id,\r\n            newElementType: 'vdml:EndEvent'\r\n          });\r\n        }\r\n\r\n        if (is(element, 'vdml:BoundaryEvent') && canAttach(element, target, null, position)) {\r\n          canExecute.replacements.push({\r\n            oldElementId: element.id,\r\n            newElementType: 'vdml:BoundaryEvent'\r\n          });\r\n        }\r\n      }\r\n    }\r\n  });\r\n\r\n  return canExecute.replacements.length ? canExecute : false;\r\n}\r\n\r\nfunction canMove(elements, target) {\r\n\r\n  // do not move selection containing boundary events\r\n  if (any(elements, isBoundaryEvent)) {\r\n    return false;\r\n  }\r\n\r\n  // do not move selection containing lanes\r\n  if (any(elements, isLane)) {\r\n    return false;\r\n  }\r\n\r\n  // allow default move check to start move operation\r\n  if (!target) {\r\n    return true;\r\n  }\r\n\r\n  return elements.every(function(element) {\r\n    return canDrop(element, target);\r\n  });\r\n}\r\n\r\nfunction canCreate(shape, target, source, position) {\r\n\r\n  if (!target) {\r\n    return false;\r\n  }\r\n\r\n  if (isLabel(target)) {\r\n    return null;\r\n  }\r\n\r\n  if (isSame(source, target)) {\r\n    return false;\r\n  }\r\n\r\n  // ensure we do not drop the element\r\n  // into source\r\n  if (source && isParent(source, target)) {\r\n    return false;\r\n  }\r\n\r\n  return canDrop(shape, target, position) || canInsert(shape, target, position);\r\n}\r\n\r\nfunction canResize(shape, newBounds) {\r\n  if (is(shape, 'vdml:SubProcess')) {\r\n    return (!!isExpanded(shape)) && (\r\n          !newBounds || (newBounds.width >= 100 && newBounds.height >= 80)\r\n    );\r\n  }\r\n\r\n  if (is(shape, 'vdml:Lane')) {\r\n    return !newBounds || (newBounds.width >= 130 && newBounds.height >= 60);\r\n  }\r\n\r\n  if (is(shape, 'vdml:Participant')) {\r\n    return !newBounds || (newBounds.width >= 250 && newBounds.height >= 50);\r\n  }\r\n\r\n  if (isTextAnnotation(shape)) {\r\n    return true;\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\nfunction canConnectAssociation(source, target) {\r\n\r\n  // do not connect connections\r\n  if (isConnection(source) || isConnection(target)) {\r\n    return false;\r\n  }\r\n\r\n  // connect if different parent\r\n  return !isParent(target, source) &&\r\n         !isParent(source, target);\r\n}\r\n\r\nfunction canConnectMessageFlow(source, target) {\r\n\r\n  return isMessageFlowSource(source) &&\r\n         isMessageFlowTarget(target) &&\r\n        !isSameOrganization(source, target);\r\n}\r\n\r\nfunction canConnectSequenceFlow(source, target) {\r\n\r\n  return isSequenceFlowSource(source) &&\r\n         isSequenceFlowTarget(target) &&\r\n         isSameScope(source, target) &&\r\n         !(is(source, 'vdml:EventBasedGateway') && !isEventBasedTarget(target));\r\n}\r\n\r\n\r\nfunction canConnectDataAssociation(source, target) {\r\n\r\n  if (isAny(source, [ 'vdml:DataObjectReference', 'vdml:DataStoreReference' ]) &&\r\n      isAny(target, [ 'vdml:Activity', 'vdml:ThrowEvent' ])) {\r\n    return { type: 'vdml:DataInputAssociation' };\r\n  }\r\n\r\n  if (isAny(target, [ 'vdml:DataObjectReference', 'vdml:DataStoreReference' ]) &&\r\n      isAny(source, [ 'vdml:Activity', 'vdml:CatchEvent' ])) {\r\n    return { type: 'vdml:DataOutputAssociation' };\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\nfunction canInsert(shape, flow, position) {\r\n\r\n  // return true if we can drop on the\r\n  // underlying flow parent\r\n  //\r\n  // at this point we are not really able to talk\r\n  // about connection rules (yet)\r\n  return (\r\n    isAny(flow, [ 'vdml:SequenceFlow', 'vdml:MessageFlow' ]) &&\r\n    is(shape, 'vdml:FlowNode') &&\r\n    !is(shape, 'vdml:BoundaryEvent') &&\r\n    canDrop(shape, flow.parent, position));\r\n}\r\n\r\nfunction contains(collection, element) {\r\n  return (collection && element) && collection.indexOf(element) !== -1;\r\n}\r\n\r\nfunction canCopy(collection, element) {\r\n  if (is(element, 'vdml:Lane') && !contains(collection, element.parent)) {\r\n    return false;\r\n  }\r\n\r\n  if (is(element, 'vdml:BoundaryEvent') && !contains(collection, element.host)) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n","module.exports = {\r\n  __depends__: [\r\n    require(208)\r\n  ],\r\n  __init__: [ 'vdmlRules' ],\r\n  vdmlRules: [ 'type', require(79) ]\r\n};\r\n","'use strict';\r\n\r\nvar map = require(286),\r\n    filter = require(281),\r\n    sortBy = require(291);\r\n\r\nvar labelUtil = require(24);\r\n\r\n\r\n/**\r\n * Provides ability to search through VDML elements\r\n */\r\nfunction VdmlSearchProvider(elementRegistry, searchPad, canvas) {\r\n\r\n  this._elementRegistry = elementRegistry;\r\n  this._canvas = canvas;\r\n\r\n  searchPad.registerProvider(this);\r\n}\r\n\r\nmodule.exports = VdmlSearchProvider;\r\n\r\nVdmlSearchProvider.$inject = [\r\n  'elementRegistry',\r\n  'searchPad',\r\n  'canvas'\r\n];\r\n\r\n\r\n/**\r\n * Finds all elements that match given pattern\r\n *\r\n * <Result> :\r\n *  {\r\n *    primaryTokens: <Array<Token>>,\r\n *    secondaryTokens: <Array<Token>>,\r\n *    element: <Element>\r\n *  }\r\n *\r\n * <Token> :\r\n *  {\r\n *    normal|matched: <String>\r\n *  }\r\n *\r\n * @param  {String} pattern\r\n * @return {Array<Result>}\r\n */\r\nVdmlSearchProvider.prototype.find = function(pattern) {\r\n  var rootElement = this._canvas.getRootElement();\r\n\r\n  var elements = this._elementRegistry.filter(function(element) {\r\n    if (element.labelTarget) {\r\n      return false;\r\n    }\r\n    return true;\r\n  });\r\n\r\n  // do not include root element\r\n  elements = filter(elements, function(element) {\r\n    return element !== rootElement;\r\n  });\r\n\r\n  elements = map(elements, function(element) {\r\n    return {\r\n      primaryTokens: matchAndSplit(labelUtil.getLabel(element), pattern),\r\n      secondaryTokens: matchAndSplit(element.id, pattern),\r\n      element: element\r\n    };\r\n  });\r\n\r\n  // exclude non-matched elements\r\n  elements = filter(elements, function(element) {\r\n    return hasMatched(element.primaryTokens) || hasMatched(element.secondaryTokens);\r\n  });\r\n\r\n  elements = sortBy(elements, function(element) {\r\n    return labelUtil.getLabel(element.element) + element.element.id;\r\n  });\r\n\r\n  return elements;\r\n};\r\n\r\n\r\nfunction hasMatched(tokens) {\r\n  var matched = filter(tokens, function(t) {\r\n    return !!t.matched;\r\n  });\r\n\r\n  return matched.length > 0;\r\n}\r\n\r\n\r\nfunction matchAndSplit(text, pattern) {\r\n  var tokens = [],\r\n      originalText = text;\r\n\r\n  if (!text) {\r\n    return tokens;\r\n  }\r\n\r\n  text = text.toLowerCase();\r\n  pattern = pattern.toLowerCase();\r\n\r\n  var i = text.indexOf(pattern);\r\n\r\n  if (i > -1) {\r\n    if (i !== 0) {\r\n      tokens.push({\r\n        normal: originalText.substr(0, i)\r\n      });\r\n    }\r\n\r\n    tokens.push({\r\n      matched: originalText.substr(i, pattern.length)\r\n    });\r\n\r\n    if (pattern.length + i < text.length) {\r\n      tokens.push({\r\n        normal: originalText.substr(pattern.length + i, text.length)\r\n      });\r\n    }\r\n  } else {\r\n    tokens.push({\r\n      normal: originalText\r\n    });\r\n  }\r\n\r\n  return tokens;\r\n}","module.exports = {\r\n  __depends__: [\r\n    require(210)\r\n  ],\r\n  __init__: [ 'vdmlSearch'],\r\n  vdmlSearch: [ 'type', require(81) ]\r\n};\r\n","'use strict';\r\n\r\nvar inherits = require(270);\r\n\r\nvar abs = Math.abs;\r\n\r\nvar forEach = require(283),\r\n    filter = require(281),\r\n    assign = require(410);\r\n\r\nvar getBoundingBox = require(247).getBBox;\r\n\r\nvar is = require(93).is,\r\n    isAny = require(66).isAny,\r\n    isExpanded = require(91).isExpanded;\r\n\r\nvar Snapping = require(217),\r\n    SnapUtil = require(216);\r\n\r\nvar asTRBL = require(233).asTRBL;\r\n\r\nvar round = Math.round;\r\n\r\nvar mid = SnapUtil.mid,\r\n    topLeft = SnapUtil.topLeft,\r\n    bottomRight = SnapUtil.bottomRight,\r\n    isSnapped = SnapUtil.isSnapped,\r\n    setSnapped = SnapUtil.setSnapped;\r\n\r\nvar getBoundaryAttachment = require(84).getBoundaryAttachment,\r\n    getParticipantSizeConstraints = require(84).getParticipantSizeConstraints,\r\n    getLanesRoot = require(65).getLanesRoot;\r\n\r\nvar HIGH_PRIORITY = 1500;\r\n\r\n\r\n/**\r\n * VDML specific snapping functionality\r\n *\r\n *  * snap on process elements if a pool is created inside a\r\n *    process diagram\r\n *\r\n * @param {EventBus} eventBus\r\n * @param {Canvas} canvas\r\n */\r\nfunction VdmlSnapping(eventBus, canvas, vdmlRules, elementRegistry) {\r\n\r\n  // instantiate super\r\n  Snapping.call(this, eventBus, canvas);\r\n\r\n\r\n  /**\r\n   * Drop participant on process <> process elements snapping\r\n   */\r\n  eventBus.on('create.start', function(event) {\r\n\r\n    var context = event.context,\r\n        shape = context.shape,\r\n        rootElement = canvas.getRootElement();\r\n\r\n    // snap participant around existing elements (if any)\r\n    if (is(shape, 'vdml:Participant') && is(rootElement, 'vdml:Process')) {\r\n      initParticipantSnapping(context, shape, rootElement.children);\r\n    }\r\n  });\r\n\r\n  eventBus.on([ 'create.move', 'create.end' ], HIGH_PRIORITY, function(event) {\r\n\r\n    var context = event.context,\r\n        shape = context.shape,\r\n        participantSnapBox = context.participantSnapBox;\r\n\r\n    if (!isSnapped(event) && participantSnapBox) {\r\n      snapParticipant(participantSnapBox, shape, event);\r\n    }\r\n  });\r\n\r\n  eventBus.on('shape.move.start', function(event) {\r\n\r\n    var context = event.context,\r\n        shape = context.shape,\r\n        rootElement = canvas.getRootElement();\r\n\r\n    // snap participant around existing elements (if any)\r\n    if (is(shape, 'vdml:Participant') && is(rootElement, 'vdml:Process')) {\r\n      initParticipantSnapping(context, shape, rootElement.children);\r\n    }\r\n  });\r\n\r\n\r\n  function canAttach(shape, target, position) {\r\n    return vdmlRules.canAttach([ shape ], target, null, position) === 'attach';\r\n  }\r\n\r\n  function canConnect(source, target) {\r\n    return vdmlRules.canConnect(source, target);\r\n  }\r\n\r\n  /**\r\n   * Snap boundary events to elements border\r\n   */\r\n  eventBus.on([\r\n    'create.move',\r\n    'create.end',\r\n    'shape.move.move',\r\n    'shape.move.end'\r\n  ], HIGH_PRIORITY, function(event) {\r\n\r\n    var context = event.context,\r\n        target = context.target,\r\n        shape = context.shape;\r\n\r\n    if (target && !isSnapped(event) && canAttach(shape, target, event)) {\r\n      snapBoundaryEvent(event, shape, target);\r\n    }\r\n  });\r\n\r\n  /**\r\n   * Adjust parent for flowElements to the target participant\r\n   * when droping onto lanes.\r\n   */\r\n  eventBus.on([\r\n    'shape.move.hover',\r\n    'shape.move.move',\r\n    'shape.move.end',\r\n    'create.hover',\r\n    'create.move',\r\n    'create.end'\r\n  ], HIGH_PRIORITY, function(event) {\r\n    var context = event.context,\r\n        shape = context.shape,\r\n        hover = event.hover;\r\n\r\n    if (is(hover, 'vdml:Lane') && !isAny(shape, [ 'vdml:Lane', 'vdml:Participant' ])) {\r\n      event.hover = getLanesRoot(hover);\r\n      event.hoverGfx = elementRegistry.getGraphics(event.hover);\r\n    }\r\n  });\r\n\r\n  /**\r\n   * Snap sequence flows.\r\n   */\r\n  eventBus.on([\r\n    'connect.move',\r\n    'connect.hover',\r\n    'connect.end'\r\n  ], HIGH_PRIORITY, function(event) {\r\n    var context = event.context,\r\n        source = context.source,\r\n        target = context.target;\r\n\r\n    var connection = canConnect(source, target) || {};\r\n\r\n    if (!context.initialSourcePosition) {\r\n      context.initialSourcePosition = context.sourcePosition;\r\n    }\r\n\r\n    if (target && connection.type === 'vdml:SequenceFlow') {\r\n\r\n      // snap source\r\n      context.sourcePosition = mid(source);\r\n\r\n      // snap target\r\n      assign(event, mid(target));\r\n    } else {\r\n\r\n      // otherwise reset source snap\r\n      context.sourcePosition = context.initialSourcePosition;\r\n    }\r\n\r\n  });\r\n\r\n\r\n  eventBus.on([\r\n    'create.move',\r\n    'shape.move.move'\r\n  ], function(event) {\r\n\r\n    var context = event.context,\r\n        shape = context.shape,\r\n        target = context.target;\r\n\r\n    var threshold = 30;\r\n\r\n    if (is(shape, 'vdml:Lane')) {\r\n      if (isAny(target, [ 'vdml:Lane', 'vdml:Participant' ])) {\r\n\r\n        var childLanes = filter(target.children, function(c) {\r\n          return is(c, 'vdml:Lane');\r\n        });\r\n\r\n        var y = event.y,\r\n            targetTrbl;\r\n\r\n        var insert = childLanes.reduce(function(insert, l) {\r\n\r\n          var laneTrbl = asTRBL(l);\r\n\r\n          if (abs(laneTrbl.top - y) < threshold) {\r\n            insert = assign(insert || {}, { before: { element: l, y: laneTrbl.top } });\r\n          } else\r\n          if (abs(laneTrbl.bottom - y) < threshold) {\r\n            insert = assign(insert || {}, { after: { element: l, y: laneTrbl.bottom } });\r\n          } else\r\n          if (laneTrbl.top < y && laneTrbl.bottom > y) {\r\n            if (abs(laneTrbl.top - y) > abs(laneTrbl.bottom - y)) {\r\n              insert = assign(insert || {}, { after: { element: l, y: laneTrbl.bottom } });\r\n            } else {\r\n              insert = assign(insert || {}, { before: { element: l, y: laneTrbl.top } });\r\n            }\r\n\r\n          }\r\n\r\n          return insert;\r\n        }, false);\r\n\r\n\r\n        if (!insert) {\r\n          targetTrbl = asTRBL(target);\r\n\r\n          if (abs(targetTrbl.top - y) < threshold) {\r\n            insert = { before: { element: target, y: targetTrbl.top } };\r\n          } else\r\n          if (abs(targetTrbl.bottom - y) < threshold) {\r\n            insert = { after: { element: target, y: targetTrbl.bottom } };\r\n          } else {\r\n            insert = { into: { element: target, y: (targetTrbl.top + targetTrbl.bottom) / 2 } };\r\n          }\r\n\r\n        }\r\n\r\n        if (insert.before && insert.after) {\r\n          console.log('insert between', insert.before.element.id, 'and', insert.after.element.id);\r\n          setSnapped(event, 'x', insert.before.element.x + insert.before.element.width / 2);\r\n          setSnapped(event, 'y', insert.before.y);\r\n        } else\r\n        if (insert.after) {\r\n          console.log('insert after', insert.after.element.id);\r\n          setSnapped(event, 'x', insert.after.element.x + insert.after.element.width / 2);\r\n          setSnapped(event, 'y', insert.after.y);\r\n        } else\r\n        if (insert.before) {\r\n          console.log('insert before', insert.before.element.id);\r\n          setSnapped(event, 'x', insert.before.element.x + insert.before.element.width / 2);\r\n          setSnapped(event, 'y', insert.before.y);\r\n        } else\r\n        if (insert.into) {\r\n          console.log('insert into', insert.into.element.id);\r\n          setSnapped(event, 'x', insert.into.element.x + insert.into.element.width / 2);\r\n          setSnapped(event, 'y', insert.into.y);\r\n        }\r\n      }\r\n    }\r\n\r\n  });\r\n\r\n  eventBus.on('resize.start', HIGH_PRIORITY, function(event) {\r\n    var context = event.context,\r\n        shape = context.shape;\r\n\r\n    if (is(shape, 'vdml:SubProcess') && isExpanded(shape)) {\r\n      context.minDimensions = { width: 140, height: 120 };\r\n    }\r\n\r\n    if (is(shape, 'vdml:Participant')) {\r\n      context.minDimensions = { width: 300, height: 150 };\r\n    }\r\n\r\n    if (is(shape, 'vdml:Lane') || is(shape, 'vdml:Participant')) {\r\n      context.resizeConstraints = getParticipantSizeConstraints(shape, context.direction, context.balanced);\r\n    }\r\n\r\n    if (is(shape, 'vdml:TextAnnotation')) {\r\n      context.minDimensions = { width: 50, height: 30 };\r\n    }\r\n  });\r\n\r\n}\r\n\r\ninherits(VdmlSnapping, Snapping);\r\n\r\nVdmlSnapping.$inject = [ 'eventBus', 'canvas', 'vdmlRules', 'elementRegistry' ];\r\n\r\nmodule.exports = VdmlSnapping;\r\n\r\n\r\nVdmlSnapping.prototype.initSnap = function(event) {\r\n\r\n  var context = event.context,\r\n      shape = event.shape,\r\n      shapeMid,\r\n      shapeBounds,\r\n      shapeTopLeft,\r\n      shapeBottomRight,\r\n      snapContext;\r\n\r\n\r\n  snapContext = Snapping.prototype.initSnap.call(this, event);\r\n\r\n  if (is(shape, 'vdml:Participant')) {\r\n    // assign higher priority for outer snaps on participants\r\n    snapContext.setSnapLocations([ 'top-left', 'bottom-right', 'mid' ]);\r\n  }\r\n\r\n\r\n  if (shape) {\r\n\r\n    shapeMid = mid(shape, event);\r\n\r\n    shapeBounds = {\r\n      width: shape.width,\r\n      height: shape.height,\r\n      x: isNaN(shape.x) ? round(shapeMid.x - shape.width / 2) : shape.x,\r\n      y: isNaN(shape.y) ? round(shapeMid.y - shape.height / 2) : shape.y\r\n    };\r\n\r\n    shapeTopLeft = topLeft(shapeBounds);\r\n    shapeBottomRight = bottomRight(shapeBounds);\r\n\r\n    snapContext.setSnapOrigin('top-left', {\r\n      x: shapeTopLeft.x - event.x,\r\n      y: shapeTopLeft.y - event.y\r\n    });\r\n\r\n    snapContext.setSnapOrigin('bottom-right', {\r\n      x: shapeBottomRight.x - event.x,\r\n      y: shapeBottomRight.y - event.y\r\n    });\r\n\r\n    forEach(shape.outgoing, function(c) {\r\n      var docking = c.waypoints[0];\r\n\r\n      docking = docking.original || docking;\r\n\r\n      snapContext.setSnapOrigin(c.id + '-docking', {\r\n        x: docking.x - event.x,\r\n        y: docking.y - event.y\r\n      });\r\n    });\r\n\r\n    forEach(shape.incoming, function(c) {\r\n      var docking = c.waypoints[c.waypoints.length - 1];\r\n\r\n      docking = docking.original || docking;\r\n\r\n      snapContext.setSnapOrigin(c.id + '-docking', {\r\n        x: docking.x - event.x,\r\n        y: docking.y - event.y\r\n      });\r\n    });\r\n\r\n  }\r\n\r\n  var source = context.source;\r\n\r\n  if (source) {\r\n    snapContext.addDefaultSnap('mid', mid(source));\r\n  }\r\n};\r\n\r\n\r\nVdmlSnapping.prototype.addTargetSnaps = function(snapPoints, shape, target) {\r\n\r\n  // use target parent as snap target\r\n  if (is(shape, 'vdml:BoundaryEvent') && shape.type !== 'label') {\r\n    target = target.parent;\r\n  }\r\n\r\n  // add sequence flow parents as snap targets\r\n  if (is(target, 'vdml:SequenceFlow')) {\r\n    this.addTargetSnaps(snapPoints, shape, target.parent);\r\n  }\r\n\r\n  var siblings = this.getSiblings(shape, target) || [];\r\n\r\n  forEach(siblings, function(s) {\r\n\r\n    // do not snap to lanes\r\n    if (is(s, 'vdml:Lane')) {\r\n      return;\r\n    }\r\n\r\n    snapPoints.add('mid', mid(s));\r\n\r\n    if (is(s, 'vdml:Participant')) {\r\n      snapPoints.add('top-left', topLeft(s));\r\n      snapPoints.add('bottom-right', bottomRight(s));\r\n    }\r\n  });\r\n\r\n\r\n  forEach(shape.incoming, function(c) {\r\n\r\n    if (siblings.indexOf(c.source) === -1) {\r\n      snapPoints.add('mid', mid(c.source));\r\n    }\r\n\r\n    var docking = c.waypoints[0];\r\n    snapPoints.add(c.id + '-docking', docking.original || docking);\r\n  });\r\n\r\n\r\n  forEach(shape.outgoing, function(c) {\r\n\r\n    if (siblings.indexOf(c.target) === -1) {\r\n      snapPoints.add('mid', mid(c.target));\r\n    }\r\n\r\n    var docking = c.waypoints[c.waypoints.length - 1];\r\n    snapPoints.add(c.id + '-docking', docking.original || docking);\r\n  });\r\n};\r\n\r\n\r\n/////// participant snapping //////////////////\r\n\r\nfunction initParticipantSnapping(context, shape, elements) {\r\n\r\n  if (!elements.length) {\r\n    return;\r\n  }\r\n\r\n  var snapBox = getBoundingBox(elements.filter(function(e) {\r\n    return !e.labelTarget && !e.waypoints;\r\n  }));\r\n\r\n  snapBox.x -= 50;\r\n  snapBox.y -= 20;\r\n  snapBox.width += 70;\r\n  snapBox.height += 40;\r\n\r\n  // adjust shape height to include bounding box\r\n  shape.width = Math.max(shape.width, snapBox.width);\r\n  shape.height = Math.max(shape.height, snapBox.height);\r\n\r\n  context.participantSnapBox = snapBox;\r\n}\r\n\r\nfunction snapParticipant(snapBox, shape, event, offset) {\r\n  offset = offset || 0;\r\n\r\n  var shapeHalfWidth = shape.width / 2 - offset,\r\n      shapeHalfHeight = shape.height / 2;\r\n\r\n  var currentTopLeft = {\r\n    x: event.x - shapeHalfWidth - offset,\r\n    y: event.y - shapeHalfHeight\r\n  };\r\n\r\n  var currentBottomRight = {\r\n    x: event.x + shapeHalfWidth + offset,\r\n    y: event.y + shapeHalfHeight\r\n  };\r\n\r\n  var snapTopLeft = snapBox,\r\n      snapBottomRight = bottomRight(snapBox);\r\n\r\n  if (currentTopLeft.x >= snapTopLeft.x) {\r\n    setSnapped(event, 'x', snapTopLeft.x + offset + shapeHalfWidth);\r\n  } else\r\n  if (currentBottomRight.x <= snapBottomRight.x) {\r\n    setSnapped(event, 'x', snapBottomRight.x - offset - shapeHalfWidth);\r\n  }\r\n\r\n  if (currentTopLeft.y >= snapTopLeft.y) {\r\n    setSnapped(event, 'y', snapTopLeft.y + shapeHalfHeight);\r\n  } else\r\n  if (currentBottomRight.y <= snapBottomRight.y) {\r\n    setSnapped(event, 'y', snapBottomRight.y - shapeHalfHeight);\r\n  }\r\n}\r\n\r\n\r\n/////// boundary event snapping /////////////////////////\r\n\r\n\r\nfunction snapBoundaryEvent(event, shape, target) {\r\n  var targetTRBL = asTRBL(target);\r\n\r\n  var direction = getBoundaryAttachment(event, target);\r\n\r\n  if (/top/.test(direction)) {\r\n    setSnapped(event, 'y', targetTRBL.top);\r\n  } else\r\n  if (/bottom/.test(direction)) {\r\n    setSnapped(event, 'y', targetTRBL.bottom);\r\n  }\r\n\r\n  if (/left/.test(direction)) {\r\n    setSnapped(event, 'x', targetTRBL.left);\r\n  } else\r\n  if (/right/.test(direction)) {\r\n    setSnapped(event, 'x', targetTRBL.right);\r\n  }\r\n}\r\n","'use strict';\r\n\r\nvar getOrientation = require(233).getOrientation;\r\n\r\n\r\nfunction getBoundaryAttachment(position, targetBounds) {\r\n\r\n  var orientation = getOrientation(position, targetBounds, -15);\r\n\r\n  if (orientation !== 'intersect') {\r\n    return orientation;\r\n  } else {\r\n    return null;\r\n  }\r\n}\r\n\r\nmodule.exports.getBoundaryAttachment = getBoundaryAttachment;\r\n\r\n\r\n\r\n// participant snapping box implementation /////////////////\r\n\r\nvar is = require(93).is;\r\n\r\nvar asTRBL = require(233).asTRBL;\r\n\r\nvar collectLanes = require(65).collectLanes,\r\n    getLanesRoot = require(65).getLanesRoot;\r\n\r\nvar abs = Math.abs,\r\n    min = Math.min,\r\n    max = Math.max;\r\n\r\n\r\nfunction addToTrbl(trbl, attr, value, choice) {\r\n\r\n  var current = trbl[attr];\r\n\r\n  // make sure to set the value if it does not exist\r\n  // or apply the correct value by comparing against\r\n  // choice(value, currentValue)\r\n  trbl[attr] = current === undefined ? value : choice(value, current);\r\n}\r\n\r\nfunction addMin(trbl, attr, value) {\r\n  return addToTrbl(trbl, attr, value, min);\r\n}\r\n\r\nfunction addMax(trbl, attr, value) {\r\n  return addToTrbl(trbl, attr, value, max);\r\n}\r\n\r\n\r\nvar LANE_MIN_HEIGHT = 60,\r\n    LANE_MIN_WIDTH = 300,\r\n    LANE_RIGHT_PADDING = 20,\r\n    LANE_LEFT_PADDING = 50,\r\n    LANE_TOP_PADDING = 20,\r\n    LANE_BOTTOM_PADDING = 20;\r\n\r\n\r\nfunction getParticipantSizeConstraints(laneShape, resizeDirection, balanced) {\r\n\r\n  var lanesRoot = getLanesRoot(laneShape);\r\n\r\n  var isFirst = true,\r\n      isLast = true;\r\n\r\n  ///// max top/bottom size for lanes\r\n\r\n  var allLanes = collectLanes(lanesRoot, [ lanesRoot ]);\r\n\r\n  var laneTrbl = asTRBL(laneShape);\r\n\r\n  var maxTrbl = {},\r\n      minTrbl = {};\r\n\r\n  if (/e/.test(resizeDirection)) {\r\n    minTrbl.right = laneTrbl.left + LANE_MIN_WIDTH;\r\n  } else\r\n  if (/w/.test(resizeDirection)) {\r\n    minTrbl.left = laneTrbl.right - LANE_MIN_WIDTH;\r\n  }\r\n\r\n  allLanes.forEach(function(other) {\r\n\r\n    var otherTrbl = asTRBL(other);\r\n\r\n    if (/n/.test(resizeDirection)) {\r\n\r\n      if (otherTrbl.top < (laneTrbl.top - 10)) {\r\n        isFirst = false;\r\n      }\r\n\r\n      // max top size (based on next element)\r\n      if (balanced && abs(laneTrbl.top - otherTrbl.bottom) < 10) {\r\n        addMax(maxTrbl, 'top', otherTrbl.top + LANE_MIN_HEIGHT);\r\n      }\r\n\r\n      // min top size (based on self or nested element)\r\n      if (abs(laneTrbl.top - otherTrbl.top) < 5) {\r\n        addMin(minTrbl, 'top', otherTrbl.bottom - LANE_MIN_HEIGHT);\r\n      }\r\n    }\r\n\r\n    if (/s/.test(resizeDirection)) {\r\n\r\n      if (otherTrbl.bottom > (laneTrbl.bottom + 10)) {\r\n        isLast = false;\r\n      }\r\n\r\n      // max bottom size (based on previous element)\r\n      if (balanced && abs(laneTrbl.bottom - otherTrbl.top) < 10) {\r\n        addMin(maxTrbl, 'bottom', otherTrbl.bottom - LANE_MIN_HEIGHT);\r\n      }\r\n\r\n      // min bottom size (based on self or nested element)\r\n      if (abs(laneTrbl.bottom - otherTrbl.bottom) < 5) {\r\n        addMax(minTrbl, 'bottom', otherTrbl.top + LANE_MIN_HEIGHT);\r\n      }\r\n    }\r\n  });\r\n\r\n\r\n  ///// max top/bottom/left/right size based on flow nodes\r\n\r\n  var flowElements = lanesRoot.children.filter(function(s) {\r\n    return !s.hidden && !s.waypoints && (is(s, 'vdml:FlowElement') || is(s, 'vdml:Artifact'));\r\n  });\r\n\r\n  flowElements.forEach(function(flowElement) {\r\n\r\n    var flowElementTrbl = asTRBL(flowElement);\r\n\r\n    if (isFirst && /n/.test(resizeDirection)) {\r\n      addMin(minTrbl, 'top', flowElementTrbl.top - LANE_TOP_PADDING);\r\n    }\r\n\r\n    if (/e/.test(resizeDirection)) {\r\n      addMax(minTrbl, 'right', flowElementTrbl.right + LANE_RIGHT_PADDING);\r\n    }\r\n\r\n    if (isLast && /s/.test(resizeDirection)) {\r\n      addMax(minTrbl, 'bottom', flowElementTrbl.bottom + LANE_BOTTOM_PADDING);\r\n    }\r\n\r\n    if (/w/.test(resizeDirection)) {\r\n      addMin(minTrbl, 'left', flowElementTrbl.left - LANE_LEFT_PADDING);\r\n    }\r\n  });\r\n\r\n\r\n  return {\r\n    min: minTrbl,\r\n    max: maxTrbl\r\n  };\r\n}\r\n\r\n\r\nmodule.exports.getParticipantSizeConstraints = getParticipantSizeConstraints;","module.exports = {\r\n  __init__: [ 'snapping' ],\r\n  snapping: [ 'type', require(83) ]\r\n};","'use strict';\r\n\r\nvar VdmlTreeWalker = require(89);\r\n\r\n\r\n/**\r\n * Import the definitions into a diagram.\r\n *\r\n * Errors and warnings are reported through the specified callback.\r\n *\r\n * @param  {Diagram} diagram\r\n * @param  {ModdleElement} definitions\r\n * @param  {Function} done the callback, invoked with (err, [ warning ]) once the import is done\r\n */\r\nfunction importVdmlDiagram(diagram, definitions, done) {\r\n\r\n  var importer = diagram.get('vdmlImporter'),\r\n      eventBus = diagram.get('eventBus'),\r\n      translate = diagram.get('translate');\r\n\r\n  var error,\r\n      warnings = [];\r\n\r\n  /**\r\n   * Walk the diagram semantically, importing (=drawing)\r\n   * all elements you encounter.\r\n   *\r\n   * @param {ModdleElement} definitions\r\n   */\r\n  function render(definitions) {\r\n\r\n    var visitor = {\r\n\r\n      root: function(element) {\r\n        return importer.add(element);\r\n      },\r\n\r\n      element: function(element, parentShape) {\r\n        return importer.add(element, parentShape);\r\n      },\r\n\r\n      error: function(message, context) {\r\n        warnings.push({ message: message, context: context });\r\n      }\r\n    };\r\n\r\n    var walker = new VdmlTreeWalker(visitor, translate);\r\n\r\n    // traverse BPMN 2.0 document model,\r\n    // starting at definitions\r\n    walker.handleDefinitions(definitions);\r\n  }\r\n\r\n  eventBus.fire('import.render.start', { definitions: definitions });\r\n\r\n  try {\r\n    render(definitions);\r\n  } catch (e) {\r\n    error = e;\r\n  }\r\n\r\n  eventBus.fire('import.render.complete', {\r\n    error: error,\r\n    warnings: warnings\r\n  });\r\n\r\n  done(error, warnings);\r\n}\r\n\r\nmodule.exports.importVdmlDiagram = importVdmlDiagram;","'use strict';\r\n\r\nmodule.exports.elementToString = function(e) {\r\n  if (!e) {\r\n    return '<null>';\r\n  }\r\n\r\n  return '<' + e.$type + (e.id ? ' id=\"' + e.id : '') + '\" />';\r\n};","'use strict';\r\n\r\nvar assign = require(410),\r\n    map = require(286);\r\n\r\nvar LabelUtil = require(92);\r\n\r\nvar is = require(93).is;\r\n\r\nvar hasExternalLabel = LabelUtil.hasExternalLabel,\r\n    getExternalLabelBounds = LabelUtil.getExternalLabelBounds,\r\n    isExpanded = require(91).isExpanded,\r\n    elementToString = require(87).elementToString;\r\n\r\n\r\nfunction elementData(semantic, attrs) {\r\n  return assign({\r\n    id: semantic.id,\r\n    type: semantic.$type,\r\n    businessObject: semantic\r\n  }, attrs);\r\n}\r\n\r\nfunction collectWaypoints(waypoints) {\r\n  return map(waypoints, function(p) {\r\n    return { x: p.x, y: p.y };\r\n  });\r\n}\r\n\r\nfunction notYetDrawn(translate, semantic, refSemantic, property) {\r\n  return new Error(translate('element {element} referenced by {referenced}#{property} not yet drawn', {\r\n    element: elementToString(refSemantic),\r\n    referenced: elementToString(semantic),\r\n    property: property\r\n  }));\r\n}\r\n\r\n/**\r\n * An importer that adds vdml elements to the canvas\r\n *\r\n * @param {EventBus} eventBus\r\n * @param {Canvas} canvas\r\n * @param {ElementFactory} elementFactory\r\n * @param {ElementRegistry} elementRegistry\r\n */\r\nfunction VdmlImporter(eventBus, canvas, elementFactory, elementRegistry, translate) {\r\n  this._eventBus = eventBus;\r\n  this._canvas = canvas;\r\n\r\n  this._elementFactory = elementFactory;\r\n  this._elementRegistry = elementRegistry;\r\n  this._translate = translate;\r\n}\r\n\r\nVdmlImporter.$inject = [ 'eventBus', 'canvas', 'elementFactory', 'elementRegistry', 'translate' ];\r\n\r\nmodule.exports = VdmlImporter;\r\n\r\n\r\n/**\r\n * Add vdml element (semantic) to the canvas onto the\r\n * specified parent shape.\r\n */\r\nVdmlImporter.prototype.add = function(semantic, parentElement) {\r\n\r\n  var di = semantic.di,\r\n      element,\r\n      translate = this._translate,\r\n      hidden;\r\n\r\n  // ROOT ELEMENT\r\n  // handle the special case that we deal with a\r\n  // invisible root element (process or collaboration)\r\n  if (is(di, 'vdmldi:VDMLPlane')) {\r\n\r\n    // add a virtual element (not being drawn)\r\n    element = this._elementFactory.createRoot(elementData(semantic));\r\n\r\n    this._canvas.setRootElement(element);\r\n  }\r\n\r\n  // SHAPE\r\n  else if (is(di, 'vdmldi:VDMLShape')) {\r\n\r\n    var collapsed = !isExpanded(semantic);\r\n    hidden = parentElement && (parentElement.hidden || parentElement.collapsed);\r\n\r\n    var bounds = semantic.di.bounds;\r\n\r\n    element = this._elementFactory.createShape(elementData(semantic, {\r\n      collapsed: collapsed,\r\n      hidden: hidden,\r\n      x: Math.round(bounds.x),\r\n      y: Math.round(bounds.y),\r\n      width: Math.round(bounds.width),\r\n      height: Math.round(bounds.height)\r\n    }));\r\n\r\n    if (is(semantic, 'vdml:BoundaryEvent')) {\r\n      this._attachBoundary(semantic, element);\r\n    }\r\n\r\n    this._canvas.addShape(element, parentElement);\r\n  }\r\n\r\n  // CONNECTION\r\n  else if (is(di, 'vdmldi:VDMLEdge')) {\r\n\r\n    var source = this._getSource(semantic),\r\n        target = this._getTarget(semantic);\r\n\r\n    hidden = parentElement && (parentElement.hidden || parentElement.collapsed);\r\n\r\n    element = this._elementFactory.createConnection(elementData(semantic, {\r\n      hidden: hidden,\r\n      source: source,\r\n      target: target,\r\n      waypoints: collectWaypoints(semantic.di.waypoint)\r\n    }));\r\n\r\n    if (is(semantic, 'vdml:DataInputAssociation') || is(semantic, 'vdml:DataOutputAssociation')) {\r\n      // implicit root element\r\n      parentElement = null;\r\n    }\r\n\r\n    this._canvas.addConnection(element, parentElement);\r\n  } else {\r\n    throw new Error(translate('unknown di {di} for element {semantic}', {\r\n      di: elementToString(di),\r\n      semantic: elementToString(semantic)\r\n    }));\r\n  }\r\n  // (optional) LABEL\r\n  if (hasExternalLabel(semantic)) {\r\n    this.addLabel(semantic, element);\r\n  }\r\n\r\n\r\n  this._eventBus.fire('vdmlElement.added', { element: element });\r\n\r\n  return element;\r\n};\r\n\r\n\r\n/**\r\n * Attach the boundary element to the given host\r\n *\r\n * @param {ModdleElement} boundarySemantic\r\n * @param {djs.model.Base} boundaryElement\r\n */\r\nVdmlImporter.prototype._attachBoundary = function(boundarySemantic, boundaryElement) {\r\n  var translate = this._translate;\r\n  var hostSemantic = boundarySemantic.attachedToRef;\r\n\r\n  if (!hostSemantic) {\r\n    throw new Error(translate('missing {semantic}#attachedToRef', {\r\n      semantic: elementToString(boundarySemantic)\r\n    }));\r\n  }\r\n\r\n  var host = this._elementRegistry.get(hostSemantic.id),\r\n      attachers = host && host.attachers;\r\n\r\n  if (!host) {\r\n    throw notYetDrawn(translate, boundarySemantic, hostSemantic, 'attachedToRef');\r\n  }\r\n\r\n  // wire element.host <> host.attachers\r\n  boundaryElement.host = host;\r\n\r\n  if (!attachers) {\r\n    host.attachers = attachers = [];\r\n  }\r\n\r\n  if (attachers.indexOf(boundaryElement) === -1) {\r\n    attachers.push(boundaryElement);\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * add label for an element\r\n */\r\nVdmlImporter.prototype.addLabel = function(semantic, element) {\r\n  var bounds = getExternalLabelBounds(semantic, element);\r\n\r\n  var label = this._elementFactory.createLabel(elementData(semantic, {\r\n    id: semantic.id + '_label',\r\n    labelTarget: element,\r\n    type: 'label',\r\n    hidden: element.hidden || !semantic.name,\r\n    x: Math.round(bounds.x),\r\n    y: Math.round(bounds.y),\r\n    width: Math.round(bounds.width),\r\n    height: Math.round(bounds.height)\r\n  }));\r\n\r\n  return this._canvas.addShape(label, element.parent);\r\n};\r\n\r\n/**\r\n * Return the drawn connection end based on the given side.\r\n *\r\n * @throws {Error} if the end is not yet drawn\r\n */\r\nVdmlImporter.prototype._getEnd = function(semantic, side) {\r\n\r\n  var element,\r\n      refSemantic,\r\n      type = semantic.$type,\r\n      translate = this._translate;\r\n\r\n  refSemantic = semantic[side + 'Ref'];\r\n\r\n  // handle mysterious isMany DataAssociation#sourceRef\r\n  if (side === 'source' && type === 'vdml:DataInputAssociation') {\r\n    refSemantic = refSemantic && refSemantic[0];\r\n  }\r\n\r\n  // fix source / target for DataInputAssociation / DataOutputAssociation\r\n  if (side === 'source' && type === 'vdml:DataOutputAssociation' ||\r\n      side === 'target' && type === 'vdml:DataInputAssociation') {\r\n\r\n    refSemantic = semantic.$parent;\r\n  }\r\n\r\n  element = refSemantic && this._getElement(refSemantic);\r\n\r\n  if (element) {\r\n    return element;\r\n  }\r\n\r\n  if (refSemantic) {\r\n    throw notYetDrawn(translate, semantic, refSemantic, side + 'Ref');\r\n  } else {\r\n    throw new Error(translate('{semantic}#{side} Ref not specified', {\r\n      semantic: elementToString(semantic),\r\n      side: side\r\n    }));\r\n  }\r\n};\r\n\r\nVdmlImporter.prototype._getSource = function(semantic) {\r\n  return this._getEnd(semantic, 'source');\r\n};\r\n\r\nVdmlImporter.prototype._getTarget = function(semantic) {\r\n  return this._getEnd(semantic, 'target');\r\n};\r\n\r\n\r\nVdmlImporter.prototype._getElement = function(semantic) {\r\n  return this._elementRegistry.get(semantic.id);\r\n};\r\n","'use strict';\r\n\r\nvar filter = require(281),\r\n    find = require(282),\r\n    forEach = require(283);\r\n\r\nvar Refs = require(441);\r\n\r\nvar elementToString = require(87).elementToString;\r\n\r\nvar diRefs = new Refs({ name: 'vdmlElement', enumerable: true }, { name: 'di' });\r\n\r\n/**\r\n * Returns true if an element has the given meta-model type\r\n *\r\n * @param  {ModdleElement}  element\r\n * @param  {String}         type\r\n *\r\n * @return {Boolean}\r\n */\r\nfunction is(element, type) {\r\n  return element.$instanceOf(type);\r\n}\r\n\r\n\r\n/**\r\n * Find a suitable display candidate for definitions where the DI does not\r\n * correctly specify one.\r\n */\r\nfunction findDisplayCandidate(definitions) {\r\n  return find(definitions.rootElements, function(e) {\r\n    return is(e, 'vdml:EcoMap');\r\n  });\r\n}\r\n\r\n\r\nfunction VdmlTreeWalker(handler, translate) {\r\n\r\n  // list of containers already walked\r\n  var handledElements = {};\r\n\r\n  // list of elements to handle deferred to ensure\r\n  // prerequisites are drawn\r\n  var deferred = [];\r\n\r\n  ///// Helpers /////////////////////////////////\r\n\r\n  function contextual(fn, ctx) {\r\n    return function(e) {\r\n      fn(e, ctx);\r\n    };\r\n  }\r\n\r\n  function handled(element) {\r\n    handledElements[element.id] = element;\r\n  }\r\n\r\n  function isHandled(element) {\r\n    return handledElements[element.id];\r\n  }\r\n\r\n  function visit(element, ctx) {\r\n\r\n    var gfx = element.gfx;\r\n\r\n    // avoid multiple rendering of elements\r\n    if (gfx) {\r\n      throw new Error(\r\n        translate('already rendered {element}', { element: elementToString(element) })\r\n      );\r\n    }\r\n\r\n    // call handler\r\n    return handler.element(element, ctx);\r\n  }\r\n\r\n  function visitRoot(element, diagram) {\r\n    return handler.root(element, diagram);\r\n  }\r\n\r\n  function visitIfDi(element, ctx) {\r\n\r\n    try {\r\n      var gfx = element.di && visit(element, ctx);\r\n\r\n      handled(element);\r\n\r\n      return gfx;\r\n    } catch (e) {\r\n      logError(e.message, { element: element, error: e });\r\n\r\n      console.error(translate('failed to import {element}', { element: elementToString(element) }));\r\n      console.error(e);\r\n    }\r\n  }\r\n\r\n  function logError(message, context) {\r\n    handler.error(message, context);\r\n  }\r\n\r\n  ////// DI handling ////////////////////////////\r\n\r\n  function registerDi(di) {\r\n    var vdmlElement = di.vdmlElement;\r\n\r\n    if (vdmlElement) {\r\n      if (vdmlElement.di) {\r\n        logError(\r\n          translate('multiple DI elements defined for {element}', {\r\n            element: elementToString(vdmlElement)\r\n          }),\r\n          { element: vdmlElement  }\r\n        );\r\n      } else {\r\n        diRefs.bind(vdmlElement, 'di');\r\n        vdmlElement.di = di;\r\n      }\r\n    } else {\r\n      logError(\r\n        translate('no vdmlElement referenced in {element}', {\r\n          element: elementToString(di)\r\n        }),\r\n        { element: di }\r\n      );\r\n    }\r\n  }\r\n\r\n  function handleDiagram(diagram) {\r\n    handlePlane(diagram.plane);\r\n  }\r\n\r\n  function handlePlane(plane) {\r\n    registerDi(plane);\r\n\r\n    forEach(plane.planeElement, handlePlaneElement);\r\n  }\r\n\r\n  function handlePlaneElement(planeElement) {\r\n    registerDi(planeElement);\r\n  }\r\n\r\n\r\n  ////// Semantic handling //////////////////////\r\n\r\n  /**\r\n   * Handle definitions and return the rendered diagram (if any)\r\n   *\r\n   * @param {ModdleElement} definitions to walk and import\r\n   * @param {ModdleElement} [diagram] specific diagram to import and display\r\n   *\r\n   * @throws {Error} if no diagram to display could be found\r\n   */\r\n  function handleDefinitions(definitions, diagram) {\r\n    // make sure we walk the correct vdmlElement\r\n\r\n    var diagrams = definitions.diagrams;\r\n\r\n    if (diagram && diagrams.indexOf(diagram) === -1) {\r\n      throw new Error(translate('diagram not part of vdml:Definitions'));\r\n    }\r\n\r\n    if (!diagram && diagrams && diagrams.length) {\r\n      diagram = diagrams[0];\r\n    }\r\n\r\n    // no diagram -> nothing to import\r\n    if (!diagram) {\r\n      throw new Error(translate('no diagram to display'));\r\n    }\r\n\r\n    // load DI from selected diagram only\r\n    handleDiagram(diagram);\r\n\r\n\r\n    var plane = diagram.plane;\r\n\r\n    if (!plane) {\r\n      throw new Error(translate(\r\n        'no plane for {element}',\r\n        { element: elementToString(diagram) }\r\n      ));\r\n    }\r\n\r\n    var rootElement = plane.vdmlElement;\r\n\r\n    // ensure we default to a suitable display candidate (process or collaboration),\r\n    // even if non is specified in DI\r\n    if (!rootElement) {\r\n      rootElement = findDisplayCandidate(definitions);\r\n\r\n      if (!rootElement) {\r\n        throw new Error(translate('no process or collaboration to display'));\r\n      } else {\r\n\r\n        logError(\r\n          translate('correcting missing vdmlElement on {plane} to {rootElement}', {\r\n            plane: elementToString(plane),\r\n            rootElement: elementToString(rootElement)\r\n          })\r\n        );\r\n\r\n        // correct DI on the fly\r\n        plane.vdmlElement = rootElement;\r\n        registerDi(plane);\r\n      }\r\n    }\r\n\r\n\r\n    var ctx = visitRoot(rootElement, plane);\r\n\r\n    if (is(rootElement, 'vdml:EcoMap')) {\r\n      handleProcess(rootElement, ctx);\r\n    } else if (is(rootElement, 'vdml:Collaboration')) {\r\n      handleCollaboration(rootElement, ctx);\r\n\r\n      // force drawing of everything not yet drawn that is part of the target DI\r\n      handleUnhandledProcesses(definitions.rootElements, ctx);\r\n    } else {\r\n      throw new Error(\r\n        translate('unsupported vdmlElement for {plane}: {rootElement}', {\r\n          plane: elementToString(plane),\r\n          rootElement: elementToString(rootElement)\r\n        })\r\n      );\r\n    }\r\n\r\n    // handle all deferred elements\r\n    handleDeferred(deferred);\r\n  }\r\n\r\n  function handleDeferred(deferred) {\r\n    forEach(deferred, function(d) { d(); });\r\n  }\r\n\r\n  function handleProcess(process, context) {\r\n      //TODO\r\n    /*handleFlowElementsContainer(process, context);\r\n    handleIoSpecification(process.ioSpecification, context);\r\n\r\n    handleArtifacts(process.artifacts, context);*/\r\n\r\n    // log process handled\r\n    handled(process);\r\n  }\r\n\r\n  function handleUnhandledProcesses(rootElements) {\r\n\r\n    // walk through all processes that have not yet been drawn and draw them\r\n    // if they contain lanes with DI information.\r\n    // we do this to pass the free-floating lane test cases in the MIWG test suite\r\n    var processes = filter(rootElements, function(e) {\r\n      return !isHandled(e) && is(e, 'vdml:Process') && e.laneSets;\r\n    });\r\n\r\n    processes.forEach(contextual(handleProcess));\r\n  }\r\n\r\n  function handleMessageFlow(messageFlow, context) {\r\n    visitIfDi(messageFlow, context);\r\n  }\r\n\r\n  function handleMessageFlows(messageFlows, context) {\r\n    forEach(messageFlows, contextual(handleMessageFlow, context));\r\n  }\r\n\r\n  function handleDataAssociation(association, context) {\r\n    visitIfDi(association, context);\r\n  }\r\n\r\n  function handleDataInput(dataInput, context) {\r\n    visitIfDi(dataInput, context);\r\n  }\r\n\r\n  function handleDataOutput(dataOutput, context) {\r\n    visitIfDi(dataOutput, context);\r\n  }\r\n\r\n  function handleArtifact(artifact, context) {\r\n\r\n    // vdml:TextAnnotation\r\n    // vdml:Group\r\n    // vdml:Association\r\n\r\n    visitIfDi(artifact, context);\r\n  }\r\n\r\n  function handleArtifacts(artifacts, context) {\r\n\r\n    forEach(artifacts, function(e) {\r\n      if (is(e, 'vdml:Association')) {\r\n        deferred.push(function() {\r\n          handleArtifact(e, context);\r\n        });\r\n      } else {\r\n        handleArtifact(e, context);\r\n      }\r\n    });\r\n  }\r\n\r\n  function handleIoSpecification(ioSpecification, context) {\r\n\r\n    if (!ioSpecification) {\r\n      return;\r\n    }\r\n\r\n    forEach(ioSpecification.dataInputs, contextual(handleDataInput, context));\r\n    forEach(ioSpecification.dataOutputs, contextual(handleDataOutput, context));\r\n  }\r\n\r\n  function handleSubProcess(subProcess, context) {\r\n    handleFlowElementsContainer(subProcess, context);\r\n    handleArtifacts(subProcess.artifacts, context);\r\n  }\r\n\r\n  function handleFlowNode(flowNode, context) {\r\n    var childCtx = visitIfDi(flowNode, context);\r\n\r\n    if (is(flowNode, 'vdml:SubProcess')) {\r\n      handleSubProcess(flowNode, childCtx || context);\r\n    }\r\n\r\n    if (is(flowNode, 'vdml:Activity')) {\r\n      handleIoSpecification(flowNode.ioSpecification, context);\r\n    }\r\n\r\n    // defer handling of associations\r\n    // affected types:\r\n    //\r\n    //   * vdml:Activity\r\n    //   * vdml:ThrowEvent\r\n    //   * vdml:CatchEvent\r\n    //\r\n    deferred.push(function() {\r\n      forEach(flowNode.dataInputAssociations, contextual(handleDataAssociation, context));\r\n      forEach(flowNode.dataOutputAssociations, contextual(handleDataAssociation, context));\r\n    });\r\n  }\r\n\r\n  function handleSequenceFlow(sequenceFlow, context) {\r\n    visitIfDi(sequenceFlow, context);\r\n  }\r\n\r\n  function handleDataElement(dataObject, context) {\r\n    visitIfDi(dataObject, context);\r\n  }\r\n\r\n  function handleBoundaryEvent(dataObject, context) {\r\n    visitIfDi(dataObject, context);\r\n  }\r\n\r\n  function handleLane(lane, context) {\r\n    var newContext = visitIfDi(lane, context);\r\n\r\n    if (lane.childLaneSet) {\r\n      handleLaneSet(lane.childLaneSet, newContext || context);\r\n    }\r\n\r\n    wireFlowNodeRefs(lane);\r\n  }\r\n\r\n  function handleLaneSet(laneSet, context) {\r\n    forEach(laneSet.lanes, contextual(handleLane, context));\r\n  }\r\n\r\n  function handleLaneSets(laneSets, context) {\r\n    forEach(laneSets, contextual(handleLaneSet, context));\r\n  }\r\n\r\n  function handleFlowElementsContainer(container, context) {\r\n    if (container.laneSets) {\r\n      handleLaneSets(container.laneSets, context);\r\n    }\r\n\r\n    handleFlowElements(container.flowElements, context);\r\n  }\r\n\r\n  function handleFlowElements(flowElements, context) {\r\n    forEach(flowElements, function(e) {\r\n      if (is(e, 'vdml:SequenceFlow')) {\r\n        deferred.push(function() {\r\n          handleSequenceFlow(e, context);\r\n        });\r\n      } else if (is(e, 'vdml:BoundaryEvent')) {\r\n        deferred.unshift(function() {\r\n          handleBoundaryEvent(e, context);\r\n        });\r\n      } else if (is(e, 'vdml:FlowNode')) {\r\n        handleFlowNode(e, context);\r\n      } else if (is(e, 'vdml:DataObject')) {\r\n        // SKIP (assume correct referencing via DataObjectReference)\r\n      } else if (is(e, 'vdml:DataStoreReference')) {\r\n        handleDataElement(e, context);\r\n      } else if (is(e, 'vdml:DataObjectReference')) {\r\n        handleDataElement(e, context);\r\n      } else {\r\n        logError(\r\n          translate('unrecognized flowElement {element} in context {context}', {\r\n            element: elementToString(e),\r\n            context: (context ? elementToString(context.businessObject) : 'null')\r\n          }),\r\n          { element: e, context: context }\r\n        );\r\n      }\r\n    });\r\n  }\r\n\r\n  function handleParticipant(participant, context) {\r\n    var newCtx = visitIfDi(participant, context);\r\n\r\n    var process = participant.processRef;\r\n    if (process) {\r\n      handleProcess(process, newCtx || context);\r\n    }\r\n  }\r\n\r\n  function handleCollaboration(collaboration) {\r\n\r\n    forEach(collaboration.participants, contextual(handleParticipant));\r\n\r\n    handleArtifacts(collaboration.artifacts);\r\n\r\n    // handle message flows latest in the process\r\n    deferred.push(function() {\r\n      handleMessageFlows(collaboration.messageFlows);\r\n    });\r\n  }\r\n\r\n\r\n  function wireFlowNodeRefs(lane) {\r\n    // wire the virtual flowNodeRefs <-> relationship\r\n    forEach(lane.flowNodeRef, function(flowNode) {\r\n      var lanes = flowNode.get('lanes');\r\n\r\n      if (lanes) {\r\n        lanes.push(lane);\r\n      }\r\n    });\r\n  }\r\n\r\n  ///// API ////////////////////////////////\r\n\r\n  return {\r\n    handleDefinitions: handleDefinitions\r\n  };\r\n}\r\n\r\nmodule.exports = VdmlTreeWalker;","module.exports = {\r\n  __depends__: [\r\n    require(229)\r\n  ],\r\n  vdmlImporter: [ 'type', require(88) ]\r\n};","'use strict';\r\n\r\nvar is = require(93).is,\r\n    getBusinessObject = require(93).getBusinessObject;\r\n\r\nmodule.exports.isExpanded = function(element) {\r\n\r\n  if (is(element, 'vdml:CallActivity')) {\r\n    return false;\r\n  }\r\n\r\n  if (is(element, 'vdml:SubProcess')) {\r\n    return !!getBusinessObject(element).di.isExpanded;\r\n  }\r\n\r\n  if (is(element, 'vdml:Participant')) {\r\n    return !!getBusinessObject(element).processRef;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nmodule.exports.isInterrupting = function(element) {\r\n  return element && getBusinessObject(element).isInterrupting !== false;\r\n};\r\n\r\nmodule.exports.isEventSubProcess = function(element) {\r\n  return element && !!getBusinessObject(element).triggeredByEvent;\r\n};\r\n","'use strict';\r\n\r\nvar assign = require(410);\r\n\r\nvar is = require(93).is;\r\n\r\nvar DEFAULT_LABEL_SIZE = module.exports.DEFAULT_LABEL_SIZE = {\r\n  width: 90,\r\n  height: 20\r\n};\r\n\r\nvar FLOW_LABEL_INDENT = module.exports.FLOW_LABEL_INDENT = 15;\r\n\r\n\r\n/**\r\n * Returns true if the given semantic has an external label\r\n *\r\n * @param {BpmnElement} semantic\r\n * @return {Boolean} true if has label\r\n */\r\nmodule.exports.hasExternalLabel = function(semantic) {\r\n  return is(semantic, 'vdml:Event') ||\r\n         is(semantic, 'vdml:Gateway') ||\r\n         is(semantic, 'vdml:DataStoreReference') ||\r\n         is(semantic, 'vdml:DataObjectReference') ||\r\n         is(semantic, 'vdml:SequenceFlow') ||\r\n         is(semantic, 'vdml:MessageFlow');\r\n};\r\n\r\n/**\r\n * Get the position for sequence flow labels\r\n *\r\n * @param  {Array<Point>} waypoints\r\n * @return {Point} the label position\r\n */\r\nfunction getFlowLabelPosition(waypoints) {\r\n\r\n  // get the waypoints mid\r\n  var mid = waypoints.length / 2 - 1;\r\n\r\n  var first = waypoints[Math.floor(mid)];\r\n  var second = waypoints[Math.ceil(mid + 0.01)];\r\n\r\n  // get position\r\n  var position = getWaypointsMid(waypoints);\r\n\r\n  // calculate angle\r\n  var angle = Math.atan( (second.y - first.y) / (second.x - first.x) );\r\n\r\n  var x = position.x,\r\n      y = position.y;\r\n\r\n  if ( Math.abs(angle) < Math.PI / 2 ) {\r\n    y -= FLOW_LABEL_INDENT;\r\n  } else {\r\n    x += FLOW_LABEL_INDENT;\r\n  }\r\n\r\n  return { x: x, y: y };\r\n}\r\n\r\nmodule.exports.getFlowLabelPosition = getFlowLabelPosition;\r\n\r\n/**\r\n * Get the middle of a number of waypoints\r\n *\r\n * @param  {Array<Point>} waypoints\r\n * @return {Point} the mid point\r\n */\r\nfunction getWaypointsMid(waypoints) {\r\n\r\n  var mid = waypoints.length / 2 - 1;\r\n\r\n  var first = waypoints[Math.floor(mid)];\r\n  var second = waypoints[Math.ceil(mid + 0.01)];\r\n\r\n  return {\r\n    x: first.x + (second.x - first.x) / 2,\r\n    y: first.y + (second.y - first.y) / 2\r\n  };\r\n}\r\n\r\nmodule.exports.getWaypointsMid = getWaypointsMid;\r\n\r\n\r\nfunction getExternalLabelMid(element) {\r\n\r\n  if (element.waypoints) {\r\n    return getFlowLabelPosition(element.waypoints);\r\n  } else {\r\n    return {\r\n      x: element.x + element.width / 2,\r\n      y: element.y + element.height + DEFAULT_LABEL_SIZE.height / 2\r\n    };\r\n  }\r\n}\r\n\r\nmodule.exports.getExternalLabelMid = getExternalLabelMid;\r\n\r\n\r\n/**\r\n * Returns the bounds of an elements label, parsed from the elements DI or\r\n * generated from its bounds.\r\n *\r\n * @param {BpmnElement} semantic\r\n * @param {djs.model.Base} element\r\n */\r\nmodule.exports.getExternalLabelBounds = function(semantic, element) {\r\n\r\n  var mid,\r\n      size,\r\n      bounds,\r\n      di = semantic.di,\r\n      label = di.label;\r\n\r\n  if (label && label.bounds) {\r\n    bounds = label.bounds;\r\n\r\n    size = {\r\n      width: Math.max(DEFAULT_LABEL_SIZE.width, bounds.width),\r\n      height: bounds.height\r\n    };\r\n\r\n    mid = {\r\n      x: bounds.x + bounds.width / 2,\r\n      y: bounds.y + bounds.height / 2\r\n    };\r\n  } else {\r\n\r\n    mid = getExternalLabelMid(element);\r\n\r\n    size = DEFAULT_LABEL_SIZE;\r\n  }\r\n\r\n  return assign({\r\n    x: mid.x - size.width / 2,\r\n    y: mid.y - size.height / 2\r\n  }, size);\r\n};\r\n","'use strict';\r\n\r\n/**\r\n * Is an element of the given BPMN type?\r\n *\r\n * @param  {djs.model.Base|ModdleElement} element\r\n * @param  {String} type\r\n *\r\n * @return {Boolean}\r\n */\r\nfunction is(element, type) {\r\n  var bo = getBusinessObject(element);\r\n\r\n  return bo && (typeof bo.$instanceOf === 'function') && bo.$instanceOf(type);\r\n}\r\n\r\nmodule.exports.is = is;\r\n\r\n\r\n/**\r\n * Return the business object for a given element.\r\n *\r\n * @param  {djs.model.Base|ModdleElement} element\r\n *\r\n * @return {ModdleElement}\r\n */\r\nfunction getBusinessObject(element) {\r\n  return (element && element.businessObject) || element;\r\n}\r\n\r\nmodule.exports.getBusinessObject = getBusinessObject;\r\n","/**\r\n * This file must not be changed or exchanged.\r\n *\r\n * @see http://bpmn.io/license for more information.\r\n */\r\n\r\n'use strict';\r\n\r\nvar domify = require(428);\r\n\r\nvar domDelegate = require(427);\r\n\r\n/* jshint -W101 */\r\n\r\n// inlined ../resources/bpmnjs.png\r\nvar logoData = module.exports.VDMLIO_LOGO = 'iVBORw0KGgoAAAANSUhEUgAAADQAAAA0CAMAAADypuvZAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAADBQTFRFiMte9PrwldFwfcZPqtqN0+zEyOe1XLgjvuKncsJAZ70y6fXh3vDT////UrQV////G2zN+AAAABB0Uk5T////////////////////AOAjXRkAAAHDSURBVHjavJZJkoUgDEBJmAX8979tM8u3E6x20VlYJfFFMoL4vBDxATxZcakIOJTWSmxvKWVIkJ8jHvlRv1F2LFrVISCZI+tCtQx+XfewgVTfyY3plPiQEAzI3zWy+kR6NBhFBYeBuscJLOUuA2WVLpCjVIaFzrNQZArxAZKUQm6gsj37L9Cb7dnIBUKxENaaMJQqMpDXvSL+ktxdGRm2IsKgJGGPg7atwUG5CcFUEuSv+CwQqizTrvDTNXdMU2bMiDWZd8d7QIySWVRsb2vBBioxOFt4OinPBapL+neAb5KL5IJ8szOza2/DYoipUCx+CjO0Bpsv0V6mktNZ+k8rlABlWG0FrOpKYVo8DT3dBeLEjUBAj7moDogVii7nSS9QzZnFcOVBp1g2PyBQ3Vr5aIapN91VJy33HTJLC1iX2FY6F8gRdaAeIEfVONgtFCzZTmoLEdOjBDfsIOA6128gw3eu1shAajdZNAORxuQDJN5A5PbEG6gNIu24QJD5iNyRMZIr6bsHbCtCU/OaOaSvgkUyDMdDa1BXGf5HJ1To+/Ym6mCKT02Y+/Sa126ZKyd3jxhzpc1r8zVL6YM1Qy/kR4ABAFJ6iQUnivhAAAAAAElFTkSuQmCC';\r\n\r\n/* jshint +W101 */\r\n\r\n\r\nfunction css(attrs) {\r\n  return attrs.join(';');\r\n}\r\n\r\nvar LIGHTBOX_STYLES = css([\r\n  'z-index: 1001',\r\n  'position: fixed',\r\n  'top: 0',\r\n  'left: 0',\r\n  'right: 0',\r\n  'bottom: 0'\r\n]);\r\n\r\nvar BACKDROP_STYLES = css([\r\n  'width: 100%',\r\n  'height: 100%',\r\n  'background: rgba(0,0,0,0.2)'\r\n]);\r\n\r\nvar NOTICE_STYLES = css([\r\n  'position: absolute',\r\n  'left: 50%',\r\n  'top: 40%',\r\n  'margin: 0 -130px',\r\n  'width: 260px',\r\n  'padding: 10px',\r\n  'background: white',\r\n  'border: solid 1px #AAA',\r\n  'border-radius: 3px',\r\n  'font-family: Helvetica, Arial, sans-serif',\r\n  'font-size: 14px',\r\n  'line-height: 1.2em'\r\n]);\r\n\r\nvar LIGHTBOX_MARKUP =\r\n  '<div class=\"bjs-powered-by-lightbox\" style=\"' + LIGHTBOX_STYLES + '\">' +\r\n    '<div class=\"backdrop\" style=\"' + BACKDROP_STYLES + '\"></div>' +\r\n    '<div class=\"notice\" style=\"' + NOTICE_STYLES + '\">' +\r\n      '<a href=\"http://bpmn.io\" target=\"_blank\" style=\"float: left; margin-right: 10px\">' +\r\n        '<img src=\"data:image/png;base64,'+ logoData +'\">' +\r\n      '</a>' +\r\n      'Web-based tooling for BPMN, DMN and CMMN diagrams ' +\r\n      'powered by <a href=\"http://bpmn.io\" target=\"_blank\">bpmn.io</a>.' +\r\n    '</div>' +\r\n  '</div>';\r\n\r\n\r\nvar lightbox;\r\n\r\nfunction open() {\r\n\r\n  if (!lightbox) {\r\n    lightbox = domify(LIGHTBOX_MARKUP);\r\n\r\n    domDelegate.bind(lightbox, '.backdrop', 'click', function(event) {\r\n      document.body.removeChild(lightbox);\r\n    });\r\n  }\r\n\r\n  document.body.appendChild(lightbox);\r\n}\r\n\r\nmodule.exports.open = open;","module.exports = {\n  __depends__: [ require(151) ],\n  __init__: [ 'directEditing' ],\n  directEditing: [ 'type', require(96) ]\n};","'use strict';\n\nvar bind = require(293),\n    find = require(282);\n\nvar TextBox = require(97);\n\n\n/**\n * A direct editing component that allows users\n * to edit an elements text directly in the diagram\n *\n * @param {EventBus} eventBus the event bus\n */\nfunction DirectEditing(eventBus, canvas) {\n\n  this._eventBus = eventBus;\n\n  this._providers = [];\n  this._textbox = new TextBox({\n    container: canvas.getContainer(),\n    keyHandler: bind(this._handleKey, this)\n  });\n}\n\nDirectEditing.$inject = [ 'eventBus', 'canvas' ];\n\n\n/**\n * Register a direct editing provider\n\n * @param {Object} provider the provider, must expose an #activate(element) method that returns\n *                          an activation context ({ bounds: {x, y, width, height }, text }) if\n *                          direct editing is available for the given element.\n *                          Additionally the provider must expose a #update(element, value) method\n *                          to receive direct editing updates.\n */\nDirectEditing.prototype.registerProvider = function(provider) {\n  this._providers.push(provider);\n};\n\n\n/**\n * Returns true if direct editing is currently active\n *\n * @return {Boolean}\n */\nDirectEditing.prototype.isActive = function() {\n  return !!this._active;\n};\n\n\n/**\n * Cancel direct editing, if it is currently active\n */\nDirectEditing.prototype.cancel = function() {\n  if (!this._active) {\n    return;\n  }\n\n  this._fire('cancel');\n  this.close();\n};\n\n\nDirectEditing.prototype._fire = function(event) {\n  this._eventBus.fire('directEditing.' + event, { active: this._active });\n};\n\nDirectEditing.prototype.close = function() {\n  this._textbox.destroy();\n\n  this._fire('deactivate');\n\n  this._active = null;\n};\n\n\nDirectEditing.prototype.complete = function() {\n\n  var active = this._active;\n\n  if (!active) {\n    return;\n  }\n\n  var text = this.getValue();\n\n  if (text !== active.context.text) {\n    active.provider.update(active.element, text, active.context.text);\n  }\n\n  this._fire('complete');\n\n  this.close();\n};\n\n\nDirectEditing.prototype.getValue = function() {\n  return this._textbox.getValue();\n};\n\n\nDirectEditing.prototype._handleKey = function(e) {\n\n  // stop bubble\n  e.stopPropagation();\n\n  var key = e.keyCode || e.charCode;\n\n  // ESC\n  if (key === 27) {\n    e.preventDefault();\n    return this.cancel();\n  }\n\n  // Enter\n  if (key === 13 && !e.shiftKey) {\n    e.preventDefault();\n    return this.complete();\n  }\n};\n\n\n/**\n * Activate direct editing on the given element\n *\n * @param {Object} ElementDescriptor the descriptor for a shape or connection\n * @return {Boolean} true if the activation was possible\n */\nDirectEditing.prototype.activate = function(element) {\n\n  if (this.isActive()) {\n    this.cancel();\n  }\n\n  // the direct editing context\n  var context;\n\n  var provider = find(this._providers, function(p) {\n    return (context = p.activate(element)) ? p : null;\n  });\n\n  // check if activation took place\n  if (context) {\n    this._textbox.create(context.bounds, context.style, context.text);\n\n    this._active = {\n      element: element,\n      context: context,\n      provider: provider\n    };\n\n    this._fire('activate');\n  }\n\n  return !!context;\n};\n\n\nmodule.exports = DirectEditing;","'use strict';\n\nvar assign = require(410),\n    domEvent = require(429),\n    domRemove = require(432);\n\nfunction stopPropagation(event) {\n  event.stopPropagation();\n}\n\n\n/**\n * Initializes a container div 'contentContainer' which contains an editable content div 'content'.\n *\n * @param {object} options\n * @param {DOMElement} options.container The DOM element to append the contentContainer to\n * @param {String} options.keyHandler\n */\nfunction TextBox(options) {\n\n  this.container = options.container;\n\n  this.content = document.createElement('div');\n\n  this.content.contentEditable = 'true';\n\n  this.keyHandler = options.keyHandler || function() {};\n}\n\nmodule.exports = TextBox;\n\n\n/**\n * Create a text box with the given position, size, style and text content\n *\n * @param {Object} bounds\n * @param {Number} bounds.x absolute x position\n * @param {Number} bounds.y absolute y position\n * @param {Number} [bounds.width] fixed width value\n * @param {Number} [bounds.height] fixed height value\n * @param {Number} [bounds.maxWidth] maximum width value\n * @param {Number} [bounds.maxHeight] maximum height value\n * @param {Number} [bounds.minWidth] minimum width value\n * @param {Number} [bounds.minHeight] minimum height value\n * @param {Object} [style]\n * @param {String} value text content\n *\n * @return {DOMElement} The created content DOM element\n */\nTextBox.prototype.create = function(bounds, style, value) {\n\n  var content = this.content,\n      container = this.container;\n\n  assign(content.style, {\n    width: bounds.width + 'px',\n    height: bounds.height + 'px',\n    maxWidth: bounds.maxWidth + 'px',\n    maxHeight: bounds.maxHeight + 'px',\n    minWidth: bounds.minWidth + 'px',\n    minHeight: bounds.minHeight + 'px',\n    left: bounds.x + 'px',\n    top: bounds.y + 'px',\n    backgroundColor: '#ffffff',\n    position: 'absolute',\n    overflowY: 'auto',\n    border: '1px solid #ccc',\n    padding: '2px',\n    wordWrap: 'normal',\n    textAlign: 'center',\n    outline: 'none'\n  }, style || {});\n\n  content.innerText = value;\n\n  domEvent.bind(content, 'keydown', this.keyHandler);\n  domEvent.bind(content, 'mousedown', stopPropagation);\n\n  container.appendChild(content);\n\n  var self = this;\n\n  setTimeout(function() {\n    if (content.parent) {\n      content.select();\n    }\n    self.setCursor();\n  }, 100);\n\n  return content;\n};\n\n\n/**\n * Clear content and style of the textbox, unbind listeners and\n * reset CSS style.\n */\nTextBox.prototype.destroy = function() {\n  var content = this.content;\n\n  // clear content\n  content.innerText = '';\n\n  // clear optional bounds values\n  assign(content.style, {\n    width: '',\n    height: '',\n    maxWidth: '',\n    maxHeight: '',\n    minWidth: '',\n    minHeight: ''\n  });\n\n  domEvent.unbind(content, 'keydown', this.keyHandler);\n  domEvent.unbind(content, 'mousedown', stopPropagation);\n\n  domRemove(content);\n};\n\n\nTextBox.prototype.getValue = function() {\n  return this.content.innerText;\n};\n\n\n/**\n * Set the cursor to the end of the text\n */\nTextBox.prototype.setCursor = function() {\n\n  // scroll to the bottom\n  this.content.scrollTop = this.content.scrollHeight;\n\n  var range = document.createRange();\n\n  range.selectNodeContents(this.content);\n  range.collapse(false);\n\n  var selection = window.getSelection();\n\n  selection.removeAllRanges();\n  selection.addRange(range);\n};\n","module.exports = require(99);","'use strict';\n\nvar di = require(261);\n\n\n/**\n * Bootstrap an injector from a list of modules, instantiating a number of default components\n *\n * @ignore\n * @param {Array<didi.Module>} bootstrapModules\n *\n * @return {didi.Injector} a injector to use to access the components\n */\nfunction bootstrap(bootstrapModules) {\n\n  var modules = [],\n      components = [];\n\n  function hasModule(m) {\n    return modules.indexOf(m) >= 0;\n  }\n\n  function addModule(m) {\n    modules.push(m);\n  }\n\n  function visit(m) {\n    if (hasModule(m)) {\n      return;\n    }\n\n    (m.__depends__ || []).forEach(visit);\n\n    if (hasModule(m)) {\n      return;\n    }\n\n    addModule(m);\n\n    (m.__init__ || []).forEach(function(c) {\n      components.push(c);\n    });\n  }\n\n  bootstrapModules.forEach(visit);\n\n  var injector = new di.Injector(modules);\n\n  components.forEach(function(c) {\n\n    try {\n      // eagerly resolve component (fn or string)\n      injector[typeof c === 'string' ? 'get' : 'invoke'](c);\n    } catch (e) {\n      console.error('Failed to instantiate component');\n      console.error(e.stack);\n\n      throw e;\n    }\n  });\n\n  return injector;\n}\n\n/**\n * Creates an injector from passed options.\n *\n * @ignore\n * @param  {Object} options\n * @return {didi.Injector}\n */\nfunction createInjector(options) {\n\n  options = options || {};\n\n  var configModule = {\n    'config': ['value', options]\n  };\n\n  var coreModule = require(108);\n\n  var modules = [ configModule, coreModule ].concat(options.modules || []);\n\n  return bootstrap(modules);\n}\n\n\n/**\n * The main diagram-js entry point that bootstraps the diagram with the given\n * configuration.\n *\n * To register extensions with the diagram, pass them as Array<didi.Module> to the constructor.\n *\n * @class djs.Diagram\n * @memberOf djs\n * @constructor\n *\n * @example\n *\n * <caption>Creating a plug-in that logs whenever a shape is added to the canvas.</caption>\n *\n * // plug-in implemenentation\n * function MyLoggingPlugin(eventBus) {\n *   eventBus.on('shape.added', function(event) {\n *     console.log('shape ', event.shape, ' was added to the diagram');\n *   });\n * }\n *\n * // export as module\n * module.exports = {\n *   __init__: [ 'myLoggingPlugin' ],\n *     myLoggingPlugin: [ 'type', MyLoggingPlugin ]\n * };\n *\n *\n * // instantiate the diagram with the new plug-in\n *\n * var diagram = new Diagram({ modules: [ require('path-to-my-logging-plugin') ] });\n *\n * diagram.invoke([ 'canvas', function(canvas) {\n *   // add shape to drawing canvas\n *   canvas.addShape({ x: 10, y: 10 });\n * });\n *\n * // 'shape ... was added to the diagram' logged to console\n *\n * @param {Object} options\n * @param {Array<didi.Module>} [options.modules] external modules to instantiate with the diagram\n * @param {didi.Injector} [injector] an (optional) injector to bootstrap the diagram with\n */\nfunction Diagram(options, injector) {\n\n  // create injector unless explicitly specified\n  this.injector = injector = injector || createInjector(options);\n\n  // API\n\n  /**\n   * Resolves a diagram service\n   *\n   * @method Diagram#get\n   *\n   * @param {String} name the name of the diagram service to be retrieved\n   * @param {Boolean} [strict=true] if false, resolve missing services to null\n   */\n  this.get = injector.get;\n\n  /**\n   * Executes a function into which diagram services are injected\n   *\n   * @method Diagram#invoke\n   *\n   * @param {Function|Object[]} fn the function to resolve\n   * @param {Object} locals a number of locals to use to resolve certain dependencies\n   */\n  this.invoke = injector.invoke;\n\n  // init\n\n  // indicate via event\n\n\n  /**\n   * An event indicating that all plug-ins are loaded.\n   *\n   * Use this event to fire other events to interested plug-ins\n   *\n   * @memberOf Diagram\n   *\n   * @event diagram.init\n   *\n   * @example\n   *\n   * eventBus.on('diagram.init', function() {\n   *   eventBus.fire('my-custom-event', { foo: 'BAR' });\n   * });\n   *\n   * @type {Object}\n   */\n  this.get('eventBus').fire('diagram.init');\n}\n\nmodule.exports = Diagram;\n\n\n/**\n * Destroys the diagram\n *\n * @method  Diagram#destroy\n */\nDiagram.prototype.destroy = function() {\n  this.get('eventBus').fire('diagram.destroy');\n};\n\n/**\n * Clear the diagram, removing all contents.\n */\nDiagram.prototype.clear = function() {\n  this.get('eventBus').fire('diagram.clear');\n};","'use strict';\n\nvar forEach = require(283),\n    isFunction = require(402),\n    isArray = require(401),\n    isNumber = require(404);\n\n\nvar DEFAULT_PRIORITY = 1000;\n\n\nfunction isObject(element) {\n  return typeof element === 'object';\n}\n\n/**\n * A utility that can be used to plug-in into the command execution for\n * extension and/or validation.\n *\n * @param {EventBus} eventBus\n *\n * @example\n *\n * var inherits = require('inherits');\n *\n * var CommandInterceptor = require('diagram-js/lib/command/CommandInterceptor');\n *\n * function CommandLogger(eventBus) {\n *   CommandInterceptor.call(this, eventBus);\n *\n *   this.preExecute(function(event) {\n *     console.log('command pre-execute', event);\n *   });\n * }\n *\n * inherits(CommandLogger, CommandInterceptor);\n *\n */\nfunction CommandInterceptor(eventBus) {\n  this._eventBus = eventBus;\n}\n\nCommandInterceptor.$inject = [ 'eventBus' ];\n\nmodule.exports = CommandInterceptor;\n\nfunction unwrapEvent(fn, that) {\n  return function(event) {\n    return fn.call(that || null, event.context, event.command, event);\n  };\n}\n\n/**\n * Register an interceptor for a command execution\n *\n * @param {String|Array<String>} [events] list of commands to register on\n * @param {String} [hook] command hook, i.e. preExecute, executed to listen on\n * @param {Number} [priority] the priority on which to hook into the execution\n * @param {Function} handlerFn interceptor to be invoked with (event)\n * @param {Boolean} unwrap if true, unwrap the event and pass (context, command, event) to the\n *                          listener instead\n * @param {Object} [that] Pass context (`this`) to the handler function\n */\nCommandInterceptor.prototype.on = function(events, hook, priority, handlerFn, unwrap, that) {\n\n  if (isFunction(hook) || isNumber(hook)) {\n    that = unwrap;\n    unwrap = handlerFn;\n    handlerFn = priority;\n    priority = hook;\n    hook = null;\n  }\n\n  if (isFunction(priority)) {\n    that = unwrap;\n    unwrap = handlerFn;\n    handlerFn = priority;\n    priority = DEFAULT_PRIORITY;\n  }\n\n  if (isObject(unwrap)) {\n    that = unwrap;\n    unwrap = false;\n  }\n\n  if (!isFunction(handlerFn)) {\n    throw new Error('handlerFn must be a function');\n  }\n\n  if (!isArray(events)) {\n    events = [ events ];\n  }\n\n  var eventBus = this._eventBus;\n\n  forEach(events, function(event) {\n    // concat commandStack(.event)?(.hook)?\n    var fullEvent = [ 'commandStack', event, hook ].filter(function(e) { return e; }).join('.');\n\n    eventBus.on(fullEvent, priority, unwrap ? unwrapEvent(handlerFn, that) : handlerFn, that);\n  });\n};\n\n\nvar hooks = [\n  'canExecute',\n  'preExecute',\n  'preExecuted',\n  'execute',\n  'executed',\n  'postExecute',\n  'postExecuted',\n  'revert',\n  'reverted'\n];\n\n/*\n * Install hook shortcuts\n *\n * This will generate the CommandInterceptor#(preExecute|...|reverted) methods\n * which will in term forward to CommandInterceptor#on.\n */\nforEach(hooks, function(hook) {\n\n  /**\n   * {canExecute|preExecute|preExecuted|execute|executed|postExecute|postExecuted|revert|reverted}\n   *\n   * A named hook for plugging into the command execution\n   *\n   * @param {String|Array<String>} [events] list of commands to register on\n   * @param {Number} [priority] the priority on which to hook into the execution\n   * @param {Function} handlerFn interceptor to be invoked with (event)\n   * @param {Boolean} [unwrap=false] if true, unwrap the event and pass (context, command, event) to the\n   *                          listener instead\n   * @param {Object} [that] Pass context (`this`) to the handler function\n   */\n  CommandInterceptor.prototype[hook] = function(events, priority, handlerFn, unwrap, that) {\n\n    if (isFunction(events) || isNumber(events)) {\n      that = unwrap;\n      unwrap = handlerFn;\n      handlerFn = priority;\n      priority = events;\n      events = null;\n    }\n\n    this.on(events, hook, priority, handlerFn, unwrap, that);\n  };\n});\n","'use strict';\n\nvar unique = require(276),\n    isArray = require(401),\n    assign = require(410);\n\nvar InternalEvent = require(106).Event;\n\n\n/**\n * A service that offers un- and redoable execution of commands.\n *\n * The command stack is responsible for executing modeling actions\n * in a un- and redoable manner. To do this it delegates the actual\n * command execution to {@link CommandHandler}s.\n *\n * Command handlers provide {@link CommandHandler#execute(ctx)} and\n * {@link CommandHandler#revert(ctx)} methods to un- and redo a command\n * identified by a command context.\n *\n *\n * ## Life-Cycle events\n *\n * In the process the command stack fires a number of life-cycle events\n * that other components to participate in the command execution.\n *\n *    * preExecute\n *    * preExecuted\n *    * execute\n *    * executed\n *    * postExecute\n *    * postExecuted\n *    * revert\n *    * reverted\n *\n * A special event is used for validating, whether a command can be\n * performed prior to its execution.\n *\n *    * canExecute\n *\n * Each of the events is fired as `commandStack.{eventName}` and\n * `commandStack.{commandName}.{eventName}`, respectively. This gives\n * components fine grained control on where to hook into.\n *\n * The event object fired transports `command`, the name of the\n * command and `context`, the command context.\n *\n *\n * ## Creating Command Handlers\n *\n * Command handlers should provide the {@link CommandHandler#execute(ctx)}\n * and {@link CommandHandler#revert(ctx)} methods to implement\n * redoing and undoing of a command.\n *\n * A command handler _must_ ensure undo is performed properly in order\n * not to break the undo chain. It must also return the shapes that\n * got changed during the `execute` and `revert` operations.\n *\n * Command handlers may execute other modeling operations (and thus\n * commands) in their `preExecute` and `postExecute` phases. The command\n * stack will properly group all commands together into a logical unit\n * that may be re- and undone atomically.\n *\n * Command handlers must not execute other commands from within their\n * core implementation (`execute`, `revert`).\n *\n *\n * ## Change Tracking\n *\n * During the execution of the CommandStack it will keep track of all\n * elements that have been touched during the command's execution.\n *\n * At the end of the CommandStack execution it will notify interested\n * components via an 'elements.changed' event with all the dirty\n * elements.\n *\n * The event can be picked up by components that are interested in the fact\n * that elements have been changed. One use case for this is updating\n * their graphical representation after moving / resizing or deletion.\n *\n * @see CommandHandler\n *\n * @param {EventBus} eventBus\n * @param {Injector} injector\n */\nfunction CommandStack(eventBus, injector) {\n\n  /**\n   * A map of all registered command handlers.\n   *\n   * @type {Object}\n   */\n  this._handlerMap = {};\n\n  /**\n   * A stack containing all re/undoable actions on the diagram\n   *\n   * @type {Array<Object>}\n   */\n  this._stack = [];\n\n  /**\n   * The current index on the stack\n   *\n   * @type {Number}\n   */\n  this._stackIdx = -1;\n\n  /**\n   * Current active commandStack execution\n   *\n   * @type {Object}\n   */\n  this._currentExecution = {\n    actions: [],\n    dirty: []\n  };\n\n\n  this._injector = injector;\n  this._eventBus = eventBus;\n\n  this._uid = 1;\n\n  eventBus.on([ 'diagram.destroy', 'diagram.clear' ], this.clear, this);\n}\n\nCommandStack.$inject = [ 'eventBus', 'injector' ];\n\nmodule.exports = CommandStack;\n\n\n/**\n * Execute a command\n *\n * @param {String} command the command to execute\n * @param {Object} context the environment to execute the command in\n */\nCommandStack.prototype.execute = function(command, context) {\n  if (!command) {\n    throw new Error('command required');\n  }\n\n  var action = { command: command, context: context };\n\n  this._pushAction(action);\n  this._internalExecute(action);\n  this._popAction(action);\n};\n\n\n/**\n * Ask whether a given command can be executed.\n *\n * Implementors may hook into the mechanism on two ways:\n *\n *   * in event listeners:\n *\n *     Users may prevent the execution via an event listener.\n *     It must prevent the default action for `commandStack.(<command>.)canExecute` events.\n *\n *   * in command handlers:\n *\n *     If the method {@link CommandHandler#canExecute} is implemented in a handler\n *     it will be called to figure out whether the execution is allowed.\n *\n * @param  {String} command the command to execute\n * @param  {Object} context the environment to execute the command in\n *\n * @return {Boolean} true if the command can be executed\n */\nCommandStack.prototype.canExecute = function(command, context) {\n\n  var action = { command: command, context: context };\n\n  var handler = this._getHandler(command);\n\n  var result = this._fire(command, 'canExecute', action);\n\n  // handler#canExecute will only be called if no listener\n  // decided on a result already\n  if (result === undefined) {\n    if (!handler) {\n      return false;\n    }\n\n    if (handler.canExecute) {\n      result = handler.canExecute(context);\n    }\n  }\n\n  return result;\n};\n\n\n/**\n * Clear the command stack, erasing all undo / redo history\n */\nCommandStack.prototype.clear = function() {\n  this._stack.length = 0;\n  this._stackIdx = -1;\n\n  this._fire('changed');\n};\n\n\n/**\n * Undo last command(s)\n */\nCommandStack.prototype.undo = function() {\n  var action = this._getUndoAction(),\n      next;\n\n  if (action) {\n    this._pushAction(action);\n\n    while (action) {\n      this._internalUndo(action);\n      next = this._getUndoAction();\n\n      if (!next || next.id !== action.id) {\n        break;\n      }\n\n      action = next;\n    }\n\n    this._popAction();\n  }\n};\n\n\n/**\n * Redo last command(s)\n */\nCommandStack.prototype.redo = function() {\n  var action = this._getRedoAction(),\n      next;\n\n  if (action) {\n    this._pushAction(action);\n\n    while (action) {\n      this._internalExecute(action, true);\n      next = this._getRedoAction();\n\n      if (!next || next.id !== action.id) {\n        break;\n      }\n\n      action = next;\n    }\n\n    this._popAction();\n  }\n};\n\n\n/**\n * Register a handler instance with the command stack\n *\n * @param {String} command\n * @param {CommandHandler} handler\n */\nCommandStack.prototype.register = function(command, handler) {\n  this._setHandler(command, handler);\n};\n\n\n/**\n * Register a handler type with the command stack\n * by instantiating it and injecting its dependencies.\n *\n * @param {String} command\n * @param {Function} a constructor for a {@link CommandHandler}\n */\nCommandStack.prototype.registerHandler = function(command, handlerCls) {\n\n  if (!command || !handlerCls) {\n    throw new Error('command and handlerCls must be defined');\n  }\n\n  var handler = this._injector.instantiate(handlerCls);\n  this.register(command, handler);\n};\n\nCommandStack.prototype.canUndo = function() {\n  return !!this._getUndoAction();\n};\n\nCommandStack.prototype.canRedo = function() {\n  return !!this._getRedoAction();\n};\n\n////// stack access  //////////////////////////////////////\n\nCommandStack.prototype._getRedoAction = function() {\n  return this._stack[this._stackIdx + 1];\n};\n\n\nCommandStack.prototype._getUndoAction = function() {\n  return this._stack[this._stackIdx];\n};\n\n\n////// internal functionality /////////////////////////////\n\nCommandStack.prototype._internalUndo = function(action) {\n  var self = this;\n\n  var command = action.command,\n      context = action.context;\n\n  var handler = this._getHandler(command);\n\n  // guard against illegal nested command stack invocations\n  this._atomicDo(function() {\n    self._fire(command, 'revert', action);\n\n    if (handler.revert) {\n      self._markDirty(handler.revert(context));\n    }\n\n    self._revertedAction(action);\n\n    self._fire(command, 'reverted', action);\n  });\n};\n\n\nCommandStack.prototype._fire = function(command, qualifier, event) {\n  if (arguments.length < 3) {\n    event = qualifier;\n    qualifier = null;\n  }\n\n  var names = qualifier ? [ command + '.' + qualifier, qualifier ] : [ command ],\n      i, name, result;\n\n  event = assign(new InternalEvent(), event);\n\n  for (i = 0; (name = names[i]); i++) {\n    result = this._eventBus.fire('commandStack.' + name, event);\n\n    if (event.cancelBubble) {\n      break;\n    }\n  }\n\n  return result;\n};\n\nCommandStack.prototype._createId = function() {\n  return this._uid++;\n};\n\nCommandStack.prototype._atomicDo = function(fn) {\n\n  var execution = this._currentExecution;\n\n  execution.atomic = true;\n\n  try {\n    fn();\n  } finally {\n    execution.atomic = false;\n  }\n};\n\nCommandStack.prototype._internalExecute = function(action, redo) {\n  var self = this;\n\n  var command = action.command,\n      context = action.context;\n\n  var handler = this._getHandler(command);\n\n  if (!handler) {\n    throw new Error('no command handler registered for <' + command + '>');\n  }\n\n  this._pushAction(action);\n\n  if (!redo) {\n    this._fire(command, 'preExecute', action);\n\n    if (handler.preExecute) {\n      handler.preExecute(context);\n    }\n\n    this._fire(command, 'preExecuted', action);\n  }\n\n  // guard against illegal nested command stack invocations\n  this._atomicDo(function() {\n\n    self._fire(command, 'execute', action);\n\n    if (handler.execute) {\n      // actual execute + mark return results as dirty\n      self._markDirty(handler.execute(context));\n    }\n\n    // log to stack\n    self._executedAction(action, redo);\n\n    self._fire(command, 'executed', action);\n  });\n\n  if (!redo) {\n    this._fire(command, 'postExecute', action);\n\n    if (handler.postExecute) {\n      handler.postExecute(context);\n    }\n\n    this._fire(command, 'postExecuted', action);\n  }\n\n  this._popAction(action);\n};\n\n\nCommandStack.prototype._pushAction = function(action) {\n\n  var execution = this._currentExecution,\n      actions = execution.actions;\n\n  var baseAction = actions[0];\n\n  if (execution.atomic) {\n    throw new Error('illegal invocation in <execute> or <revert> phase (action: ' + action.command + ')');\n  }\n\n  if (!action.id) {\n    action.id = (baseAction && baseAction.id) || this._createId();\n  }\n\n  actions.push(action);\n};\n\n\nCommandStack.prototype._popAction = function() {\n  var execution = this._currentExecution,\n      actions = execution.actions,\n      dirty = execution.dirty;\n\n  actions.pop();\n\n  if (!actions.length) {\n    this._eventBus.fire('elements.changed', { elements: unique(dirty) });\n\n    dirty.length = 0;\n\n    this._fire('changed');\n  }\n};\n\n\nCommandStack.prototype._markDirty = function(elements) {\n  var execution = this._currentExecution;\n\n  if (!elements) {\n    return;\n  }\n\n  elements = isArray(elements) ? elements : [ elements ];\n\n  execution.dirty = execution.dirty.concat(elements);\n};\n\n\nCommandStack.prototype._executedAction = function(action, redo) {\n  var stackIdx = ++this._stackIdx;\n\n  if (!redo) {\n    this._stack.splice(stackIdx, this._stack.length, action);\n  }\n};\n\n\nCommandStack.prototype._revertedAction = function(action) {\n  this._stackIdx--;\n};\n\n\nCommandStack.prototype._getHandler = function(command) {\n  return this._handlerMap[command];\n};\n\nCommandStack.prototype._setHandler = function(command, handler) {\n  if (!command || !handler) {\n    throw new Error('command and handler required');\n  }\n\n  if (this._handlerMap[command]) {\n    throw new Error('overriding handler for command <' + command + '>');\n  }\n\n  this._handlerMap[command] = handler;\n};\n","module.exports = {\n  commandStack: [ 'type', require(101) ]\n};\n","'use strict';\n\nvar isNumber = require(404),\n    assign = require(410),\n    forEach = require(283),\n    every = require(280),\n    debounce = require(294);\n\nvar Collections = require(244),\n    Elements = require(247);\n\nvar Snap = require(267);\n\nfunction round(number, resolution) {\n  return Math.round(number * resolution) / resolution;\n}\n\nfunction ensurePx(number) {\n  return isNumber(number) ? number + 'px' : number;\n}\n\n/**\n * Creates a HTML container element for a SVG element with\n * the given configuration\n *\n * @param  {Object} options\n * @return {HTMLElement} the container element\n */\nfunction createContainer(options) {\n\n  options = assign({}, { width: '100%', height: '100%' }, options);\n\n  var container = options.container || document.body;\n\n  // create a <div> around the svg element with the respective size\n  // this way we can always get the correct container size\n  // (this is impossible for <svg> elements at the moment)\n  var parent = document.createElement('div');\n  parent.setAttribute('class', 'djs-container');\n\n  assign(parent.style, {\n    position: 'relative',\n    overflow: 'hidden',\n    width: ensurePx(options.width),\n    height: ensurePx(options.height)\n  });\n\n  container.appendChild(parent);\n\n  return parent;\n}\n\nfunction createGroup(parent, cls) {\n  return parent.group().attr({ 'class' : cls });\n}\n\nvar BASE_LAYER = 'base';\n\n\nvar REQUIRED_MODEL_ATTRS = {\n  shape: [ 'x', 'y', 'width', 'height' ],\n  connection: [ 'waypoints' ]\n};\n\n/**\n * The main drawing canvas.\n *\n * @class\n * @constructor\n *\n * @emits Canvas#canvas.init\n *\n * @param {Object} config\n * @param {EventBus} eventBus\n * @param {GraphicsFactory} graphicsFactory\n * @param {ElementRegistry} elementRegistry\n */\nfunction Canvas(config, eventBus, graphicsFactory, elementRegistry) {\n\n  this._eventBus = eventBus;\n  this._elementRegistry = elementRegistry;\n  this._graphicsFactory = graphicsFactory;\n\n  this._init(config || {});\n}\n\nCanvas.$inject = [ 'config.canvas', 'eventBus', 'graphicsFactory', 'elementRegistry' ];\n\nmodule.exports = Canvas;\n\n\nCanvas.prototype._init = function(config) {\n\n  var eventBus = this._eventBus;\n\n  // Creates a <svg> element that is wrapped into a <div>.\n  // This way we are always able to correctly figure out the size of the svg element\n  // by querying the parent node.\n  //\n  // (It is not possible to get the size of a svg element cross browser @ 2014-04-01)\n  //\n  // <div class=\"djs-container\" style=\"width: {desired-width}, height: {desired-height}\">\n  //   <svg width=\"100%\" height=\"100%\">\n  //    ...\n  //   </svg>\n  // </div>\n\n  // html container\n  var container = this._container = createContainer(config),\n      svg = this._svg = Snap.createSnapAt('100%', '100%', container),\n      viewport = this._viewport = createGroup(svg, 'viewport');\n\n  this._layers = {};\n\n  // debounce canvas.viewbox.changed events\n  // for smoother diagram interaction\n  if (config.deferUpdate !== false) {\n    this._viewboxChanged = debounce(this._viewboxChanged, 300);\n  }\n\n  eventBus.on('diagram.init', function() {\n\n    /**\n     * An event indicating that the canvas is ready to be drawn on.\n     *\n     * @memberOf Canvas\n     *\n     * @event canvas.init\n     *\n     * @type {Object}\n     * @property {Snap<SVGSVGElement>} svg the created svg element\n     * @property {Snap<SVGGroup>} viewport the direct parent of diagram elements and shapes\n     */\n    eventBus.fire('canvas.init', {\n      svg: svg,\n      viewport: viewport\n    });\n\n    // fire this in order for certain components to check\n    // if they need to be adjusted due the canvas size\n    this.resized();\n\n  }, this);\n\n  eventBus.on('diagram.destroy', 500, this._destroy, this);\n  eventBus.on('diagram.clear', 500, this._clear, this);\n};\n\nCanvas.prototype._destroy = function(emit) {\n  this._eventBus.fire('canvas.destroy', {\n    svg: this._svg,\n    viewport: this._viewport\n  });\n\n  var parent = this._container.parentNode;\n\n  if (parent) {\n    parent.removeChild(this._container);\n  }\n\n  delete this._svg;\n  delete this._container;\n  delete this._layers;\n  delete this._rootElement;\n  delete this._viewport;\n};\n\nCanvas.prototype._clear = function() {\n\n  var self = this;\n\n  var allElements = this._elementRegistry.getAll();\n\n  // remove all elements\n  allElements.forEach(function(element) {\n    var type = Elements.getType(element);\n\n    if (type === 'root') {\n      self.setRootElement(null, true);\n    } else {\n      self._removeElement(element, type);\n    }\n  });\n\n  // force recomputation of view box\n  delete this._cachedViewbox;\n};\n\n/**\n * Returns the default layer on which\n * all elements are drawn.\n *\n * @returns {Snap<SVGGroup>}\n */\nCanvas.prototype.getDefaultLayer = function() {\n  return this.getLayer(BASE_LAYER);\n};\n\n/**\n * Returns a layer that is used to draw elements\n * or annotations on it.\n *\n * @param  {String} name\n *\n * @returns {Snap<SVGGroup>}\n */\nCanvas.prototype.getLayer = function(name) {\n\n  if (!name) {\n    throw new Error('must specify a name');\n  }\n\n  var layer = this._layers[name];\n  if (!layer) {\n    layer = this._layers[name] = createGroup(this._viewport, 'layer-' + name);\n  }\n\n  return layer;\n};\n\n\n/**\n * Returns the html element that encloses the\n * drawing canvas.\n *\n * @return {DOMNode}\n */\nCanvas.prototype.getContainer = function() {\n  return this._container;\n};\n\n\n/////////////// markers ///////////////////////////////////\n\nCanvas.prototype._updateMarker = function(element, marker, add) {\n  var container;\n\n  if (!element.id) {\n    element = this._elementRegistry.get(element);\n  }\n\n  // we need to access all\n  container = this._elementRegistry._elements[element.id];\n\n  if (!container) {\n    return;\n  }\n\n  forEach([ container.gfx, container.secondaryGfx ], function(gfx) {\n    if (gfx) {\n      // invoke either addClass or removeClass based on mode\n      gfx[add ? 'addClass' : 'removeClass'](marker);\n    }\n  });\n\n  /**\n   * An event indicating that a marker has been updated for an element\n   *\n   * @event element.marker.update\n   * @type {Object}\n   * @property {djs.model.Element} element the shape\n   * @property {Object} gfx the graphical representation of the shape\n   * @property {String} marker\n   * @property {Boolean} add true if the marker was added, false if it got removed\n   */\n  this._eventBus.fire('element.marker.update', { element: element, gfx: container.gfx, marker: marker, add: !!add });\n};\n\n\n/**\n * Adds a marker to an element (basically a css class).\n *\n * Fires the element.marker.update event, making it possible to\n * integrate extension into the marker life-cycle, too.\n *\n * @example\n * canvas.addMarker('foo', 'some-marker');\n *\n * var fooGfx = canvas.getGraphics('foo');\n *\n * fooGfx; // <g class=\"... some-marker\"> ... </g>\n *\n * @param {String|djs.model.Base} element\n * @param {String} marker\n */\nCanvas.prototype.addMarker = function(element, marker) {\n  this._updateMarker(element, marker, true);\n};\n\n\n/**\n * Remove a marker from an element.\n *\n * Fires the element.marker.update event, making it possible to\n * integrate extension into the marker life-cycle, too.\n *\n * @param  {String|djs.model.Base} element\n * @param  {String} marker\n */\nCanvas.prototype.removeMarker = function(element, marker) {\n  this._updateMarker(element, marker, false);\n};\n\n/**\n * Check the existence of a marker on element.\n *\n * @param  {String|djs.model.Base} element\n * @param  {String} marker\n */\nCanvas.prototype.hasMarker = function(element, marker) {\n  if (!element.id) {\n    element = this._elementRegistry.get(element);\n  }\n\n  var gfx = this.getGraphics(element);\n\n  return gfx && gfx.hasClass(marker);\n};\n\n/**\n * Toggles a marker on an element.\n *\n * Fires the element.marker.update event, making it possible to\n * integrate extension into the marker life-cycle, too.\n *\n * @param  {String|djs.model.Base} element\n * @param  {String} marker\n */\nCanvas.prototype.toggleMarker = function(element, marker) {\n  if (this.hasMarker(element, marker)) {\n    this.removeMarker(element, marker);\n  } else {\n    this.addMarker(element, marker);\n  }\n};\n\nCanvas.prototype.getRootElement = function() {\n  if (!this._rootElement) {\n    this.setRootElement({ id: '__implicitroot', children: [] });\n  }\n\n  return this._rootElement;\n};\n\n\n\n//////////////// root element handling ///////////////////////////\n\n/**\n * Sets a given element as the new root element for the canvas\n * and returns the new root element.\n *\n * @param {Object|djs.model.Root} element\n * @param {Boolean} [override] whether to override the current root element, if any\n *\n * @return {Object|djs.model.Root} new root element\n */\nCanvas.prototype.setRootElement = function(element, override) {\n\n  if (element) {\n    this._ensureValid('root', element);\n  }\n\n  var currentRoot = this._rootElement,\n      elementRegistry = this._elementRegistry,\n      eventBus = this._eventBus;\n\n  if (currentRoot) {\n    if (!override) {\n      throw new Error('rootElement already set, need to specify override');\n    }\n\n    // simulate element remove event sequence\n    eventBus.fire('root.remove', { element: currentRoot });\n    eventBus.fire('root.removed', { element: currentRoot });\n\n    elementRegistry.remove(currentRoot);\n  }\n\n  if (element) {\n    var gfx = this.getDefaultLayer();\n\n    // resemble element add event sequence\n    eventBus.fire('root.add', { element: element });\n\n    elementRegistry.add(element, gfx, this._svg);\n\n    eventBus.fire('root.added', { element: element, gfx: gfx });\n  }\n\n  this._rootElement = element;\n\n  return element;\n};\n\n\n\n///////////// add functionality ///////////////////////////////\n\nCanvas.prototype._ensureValid = function(type, element) {\n  if (!element.id) {\n    throw new Error('element must have an id');\n  }\n\n  if (this._elementRegistry.get(element.id)) {\n    throw new Error('element with id ' + element.id + ' already exists');\n  }\n\n  var requiredAttrs = REQUIRED_MODEL_ATTRS[type];\n\n  var valid = every(requiredAttrs, function(attr) {\n    return typeof element[attr] !== 'undefined';\n  });\n\n  if (!valid) {\n    throw new Error(\n      'must supply { ' + requiredAttrs.join(', ') + ' } with ' + type);\n  }\n};\n\nCanvas.prototype._setParent = function(element, parent, parentIndex) {\n  Collections.add(parent.children, element, parentIndex);\n  element.parent = parent;\n};\n\n/**\n * Adds an element to the canvas.\n *\n * This wires the parent <-> child relationship between the element and\n * a explicitly specified parent or an implicit root element.\n *\n * During add it emits the events\n *\n *  * <{type}.add> (element, parent)\n *  * <{type}.added> (element, gfx)\n *\n * Extensions may hook into these events to perform their magic.\n *\n * @param {String} type\n * @param {Object|djs.model.Base} element\n * @param {Object|djs.model.Base} [parent]\n * @param {Number} [parentIndex]\n *\n * @return {Object|djs.model.Base} the added element\n */\nCanvas.prototype._addElement = function(type, element, parent, parentIndex) {\n\n  parent = parent || this.getRootElement();\n\n  var eventBus = this._eventBus,\n      graphicsFactory = this._graphicsFactory;\n\n  this._ensureValid(type, element);\n\n  eventBus.fire(type + '.add', { element: element, parent: parent });\n\n  this._setParent(element, parent, parentIndex);\n\n  // create graphics\n  var gfx = graphicsFactory.create(type, element);\n\n  this._elementRegistry.add(element, gfx);\n\n  // update its visual\n  graphicsFactory.update(type, element, gfx);\n\n  eventBus.fire(type + '.added', { element: element, gfx: gfx });\n\n  return element;\n};\n\n/**\n * Adds a shape to the canvas\n *\n * @param {Object|djs.model.Shape} shape to add to the diagram\n * @param {djs.model.Base} [parent]\n * @param {Number} [parentIndex]\n *\n * @return {djs.model.Shape} the added shape\n */\nCanvas.prototype.addShape = function(shape, parent, parentIndex) {\n  return this._addElement('shape', shape, parent, parentIndex);\n};\n\n/**\n * Adds a connection to the canvas\n *\n * @param {Object|djs.model.Connection} connection to add to the diagram\n * @param {djs.model.Base} [parent]\n * @param {Number} [parentIndex]\n *\n * @return {djs.model.Connection} the added connection\n */\nCanvas.prototype.addConnection = function(connection, parent, parentIndex) {\n  return this._addElement('connection', connection, parent, parentIndex);\n};\n\n\n/**\n * Internal remove element\n */\nCanvas.prototype._removeElement = function(element, type) {\n\n  var elementRegistry = this._elementRegistry,\n      graphicsFactory = this._graphicsFactory,\n      eventBus = this._eventBus;\n\n  element = elementRegistry.get(element.id || element);\n\n  if (!element) {\n    // element was removed already\n    return;\n  }\n\n  eventBus.fire(type + '.remove', { element: element });\n\n  graphicsFactory.remove(element);\n\n  // unset parent <-> child relationship\n  Collections.remove(element.parent && element.parent.children, element);\n  element.parent = null;\n\n  eventBus.fire(type + '.removed', { element: element });\n\n  elementRegistry.remove(element);\n\n  return element;\n};\n\n\n/**\n * Removes a shape from the canvas\n *\n * @param {String|djs.model.Shape} shape or shape id to be removed\n *\n * @return {djs.model.Shape} the removed shape\n */\nCanvas.prototype.removeShape = function(shape) {\n\n  /**\n   * An event indicating that a shape is about to be removed from the canvas.\n   *\n   * @memberOf Canvas\n   *\n   * @event shape.remove\n   * @type {Object}\n   * @property {djs.model.Shape} element the shape descriptor\n   * @property {Object} gfx the graphical representation of the shape\n   */\n\n  /**\n   * An event indicating that a shape has been removed from the canvas.\n   *\n   * @memberOf Canvas\n   *\n   * @event shape.removed\n   * @type {Object}\n   * @property {djs.model.Shape} element the shape descriptor\n   * @property {Object} gfx the graphical representation of the shape\n   */\n  return this._removeElement(shape, 'shape');\n};\n\n\n/**\n * Removes a connection from the canvas\n *\n * @param {String|djs.model.Connection} connection or connection id to be removed\n *\n * @return {djs.model.Connection} the removed connection\n */\nCanvas.prototype.removeConnection = function(connection) {\n\n  /**\n   * An event indicating that a connection is about to be removed from the canvas.\n   *\n   * @memberOf Canvas\n   *\n   * @event connection.remove\n   * @type {Object}\n   * @property {djs.model.Connection} element the connection descriptor\n   * @property {Object} gfx the graphical representation of the connection\n   */\n\n  /**\n   * An event indicating that a connection has been removed from the canvas.\n   *\n   * @memberOf Canvas\n   *\n   * @event connection.removed\n   * @type {Object}\n   * @property {djs.model.Connection} element the connection descriptor\n   * @property {Object} gfx the graphical representation of the connection\n   */\n  return this._removeElement(connection, 'connection');\n};\n\n\n/**\n * Return the graphical object underlaying a certain diagram element\n *\n * @param {String|djs.model.Base} element descriptor of the element\n * @param {Boolean} [secondary=false] whether to return the secondary connected element\n *\n * @return {SVGElement}\n */\nCanvas.prototype.getGraphics = function(element, secondary) {\n  return this._elementRegistry.getGraphics(element, secondary);\n};\n\n\n/**\n * Perform a viewbox update via a given change function.\n *\n * @param {Function} changeFn\n */\nCanvas.prototype._changeViewbox = function(changeFn) {\n\n  // notify others of the upcoming viewbox change\n  this._eventBus.fire('canvas.viewbox.changing');\n\n  // perform actual change\n  changeFn.apply(this);\n\n  // reset the cached viewbox so that\n  // a new get operation on viewbox or zoom\n  // triggers a viewbox re-computation\n  this._cachedViewbox = null;\n\n  // notify others of the change; this step\n  // may or may not be debounced\n  this._viewboxChanged();\n};\n\nCanvas.prototype._viewboxChanged = function() {\n  this._eventBus.fire('canvas.viewbox.changed', { viewbox: this.viewbox() });\n};\n\n\n/**\n * Gets or sets the view box of the canvas, i.e. the\n * area that is currently displayed.\n *\n * The getter may return a cached viewbox (if it is currently\n * changing). To force a recomputation, pass `false` as the first argument.\n *\n * @example\n *\n * canvas.viewbox({ x: 100, y: 100, width: 500, height: 500 })\n *\n * // sets the visible area of the diagram to (100|100) -> (600|100)\n * // and and scales it according to the diagram width\n *\n * var viewbox = canvas.viewbox(); // pass `false` to force recomputing the box.\n *\n * console.log(viewbox);\n * // {\n * //   inner: Dimensions,\n * //   outer: Dimensions,\n * //   scale,\n * //   x, y,\n * //   width, height\n * // }\n *\n * @param  {Object} [box] the new view box to set\n * @param  {Number} box.x the top left X coordinate of the canvas visible in view box\n * @param  {Number} box.y the top left Y coordinate of the canvas visible in view box\n * @param  {Number} box.width the visible width\n * @param  {Number} box.height\n *\n * @return {Object} the current view box\n */\nCanvas.prototype.viewbox = function(box) {\n\n  if (box === undefined && this._cachedViewbox) {\n    return this._cachedViewbox;\n  }\n\n  var viewport = this._viewport,\n      innerBox,\n      outerBox = this.getSize(),\n      matrix,\n      scale,\n      x, y;\n\n  if (!box) {\n    // compute the inner box based on the\n    // diagrams default layer. This allows us to exclude\n    // external components, such as overlays\n    innerBox = this.getDefaultLayer().getBBox(true);\n\n    matrix = viewport.transform().localMatrix;\n    scale = round(matrix.a, 1000);\n\n    x = round(-matrix.e || 0, 1000);\n    y = round(-matrix.f || 0, 1000);\n\n    box = this._cachedViewbox = {\n      x: x ? x / scale : 0,\n      y: y ? y / scale : 0,\n      width: outerBox.width / scale,\n      height: outerBox.height / scale,\n      scale: scale,\n      inner: {\n        width: innerBox.width,\n        height: innerBox.height,\n        x: innerBox.x,\n        y: innerBox.y\n      },\n      outer: outerBox\n    };\n\n    return box;\n  } else {\n\n    this._changeViewbox(function() {\n      scale = Math.min(outerBox.width / box.width, outerBox.height / box.height);\n\n      matrix = new Snap.Matrix().scale(scale).translate(-box.x, -box.y);\n      viewport.transform(matrix);\n    });\n  }\n\n  return box;\n};\n\n\n/**\n * Gets or sets the scroll of the canvas.\n *\n * @param {Object} [delta] the new scroll to apply.\n *\n * @param {Number} [delta.dx]\n * @param {Number} [delta.dy]\n */\nCanvas.prototype.scroll = function(delta) {\n\n  var node = this._viewport.node;\n  var matrix = node.getCTM();\n\n  if (delta) {\n    this._changeViewbox(function() {\n      delta = assign({ dx: 0, dy: 0 }, delta || {});\n\n      matrix = this._svg.node.createSVGMatrix().translate(delta.dx, delta.dy).multiply(matrix);\n\n      setCTM(node, matrix);\n    });\n  }\n\n  return { x: matrix.e, y: matrix.f };\n};\n\n\n/**\n * Gets or sets the current zoom of the canvas, optionally zooming\n * to the specified position.\n *\n * The getter may return a cached zoom level. Call it with `false` as\n * the first argument to force recomputation of the current level.\n *\n * @param {String|Number} [newScale] the new zoom level, either a number, i.e. 0.9,\n *                                   or `fit-viewport` to adjust the size to fit the current viewport\n * @param {String|Point} [center] the reference point { x: .., y: ..} to zoom to, 'auto' to zoom into mid or null\n *\n * @return {Number} the current scale\n */\nCanvas.prototype.zoom = function(newScale, center) {\n\n  if (!newScale) {\n    return this.viewbox(newScale).scale;\n  }\n\n  if (newScale === 'fit-viewport') {\n    return this._fitViewport(center);\n  }\n\n  var outer,\n      matrix;\n\n  this._changeViewbox(function() {\n\n    if (typeof center !== 'object') {\n      outer = this.viewbox().outer;\n\n      center = {\n        x: outer.width / 2,\n        y: outer.height / 2\n      };\n    }\n\n    matrix = this._setZoom(newScale, center);\n  });\n\n  return round(matrix.a, 1000);\n};\n\nfunction setCTM(node, m) {\n  var mstr = 'matrix(' + m.a + ',' + m.b + ',' + m.c + ',' + m.d + ',' + m.e + ',' + m.f + ')';\n  node.setAttribute('transform', mstr);\n}\n\nCanvas.prototype._fitViewport = function(center) {\n\n  var vbox = this.viewbox(),\n      outer = vbox.outer,\n      inner = vbox.inner,\n      newScale,\n      newViewbox;\n\n  // display the complete diagram without zooming in.\n  // instead of relying on internal zoom, we perform a\n  // hard reset on the canvas viewbox to realize this\n  //\n  // if diagram does not need to be zoomed in, we focus it around\n  // the diagram origin instead\n\n  if (inner.x >= 0 &&\n      inner.y >= 0 &&\n      inner.x + inner.width <= outer.width &&\n      inner.y + inner.height <= outer.height &&\n      !center) {\n\n    newViewbox = {\n      x: 0,\n      y: 0,\n      width: Math.max(inner.width + inner.x, outer.width),\n      height: Math.max(inner.height + inner.y, outer.height)\n    };\n  } else {\n\n    newScale = Math.min(1, outer.width / inner.width, outer.height / inner.height);\n    newViewbox = {\n      x: inner.x + (center ? inner.width / 2 - outer.width / newScale / 2 : 0),\n      y: inner.y + (center ? inner.height / 2 - outer.height / newScale / 2 : 0),\n      width: outer.width / newScale,\n      height: outer.height / newScale\n    };\n  }\n\n  this.viewbox(newViewbox);\n\n  return this.viewbox(false).scale;\n};\n\n\nCanvas.prototype._setZoom = function(scale, center) {\n\n  var svg = this._svg.node,\n      viewport = this._viewport.node;\n\n  var matrix = svg.createSVGMatrix();\n  var point = svg.createSVGPoint();\n\n  var centerPoint,\n      originalPoint,\n      currentMatrix,\n      scaleMatrix,\n      newMatrix;\n\n  currentMatrix = viewport.getCTM();\n\n\n  var currentScale = currentMatrix.a;\n\n  if (center) {\n    centerPoint = assign(point, center);\n\n    // revert applied viewport transformations\n    originalPoint = centerPoint.matrixTransform(currentMatrix.inverse());\n\n    // create scale matrix\n    scaleMatrix = matrix\n                    .translate(originalPoint.x, originalPoint.y)\n                    .scale(1 / currentScale * scale)\n                    .translate(-originalPoint.x, -originalPoint.y);\n\n    newMatrix = currentMatrix.multiply(scaleMatrix);\n  } else {\n    newMatrix = matrix.scale(scale);\n  }\n\n  setCTM(this._viewport.node, newMatrix);\n\n  return newMatrix;\n};\n\n\n/**\n * Returns the size of the canvas\n *\n * @return {Dimensions}\n */\nCanvas.prototype.getSize = function() {\n  return {\n    width: this._container.clientWidth,\n    height: this._container.clientHeight\n  };\n};\n\n\n/**\n * Return the absolute bounding box for the given element\n *\n * The absolute bounding box may be used to display overlays in the\n * callers (browser) coordinate system rather than the zoomed in/out\n * canvas coordinates.\n *\n * @param  {ElementDescriptor} element\n * @return {Bounds} the absolute bounding box\n */\nCanvas.prototype.getAbsoluteBBox = function(element) {\n  var vbox = this.viewbox();\n  var bbox;\n\n  // connection\n  // use svg bbox\n  if (element.waypoints) {\n    var gfx = this.getGraphics(element);\n\n    var transformBBox = gfx.getBBox(true);\n    bbox = gfx.getBBox();\n\n    bbox.x -= transformBBox.x;\n    bbox.y -= transformBBox.y;\n\n    bbox.width += 2 * transformBBox.x;\n    bbox.height +=  2 * transformBBox.y;\n  }\n  // shapes\n  // use data\n  else {\n    bbox = element;\n  }\n\n  var x = bbox.x * vbox.scale - vbox.x * vbox.scale;\n  var y = bbox.y * vbox.scale - vbox.y * vbox.scale;\n\n  var width = bbox.width * vbox.scale;\n  var height = bbox.height * vbox.scale;\n\n  return {\n    x: x,\n    y: y,\n    width: width,\n    height: height\n  };\n};\n\n/**\n * Fires an event in order other modules can react to the\n * canvas resizing\n */\nCanvas.prototype.resized = function() {\n\n  // force recomputation of view box\n  delete this._cachedViewbox;\n\n  this._eventBus.fire('canvas.resized');\n};\n","'use strict';\n\nvar Model = require(235);\n\nvar assign = require(410);\n\n/**\n * A factory for diagram-js shapes\n */\nfunction ElementFactory() {\n  this._uid = 12;\n}\n\nmodule.exports = ElementFactory;\n\n\nElementFactory.prototype.createRoot = function(attrs) {\n  return this.create('root', attrs);\n};\n\nElementFactory.prototype.createLabel = function(attrs) {\n  return this.create('label', attrs);\n};\n\nElementFactory.prototype.createShape = function(attrs) {\n  return this.create('shape', attrs);\n};\n\nElementFactory.prototype.createConnection = function(attrs) {\n  return this.create('connection', attrs);\n};\n\n/**\n * Create a model element with the given type and\n * a number of pre-set attributes.\n *\n * @param  {String} type\n * @param  {Object} attrs\n * @return {djs.model.Base} the newly created model instance\n */\nElementFactory.prototype.create = function(type, attrs) {\n\n  attrs = assign({}, attrs || {});\n\n  if (!attrs.id) {\n    attrs.id = type + '_' + (this._uid++);\n  }\n\n  return Model.create(type, attrs);\n};","'use strict';\n\nvar ELEMENT_ID = 'data-element-id';\n\n\n/**\n * @class\n *\n * A registry that keeps track of all shapes in the diagram.\n */\nfunction ElementRegistry() {\n  this._elements = {};\n}\n\nmodule.exports = ElementRegistry;\n\n/**\n * Register a pair of (element, gfx, (secondaryGfx)).\n *\n * @param {djs.model.Base} element\n * @param {Snap<SVGElement>} gfx\n * @param {Snap<SVGElement>} [secondaryGfx] optional other element to register, too\n */\nElementRegistry.prototype.add = function(element, gfx, secondaryGfx) {\n\n  var id = element.id;\n\n  this._validateId(id);\n\n  // associate dom node with element\n  gfx.attr(ELEMENT_ID, id);\n\n  if (secondaryGfx) {\n    secondaryGfx.attr(ELEMENT_ID, id);\n  }\n\n  this._elements[id] = { element: element, gfx: gfx, secondaryGfx: secondaryGfx };\n};\n\n/**\n * Removes an element from the registry.\n *\n * @param {djs.model.Base} element\n */\nElementRegistry.prototype.remove = function(element) {\n  var elements = this._elements,\n      id = element.id || element,\n      container = id && elements[id];\n\n  if (container) {\n\n    // unset element id on gfx\n    container.gfx.attr(ELEMENT_ID, '');\n\n    if (container.secondaryGfx) {\n      container.secondaryGfx.attr(ELEMENT_ID, '');\n    }\n\n    delete elements[id];\n  }\n};\n\n/**\n * Update the id of an element\n *\n * @param {djs.model.Base} element\n * @param {String} newId\n */\nElementRegistry.prototype.updateId = function(element, newId) {\n\n  this._validateId(newId);\n\n  if (typeof element === 'string') {\n    element = this.get(element);\n  }\n\n  var gfx = this.getGraphics(element),\n      secondaryGfx = this.getGraphics(element, true);\n\n  this.remove(element);\n\n  element.id = newId;\n\n  this.add(element, gfx, secondaryGfx);\n};\n\n/**\n * Return the model element for a given id or graphics.\n *\n * @example\n *\n * elementRegistry.get('SomeElementId_1');\n * elementRegistry.get(gfx);\n *\n *\n * @param {String|SVGElement} filter for selecting the element\n *\n * @return {djs.model.Base}\n */\nElementRegistry.prototype.get = function(filter) {\n  var id;\n\n  if (typeof filter === 'string') {\n    id = filter;\n  } else {\n    id = filter && filter.attr(ELEMENT_ID);\n  }\n\n  var container = this._elements[id];\n  return container && container.element;\n};\n\n/**\n * Return all elements that match a given filter function.\n *\n * @param {Function} fn\n *\n * @return {Array<djs.model.Base>}\n */\nElementRegistry.prototype.filter = function(fn) {\n\n  var filtered = [];\n\n  this.forEach(function(element, gfx) {\n    if (fn(element, gfx)) {\n      filtered.push(element);\n    }\n  });\n\n  return filtered;\n};\n\n/**\n * Return all rendered model elements.\n *\n * @return {Array<djs.model.Base>}\n */\nElementRegistry.prototype.getAll = function() {\n  return this.filter(function(e) { return e; });\n};\n\n/**\n * Iterate over all diagram elements.\n *\n * @param {Function} fn\n */\nElementRegistry.prototype.forEach = function(fn) {\n\n  var map = this._elements;\n\n  Object.keys(map).forEach(function(id) {\n    var container = map[id],\n        element = container.element,\n        gfx = container.gfx;\n\n    return fn(element, gfx);\n  });\n};\n\n/**\n * Return the graphical representation of an element or its id.\n *\n * @example\n * elementRegistry.getGraphics('SomeElementId_1');\n * elementRegistry.getGraphics(rootElement); // <g ...>\n *\n * elementRegistry.getGraphics(rootElement, true); // <svg ...>\n *\n *\n * @param {String|djs.model.Base} filter\n * @param {Boolean} [secondary=false] whether to return the secondary connected element\n *\n * @return {SVGElement}\n */\nElementRegistry.prototype.getGraphics = function(filter, secondary) {\n  var id = filter.id || filter;\n\n  var container = this._elements[id];\n  return container && (secondary ? container.secondaryGfx : container.gfx);\n};\n\n/**\n * Validate the suitability of the given id and signals a problem\n * with an exception.\n *\n * @param {String} id\n *\n * @throws {Error} if id is empty or already assigned\n */\nElementRegistry.prototype._validateId = function(id) {\n  if (!id) {\n    throw new Error('element must have an id');\n  }\n\n  if (this._elements[id]) {\n    throw new Error('element with id ' + id + ' already added');\n  }\n};","'use strict';\n\nvar isFunction = require(402),\n    isArray = require(401),\n    isNumber = require(404),\n    bind = require(293),\n    assign = require(410);\n\nvar FN_REF = '__fn';\n\nvar DEFAULT_PRIORITY = 1000;\n\nvar slice = Array.prototype.slice;\n\n/**\n * A general purpose event bus.\n *\n * This component is used to communicate across a diagram instance.\n * Other parts of a diagram can use it to listen to and broadcast events.\n *\n *\n * ## Registering for Events\n *\n * The event bus provides the {@link EventBus#on} and {@link EventBus#once}\n * methods to register for events. {@link EventBus#off} can be used to\n * remove event registrations. Listeners receive an instance of {@link Event}\n * as the first argument. It allows them to hook into the event execution.\n *\n * ```javascript\n *\n * // listen for event\n * eventBus.on('foo', function(event) {\n *\n *   // access event type\n *   event.type; // 'foo'\n *\n *   // stop propagation to other listeners\n *   event.stopPropagation();\n *\n *   // prevent event default\n *   event.preventDefault();\n * });\n *\n * // listen for event with custom payload\n * eventBus.on('bar', function(event, payload) {\n *   console.log(payload);\n * });\n *\n * // listen for event returning value\n * eventBus.on('foobar', function(event) {\n *\n *   // stop event propagation + prevent default\n *   return false;\n *\n *   // stop event propagation + return custom result\n *   return {\n *     complex: 'listening result'\n *   };\n * });\n *\n *\n * // listen with custom priority (default=1000, higher is better)\n * eventBus.on('priorityfoo', 1500, function(event) {\n *   console.log('invoked first!');\n * });\n *\n *\n * // listen for event and pass the context (`this`)\n * eventBus.on('foobar', function(event) {\n *   this.foo();\n * }, this);\n * ```\n *\n *\n * ## Emitting Events\n *\n * Events can be emitted via the event bus using {@link EventBus#fire}.\n *\n * ```javascript\n *\n * // false indicates that the default action\n * // was prevented by listeners\n * if (eventBus.fire('foo') === false) {\n *   console.log('default has been prevented!');\n * };\n *\n *\n * // custom args + return value listener\n * eventBus.on('sum', function(event, a, b) {\n *   return a + b;\n * });\n *\n * // you can pass custom arguments + retrieve result values.\n * var sum = eventBus.fire('sum', 1, 2);\n * console.log(sum); // 3\n * ```\n */\nfunction EventBus() {\n  this._listeners = {};\n\n  // cleanup on destroy on lowest priority to allow\n  // message passing until the bitter end\n  this.on('diagram.destroy', 1, this._destroy, this);\n}\n\nmodule.exports = EventBus;\n\n\n/**\n * Register an event listener for events with the given name.\n *\n * The callback will be invoked with `event, ...additionalArguments`\n * that have been passed to {@link EventBus#fire}.\n *\n * Returning false from a listener will prevent the events default action\n * (if any is specified). To stop an event from being processed further in\n * other listeners execute {@link Event#stopPropagation}.\n *\n * Returning anything but `undefined` from a listener will stop the listener propagation.\n *\n * @param {String|Array<String>} events\n * @param {Number} [priority=1000] the priority in which this listener is called, larger is higher\n * @param {Function} callback\n * @param {Object} [that] Pass context (`this`) to the callback\n */\nEventBus.prototype.on = function(events, priority, callback, that) {\n\n  events = isArray(events) ? events : [ events ];\n\n  if (isFunction(priority)) {\n    that = callback;\n    callback = priority;\n    priority = DEFAULT_PRIORITY;\n  }\n\n  if (!isNumber(priority)) {\n    throw new Error('priority must be a number');\n  }\n\n  var actualCallback = callback;\n\n  if (that) {\n    actualCallback = bind(callback, that);\n\n    // make sure we remember and are able to remove\n    // bound callbacks via {@link #off} using the original\n    // callback\n    actualCallback[FN_REF] = callback[FN_REF] || callback;\n  }\n\n  var self = this,\n      listener = { priority: priority, callback: actualCallback };\n\n  events.forEach(function(e) {\n    self._addListener(e, listener);\n  });\n};\n\n\n/**\n * Register an event listener that is executed only once.\n *\n * @param {String} event the event name to register for\n * @param {Function} callback the callback to execute\n * @param {Object} [that] Pass context (`this`) to the callback\n */\nEventBus.prototype.once = function(event, priority, callback, that) {\n  var self = this;\n\n  if (isFunction(priority)) {\n    that = callback;\n    callback = priority;\n    priority = DEFAULT_PRIORITY;\n  }\n\n  if (!isNumber(priority)) {\n    throw new Error('priority must be a number');\n  }\n\n  function wrappedCallback() {\n    self.off(event, wrappedCallback);\n    return callback.apply(that, arguments);\n  }\n\n  // make sure we remember and are able to remove\n  // bound callbacks via {@link #off} using the original\n  // callback\n  wrappedCallback[FN_REF] = callback;\n\n  this.on(event, priority, wrappedCallback);\n};\n\n\n/**\n * Removes event listeners by event and callback.\n *\n * If no callback is given, all listeners for a given event name are being removed.\n *\n * @param {String} event\n * @param {Function} [callback]\n */\nEventBus.prototype.off = function(event, callback) {\n  var listeners = this._getListeners(event),\n      listener,\n      listenerCallback,\n      idx;\n\n  if (callback) {\n\n    // move through listeners from back to front\n    // and remove matching listeners\n    for (idx = listeners.length - 1; (listener = listeners[idx]); idx--) {\n      listenerCallback = listener.callback;\n\n      if (listenerCallback === callback || listenerCallback[FN_REF] === callback) {\n        listeners.splice(idx, 1);\n      }\n    }\n  } else {\n    // clear listeners\n    listeners.length = 0;\n  }\n};\n\n\n/**\n * Fires a named event.\n *\n * @example\n *\n * // fire event by name\n * events.fire('foo');\n *\n * // fire event object with nested type\n * var event = { type: 'foo' };\n * events.fire(event);\n *\n * // fire event with explicit type\n * var event = { x: 10, y: 20 };\n * events.fire('element.moved', event);\n *\n * // pass additional arguments to the event\n * events.on('foo', function(event, bar) {\n *   alert(bar);\n * });\n *\n * events.fire({ type: 'foo' }, 'I am bar!');\n *\n * @param {String} [name] the optional event name\n * @param {Object} [event] the event object\n * @param {...Object} additional arguments to be passed to the callback functions\n *\n * @return {Boolean} the events return value, if specified or false if the\n *                   default action was prevented by listeners\n */\nEventBus.prototype.fire = function(type, data) {\n\n  var event,\n      listeners,\n      returnValue,\n      args;\n\n  args = slice.call(arguments);\n\n  if (typeof type === 'object') {\n    event = type;\n    type = event.type;\n  }\n\n  if (!type) {\n    throw new Error('no event type specified');\n  }\n\n  listeners = this._listeners[type];\n\n  if (!listeners) {\n    return;\n  }\n\n  // we make sure we fire instances of our home made\n  // events here. We wrap them only once, though\n  if (data instanceof Event) {\n    // we are fine, we alread have an event\n    event = data;\n  } else {\n    event = new Event();\n    event.init(data);\n  }\n\n  // ensure we pass the event as the first parameter\n  args[0] = event;\n\n  // original event type (in case we delegate)\n  var originalType = event.type;\n\n  // update event type before delegation\n  if (type !== originalType) {\n    event.type = type;\n  }\n\n  try {\n    returnValue = this._invokeListeners(event, args, listeners);\n  } finally {\n    // reset event type after delegation\n    if (type !== originalType) {\n      event.type = originalType;\n    }\n  }\n\n  // set the return value to false if the event default\n  // got prevented and no other return value exists\n  if (returnValue === undefined && event.defaultPrevented) {\n    returnValue = false;\n  }\n\n  return returnValue;\n};\n\n\nEventBus.prototype.handleError = function(error) {\n  return this.fire('error', { error: error }) === false;\n};\n\n\nEventBus.prototype._destroy = function() {\n  this._listeners = {};\n};\n\nEventBus.prototype._invokeListeners = function(event, args, listeners) {\n\n  var idx,\n      listener,\n      returnValue;\n\n  for (idx = 0; (listener = listeners[idx]); idx++) {\n\n    // handle stopped propagation\n    if (event.cancelBubble) {\n      break;\n    }\n\n    returnValue = this._invokeListener(event, args, listener);\n  }\n\n  return returnValue;\n};\n\nEventBus.prototype._invokeListener = function(event, args, listener) {\n\n  var returnValue;\n\n  try {\n    // returning false prevents the default action\n    returnValue = invokeFunction(listener.callback, args);\n\n    // stop propagation on return value\n    if (returnValue !== undefined) {\n      event.returnValue = returnValue;\n      event.stopPropagation();\n    }\n\n    // prevent default on return false\n    if (returnValue === false) {\n      event.preventDefault();\n    }\n  } catch (e) {\n    if (!this.handleError(e)) {\n      console.error('unhandled error in event listener');\n      console.error(e.stack);\n\n      throw e;\n    }\n  }\n\n  return returnValue;\n};\n\n/*\n * Add new listener with a certain priority to the list\n * of listeners (for the given event).\n *\n * The semantics of listener registration / listener execution are\n * first register, first serve: New listeners will always be inserted\n * after existing listeners with the same priority.\n *\n * Example: Inserting two listeners with priority 1000 and 1300\n *\n *    * before: [ 1500, 1500, 1000, 1000 ]\n *    * after: [ 1500, 1500, (new=1300), 1000, 1000, (new=1000) ]\n *\n * @param {String} event\n * @param {Object} listener { priority, callback }\n */\nEventBus.prototype._addListener = function(event, newListener) {\n\n  var listeners = this._getListeners(event),\n      existingListener,\n      idx;\n\n  // ensure we order listeners by priority from\n  // 0 (high) to n > 0 (low)\n  for (idx = 0; (existingListener = listeners[idx]); idx++) {\n    if (existingListener.priority < newListener.priority) {\n\n      // prepend newListener at before existingListener\n      listeners.splice(idx, 0, newListener);\n      return;\n    }\n  }\n\n  listeners.push(newListener);\n};\n\n\nEventBus.prototype._getListeners = function(name) {\n  var listeners = this._listeners[name];\n\n  if (!listeners) {\n    this._listeners[name] = listeners = [];\n  }\n\n  return listeners;\n};\n\n\n/**\n * A event that is emitted via the event bus.\n */\nfunction Event() { }\n\nmodule.exports.Event = Event;\n\nEvent.prototype.stopPropagation = function() {\n  this.cancelBubble = true;\n};\n\nEvent.prototype.preventDefault = function() {\n  this.defaultPrevented = true;\n};\n\nEvent.prototype.init = function(data) {\n  assign(this, data || {});\n};\n\n\n/**\n * Invoke function. Be fast...\n *\n * @param {Function} fn\n * @param {Array<Object>} args\n *\n * @return {Any}\n */\nfunction invokeFunction(fn, args) {\n  return fn.apply(null, args);\n}\n","'use strict';\n\nvar forEach = require(283),\n    reduce = require(287);\n\nvar GraphicsUtil = require(250),\n    domClear = require(425);\n\n/**\n * A factory that creates graphical elements\n *\n * @param {EventBus} eventBus\n * @param {ElementRegistry} elementRegistry\n */\nfunction GraphicsFactory(eventBus, elementRegistry) {\n  this._eventBus = eventBus;\n  this._elementRegistry = elementRegistry;\n}\n\nGraphicsFactory.$inject = [ 'eventBus' , 'elementRegistry' ];\n\nmodule.exports = GraphicsFactory;\n\n\nGraphicsFactory.prototype._getChildren = function(element) {\n\n  var gfx = this._elementRegistry.getGraphics(element);\n\n  var childrenGfx;\n\n  // root element\n  if (!element.parent) {\n    childrenGfx = gfx;\n  } else {\n    childrenGfx = GraphicsUtil.getChildren(gfx);\n    if (!childrenGfx) {\n      childrenGfx = gfx.parent().group().attr('class', 'djs-children');\n    }\n  }\n\n  return childrenGfx;\n};\n\n/**\n * Clears the graphical representation of the element and returns the\n * cleared visual (the <g class=\"djs-visual\" /> element).\n */\nGraphicsFactory.prototype._clear = function(gfx) {\n  var visual = GraphicsUtil.getVisual(gfx);\n\n  domClear(visual.node);\n\n  return visual;\n};\n\n/**\n * Creates a gfx container for shapes and connections\n *\n * The layout is as follows:\n *\n * <g class=\"djs-group\">\n *\n *   <!-- the gfx -->\n *   <g class=\"djs-element djs-(shape|connection)\">\n *     <g class=\"djs-visual\">\n *       <!-- the renderer draws in here -->\n *     </g>\n *\n *     <!-- extensions (overlays, click box, ...) goes here\n *   </g>\n *\n *   <!-- the gfx child nodes -->\n *   <g class=\"djs-children\"></g>\n * </g>\n *\n * @param {Object} parent\n * @param {String} type the type of the element, i.e. shape | connection\n */\nGraphicsFactory.prototype._createContainer = function(type, parentGfx) {\n  var outerGfx = parentGfx.group().attr('class', 'djs-group'),\n      gfx = outerGfx.group().attr('class', 'djs-element djs-' + type);\n\n  // create visual\n  gfx.group().attr('class', 'djs-visual');\n\n  return gfx;\n};\n\nGraphicsFactory.prototype.create = function(type, element) {\n  var childrenGfx = this._getChildren(element.parent);\n  return this._createContainer(type, childrenGfx);\n};\n\n\nGraphicsFactory.prototype.updateContainments = function(elements) {\n\n  var self = this,\n      elementRegistry = this._elementRegistry,\n      parents;\n\n\n  parents = reduce(elements, function(map, e) {\n\n    if (e.parent) {\n      map[e.parent.id] = e.parent;\n    }\n\n    return map;\n  }, {});\n\n  // update all parents of changed and reorganized their children\n  // in the correct order (as indicated in our model)\n  forEach(parents, function(parent) {\n\n    var childGfx = self._getChildren(parent),\n        children = parent.children;\n\n    if (!children) {\n      return;\n    }\n\n    forEach(children.slice().reverse(), function(c) {\n      var gfx = elementRegistry.getGraphics(c);\n      gfx.parent().prependTo(childGfx);\n    });\n  });\n};\n\nGraphicsFactory.prototype.drawShape = function(visual, element) {\n  var eventBus = this._eventBus;\n\n  return eventBus.fire('render.shape', { gfx: visual, element: element });\n};\n\nGraphicsFactory.prototype.getShapePath = function(element) {\n  var eventBus = this._eventBus;\n\n  return eventBus.fire('render.getShapePath', element);\n};\n\nGraphicsFactory.prototype.drawConnection = function(visual, element) {\n  var eventBus = this._eventBus;\n\n  return eventBus.fire('render.connection', { gfx: visual, element: element });\n};\n\nGraphicsFactory.prototype.getConnectionPath = function(waypoints) {\n  var eventBus = this._eventBus;\n\n  return eventBus.fire('render.getConnectionPath', waypoints);\n};\n\nGraphicsFactory.prototype.update = function(type, element, gfx) {\n  // Do not update root element\n  if (!element.parent) {\n    return;\n  }\n\n  var visual = this._clear(gfx);\n\n  // redraw\n  if (type === 'shape') {\n    this.drawShape(visual, element);\n\n    // update positioning\n    gfx.translate(element.x, element.y);\n  } else\n  if (type === 'connection') {\n    this.drawConnection(visual, element);\n  } else {\n    throw new Error('unknown type: ' + type);\n  }\n\n  gfx.attr('display', element.hidden ? 'none' : 'block');\n};\n\nGraphicsFactory.prototype.remove = function(element) {\n  var gfx = this._elementRegistry.getGraphics(element);\n\n  // remove\n  gfx.parent().remove();\n};\n","module.exports = {\n  __depends__: [ require(112) ],\n  __init__: [ 'canvas' ],\n  canvas: [ 'type', require(103) ],\n  elementRegistry: [ 'type', require(105) ],\n  elementFactory: [ 'type', require(104) ],\n  eventBus: [ 'type', require(106) ],\n  graphicsFactory: [ 'type', require(107) ]\n};","'use strict';\n\nvar DEFAULT_RENDER_PRIORITY = 1000;\n\n/**\n * The base implementation of shape and connection renderers.\n *\n * @param {EventBus} eventBus\n * @param {Number} [renderPriority=1000]\n */\nfunction BaseRenderer(eventBus, renderPriority) {\n  var self = this;\n\n  renderPriority = renderPriority || DEFAULT_RENDER_PRIORITY;\n\n  eventBus.on([ 'render.shape', 'render.connection' ], renderPriority, function(evt, context) {\n    var type = evt.type,\n        element = context.element,\n        visuals = context.gfx;\n\n    if (self.canRender(element)) {\n      if (type === 'render.shape') {\n        return self.drawShape(visuals, element);\n      } else {\n        return self.drawConnection(visuals, element);\n      }\n    }\n  });\n\n  eventBus.on([ 'render.getShapePath', 'render.getConnectionPath'], renderPriority, function(evt, element) {\n    if (self.canRender(element)) {\n      if (evt.type === 'render.getShapePath') {\n        return self.getShapePath(element);\n      } else {\n        return self.getConnectionPath(element);\n      }\n    }\n  });\n}\n\n/**\n * Should check whether *this* renderer can render\n * the element/connection.\n *\n * @param {element} element\n *\n * @returns {Boolean}\n */\nBaseRenderer.prototype.canRender = function() {};\n\n/**\n * Provides the shape's snap svg element to be drawn on the `canvas`.\n *\n * @param {djs.Graphics} visuals\n * @param {Shape} shape\n *\n * @returns {Snap.svg} [returns a Snap.svg paper element ]\n */\nBaseRenderer.prototype.drawShape = function() {};\n\n/**\n * Provides the shape's snap svg element to be drawn on the `canvas`.\n *\n * @param {djs.Graphics} visuals\n * @param {Connection} connection\n *\n * @returns {Snap.svg} [returns a Snap.svg paper element ]\n */\nBaseRenderer.prototype.drawConnection = function() {};\n\n/**\n * Gets the SVG path of a shape that represents it's visual bounds.\n *\n * @param {Shape} shape\n *\n * @return {string} svg path\n */\nBaseRenderer.prototype.getShapePath = function() {};\n\n/**\n * Gets the SVG path of a connection that represents it's visual bounds.\n *\n * @param {Connection} connection\n *\n * @return {string} svg path\n */\nBaseRenderer.prototype.getConnectionPath = function() {};\n\nmodule.exports = BaseRenderer;\n","'use strict';\n\nvar inherits = require(270);\n\nvar BaseRenderer = require(109);\n\nvar renderUtil = require(258);\n\nvar componentsToPath = renderUtil.componentsToPath,\n    createLine = renderUtil.createLine;\n\n// apply default renderer with lowest possible priority\n// so that it only kicks in if noone else could render\nvar DEFAULT_RENDER_PRIORITY = 1;\n\n/**\n * The default renderer used for shapes and connections.\n *\n * @param {EventBus} eventBus\n * @param {Styles} styles\n */\nfunction DefaultRenderer(eventBus, styles) {\n  //\n  BaseRenderer.call(this, eventBus, DEFAULT_RENDER_PRIORITY);\n\n  this.CONNECTION_STYLE = styles.style([ 'no-fill' ], { strokeWidth: 5, stroke: 'fuchsia' });\n  this.SHAPE_STYLE = styles.style({ fill: 'white', stroke: 'fuchsia', strokeWidth: 2 });\n}\n\ninherits(DefaultRenderer, BaseRenderer);\n\n\nDefaultRenderer.prototype.canRender = function() {\n  return true;\n};\n\nDefaultRenderer.prototype.drawShape = function drawShape(visuals, element) {\n  return visuals.rect(0, 0, element.width || 0, element.height || 0).attr(this.SHAPE_STYLE);\n};\n\nDefaultRenderer.prototype.drawConnection = function drawConnection(visuals, connection) {\n  return createLine(connection.waypoints, this.CONNECTION_STYLE).appendTo(visuals);\n};\n\nDefaultRenderer.prototype.getShapePath = function getShapePath(shape) {\n\n  var x = shape.x,\n      y = shape.y,\n      width = shape.width,\n      height = shape.height;\n\n  var shapePath = [\n    ['M', x, y],\n    ['l', width, 0],\n    ['l', 0, height],\n    ['l', -width, 0],\n    ['z']\n  ];\n\n  return componentsToPath(shapePath);\n};\n\nDefaultRenderer.prototype.getConnectionPath = function getConnectionPath(connection) {\n  var waypoints = connection.waypoints;\n\n  var idx, point, connectionPath = [];\n\n  for (idx = 0; (point = waypoints[idx]); idx++) {\n\n    // take invisible docking into account\n    // when creating the path\n    point = point.original || point;\n\n    connectionPath.push([ idx === 0 ? 'M' : 'L', point.x, point.y ]);\n  }\n\n  return componentsToPath(connectionPath);\n};\n\n\nDefaultRenderer.$inject = [ 'eventBus', 'styles' ];\n\nmodule.exports = DefaultRenderer;\n","'use strict';\n\nvar isArray = require(401),\n    assign = require(410),\n    reduce = require(287);\n\n\n/**\n * A component that manages shape styles\n */\nfunction Styles() {\n\n  var defaultTraits = {\n\n    'no-fill': {\n      fill: 'none'\n    },\n    'no-border': {\n      strokeOpacity: 0.0\n    },\n    'no-events': {\n      pointerEvents: 'none'\n    }\n  };\n\n  var self = this;\n\n  /**\n   * Builds a style definition from a className, a list of traits and an object of additional attributes.\n   *\n   * @param  {String} className\n   * @param  {Array<String>} traits\n   * @param  {Object} additionalAttrs\n   *\n   * @return {Object} the style defintion\n   */\n  this.cls = function(className, traits, additionalAttrs) {\n    var attrs = this.style(traits, additionalAttrs);\n\n    return assign(attrs, { 'class': className });\n  };\n\n  /**\n   * Builds a style definition from a list of traits and an object of additional attributes.\n   *\n   * @param  {Array<String>} traits\n   * @param  {Object} additionalAttrs\n   *\n   * @return {Object} the style defintion\n   */\n  this.style = function(traits, additionalAttrs) {\n\n    if (!isArray(traits) && !additionalAttrs) {\n      additionalAttrs = traits;\n      traits = [];\n    }\n\n    var attrs = reduce(traits, function(attrs, t) {\n      return assign(attrs, defaultTraits[t] || {});\n    }, {});\n\n    return additionalAttrs ? assign(attrs, additionalAttrs) : attrs;\n  };\n\n  this.computeStyle = function(custom, traits, defaultStyles) {\n    if (!isArray(traits)) {\n      defaultStyles = traits;\n      traits = [];\n    }\n\n    return self.style(traits || [], assign({}, defaultStyles, custom || {}));\n  };\n}\n\nmodule.exports = Styles;\n","module.exports = {\n  __init__: [ 'defaultRenderer' ],\n  defaultRenderer: [ 'type', require(110) ],\n  styles: [ 'type', require(111) ]\n};\n","'use strict';\n\nvar filter = require(281),\n    forEach = require(283),\n    sortBy = require(291);\n\nfunction last(arr) {\n  return arr && arr[arr.length - 1];\n}\n\nfunction sortTopOrMiddle(element) {\n  return element.y;\n}\n\nfunction sortLeftOrCenter(element) {\n  return element.x;\n}\n\n/**\n * Sorting functions for different types of alignment\n *\n * @type {Object}\n *\n * @return {Function}\n */\nvar ALIGNMENT_SORTING = {\n  left: sortLeftOrCenter,\n  center: sortLeftOrCenter,\n  right: function(element) {\n    return element.x + element.width;\n  },\n  top: sortTopOrMiddle,\n  middle: sortTopOrMiddle,\n  bottom: function(element) {\n    return element.y + element.height;\n  }\n};\n\n\nfunction AlignElements(modeling) {\n  this._modeling = modeling;\n}\n\nmodule.exports = AlignElements;\n\nAlignElements.$inject = [ 'modeling' ];\n\n\n/**\n * Get the relevant \"axis\" and \"dimension\" related to the current type of alignment\n *\n * @param  {String} type left|right|center|top|bottom|middle\n *\n * @return {Object} { axis, dimension }\n */\nAlignElements.prototype._getOrientationDetails = function(type) {\n  var vertical = [ 'top', 'bottom', 'middle' ],\n      axis = 'x',\n      dimension = 'width';\n\n  if (vertical.indexOf(type) !== -1) {\n    axis = 'y';\n    dimension = 'height';\n  }\n\n  return {\n    axis: axis,\n    dimension: dimension\n  };\n};\n\nAlignElements.prototype._isType = function(type, types) {\n  return types.indexOf(type) !== -1;\n};\n\n/**\n * Get a point on the relevant axis where elements should align to\n *\n * @param  {String} type left|right|center|top|bottom|middle\n * @param  {Array} sortedElements\n *\n * @return {Object}\n */\nAlignElements.prototype._alignmentPosition = function(type, sortedElements) {\n  var orientation = this._getOrientationDetails(type),\n      axis = orientation.axis,\n      dimension = orientation.dimension,\n      alignment = {},\n      centers = {},\n      hasSharedCenters = false,\n      centeredElements,\n      firstElement,\n      lastElement;\n\n  function getMiddleOrTop(first, last) {\n    return Math.round((first[axis] + last[axis] + last[dimension]) / 2);\n  }\n\n  if (this._isType(type, [ 'left', 'top' ])) {\n    alignment[type] = sortedElements[0][axis];\n\n  } else if (this._isType(type, [ 'right', 'bottom' ])) {\n    lastElement = last(sortedElements);\n\n    alignment[type] = lastElement[axis] + lastElement[dimension];\n\n  } else if (this._isType(type, [ 'center', 'middle' ])) {\n\n    // check if there is a center shared by more than one shape\n    // if not, just take the middle of the range\n    forEach(sortedElements, function(element) {\n      var center = element[axis] + Math.round(element[dimension] / 2);\n\n      if (centers[center]) {\n        centers[center].elements.push(element);\n      } else {\n        centers[center] = {\n          elements: [ element ],\n          center: center\n        };\n      }\n    });\n\n    centeredElements = sortBy(centers, function(center) {\n      if (center.elements.length > 1) {\n        hasSharedCenters = true;\n      }\n\n      return center.elements.length;\n    });\n\n    if (hasSharedCenters) {\n      alignment[type] = last(centeredElements).center;\n\n      return alignment;\n    }\n\n    firstElement = sortedElements[0];\n\n    sortedElements = sortBy(sortedElements, function(element) {\n      return element[axis] + element[dimension];\n    });\n\n    lastElement = last(sortedElements);\n\n    alignment[type] = getMiddleOrTop(firstElement, lastElement);\n  }\n\n  return alignment;\n};\n\n/**\n * Executes the alignment of a selection of elements\n *\n * @param  {Array} elements [description]\n * @param  {String} type left|right|center|top|bottom|middle\n */\nAlignElements.prototype.trigger = function(elements, type) {\n  var modeling = this._modeling;\n\n  var filteredElements = filter(elements, function(element) {\n    return !(element.waypoints || element.host || element.labelTarget);\n  });\n\n  var sortFn = ALIGNMENT_SORTING[type];\n\n  var sortedElements = sortBy(filteredElements, sortFn);\n\n  var alignment = this._alignmentPosition(type, sortedElements);\n\n  modeling.alignElements(sortedElements, alignment);\n};\n","'use strict';\n\nmodule.exports = {\n  __init__: [ 'alignElements' ],\n  alignElements: [ 'type', require(113) ]\n};\n","'use strict';\n\nvar forEach = require(283),\n    flatten = require(272),\n    union = require(274),\n    filter = require(281),\n    groupBy = require(284),\n    map = require(286);\n\nvar saveClear = require(257).saveClear,\n    Collections = require(244);\n\nvar getNewAttachShapeDelta = require(242).getNewAttachShapeDelta;\n\nvar inherits = require(270);\n\nvar HIGH_PRIORITY = 1500;\n\nvar CommandInterceptor = require(100);\n\n\nfunction AttachSupport(eventBus, modeling, movePreview, rules) {\n\n  CommandInterceptor.call(this, eventBus);\n\n\n  // remove all the attached elements from the shapes to be validated\n  // add all the attached shapes to the overall list of moved shapes\n  eventBus.on('shape.move.start', HIGH_PRIORITY, function(e) {\n\n    var context = e.context,\n        shapes = context.shapes,\n        validatedShapes = context.validatedShapes;\n\n    context.shapes = addAttached(shapes);\n\n    context.validatedShapes = removeAttached(validatedShapes);\n  });\n\n\n  // move all attachments after the other shapes are done moving\n  this.postExecuted([ 'elements.move' ], function(event) {\n\n    var context = event.context,\n        delta = context.delta,\n        newParent = context.newParent,\n        closure = context.closure,\n        enclosedElements = closure.enclosedElements,\n        attachers = getAttachers(enclosedElements);\n\n    // ensure we move all attachers with their hosts\n    // if they have not been moved already\n    forEach(attachers, function(attacher) {\n      if (!enclosedElements[attacher.id]) {\n        modeling.moveShape(attacher, delta, newParent);\n      }\n    });\n  });\n\n  // perform the attaching after shapes are done moving\n  this.postExecuted([ 'elements.move' ], function(e) {\n\n    var context = e.context,\n        shapes = context.shapes,\n        newHost = context.newHost,\n        attachers;\n\n    // we only support attachment / detachment of one element\n    if (shapes.length > 1) {\n      return;\n    }\n\n    if (newHost) {\n\n      attachers = shapes;\n    } else {\n\n      attachers = filter(shapes, function(s) {\n        return !!s.host;\n      });\n    }\n\n    forEach(attachers, function(attacher) {\n      modeling.updateAttachment(attacher, newHost);\n    });\n  });\n\n  // ensure invalid attachment connections are removed\n  this.postExecuted([ 'elements.move' ], function(e) {\n\n    var shapes = e.context.shapes;\n\n    forEach(shapes, function(shape) {\n\n      forEach(shape.attachers, function(attacher) {\n\n        // remove invalid outgoing connections\n        forEach(attacher.outgoing.slice(), function(connection) {\n          var allowed = rules.allowed('connection.reconnectStart', {\n            connection: connection,\n            source: connection.source,\n            target: connection.target\n          });\n\n          if (!allowed) {\n            modeling.removeConnection(connection);\n          }\n        });\n\n        // remove invalid incoming connections\n        forEach(attacher.incoming.slice(), function(connection) {\n          var allowed = rules.allowed('connection.reconnectEnd', {\n            connection: connection,\n            source: connection.source,\n            target: connection.target\n          });\n\n          if (!allowed) {\n            modeling.removeConnection(connection);\n          }\n        });\n      });\n    });\n  });\n\n  this.postExecute([ 'shape.create' ], function(e) {\n    var context = e.context,\n        shape = context.shape,\n        host = context.host;\n\n    if (host) {\n      modeling.updateAttachment(shape, host);\n    }\n  });\n\n  // update attachments if the host is replaced\n  this.postExecute([ 'shape.replace' ], function(e) {\n\n    var context = e.context,\n        oldShape = context.oldShape,\n        newShape = context.newShape;\n\n    // move the attachers to the new host\n    saveClear(oldShape.attachers, function(attacher) {\n      var allowed = rules.allowed('elements.move', {\n        target: newShape,\n        shapes: [attacher]\n      });\n\n      if (allowed === 'attach') {\n        modeling.updateAttachment(attacher, newShape);\n      } else {\n        modeling.removeShape(attacher);\n      }\n    });\n\n    // move attachers if new host has different size\n    if (newShape.attachers.length) {\n\n      forEach(newShape.attachers, function(attacher) {\n        var delta = getNewAttachShapeDelta(attacher, oldShape, newShape);\n        modeling.moveShape(attacher, delta, attacher.parent);\n      });\n    }\n\n  });\n\n  // move shape on host resize\n  this.postExecute([ 'shape.resize' ], function(event) {\n    var context = event.context,\n        shape = context.shape,\n        oldBounds = context.oldBounds,\n        newBounds = context.newBounds,\n        attachers = shape.attachers;\n\n    if (!attachers.length) {\n      return;\n    }\n\n    forEach(attachers, function(attacher) {\n      var delta = getNewAttachShapeDelta(attacher, oldBounds, newBounds);\n\n      modeling.moveShape(attacher, delta, attacher.parent);\n\n      if (attacher.label) {\n        modeling.moveShape(attacher.label, delta, attacher.label.parent);\n      }\n    });\n  });\n\n  // remove attachments\n  this.preExecute([ 'shape.delete' ], function(event) {\n\n    var shape = event.context.shape;\n\n    saveClear(shape.attachers, function(attacher) {\n      modeling.removeShape(attacher);\n    });\n\n    if (shape.host) {\n      modeling.updateAttachment(shape, null);\n    }\n  });\n\n\n  // Prevent attachers and their labels from moving, when the space tool is performed.\n  // Otherwise the attachers and their labels would be moved twice.\n  eventBus.on('spaceTool.move', function(event) {\n\n    var movingShapes = event.context.movingShapes;\n\n    // Collect all attachers which would be moved using the space tool\n    var movingAttachers = filter(movingShapes, function(shape) {\n      return shape.host && shape.host.id;\n    });\n\n    forEach(movingAttachers, function(shape) {\n      // Remove all attachers and their labels from the movingShapes, because they\n      // already will be moved along with the host.\n      Collections.remove(movingShapes, shape);\n      if (shape.label) {\n        Collections.remove(movingShapes, shape.label);\n      }\n    });\n\n  });\n}\n\ninherits(AttachSupport, CommandInterceptor);\n\nAttachSupport.$inject = [ 'eventBus', 'modeling', 'movePreview', 'rules' ];\n\nmodule.exports = AttachSupport;\n\n\n/**\n * Return attachers of the given shapes\n *\n * @param {Array<djs.model.Base>} shapes\n * @return {Array<djs.model.Base>}\n */\nfunction getAttachers(shapes) {\n  return flatten(map(shapes, function(s) {\n    return s.attachers || [];\n  }));\n}\n\n/**\n * Return a combined list of elements and\n * attachers.\n *\n * @param {Array<djs.model.Base>} elements\n * @return {Array<djs.model.Base>} filtered\n */\nfunction addAttached(elements) {\n  var attachers = getAttachers(elements);\n\n  return union(elements, attachers);\n}\n\n/**\n * Return a filtered list of elements that do not\n * contain attached elements with hosts being part\n * of the selection.\n *\n * @param  {Array<djs.model.Base>} elements\n *\n * @return {Array<djs.model.Base>} filtered\n */\nfunction removeAttached(elements) {\n\n  var ids = groupBy(elements, 'id');\n\n  return filter(elements, function(element) {\n    while (element) {\n\n      // host in selection\n      if (element.host && ids[element.host.id]) {\n        return false;\n      }\n\n      element = element.parent;\n    }\n\n    return true;\n  });\n}\n","module.exports = {\n  __depends__: [\n    require(187),\n    require(155)\n  ],\n  __init__: [ 'attachSupport'],\n  attachSupport: [ 'type', require(115) ]\n};\n","'use strict';\n\nvar inherits = require(270);\n\nvar getBoundingBox = require(247).getBBox;\n\nvar asTRBL = require(233).asTRBL,\n    asBounds = require(233).asBounds;\n\nvar assign = require(410),\n    forEach = require(283),\n    values = require(419),\n    flatten = require(272),\n    groupBy = require(284);\n\nvar CommandInterceptor = require(100);\n\n\n/**\n * An auto resize component that takes care of expanding a parent element\n * if child elements are created or moved close the parents edge.\n *\n * @param {EventBus} eventBus\n * @param {ElementRegistry} elementRegistry\n * @param {Modeling} modeling\n * @param {Rules} rules\n */\nfunction AutoResize(eventBus, elementRegistry, modeling, rules) {\n\n  CommandInterceptor.call(this, eventBus);\n\n  this._elementRegistry = elementRegistry;\n  this._modeling = modeling;\n  this._rules = rules;\n\n  var self = this;\n\n  this.postExecuted([ 'shape.create' ], function(event) {\n\n    var context = event.context,\n        hints = context.hints,\n        shape = context.shape,\n        parent = context.parent || context.newParent;\n\n    if (hints && hints.root === false) {\n      return;\n    }\n\n    self._expand([ shape ], parent);\n  });\n\n  this.postExecuted([ 'elements.move' ], function(event) {\n\n    var context = event.context,\n        elements = flatten(values(context.closure.topLevel)),\n        hints = context.hints;\n\n    if (hints && hints.autoResize === false) {\n      return;\n    }\n\n    var expandings = groupBy(elements, function(element) {\n      return element.parent.id;\n    });\n\n    forEach(expandings, function(elements, parentId) {\n      self._expand(elements, parentId);\n    });\n  });\n}\n\nAutoResize.$inject = [ 'eventBus', 'elementRegistry', 'modeling', 'rules' ];\n\ninherits(AutoResize, CommandInterceptor);\n\nmodule.exports = AutoResize;\n\n\n/**\n * Calculate the new bounds of the target shape, given\n * a number of elements have been moved or added into the parent.\n *\n * This method considers the current size, the added elements as well as\n * the provided padding for the new bounds.\n *\n * @param {Array<djs.model.Shape>} elements\n * @param {djs.model.Shape} target\n */\nAutoResize.prototype._getOptimalBounds = function(elements, target) {\n\n  var offset = this.getOffset(target),\n      padding = this.getPadding(target);\n\n  var elementsTrbl = asTRBL(getBoundingBox(elements)),\n      targetTrbl = asTRBL(target);\n\n  var newTrbl = {};\n\n  if (elementsTrbl.top - targetTrbl.top < padding.top) {\n    newTrbl.top = elementsTrbl.top - offset.top;\n  }\n\n  if (elementsTrbl.left - targetTrbl.left < padding.left) {\n    newTrbl.left = elementsTrbl.left - offset.left;\n  }\n\n  if (targetTrbl.right - elementsTrbl.right < padding.right) {\n    newTrbl.right = elementsTrbl.right + offset.right;\n  }\n\n  if (targetTrbl.bottom - elementsTrbl.bottom < padding.bottom) {\n    newTrbl.bottom = elementsTrbl.bottom + offset.bottom;\n  }\n\n  return asBounds(assign({}, targetTrbl, newTrbl));\n};\n\n\n/**\n * Expand the target shape respecting rules, offset and padding\n *\n * @param {Array<djs.model.Shape>} elements\n * @param {djs.model.Shape|String} target|targetId\n */\nAutoResize.prototype._expand = function(elements, target) {\n\n  if (typeof target === 'string') {\n    target = this._elementRegistry.get(target);\n  }\n\n  var allowed = this._rules.allowed('element.autoResize', {\n    elements: elements,\n    target: target\n  });\n\n  if (!allowed) {\n    return;\n  }\n\n  // calculate the new bounds\n  var newBounds = this._getOptimalBounds(elements, target);\n\n  // resize the parent shape\n  this.resize(target, newBounds);\n\n  var parent = target.parent;\n\n  // recursively expand parent elements\n  if (parent) {\n    this._expand([ target ], parent);\n  }\n};\n\n\n/**\n * Get the amount to expand the given shape in each direction.\n *\n * @param {djs.model.Shape} shape\n *\n * @return {Object} {top, bottom, left, right}\n */\nAutoResize.prototype.getOffset = function(shape) {\n  return { top: 60, bottom: 60, left: 100, right: 100 };\n};\n\n\n/**\n * Get the activation threshold for each side for which\n * resize triggers.\n *\n * @param {djs.model.Shape} shape\n *\n * @return {Object} {top, bottom, left, right}\n */\nAutoResize.prototype.getPadding = function(shape) {\n  return { top: 2, bottom: 2, left: 15, right: 15 };\n};\n\n\n/**\n * Perform the actual resize operation.\n *\n * @param {djs.model.Shape} target\n * @param {Object} newBounds\n */\nAutoResize.prototype.resize = function(target, newBounds) {\n  this._modeling.resizeShape(target, newBounds);\n};\n","var RuleProvider = require(206);\n\nvar inherits = require(270);\n\n/**\n * This is a base rule provider for the element.autoResize rule.\n */\nfunction AutoResizeProvider(eventBus) {\n\n  RuleProvider.call(this, eventBus);\n\n  var self = this;\n\n  this.addRule('element.autoResize', function(context) {\n    return self.canResize(context.elements, context.target);\n  });\n}\n\nAutoResizeProvider.$inject = [ 'eventBus' ];\n\ninherits(AutoResizeProvider, RuleProvider);\n\nmodule.exports = AutoResizeProvider;\n\n/**\n * Needs to be implemented by sub classes to allow actual auto resize\n *\n * @param  {Array<djs.model.Shape>} elements\n * @param  {djs.model.Shape} target\n *\n * @return {Boolean}\n */\nAutoResizeProvider.prototype.canResize = function(elements, target) {\n  return false;\n};","'use strict';\n\nvar assign = require(410);\n\nvar EventUtil = require(248);\n\n\n/**\n * Initiates canvas scrolling if current cursor point is close to a border.\n * Cancelled when current point moves back inside the scrolling borders\n * or cancelled manually.\n *\n * Default options :\n *   scrollThresholdIn: [ 20, 20, 20, 20 ],\n *   scrollThresholdOut: [ 0, 0, 0, 0 ],\n *   scrollRepeatTimeout: 15,\n *   scrollStep: 10\n *\n * Threshold order:\n *   [ left, top, right, bottom ]\n */\nfunction AutoScroll(config, eventBus, canvas, mouseTracking) {\n\n  this._canvas = canvas;\n  this._mouseTracking = mouseTracking;\n\n  this._opts = assign({\n    scrollThresholdIn: [ 20, 20, 20, 20 ],\n    scrollThresholdOut: [ 0, 0, 0, 0 ],\n    scrollRepeatTimeout: 15,\n    scrollStep: 10\n  }, config);\n\n  var self = this;\n\n  eventBus.on('drag.move', function(e) {\n    var point = self._toBorderPoint(e);\n\n    self.startScroll(point);\n  });\n\n  eventBus.on([ 'drag.cleanup' ], function() {\n    self.stopScroll();\n  });\n}\n\nAutoScroll.$inject = [ 'config.autoScroll', 'eventBus', 'canvas', 'mouseTracking'];\n\nmodule.exports = AutoScroll;\n\n\n/**\n * Starts scrolling loop.\n * Point is given in global scale in canvas container box plane.\n *\n * @param  {Object} point { x: X, y: Y }\n */\nAutoScroll.prototype.startScroll = function(point) {\n\n  var canvas = this._canvas;\n  var opts = this._opts;\n  var self = this;\n\n  var clientRect = canvas.getContainer().getBoundingClientRect();\n\n  var diff = [\n    point.x,\n    point.y,\n    clientRect.width - point.x,\n    clientRect.height - point.y\n  ];\n\n  this.stopScroll();\n\n  var dx = 0,\n      dy = 0;\n\n  for (var i = 0; i < 4; i++) {\n    if (between(diff[i], opts.scrollThresholdOut[i], opts.scrollThresholdIn[i])) {\n      if (i === 0) {\n        dx = opts.scrollStep;\n      } else if (i == 1) {\n        dy = opts.scrollStep;\n      } else if (i == 2) {\n        dx = -opts.scrollStep;\n      } else if (i == 3) {\n        dy = -opts.scrollStep;\n      }\n    }\n  }\n\n  if (dx !== 0 || dy !== 0) {\n    canvas.scroll({ dx: dx, dy: dy });\n\n    this._scrolling = setTimeout(function() {\n      self.startScroll(point);\n    }, opts.scrollRepeatTimeout);\n  }\n};\n\nfunction between(val, start, end) {\n  if (start < val && val < end) {\n    return true;\n  }\n\n  return false;\n}\n\n\n/**\n * Stops scrolling loop.\n */\nAutoScroll.prototype.stopScroll = function() {\n  clearTimeout(this._scrolling);\n};\n\n\n/**\n * Overrides defaults options.\n *\n * @param  {Object} options\n */\nAutoScroll.prototype.setOptions = function(options) {\n  this._opts = assign({}, this._opts, options);\n};\n\n\n/**\n * Converts event to a point in canvas container plane in global scale.\n *\n * @param  {Event} event\n * @return {Point}\n */\nAutoScroll.prototype._toBorderPoint = function(event) {\n  var clientRect = this._canvas._container.getBoundingClientRect();\n\n  var globalPosition = EventUtil.toPoint(event.originalEvent);\n\n  return {\n    x: globalPosition.x - clientRect.left,\n    y: globalPosition.y - clientRect.top\n  };\n};","module.exports = {\n  __depends__: [\n    require(143),\n    require(184)\n  ],\n  __init__: [ 'autoScroll' ],\n  autoScroll: [ 'type', require(119) ]\n};","'use strict';\n\nvar Geometry = require(249),\n    BendpointUtil = require(123);\n\nvar MARKER_OK = 'connect-ok',\n    MARKER_NOT_OK = 'connect-not-ok',\n    MARKER_CONNECT_HOVER = 'connect-hover',\n    MARKER_CONNECT_UPDATING = 'djs-updating';\n\nvar COMMAND_BENDPOINT_UPDATE = 'connection.updateWaypoints',\n    COMMAND_RECONNECT_START = 'connection.reconnectStart',\n    COMMAND_RECONNECT_END = 'connection.reconnectEnd';\n\nvar round = Math.round;\n\n\n/**\n * A component that implements moving of bendpoints\n */\nfunction BendpointMove(injector, eventBus, canvas, dragging, graphicsFactory, rules, modeling) {\n\n  // optional connection docking integration\n  var connectionDocking = injector.get('connectionDocking', false);\n\n\n  // API\n\n  this.start = function(event, connection, bendpointIndex, insert) {\n\n    var type,\n        context,\n        waypoints = connection.waypoints,\n        gfx = canvas.getGraphics(connection);\n\n    if (!insert && bendpointIndex === 0) {\n      type = COMMAND_RECONNECT_START;\n    } else\n    if (!insert && bendpointIndex === waypoints.length - 1) {\n      type = COMMAND_RECONNECT_END;\n    } else {\n      type = COMMAND_BENDPOINT_UPDATE;\n    }\n\n    context = {\n      connection: connection,\n      bendpointIndex: bendpointIndex,\n      insert: insert,\n      type: type\n    };\n\n    dragging.init(event, 'bendpoint.move', {\n      data: {\n        connection: connection,\n        connectionGfx: gfx,\n        context: context\n      }\n    });\n  };\n\n\n  // DRAGGING IMPLEMENTATION\n\n\n  function redrawConnection(data) {\n    graphicsFactory.update('connection', data.connection, data.connectionGfx);\n  }\n\n  function filterRedundantWaypoints(waypoints) {\n\n    // alter copy of waypoints, not original\n    waypoints = waypoints.slice();\n\n    var idx = 0,\n        point,\n        previousPoint,\n        nextPoint;\n\n    while (waypoints[idx]) {\n      point = waypoints[idx];\n      previousPoint = waypoints[idx - 1];\n      nextPoint = waypoints[idx + 1];\n\n      if (Geometry.pointDistance(point, nextPoint) === 0 ||\n          Geometry.pointsOnLine(previousPoint, nextPoint, point)) {\n\n        // remove point, if overlapping with {nextPoint}\n        // or on line with {previousPoint} -> {point} -> {nextPoint}\n        waypoints.splice(idx, 1);\n      } else {\n        idx++;\n      }\n    }\n\n    return waypoints;\n  }\n\n  eventBus.on('bendpoint.move.start', function(e) {\n\n    var context = e.context,\n        connection = context.connection,\n        originalWaypoints = connection.waypoints,\n        waypoints = originalWaypoints.slice(),\n        insert = context.insert,\n        idx = context.bendpointIndex;\n\n    context.originalWaypoints = originalWaypoints;\n\n    if (insert) {\n      // insert placeholder for bendpoint to-be-added\n      waypoints.splice(idx, 0, null);\n    }\n\n    connection.waypoints = waypoints;\n\n    // add dragger gfx\n    context.draggerGfx = BendpointUtil.addBendpoint(canvas.getLayer('overlays'));\n    context.draggerGfx.addClass('djs-dragging');\n\n    canvas.addMarker(connection, MARKER_CONNECT_UPDATING);\n  });\n\n  eventBus.on('bendpoint.move.hover', function(e) {\n\n    e.context.hover = e.hover;\n    canvas.addMarker(e.hover, MARKER_CONNECT_HOVER);\n  });\n\n  eventBus.on([\n    'bendpoint.move.out',\n    'bendpoint.move.cleanup'\n  ], function(e) {\n\n    // remove connect marker\n    // if it was added\n    var hover = e.context.hover;\n\n    if (hover) {\n      canvas.removeMarker(hover, MARKER_CONNECT_HOVER);\n      canvas.removeMarker(hover, e.context.target ? MARKER_OK : MARKER_NOT_OK);\n    }\n  });\n\n  eventBus.on('bendpoint.move.move', function(e) {\n\n    var context = e.context,\n        moveType = context.type,\n        connection = e.connection,\n        source, target;\n\n    connection.waypoints[context.bendpointIndex] = { x: e.x, y: e.y };\n\n    if (connectionDocking) {\n\n      if (context.hover) {\n        if (moveType === COMMAND_RECONNECT_START) {\n          source = context.hover;\n        }\n\n        if (moveType === COMMAND_RECONNECT_END) {\n          target = context.hover;\n        }\n      }\n\n      connection.waypoints = connectionDocking.getCroppedWaypoints(connection, source, target);\n    }\n\n    // asks whether reconnect / bendpoint move / bendpoint add\n    // is allowed at the given position\n    var allowed = context.allowed = rules.allowed(context.type, context);\n\n    if (allowed) {\n\n      if (context.hover) {\n        canvas.removeMarker(context.hover, MARKER_NOT_OK);\n        canvas.addMarker(context.hover, MARKER_OK);\n\n        context.target = context.hover;\n      }\n    } else\n    if (allowed === false) {\n      if (context.hover) {\n        canvas.removeMarker(context.hover, MARKER_OK);\n        canvas.addMarker(context.hover, MARKER_NOT_OK);\n\n        context.target = null;\n      }\n    }\n\n    // add dragger gfx\n    context.draggerGfx.translate(e.x, e.y);\n\n    redrawConnection(e);\n  });\n\n  eventBus.on([\n    'bendpoint.move.end',\n    'bendpoint.move.cancel'\n  ], function(e) {\n\n    var context = e.context,\n        hover = context.hover,\n        connection = context.connection;\n\n    // remove dragger gfx\n    context.draggerGfx.remove();\n    context.newWaypoints = connection.waypoints.slice();\n    connection.waypoints = context.originalWaypoints;\n    canvas.removeMarker(connection, MARKER_CONNECT_UPDATING);\n\n    if (hover) {\n      canvas.removeMarker(hover, MARKER_OK);\n      canvas.removeMarker(hover, MARKER_NOT_OK);\n    }\n  });\n\n  eventBus.on('bendpoint.move.end', function(e) {\n\n    var context = e.context,\n        waypoints = context.newWaypoints,\n        bendpointIndex = context.bendpointIndex,\n        bendpoint = waypoints[bendpointIndex],\n        allowed = context.allowed,\n        hints;\n\n    // ensure we have actual pixel values bendpoint\n    // coordinates (important when zoom level was > 1 during move)\n    bendpoint.x = round(bendpoint.x);\n    bendpoint.y = round(bendpoint.y);\n\n    if (allowed && context.type === COMMAND_RECONNECT_START) {\n      modeling.reconnectStart(context.connection, context.target, bendpoint);\n    } else\n    if (allowed && context.type === COMMAND_RECONNECT_END) {\n      modeling.reconnectEnd(context.connection, context.target, bendpoint);\n    } else\n    if (allowed !== false && context.type === COMMAND_BENDPOINT_UPDATE) {\n\n      // pass hints on the actual moved bendpoint\n      // this is useful for connection and label layouting\n      hints = {\n        bendpointMove: {\n          insert: e.context.insert,\n          bendpointIndex: bendpointIndex\n        }\n      };\n\n      modeling.updateWaypoints(context.connection, filterRedundantWaypoints(waypoints), hints);\n    } else {\n      redrawConnection(e);\n\n      return false;\n    }\n  });\n\n  eventBus.on('bendpoint.move.cancel', function(e) {\n    redrawConnection(e);\n  });\n}\n\nBendpointMove.$inject = [ 'injector', 'eventBus', 'canvas', 'dragging', 'graphicsFactory', 'rules', 'modeling' ];\n\nmodule.exports = BendpointMove;\n","'use strict';\n\nvar assign = require(410),\n    forEach = require(283);\n\nvar Snap = require(267);\n\nvar round = Math.round;\n\n\nfunction BendpointSnapping(eventBus) {\n\n  function snapTo(candidates, point) {\n    return Snap.snapTo(candidates, point);\n  }\n\n  function mid(element) {\n    if (element.width) {\n      return {\n        x: round(element.width / 2 + element.x),\n        y: round(element.height / 2 + element.y)\n      };\n    }\n  }\n\n  ////////// connection segment snapping //////////////////////////////////////\n\n  function getConnectionSegmentSnaps(context) {\n\n    var snapPoints = context.snapPoints,\n        connection = context.connection,\n        waypoints = connection.waypoints,\n        segmentStart = context.segmentStart,\n        segmentStartIndex = context.segmentStartIndex,\n        segmentEnd = context.segmentEnd,\n        segmentEndIndex = context.segmentEndIndex,\n        axis = context.axis;\n\n    if (snapPoints) {\n      return snapPoints;\n    }\n\n    var referenceWaypoints = [\n      waypoints[segmentStartIndex - 1],\n      segmentStart,\n      segmentEnd,\n      waypoints[segmentEndIndex + 1]\n    ];\n\n    if (segmentStartIndex < 2) {\n      referenceWaypoints.unshift(mid(connection.source));\n    }\n\n    if (segmentEndIndex > waypoints.length - 3) {\n      referenceWaypoints.unshift(mid(connection.target));\n    }\n\n    context.snapPoints = snapPoints = { horizontal: [] , vertical: [] };\n\n    forEach(referenceWaypoints, function(p) {\n      // we snap on existing bendpoints only,\n      // not placeholders that are inserted during add\n      if (p) {\n        p = p.original || p;\n\n        if (axis === 'y') {\n          snapPoints.horizontal.push(p.y);\n        }\n\n        if (axis === 'x') {\n          snapPoints.vertical.push(p.x);\n        }\n      }\n    });\n\n    return snapPoints;\n  }\n\n  eventBus.on('connectionSegment.move.move', 1500, function(event) {\n    var context = event.context,\n        snapPoints = getConnectionSegmentSnaps(context),\n        x = event.x,\n        y = event.y,\n        sx, sy;\n\n    if (!snapPoints) {\n      return;\n    }\n\n    // snap\n    sx = snapTo(snapPoints.vertical, x);\n    sy = snapTo(snapPoints.horizontal, y);\n\n\n    // correction x/y\n    var cx = (x - sx),\n        cy = (y - sy);\n\n    // update delta\n    assign(event, {\n      dx: event.dx - cx,\n      dy: event.dy - cy,\n      x: sx,\n      y: sy\n    });\n  });\n\n\n  ///////// bendpoint snapping /////////////////////////////\n\n  function getBendpointSnaps(context) {\n\n    var snapPoints = context.snapPoints,\n        waypoints = context.connection.waypoints,\n        bendpointIndex = context.bendpointIndex;\n\n    if (snapPoints) {\n      return snapPoints;\n    }\n\n    var referenceWaypoints = [ waypoints[bendpointIndex - 1], waypoints[bendpointIndex + 1] ];\n\n    context.snapPoints = snapPoints = { horizontal: [] , vertical: [] };\n\n    forEach(referenceWaypoints, function(p) {\n      // we snap on existing bendpoints only,\n      // not placeholders that are inserted during add\n      if (p) {\n        p = p.original || p;\n\n        snapPoints.horizontal.push(p.y);\n        snapPoints.vertical.push(p.x);\n      }\n    });\n\n    return snapPoints;\n  }\n\n\n  eventBus.on('bendpoint.move.move', 1500, function(event) {\n\n    var context = event.context,\n        snapPoints = getBendpointSnaps(context),\n        target = context.target,\n        targetMid = target && mid(target),\n        x = event.x,\n        y = event.y,\n        sx, sy;\n\n    if (!snapPoints) {\n      return;\n    }\n\n    // snap\n    sx = snapTo(targetMid ? snapPoints.vertical.concat([ targetMid.x ]) : snapPoints.vertical, x);\n    sy = snapTo(targetMid ? snapPoints.horizontal.concat([ targetMid.y ]) : snapPoints.horizontal, y);\n\n\n    // correction x/y\n    var cx = (x - sx),\n        cy = (y - sy);\n\n    // update delta\n    assign(event, {\n      dx: event.dx - cx,\n      dy: event.dy - cy,\n      x: event.x - cx,\n      y: event.y - cy\n    });\n  });\n}\n\n\nBendpointSnapping.$inject = [ 'eventBus' ];\n\nmodule.exports = BendpointSnapping;","'use strict';\n\nvar Events = require(248),\n    Geometry = require(249);\n\nvar Snap = require(267);\n\nvar BENDPOINT_CLS = module.exports.BENDPOINT_CLS = 'djs-bendpoint';\nvar SEGMENT_DRAGGER_CLS = module.exports.SEGMENT_DRAGGER_CLS = 'djs-segment-dragger';\n\n\nmodule.exports.toCanvasCoordinates = function(canvas, event) {\n\n  var position = Events.toPoint(event),\n      clientRect = canvas._container.getBoundingClientRect(),\n      offset;\n\n  // canvas relative position\n\n  offset = {\n    x: clientRect.left,\n    y: clientRect.top\n  };\n\n  // update actual event payload with canvas relative measures\n\n  var viewbox = canvas.viewbox();\n\n  return {\n    x: viewbox.x + (position.x - offset.x) / viewbox.scale,\n    y: viewbox.y + (position.y - offset.y) / viewbox.scale\n  };\n};\n\nmodule.exports.addBendpoint = function(parentGfx, cls) {\n  var groupGfx = parentGfx.group().addClass(BENDPOINT_CLS);\n\n  groupGfx.circle(0, 0, 4).addClass('djs-visual');\n  groupGfx.circle(0, 0, 10).addClass('djs-hit');\n\n  if (cls) {\n    groupGfx.addClass(cls);\n  }\n\n  return groupGfx;\n};\n\nfunction createParallelDragger(parentGfx, position, alignment) {\n  var draggerGfx = parentGfx.group();\n\n  var width = 14,\n      height = 3,\n      padding = 6,\n      hitWidth = width + padding,\n      hitHeight = height + padding;\n\n  draggerGfx.rect(-width / 2, -height / 2, width, height).addClass('djs-visual');\n  draggerGfx.rect(-hitWidth / 2, -hitHeight / 2, hitWidth, hitHeight).addClass('djs-hit');\n\n  var matrix = new Snap.Matrix().rotate(alignment === 'h' ? 90 : 0, 0, 0);\n\n  draggerGfx.transform(matrix);\n\n  return draggerGfx;\n}\n\n\nmodule.exports.addSegmentDragger = function(parentGfx, segmentStart, segmentEnd) {\n\n  var groupGfx = parentGfx.group(),\n      mid = Geometry.getMidPoint(segmentStart, segmentEnd),\n      alignment = Geometry.pointsAligned(segmentStart, segmentEnd);\n\n  createParallelDragger(groupGfx, mid, alignment);\n\n  groupGfx.addClass(SEGMENT_DRAGGER_CLS);\n  groupGfx.addClass(alignment === 'h' ? 'vertical' : 'horizontal');\n  groupGfx.translate(mid.x, mid.y);\n\n  return groupGfx;\n};\n","'use strict';\n\nvar domEvent = require(429),\n    BendpointUtil = require(123);\n\nvar pointsAligned = require(249).pointsAligned,\n    getMidPoint = require(249).getMidPoint;\n\nvar BENDPOINT_CLS = BendpointUtil.BENDPOINT_CLS,\n    SEGMENT_DRAGGER_CLS = BendpointUtil.SEGMENT_DRAGGER_CLS;\n\nvar getApproxIntersection = require(252).getApproxIntersection;\n\n\n/**\n * A service that adds editable bendpoints to connections.\n */\nfunction Bendpoints(eventBus, canvas, interactionEvents,\n                    bendpointMove, connectionSegmentMove) {\n\n  function getConnectionIntersection(waypoints, event) {\n    var localPosition = BendpointUtil.toCanvasCoordinates(canvas, event),\n        intersection = getApproxIntersection(waypoints, localPosition);\n\n    return intersection;\n  }\n\n  function isIntersectionMiddle(intersection, waypoints, treshold) {\n    var idx = intersection.index,\n        p = intersection.point,\n        p0, p1, mid, aligned, xDelta, yDelta;\n\n    if (idx <= 0 || intersection.bendpoint) {\n      return false;\n    }\n\n    p0 = waypoints[idx - 1];\n    p1 = waypoints[idx];\n    mid = getMidPoint(p0, p1),\n    aligned = pointsAligned(p0, p1);\n    xDelta = Math.abs(p.x - mid.x);\n    yDelta = Math.abs(p.y - mid.y);\n\n    return aligned && xDelta <= treshold && yDelta <= treshold;\n  }\n\n  function activateBendpointMove(event, connection) {\n    var waypoints = connection.waypoints,\n        intersection = getConnectionIntersection(waypoints, event);\n\n    if (!intersection) {\n      return;\n    }\n\n    if (isIntersectionMiddle(intersection, waypoints, 10)) {\n      connectionSegmentMove.start(event, connection, intersection.index);\n    } else {\n      bendpointMove.start(event, connection, intersection.index, !intersection.bendpoint);\n    }\n  }\n\n  function bindInteractionEvents(node, eventName, element) {\n\n    domEvent.bind(node, eventName, function(event) {\n      interactionEvents.triggerMouseEvent(eventName, event, element);\n      event.stopPropagation();\n    });\n  }\n\n  function getBendpointsContainer(element, create) {\n\n    var layer = canvas.getLayer('overlays'),\n        gfx = layer.select('.djs-bendpoints[data-element-id=' + element.id + ']');\n\n    if (!gfx && create) {\n      gfx = layer.group().addClass('djs-bendpoints').attr('data-element-id', element.id);\n\n      bindInteractionEvents(gfx.node, 'mousedown', element);\n      bindInteractionEvents(gfx.node, 'click', element);\n      bindInteractionEvents(gfx.node, 'dblclick', element);\n    }\n\n    return gfx;\n  }\n\n  function createBendpoints(gfx, connection) {\n    connection.waypoints.forEach(function(p, idx) {\n      BendpointUtil.addBendpoint(gfx).translate(p.x, p.y);\n    });\n\n    // add floating bendpoint\n    BendpointUtil.addBendpoint(gfx, 'floating');\n  }\n\n  function createSegmentDraggers(gfx, connection) {\n\n    var waypoints = connection.waypoints;\n\n    var segmentStart,\n        segmentEnd;\n\n    for (var i = 1; i < waypoints.length; i++) {\n\n      segmentStart = waypoints[i - 1];\n      segmentEnd = waypoints[i];\n\n      if (pointsAligned(segmentStart, segmentEnd)) {\n        BendpointUtil.addSegmentDragger(gfx, segmentStart, segmentEnd);\n      }\n    }\n  }\n\n  function clearBendpoints(gfx) {\n    gfx.selectAll('.' + BENDPOINT_CLS).forEach(function(s) {\n      s.remove();\n    });\n  }\n\n  function clearSegmentDraggers(gfx) {\n    gfx.selectAll('.' + SEGMENT_DRAGGER_CLS).forEach(function(s) {\n      s.remove();\n    });\n  }\n\n  function addHandles(connection) {\n\n    var gfx = getBendpointsContainer(connection);\n\n    if (!gfx) {\n      gfx = getBendpointsContainer(connection, true);\n\n      createBendpoints(gfx, connection);\n      createSegmentDraggers(gfx, connection);\n    }\n\n    return gfx;\n  }\n\n  function updateHandles(connection) {\n\n    var gfx = getBendpointsContainer(connection);\n\n    if (gfx) {\n      clearSegmentDraggers(gfx);\n      clearBendpoints(gfx);\n      createSegmentDraggers(gfx, connection);\n      createBendpoints(gfx, connection);\n    }\n  }\n\n  eventBus.on('connection.changed', function(event) {\n    updateHandles(event.element);\n  });\n\n  eventBus.on('connection.remove', function(event) {\n    var gfx = getBendpointsContainer(event.element);\n\n    if (gfx) {\n      gfx.remove();\n    }\n  });\n\n  eventBus.on('element.marker.update', function(event) {\n\n    var element = event.element,\n        bendpointsGfx;\n\n    if (!element.waypoints) {\n      return;\n    }\n\n    bendpointsGfx = addHandles(element);\n    bendpointsGfx[event.add ? 'addClass' : 'removeClass'](event.marker);\n  });\n\n  eventBus.on('element.mousemove', function(event) {\n\n    var element = event.element,\n        waypoints = element.waypoints,\n        bendpointsGfx,\n        floating,\n        intersection;\n\n    if (waypoints) {\n\n      bendpointsGfx = getBendpointsContainer(element, true);\n      floating = bendpointsGfx.select('.floating');\n\n      if (!floating) {\n        return;\n      }\n\n      intersection = getConnectionIntersection(waypoints, event.originalEvent);\n\n      if (intersection) {\n        floating.translate(intersection.point.x, intersection.point.y);\n      }\n    }\n  });\n\n  eventBus.on('element.mousedown', function(event) {\n\n    var originalEvent = event.originalEvent,\n        element = event.element,\n        waypoints = element.waypoints;\n\n    if (!waypoints) {\n      return;\n    }\n\n    activateBendpointMove(originalEvent, element, waypoints);\n  });\n\n  eventBus.on('selection.changed', function(event) {\n    var newSelection = event.newSelection,\n        primary = newSelection[0];\n\n    if (primary && primary.waypoints) {\n      addHandles(primary);\n    }\n  });\n\n  eventBus.on('element.hover', function(event) {\n    var element = event.element;\n\n    if (element.waypoints) {\n      addHandles(element);\n      interactionEvents.registerEvent(event.gfx.node, 'mousemove', 'element.mousemove');\n    }\n  });\n\n  eventBus.on('element.out', function(event) {\n    interactionEvents.unregisterEvent(event.gfx.node, 'mousemove', 'element.mousemove');\n  });\n\n  // API\n\n  this.addHandles = addHandles;\n  this.updateHandles = updateHandles;\n  this.getBendpointsContainer = getBendpointsContainer;\n}\n\nBendpoints.$inject = [\n  'eventBus', 'canvas', 'interactionEvents',\n  'bendpointMove', 'connectionSegmentMove'\n];\n\nmodule.exports = Bendpoints;\n","'use strict';\n\nvar Geometry = require(249),\n    BendpointUtil = require(123),\n    LayoutUtil = require(233);\n\nvar MARKER_CONNECT_HOVER = 'connect-hover',\n    MARKER_CONNECT_UPDATING = 'djs-updating';\n\nfunction axisAdd(point, axis, delta) {\n  return axisSet(point, axis, point[axis] + delta);\n}\n\nfunction axisSet(point, axis, value) {\n  return {\n    x: (axis === 'x' ? value : point.x),\n    y: (axis === 'y' ? value : point.y)\n  };\n}\n\nfunction axisFenced(position, segmentStart, segmentEnd, axis) {\n\n  var maxValue = Math.max(segmentStart[axis], segmentEnd[axis]),\n      minValue = Math.min(segmentStart[axis], segmentEnd[axis]);\n\n  var padding = 20;\n\n  var fencedValue = Math.min(Math.max(minValue + padding, position[axis]), maxValue - padding);\n\n  return axisSet(segmentStart, axis, fencedValue);\n}\n\nfunction flipAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\n\n/**\n * Get the docking point on the given element.\n *\n * Compute a reasonable docking, if non exists.\n *\n * @param  {Point} point\n * @param  {djs.model.Shape} referenceElement\n * @param  {String} moveAxis (x|y)\n *\n * @return {Point}\n */\nfunction getDocking(point, referenceElement, moveAxis) {\n\n  var referenceMid,\n      inverseAxis;\n\n  if (point.original) {\n    return point.original;\n  } else {\n    referenceMid = LayoutUtil.getMid(referenceElement);\n    inverseAxis = flipAxis(moveAxis);\n\n    return axisSet(point, inverseAxis, referenceMid[inverseAxis]);\n  }\n}\n\n/**\n * A component that implements moving of bendpoints\n */\nfunction ConnectionSegmentMove(injector, eventBus, canvas, dragging, graphicsFactory, rules, modeling) {\n\n  // optional connection docking integration\n  var connectionDocking = injector.get('connectionDocking', false);\n\n\n  // API\n\n  this.start = function(event, connection, idx) {\n\n    var context,\n        gfx = canvas.getGraphics(connection),\n        segmentStartIndex = idx - 1,\n        segmentEndIndex = idx,\n        waypoints = connection.waypoints,\n        segmentStart = waypoints[segmentStartIndex],\n        segmentEnd = waypoints[segmentEndIndex],\n        direction,\n        axis;\n\n    direction = Geometry.pointsAligned(segmentStart, segmentEnd);\n\n    // do not move diagonal connection\n    if (!direction) {\n      return;\n    }\n\n    // the axis where we are going to move things\n    axis = direction === 'v' ? 'y' : 'x';\n\n    if (segmentStartIndex === 0) {\n      segmentStart = getDocking(segmentStart, connection.source, axis);\n    }\n\n    if (segmentEndIndex === waypoints.length - 1) {\n      segmentEnd = getDocking(segmentEnd, connection.target, axis);\n    }\n\n    context = {\n      connection: connection,\n      segmentStartIndex: segmentStartIndex,\n      segmentEndIndex: segmentEndIndex,\n      segmentStart: segmentStart,\n      segmentEnd: segmentEnd,\n      axis: axis\n    };\n\n    dragging.init(event, {\n      x: (segmentStart.x + segmentEnd.x)/2,\n      y: (segmentStart.y + segmentEnd.y)/2\n    }, 'connectionSegment.move', {\n      cursor: axis === 'x' ? 'resize-ew' : 'resize-ns',\n      data: {\n        connection: connection,\n        connectionGfx: gfx,\n        context: context\n      }\n    });\n  };\n\n  /**\n   * Crop connection if connection cropping is provided.\n   *\n   * @param {Connection} connection\n   * @param {Array<Point>} newWaypoints\n   *\n   * @return {Array<Point>} cropped connection waypoints\n   */\n  function cropConnection(connection, newWaypoints) {\n\n    // crop connection, if docking service is provided only\n    if (!connectionDocking) {\n      return newWaypoints;\n    }\n\n    var oldWaypoints = connection.waypoints,\n        croppedWaypoints;\n\n    // temporary set new waypoints\n    connection.waypoints = newWaypoints;\n\n    croppedWaypoints = connectionDocking.getCroppedWaypoints(connection);\n\n    // restore old waypoints\n    connection.waypoints = oldWaypoints;\n\n    return croppedWaypoints;\n  }\n\n  // DRAGGING IMPLEMENTATION\n\n  function redrawConnection(data) {\n    graphicsFactory.update('connection', data.connection, data.connectionGfx);\n  }\n\n  function updateDragger(context, segmentOffset, event) {\n\n    var newWaypoints = context.newWaypoints,\n        segmentStartIndex = context.segmentStartIndex + segmentOffset,\n        segmentStart = newWaypoints[segmentStartIndex],\n        segmentEndIndex = context.segmentEndIndex + segmentOffset,\n        segmentEnd = newWaypoints[segmentEndIndex],\n        axis = flipAxis(context.axis);\n\n    // make sure the dragger does not move\n    // outside the connection\n    var draggerPosition = axisFenced(event, segmentStart, segmentEnd, axis);\n\n    // update dragger\n    context.draggerGfx.translate(draggerPosition.x, draggerPosition.y);\n  }\n\n  /**\n   * Filter waypoints for redundant ones (i.e. on the same axis).\n   * Returns the filtered waypoints and the offset related to the segment move.\n   *\n   * @param {Array<Point>} waypoints\n   * @param {Integer} segmentStartIndex of moved segment start\n   *\n   * @return {Object} { filteredWaypoints, segmentOffset }\n   */\n  function filterRedundantWaypoints(waypoints, segmentStartIndex) {\n\n    var segmentOffset = 0;\n\n    var filteredWaypoints = waypoints.filter(function(r, idx) {\n      if (Geometry.pointsOnLine(waypoints[idx - 1], waypoints[idx + 1], r)) {\n\n        // remove point and increment offset\n        segmentOffset = idx <= segmentStartIndex ? segmentOffset - 1 : segmentOffset;\n        return false;\n      }\n\n      // dont remove point\n      return true;\n    });\n\n    return {\n      waypoints: filteredWaypoints,\n      segmentOffset: segmentOffset\n    };\n  }\n\n  eventBus.on('connectionSegment.move.start', function(e) {\n\n    var context = e.context,\n        connection = e.connection,\n        layer = canvas.getLayer('overlays');\n\n    context.originalWaypoints = connection.waypoints.slice();\n\n    // add dragger gfx\n    context.draggerGfx = BendpointUtil.addSegmentDragger(layer, context.segmentStart, context.segmentEnd);\n    context.draggerGfx.addClass('djs-dragging');\n\n    canvas.addMarker(connection, MARKER_CONNECT_UPDATING);\n  });\n\n  eventBus.on('connectionSegment.move.move', function(e) {\n\n    var context = e.context,\n        connection = context.connection,\n        segmentStartIndex = context.segmentStartIndex,\n        segmentEndIndex = context.segmentEndIndex,\n        segmentStart = context.segmentStart,\n        segmentEnd = context.segmentEnd,\n        axis = context.axis;\n\n    var newWaypoints = context.originalWaypoints.slice(),\n        newSegmentStart = axisAdd(segmentStart, axis, e['d' + axis]),\n        newSegmentEnd = axisAdd(segmentEnd, axis, e['d' + axis]);\n\n    // original waypoint count and added / removed\n    // from start waypoint delta. We use the later\n    // to retrieve the updated segmentStartIndex / segmentEndIndex\n    var waypointCount = newWaypoints.length,\n        segmentOffset = 0;\n\n    // move segment start / end by axis delta\n    newWaypoints[segmentStartIndex] = newSegmentStart;\n    newWaypoints[segmentEndIndex] = newSegmentEnd;\n\n    var sourceToSegmentOrientation,\n        targetToSegmentOrientation;\n\n    // handle first segment\n    if (segmentStartIndex < 2) {\n      sourceToSegmentOrientation = LayoutUtil.getOrientation(connection.source, newSegmentStart);\n\n      // first bendpoint, remove first segment if intersecting\n      if (segmentStartIndex === 1) {\n\n        if (sourceToSegmentOrientation === 'intersect') {\n          newWaypoints.shift();\n          newWaypoints[0] = newSegmentStart;\n          segmentOffset--;\n        }\n      }\n\n      // docking point, add segment if not intersecting anymore\n      else {\n        if (sourceToSegmentOrientation !== 'intersect') {\n          newWaypoints.unshift(segmentStart);\n          segmentOffset++;\n        }\n      }\n    }\n\n    // handle last segment\n    if (segmentEndIndex > waypointCount - 3) {\n      targetToSegmentOrientation = LayoutUtil.getOrientation(connection.target, newSegmentEnd);\n\n      // last bendpoint, remove last segment if intersecting\n      if (segmentEndIndex === waypointCount - 2) {\n\n        if (targetToSegmentOrientation === 'intersect') {\n          newWaypoints.pop();\n          newWaypoints[newWaypoints.length - 1] = newSegmentEnd;\n        }\n      }\n\n      // last bendpoint, remove last segment if intersecting\n      else {\n        if (targetToSegmentOrientation !== 'intersect') {\n          newWaypoints.push(segmentEnd);\n        }\n      }\n    }\n\n    // update connection waypoints\n    context.newWaypoints = connection.waypoints = cropConnection(connection, newWaypoints);\n\n    // update dragger position\n    updateDragger(context, segmentOffset, e);\n\n    // save segmentOffset in context\n    context.newSegmentStartIndex = segmentStartIndex + segmentOffset;\n\n    // redraw connection\n    redrawConnection(e);\n  });\n\n  eventBus.on('connectionSegment.move.hover', function(e) {\n\n    e.context.hover = e.hover;\n    canvas.addMarker(e.hover, MARKER_CONNECT_HOVER);\n  });\n\n  eventBus.on([\n    'connectionSegment.move.out',\n    'connectionSegment.move.cleanup'\n  ], function(e) {\n\n    // remove connect marker\n    // if it was added\n    var hover = e.context.hover;\n\n    if (hover) {\n      canvas.removeMarker(hover, MARKER_CONNECT_HOVER);\n    }\n  });\n\n  eventBus.on('connectionSegment.move.cleanup', function(e) {\n\n    var context = e.context,\n        connection = context.connection;\n\n    // remove dragger gfx\n    if (context.draggerGfx) {\n      context.draggerGfx.remove();\n    }\n\n    canvas.removeMarker(connection, MARKER_CONNECT_UPDATING);\n  });\n\n  eventBus.on([\n    'connectionSegment.move.cancel',\n    'connectionSegment.move.end'\n  ], function(e) {\n    var context = e.context,\n        connection = context.connection;\n\n    connection.waypoints = context.originalWaypoints;\n\n    redrawConnection(e);\n  });\n\n  eventBus.on('connectionSegment.move.end', function(e) {\n\n    var context = e.context,\n        connection = context.connection,\n        newWaypoints = context.newWaypoints,\n        newSegmentStartIndex = context.newSegmentStartIndex;\n\n    // ensure we have actual pixel values bendpoint\n    // coordinates (important when zoom level was > 1 during move)\n    newWaypoints = newWaypoints.map(function(p) {\n      return {\n        original: p.original,\n        x: Math.round(p.x),\n        y: Math.round(p.y)\n      };\n    });\n\n    // apply filter redunant waypoints\n    var filtered = filterRedundantWaypoints(newWaypoints, newSegmentStartIndex);\n\n    // get filtered waypoints\n    var filteredWaypoints = filtered.waypoints,\n        croppedWaypoints = cropConnection(connection, filteredWaypoints),\n        segmentOffset = filtered.segmentOffset;\n\n    var hints = {\n      segmentMove: {\n        segmentStartIndex: context.segmentStartIndex,\n        newSegmentStartIndex: newSegmentStartIndex + segmentOffset\n      }\n    };\n\n    modeling.updateWaypoints(connection, croppedWaypoints, hints);\n  });\n}\n\nConnectionSegmentMove.$inject = [\n  'injector', 'eventBus', 'canvas',\n  'dragging', 'graphicsFactory', 'rules',\n  'modeling'\n];\n\nmodule.exports = ConnectionSegmentMove;\n","module.exports = {\n  __depends__: [ require(143), require(208) ],\n  __init__: [ 'bendpoints', 'bendpointSnapping' ],\n  bendpoints: [ 'type', require(124) ],\n  bendpointMove: [ 'type', require(121) ],\n  connectionSegmentMove: [ 'type', require(125) ],\n  bendpointSnapping: [ 'type', require(122) ]\n};\n","'use strict';\n\nvar getElementType = require(247).getType;\n\n/**\n * Adds change support to the diagram, including\n *\n * <ul>\n *   <li>redrawing shapes and connections on change</li>\n * </ul>\n *\n * @param {EventBus} eventBus\n * @param {Canvas} canvas\n * @param {ElementRegistry} elementRegistry\n * @param {GraphicsFactory} graphicsFactory\n */\nfunction ChangeSupport(eventBus, canvas, elementRegistry, graphicsFactory) {\n\n  // redraw shapes / connections on change\n\n  eventBus.on('element.changed', function(event) {\n\n    var element = event.element;\n\n    // element might have been deleted and replaced by new element with same ID\n    // thus check for parent of element except for root element\n    if (element.parent || element === canvas.getRootElement()) {\n      event.gfx = elementRegistry.getGraphics(element);\n    }\n\n    // shape + gfx may have been deleted\n    if (!event.gfx) {\n      return;\n    }\n\n    eventBus.fire(getElementType(element) + '.changed', event);\n  });\n\n  eventBus.on('elements.changed', function(event) {\n\n    var elements = event.elements;\n\n    elements.forEach(function(e) {\n      eventBus.fire('element.changed', { element: e });\n    });\n\n    graphicsFactory.updateContainments(elements);\n  });\n\n  eventBus.on('shape.changed', function(event) {\n    graphicsFactory.update('shape', event.element, event.gfx);\n  });\n\n  eventBus.on('connection.changed', function(event) {\n    graphicsFactory.update('connection', event.element, event.gfx);\n  });\n}\n\nChangeSupport.$inject = [ 'eventBus', 'canvas', 'elementRegistry', 'graphicsFactory' ];\n\nmodule.exports = ChangeSupport;\n","module.exports = {\n  __init__: [ 'changeSupport'],\n  changeSupport: [ 'type', require(127) ]\n};","'use strict';\n\n/**\n * A clip board stub\n */\nfunction Clipboard() {}\n\nmodule.exports = Clipboard;\n\n\nClipboard.prototype.get = function() {\n  return this._data;\n};\n\nClipboard.prototype.set = function(data) {\n  this._data = data;\n};\n\nClipboard.prototype.clear = function() {\n  var data = this._data;\n\n  delete this._data;\n\n  return data;\n};\n\nClipboard.prototype.isEmpty = function() {\n  return !this._data;\n};","module.exports = {\n  clipboard: [ 'type', require(129) ]\n};\n","'use strict';\n\nvar LayoutUtil = require(233);\n\nvar MARKER_OK = 'connect-ok',\n    MARKER_NOT_OK = 'connect-not-ok';\n\n\nfunction Connect(eventBus, dragging, modeling, rules, canvas, graphicsFactory) {\n\n  // TODO(nre): separate UI and events\n\n  // rules\n\n  function canConnect(source, target) {\n    return rules.allowed('connection.create', {\n      source: source,\n      target: target\n    });\n  }\n\n\n  // layouting\n\n  function crop(start, end, source, target) {\n\n    var sourcePath = graphicsFactory.getShapePath(source),\n        targetPath = target && graphicsFactory.getShapePath(target),\n        connectionPath = graphicsFactory.getConnectionPath({ waypoints: [ start, end ] });\n\n    start = LayoutUtil.getElementLineIntersection(sourcePath, connectionPath, true) || start;\n    end = (target && LayoutUtil.getElementLineIntersection(targetPath, connectionPath, false)) || end;\n\n    return [ start, end ];\n  }\n\n\n  // event handlers\n\n  eventBus.on('connect.move', function(event) {\n\n    var context = event.context,\n        source = context.source,\n        target = context.target,\n        visual = context.visual,\n        sourcePosition = context.sourcePosition,\n        endPosition,\n        waypoints;\n\n    // update connection visuals during drag\n\n    endPosition = {\n      x: event.x,\n      y: event.y\n    };\n\n    waypoints = crop(sourcePosition, endPosition, source, target);\n\n    visual.attr('points', [ waypoints[0].x, waypoints[0].y, waypoints[1].x, waypoints[1].y ]);\n  });\n\n  eventBus.on('connect.hover', function(event) {\n    var context = event.context,\n        source = context.source,\n        hover = event.hover,\n        canExecute;\n\n    canExecute = context.canExecute = canConnect(source, hover);\n\n    // simply ignore hover\n    if (canExecute === null) {\n      return;\n    }\n\n    context.target = hover;\n\n    canvas.addMarker(hover, canExecute ? MARKER_OK : MARKER_NOT_OK);\n  });\n\n  eventBus.on([ 'connect.out', 'connect.cleanup' ], function(event) {\n    var context = event.context;\n\n    if (context.target) {\n      canvas.removeMarker(context.target, context.canExecute ? MARKER_OK : MARKER_NOT_OK);\n    }\n\n    context.target = null;\n  });\n\n  eventBus.on('connect.cleanup', function(event) {\n    var context = event.context;\n\n    if (context.visual) {\n      context.visual.remove();\n    }\n  });\n\n  eventBus.on('connect.start', function(event) {\n    var context = event.context,\n        visual;\n\n    visual = canvas.getDefaultLayer().polyline().attr({\n      'stroke': '#333',\n      'strokeDasharray': [ 1 ],\n      'strokeWidth': 2,\n      'pointer-events': 'none'\n    });\n\n    context.visual = visual;\n  });\n\n  eventBus.on('connect.end', function(event) {\n\n    var context = event.context,\n        source = context.source,\n        sourcePosition = context.sourcePosition,\n        target = context.target,\n        targetPosition = {\n          x: event.x,\n          y: event.y\n        },\n        canExecute = context.canExecute || canConnect(source, target);\n\n    if (!canExecute) {\n      return false;\n    }\n\n    var attrs = null,\n        hints = {\n          connectionStart: sourcePosition,\n          connectionEnd: targetPosition\n        };\n\n    if (typeof canExecute === 'object') {\n      attrs = canExecute;\n    }\n\n    modeling.connect(source, target, attrs, hints);\n  });\n\n\n  // API\n\n  /**\n   * Start connect operation.\n   *\n   * @param {DOMEvent} event\n   * @param {djs.model.Base} source\n   * @param {Point} [sourcePosition]\n   * @param {Boolean} [autoActivate=false]\n   */\n  this.start = function(event, source, sourcePosition, autoActivate) {\n\n    if (typeof sourcePosition !== 'object') {\n      autoActivate = sourcePosition;\n      sourcePosition = LayoutUtil.getMid(source);\n    }\n\n    dragging.init(event, 'connect', {\n      autoActivate: autoActivate,\n      data: {\n        shape: source,\n        context: {\n          source: source,\n          sourcePosition: sourcePosition\n        }\n      }\n    });\n  };\n}\n\nConnect.$inject = [ 'eventBus', 'dragging', 'modeling', 'rules', 'canvas', 'graphicsFactory' ];\n\nmodule.exports = Connect;\n","module.exports = {\n  __depends__: [\n    require(214),\n    require(208),\n    require(143)\n  ],\n  connect: [ 'type', require(131) ]\n};\n","'use strict';\n\nvar isFunction = require(402),\n    forEach = require(283),\n\n    domDelegate = require(427),\n    domEvent = require(429),\n    domAttr = require(423),\n    domQuery = require(431),\n    domClasses = require(424),\n    domify = require(428);\n\n\nvar entrySelector = '.entry';\n\n\n/*k\n * A context pad that displays element specific, contextual actions next\n * to a diagram element.\n *\n * @param {EventBus} eventBus\n * @param {Overlays} overlays\n */\nfunction ContextPad(eventBus, overlays) {\n\n  this._providers = [];\n\n  this._eventBus = eventBus;\n  this._overlays = overlays;\n\n  this._current = null;\n\n  this._init();\n}\n\nContextPad.$inject = [ 'eventBus', 'overlays' ];\n\n/**\n * Registers events needed for interaction with other components\n */\nContextPad.prototype._init = function() {\n\n  var eventBus = this._eventBus;\n\n  var self = this;\n\n  eventBus.on('selection.changed', function(e) {\n\n    var selection = e.newSelection;\n\n    if (selection.length === 1) {\n      self.open(selection[0]);\n    } else {\n      self.close();\n    }\n  });\n\n  eventBus.on('elements.delete', function(event) {\n    var elements = event.elements;\n\n    forEach(elements, function(e) {\n      if (self.isOpen(e)) {\n        self.close();\n      }\n    });\n  });\n\n  eventBus.on('element.changed', function(event) {\n    var element = event.element,\n        current = self._current;\n\n    // force reopen if element for which we are currently opened changed\n    if (current && current.element === element) {\n      self.open(element, true);\n    }\n  });\n};\n\n\n/**\n * Register a provider with the context pad\n *\n * @param  {ContextPadProvider} provider\n */\nContextPad.prototype.registerProvider = function(provider) {\n  this._providers.push(provider);\n};\n\n\n/**\n * Returns the context pad entries for a given element\n *\n * @param {djs.element.Base} element\n *\n * @return {Array<ContextPadEntryDescriptor>} list of entries\n */\nContextPad.prototype.getEntries = function(element) {\n  var entries = {};\n\n  // loop through all providers and their entries.\n  // group entries by id so that overriding an entry is possible\n  forEach(this._providers, function(provider) {\n    var e = provider.getContextPadEntries(element);\n\n    forEach(e, function(entry, id) {\n      entries[id] = entry;\n    });\n  });\n\n  return entries;\n};\n\n\n/**\n * Trigger an action available on the opened context pad\n *\n * @param  {String} action\n * @param  {Event} event\n * @param  {Boolean} [autoActivate=false]\n */\nContextPad.prototype.trigger = function(action, event, autoActivate) {\n\n  var element = this._current.element,\n      entries = this._current.entries,\n      entry,\n      handler,\n      originalEvent,\n      button = event.delegateTarget || event.target;\n\n  if (!button) {\n    return event.preventDefault();\n  }\n\n  entry = entries[domAttr(button, 'data-action')];\n  handler = entry.action;\n\n  originalEvent = event.originalEvent || event;\n\n  // simple action (via callback function)\n  if (isFunction(handler)) {\n    if (action === 'click') {\n      return handler(originalEvent, element, autoActivate);\n    }\n  } else {\n    if (handler[action]) {\n      return handler[action](originalEvent, element, autoActivate);\n    }\n  }\n\n  // silence other actions\n  event.preventDefault();\n};\n\n\n/**\n * Open the context pad for the given element\n *\n * @param {djs.model.Base} element\n * @param {Boolean} force if true, force reopening the context pad\n */\nContextPad.prototype.open = function(element, force) {\n  if (!force && this.isOpen(element)) {\n    return;\n  }\n\n  this.close();\n  this._updateAndOpen(element);\n};\n\n\nContextPad.prototype._updateAndOpen = function(element) {\n\n  var entries = this.getEntries(element),\n      pad = this.getPad(element),\n      html = pad.html;\n\n  forEach(entries, function(entry, id) {\n    var grouping = entry.group || 'default',\n        control = domify(entry.html || '<div class=\"entry\" draggable=\"true\"></div>'),\n        container;\n\n    domAttr(control, 'data-action', id);\n\n    container = domQuery('[data-group=' + grouping + ']', html);\n    if (!container) {\n      container = domify('<div class=\"group\" data-group=\"' + grouping + '\"></div>');\n      html.appendChild(container);\n    }\n\n    container.appendChild(control);\n\n    if (entry.className) {\n      domClasses(control).add(entry.className);\n    }\n\n    if (entry.title) {\n      domAttr(control, 'title', entry.title);\n    }\n\n    if (entry.imageUrl) {\n      control.appendChild(domify('<img src=\"' + entry.imageUrl + '\">'));\n    }\n  });\n\n  domClasses(html).add('open');\n\n  this._current = {\n    element: element,\n    pad: pad,\n    entries: entries\n  };\n\n  this._eventBus.fire('contextPad.open', { current: this._current });\n};\n\n\nContextPad.prototype.getPad = function(element) {\n  if (this.isOpen()) {\n    return this._current.pad;\n  }\n\n  var self = this;\n\n  var overlays = this._overlays;\n\n  var html = domify('<div class=\"djs-context-pad\"></div>');\n\n  domDelegate.bind(html, entrySelector, 'click', function(event) {\n    self.trigger('click', event);\n  });\n\n  domDelegate.bind(html, entrySelector, 'dragstart', function(event) {\n    self.trigger('dragstart', event);\n  });\n\n  // stop propagation of mouse events\n  domEvent.bind(html, 'mousedown', function(event) {\n    event.stopPropagation();\n  });\n\n  this._overlayId = overlays.add(element, 'context-pad', {\n    position: {\n      right: -9,\n      top: -6\n    },\n    html: html\n  });\n\n  var pad = overlays.get(this._overlayId);\n\n  this._eventBus.fire('contextPad.create', { element: element, pad: pad });\n\n  return pad;\n};\n\n\n/**\n * Close the context pad\n */\nContextPad.prototype.close = function() {\n  if (!this.isOpen()) {\n    return;\n  }\n\n  this._overlays.remove(this._overlayId);\n\n  this._overlayId = null;\n\n  this._eventBus.fire('contextPad.close', { current: this._current });\n\n  this._current = null;\n};\n\n/**\n * Check if pad is open. If element is given, will check\n * if pad is opened with given element.\n *\n * @param {Element} element\n * @return {Boolean}\n */\nContextPad.prototype.isOpen = function(element) {\n  return !!this._current && (!element ? true : this._current.element === element);\n};\n\nmodule.exports = ContextPad;\n","module.exports = {\n  __depends__: [\n    require(151),\n    require(192)\n  ],\n  contextPad: [ 'type', require(133) ]\n};","'use strict';\n\nvar isArray = require(401),\n    forEach = require(283),\n    map = require(286),\n    find = require(282),\n    findIndex = require(271),\n    sortBy = require(291),\n    reduce = require(287);\n\nvar getBBox = require(247).getBBox;\n\nvar PositionUtil = require(256);\n\nvar CopyPasteUtil = require(245),\n    ElementsUtil = require(247);\n\n\n\nfunction CopyPaste(eventBus, modeling, elementFactory, rules, clipboard, canvas) {\n  this._eventBus = eventBus;\n  this._modeling = modeling;\n  this._elementFactory = elementFactory;\n  this._rules = rules;\n  this._canvas = canvas;\n\n  this._clipboard = clipboard;\n\n  this._descriptors = [];\n\n\n  // Element creation priorities:\n  // - 1: Independent shapes\n  // - 2: Attached shapes\n  // - 3: Connections\n  // - 4: labels\n  this.registerDescriptor(function(element, descriptor) {\n    // Base priority\n    descriptor.priority = 1;\n\n    descriptor.id = element.id;\n\n    if (element.parent) {\n      descriptor.parent = element.parent.id;\n    }\n\n    if (element.labelTarget) {\n      // Labels priority\n      descriptor.priority = 4;\n      descriptor.labelTarget = element.labelTarget.id;\n    }\n\n    if (element.host) {\n      // Attached shapes priority\n      descriptor.priority = 2;\n      descriptor.host = element.host.id;\n    }\n\n    if (element.x) {\n      descriptor.x = element.x;\n      descriptor.y = element.y;\n    }\n\n    if (element.width) {\n      descriptor.width = element.width;\n      descriptor.height = element.height;\n    }\n\n    if (element.waypoints) {\n      // Connections priority\n      descriptor.priority = 3;\n      descriptor.waypoints = [];\n\n      forEach(element.waypoints, function(waypoint) {\n        var wp = {\n          x: waypoint.x,\n          y: waypoint.y\n        };\n\n        if (waypoint.original) {\n          wp.original = {\n            x: waypoint.original.x,\n            y: waypoint.original.y\n          };\n        }\n\n        descriptor.waypoints.push(wp);\n      });\n    }\n\n    if (element.source && element.target) {\n      descriptor.source = element.source.id;\n      descriptor.target = element.target.id;\n    }\n\n    return descriptor;\n  });\n}\n\nCopyPaste.$inject = [\n  'eventBus',\n  'modeling',\n  'elementFactory',\n  'rules',\n  'clipboard',\n  'canvas'\n];\n\nmodule.exports = CopyPaste;\n\n/**\n * Copy a number of elements.\n *\n * @param {djs.model.Base} selectedElements\n *\n * @return {Object} the copied tree\n */\nCopyPaste.prototype.copy = function(selectedElements) {\n  var clipboard = this._clipboard,\n      tree, bbox;\n\n  if (!isArray(selectedElements)) {\n    selectedElements = selectedElements ? [ selectedElements ] : [];\n  }\n\n  if (!selectedElements.length) {\n    return;\n  }\n\n  tree = this.createTree(selectedElements);\n\n  bbox = this._bbox = PositionUtil.center(getBBox(tree.allShapes));\n\n  // not needed after computing the center position of the copied elements\n  delete tree.allShapes;\n\n  forEach(tree, function(elements) {\n\n    forEach(elements, function(element) {\n      var delta, labelTarget;\n\n      // set label's relative position to their label target\n      if (element.labelTarget) {\n        labelTarget = find(elements, { id: element.labelTarget });\n\n        // just grab the delta from the first waypoint\n        if (labelTarget.waypoints) {\n          delta = PositionUtil.delta(element, labelTarget.waypoints[0]);\n        } else {\n          delta = PositionUtil.delta(element, labelTarget);\n        }\n\n      } else\n      if (element.priority === 3) {\n        // connections have priority 3\n        delta = [];\n\n        forEach(element.waypoints, function(waypoint) {\n          var waypointDelta = PositionUtil.delta(waypoint, bbox);\n\n          delta.push(waypointDelta);\n        }, this);\n      } else {\n        delta = PositionUtil.delta(element, bbox);\n      }\n\n      element.delta = delta;\n    });\n  });\n\n  this._eventBus.fire('elements.copy', { context: { tree: tree } });\n\n  // if tree is empty, means that nothing can be or is allowed to be copied\n  if (Object.keys(tree).length === 0) {\n    clipboard.clear();\n  } else {\n    clipboard.set(tree);\n  }\n\n  this._eventBus.fire('elements.copied', { context: { tree: tree } });\n\n  return tree;\n};\n\n\n// Allow pasting under the cursor\nCopyPaste.prototype.paste = function(context) {\n  var clipboard = this._clipboard,\n      modeling = this._modeling,\n      eventBus = this._eventBus,\n      rules = this._rules;\n\n  var tree = clipboard.get(),\n      topParent = context.element,\n      position = context.point,\n      newTree, canPaste;\n\n  if (clipboard.isEmpty()) {\n    return;\n  }\n\n  newTree = reduce(tree, function(pasteTree, elements, depthStr) {\n    var depth = parseInt(depthStr, 10);\n\n    if (isNaN(depth)) {\n      return pasteTree;\n    }\n\n    pasteTree[depth] = elements;\n\n    return pasteTree;\n  }, {}, this);\n\n\n  canPaste = rules.allowed('elements.paste', {\n    tree: newTree,\n    target: topParent\n  });\n\n  if (!canPaste) {\n    eventBus.fire('elements.paste.rejected', {\n      context: {\n        tree: newTree,\n        position: position,\n        target: topParent\n      }\n    });\n\n    return;\n  }\n\n  modeling.pasteElements(newTree, topParent, position);\n};\n\n\nCopyPaste.prototype._computeDelta = function(elements, element) {\n  var bbox = this._bbox,\n      delta = {};\n\n  // set label's relative position to their label target\n  if (element.labelTarget) {\n    console.log(elements);\n    return PositionUtil.delta(element, element.labelTarget);\n  }\n\n  // connections have prority 3\n  if (element.priority === 3) {\n    delta = [];\n\n    forEach(element.waypoints, function(waypoint) {\n      var waypointDelta = PositionUtil.delta(waypoint, bbox);\n\n      delta.push(waypointDelta);\n    }, this);\n  } else {\n    delta = PositionUtil.delta(element, bbox);\n  }\n\n  return delta;\n};\n\n\n/**\n * Checks if the element in question has a relations to other elements.\n * Possible dependants: connections, labels, attachers\n *\n * @param  {Array} elements\n * @param  {Object} element\n *\n * @return {Boolean}\n */\nCopyPaste.prototype.hasRelations = function(elements, element) {\n  var source, target, labelTarget;\n\n  if (element.waypoints) {\n    source = find(elements, { id: element.source.id });\n    target = find(elements, { id: element.target.id });\n\n    if (!source || !target) {\n      return false;\n    }\n  }\n\n  if (element.labelTarget) {\n    labelTarget = find(elements, { id: element.labelTarget.id });\n\n    if (!labelTarget) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\n\nCopyPaste.prototype.registerDescriptor = function(descriptor) {\n  if (typeof descriptor !== 'function') {\n    throw new Error('the descriptor must be a function');\n  }\n\n  if (this._descriptors.indexOf(descriptor) !== -1) {\n    throw new Error('this descriptor is already registered');\n  }\n\n  this._descriptors.push(descriptor);\n};\n\n\nCopyPaste.prototype._executeDescriptors = function(data) {\n  if (!data.descriptor) {\n    data.descriptor = {};\n  }\n\n  forEach(this._descriptors, function(descriptor) {\n    data.descriptor = descriptor(data.element, data.descriptor);\n  });\n\n  return data;\n};\n\n/**\n * Creates a tree like structure from an arbitrary collection of elements\n *\n * @example\n * tree: {\n *\t0: [\n *\t\t{ id: 'shape_12da', priority: 1, ... },\n *\t\t{ id: 'shape_01bj', priority: 1, ... },\n *\t\t{ id: 'connection_79fa', source: 'shape_12da', target: 'shape_01bj', priority: 3, ... },\n *\t],\n *\t1: [ ... ]\n * };\n *\n * @param  {Array} elements\n * @return {Object}\n */\nCopyPaste.prototype.createTree = function(elements) {\n  var rules = this._rules;\n\n  var tree = {},\n      includedElements = [],\n      _elements;\n\n  var topLevel = CopyPasteUtil.getTopLevel(elements);\n\n  tree.allShapes = [];\n\n  function canCopy(collection, element) {\n    return rules.allowed('element.copy', {\n      collection: collection,\n      element: element\n    });\n  }\n\n  function includeElement(data) {\n    var idx = findIndex(includedElements, { element: data.element }),\n        element;\n\n    if (idx !== -1) {\n      element = includedElements[idx];\n    } else {\n      return includedElements.push(data);\n    }\n\n    // makes sure that it has the correct depth\n    if (element.depth < data.depth) {\n      includedElements.splice(idx, 1);\n\n      includedElements.push(data);\n    }\n  }\n\n\n  ElementsUtil.eachElement(topLevel, function(element, i, depth) {\n    var nestedChildren = element.children;\n\n    // don't add labels directly\n    if (element.labelTarget) {\n      return;\n    }\n\n    function getNested(lists) {\n      forEach(lists, function(list) {\n        if (list && list.length) {\n\n          forEach(list, function(elem) {\n            // fetch element's label\n            if (elem.label) {\n              includeElement({\n                element: elem.label,\n                depth: depth\n              });\n            }\n\n            includeElement({\n              element: elem,\n              depth: depth\n            });\n          });\n        }\n      });\n    }\n\n    // fetch element's label\n    if (element.label) {\n      includeElement({\n        element: element.label,\n        depth: depth\n      });\n    }\n\n    getNested([ element.attachers, element.incoming, element.outgoing ]);\n\n    includeElement({\n      element: element,\n      depth: depth\n    });\n\n    if (nestedChildren) {\n      return nestedChildren;\n    }\n  });\n\n  includedElements = map(includedElements, function(data) {\n    // this is where other registered descriptors hook in\n    return this._executeDescriptors(data);\n  }, this);\n\n  // order the elements to check if the ones dependant on others (by relationship)\n  // can be copied. f.ex: label needs it's label target\n  includedElements = sortBy(includedElements, function(data) {\n    return data.descriptor.priority;\n  });\n\n  _elements = map(includedElements, function(data) {\n    return data.element;\n  });\n\n  forEach(includedElements, function(data) {\n    var depth = data.depth;\n\n    if (!this.hasRelations(tree.allShapes, data.element)) {\n      return;\n    }\n\n    if (!canCopy(_elements, data.element)) {\n      return;\n    }\n\n    tree.allShapes.push(data.element);\n\n    // create depth branches\n    if (!tree[depth]) {\n      tree[depth] = [];\n    }\n\n    tree[depth].push(data.descriptor);\n  }, this);\n\n  return tree;\n};\n","module.exports = {\n  __depends__: [\n    require(130),\n    require(208),\n    require(184)\n  ],\n  __init__: [ 'copyPaste' ],\n  copyPaste: [ 'type', require(135) ]\n};\n","'use strict';\n\nvar LOW_PRIORITY = 750;\n\nvar MARKER_OK = 'drop-ok',\n    MARKER_NOT_OK = 'drop-not-ok',\n    MARKER_ATTACH = 'attach-ok',\n    MARKER_NEW_PARENT = 'new-parent';\n\n\nfunction Create(eventBus, dragging, rules, modeling, canvas, styles, graphicsFactory) {\n\n  // rules\n\n  function canCreate(shape, target, source, position) {\n\n    if (source) {\n      return rules.allowed('shape.append', {\n        source: source,\n        shape: shape,\n        target: target,\n        position: position\n      });\n    } else {\n      return rules.allowed('shape.create', {\n        shape: shape,\n        target: target,\n        position: position\n      });\n    }\n  }\n\n\n  /** set drop marker on an element */\n  function setMarker(element, marker) {\n\n    [ MARKER_ATTACH, MARKER_OK, MARKER_NOT_OK, MARKER_NEW_PARENT ].forEach(function(m) {\n\n      if (m === marker) {\n        canvas.addMarker(element, m);\n      } else {\n        canvas.removeMarker(element, m);\n      }\n    });\n  }\n\n\n  // visual helpers\n\n  function createVisual(shape) {\n    var group, preview, visual;\n\n    group = canvas.getDefaultLayer().group().attr(styles.cls('djs-drag-group', [ 'no-events' ]));\n\n    preview = group.group().addClass('djs-dragger');\n\n    preview.translate(shape.width / -2, shape.height / -2);\n\n    visual = preview.group().addClass('djs-visual');\n\n    // hijack renderer to draw preview\n    graphicsFactory.drawShape(visual, shape);\n\n    return group;\n  }\n\n\n  // event handlers\n\n  eventBus.on('create.move', function(event) {\n\n    var context = event.context,\n        hover = event.hover,\n        canExecute;\n\n    var position = {\n      x: event.x,\n      y: event.y\n    };\n\n    canExecute = context.canExecute = hover && canCreate(context.shape, hover, context.source, position);\n\n    // ignore hover visually if canExecute is null\n    if (hover && canExecute !== null) {\n      context.target = hover;\n\n      if (canExecute === 'attach') {\n        setMarker(hover, MARKER_ATTACH);\n      } else {\n        setMarker(hover, context.canExecute ? MARKER_NEW_PARENT : MARKER_NOT_OK);\n      }\n    }\n  });\n\n  eventBus.on('create.move', LOW_PRIORITY, function(event) {\n\n    var context = event.context,\n        shape = context.shape,\n        visual = context.visual;\n\n    // lazy init drag visual once we received the first real\n    // drag move event (this allows us to get the proper canvas local coordinates)\n    if (!visual) {\n      visual = context.visual = createVisual(shape);\n    }\n\n    visual.translate(event.x, event.y);\n  });\n\n\n  eventBus.on([ 'create.end', 'create.out', 'create.cleanup' ], function(event) {\n    var context = event.context,\n        target = context.target;\n\n    if (target) {\n      setMarker(target, null);\n    }\n  });\n\n  eventBus.on('create.end', function(event) {\n    var context = event.context,\n        source = context.source,\n        shape = context.shape,\n        target = context.target,\n        canExecute = context.canExecute,\n        isAttach,\n        position = {\n          x: event.x,\n          y: event.y\n        };\n\n    if (!canExecute) {\n      return false;\n    }\n\n    if (source) {\n      shape = modeling.appendShape(source, shape, position, target);\n    } else {\n      isAttach = canExecute === 'attach';\n\n      shape = modeling.createShape(shape, position, target, isAttach);\n    }\n\n    // make sure we provide the actual attached\n    // shape with the context so that selection and\n    // other components can use it right after the create\n    // operation ends\n    context.shape = shape;\n  });\n\n\n  eventBus.on('create.cleanup', function(event) {\n    var context = event.context;\n\n    if (context.visual) {\n      context.visual.remove();\n    }\n  });\n\n  // API\n\n  this.start = function(event, shape, source) {\n\n    dragging.init(event, 'create', {\n      cursor: 'grabbing',\n      autoActivate: true,\n      data: {\n        shape: shape,\n        context: {\n          shape: shape,\n          source: source\n        }\n      }\n    });\n  };\n}\n\nCreate.$inject = [ 'eventBus', 'dragging', 'rules', 'modeling', 'canvas', 'styles', 'graphicsFactory' ];\n\nmodule.exports = Create;\n","module.exports = {\n  __depends__: [\n    require(143),\n    require(214),\n    require(208)\n  ],\n  create: [ 'type', require(137) ]\n};\n","'use strict';\n\nvar sortBy = require(291),\n    forEach = require(283),\n    filter = require(281);\n\nvar AXIS_DIMENSIONS = {\n  horizontal: [ 'x', 'width' ],\n  vertical: [ 'y', 'height' ]\n};\n\nvar THRESHOLD = 5;\n\n/**\n * Groups and filters elements and then trigger even distribution.\n */\nfunction DistributeElements(modeling) {\n  this._modeling = modeling;\n\n  this._filters = [];\n\n  // register filter for filtering big elements\n  this.registerFilter(function(elements, axis, dimension) {\n    var elementsSize = 0,\n        numOfShapes = 0,\n        avgDimension;\n\n    forEach(elements, function(element) {\n      if (element.waypoints || element.labelTarget) {\n        return;\n      }\n\n      elementsSize += element[dimension];\n\n      numOfShapes += 1;\n    });\n\n    avgDimension = Math.round(elementsSize / numOfShapes);\n\n    return filter(elements, function(element) {\n      return element[dimension] < (avgDimension + 50);\n    });\n  });\n\n}\n\nmodule.exports = DistributeElements;\n\nDistributeElements.$inject = [ 'modeling' ];\n\n\n/**\n * Registers filter functions that allow external parties to filter\n * out certain elements.\n *\n * @param  {Function} filterFn\n */\nDistributeElements.prototype.registerFilter = function(filterFn) {\n  if (typeof filterFn !== 'function') {\n    throw new Error('the filter has to be a function');\n  }\n\n  this._filters.push(filterFn);\n};\n\n/**\n * Distributes the elements with a given orientation\n *\n * @param  {Array} elements    [description]\n * @param  {String} orientation [description]\n */\nDistributeElements.prototype.trigger = function(elements, orientation) {\n  var modeling = this._modeling;\n\n  var groups,\n      distributableElements;\n\n  if (elements.length < 3) {\n    return;\n  }\n\n  this._setOrientation(orientation);\n\n  distributableElements = this._filterElements(elements);\n\n  groups = this._createGroups(distributableElements);\n\n  // nothing to distribute\n  if (groups.length <= 2) {\n    return;\n  }\n\n  modeling.distributeElements(groups, this._axis, this._dimension);\n\n  return groups;\n};\n\n/**\n * Filters the elements with provided filters by external parties\n *\n * @param  {Array[Elements]} elements\n *\n * @return {Array[Elements]}\n */\nDistributeElements.prototype._filterElements = function(elements) {\n  var filters = this._filters,\n      axis = this._axis,\n      dimension = this._dimension,\n      distributableElements = [].concat(elements);\n\n  if (!filters.length) {\n    return elements;\n  }\n\n  forEach(filters, function(filterFn) {\n    distributableElements = filterFn(distributableElements, axis, dimension);\n  });\n\n  return distributableElements;\n};\n\n\n/**\n * Create range (min, max) groups. Also tries to group elements\n * together that share the same range.\n *\n * @example\n * \tvar distributableElements = [\n * \t\t{\n * \t\t\trange: {\n * \t\t\t\tmin: 100,\n * \t\t\t\tmax: 200\n * \t\t\t},\n * \t\t\telements: [ { id: 'shape1', .. }]\n * \t\t}\n * \t]\n *\n * @param  {Array} elements\n *\n * @return {Array[Objects]}\n */\nDistributeElements.prototype._createGroups = function(elements) {\n  var rangeGroups = [],\n      axis = this._axis,\n      dimension = this._dimension;\n\n  if (!axis) {\n    throw new Error('must have a defined \"axis\" and \"dimension\"');\n  }\n\n  // sort by 'left->right' or 'top->bottom'\n  var sortedElements = sortBy(elements, axis);\n\n  forEach(sortedElements, function(element, idx) {\n    var elementRange = this._findRange(element, axis, dimension),\n        range;\n\n    var previous = rangeGroups[rangeGroups.length - 1];\n\n    if (previous && this._hasIntersection(previous.range, elementRange)) {\n      rangeGroups[rangeGroups.length - 1].elements.push(element);\n    } else {\n      range = { range: elementRange, elements: [ element ] };\n\n      rangeGroups.push(range);\n    }\n  }, this);\n\n  return rangeGroups;\n};\n\n\n/**\n * Maps a direction to the according axis and dimension\n *\n * @param  {String} direction 'horizontal' or 'vertical'\n */\nDistributeElements.prototype._setOrientation = function(direction) {\n  var orientation = AXIS_DIMENSIONS[direction];\n\n  this._axis = orientation[0];\n  this._dimension = orientation[1];\n};\n\n\n/**\n * Checks if the two ranges intercept each other\n *\n * @param  {Object} rangeA {min, max}\n * @param  {Object} rangeB {min, max}\n *\n * @return {Boolean}\n */\nDistributeElements.prototype._hasIntersection = function(rangeA, rangeB) {\n  return Math.max(rangeA.min, rangeA.max) >= Math.min(rangeB.min, rangeB.max) &&\n         Math.min(rangeA.min, rangeA.max) <= Math.max(rangeB.min, rangeB.max);\n};\n\n\n/**\n * Returns the min and max values for an element\n *\n * @param  {[type]} element   [description]\n * @param  {[type]} axis      [description]\n * @param  {[type]} dimension [description]\n *\n * @return {[type]}           [description]\n */\nDistributeElements.prototype._findRange = function(element) {\n  var axis = element[this._axis],\n      dimension = element[this._dimension];\n\n  return {\n    min: axis + THRESHOLD,\n    max: axis + dimension - THRESHOLD\n  };\n};\n","'use strict';\n\nmodule.exports = {\n  __init__: [ 'distributeElements' ],\n  distributeElements: [ 'type', require(139) ]\n};\n","'use strict';\n\n/* global TouchEvent */\n\nvar round = Math.round;\n\nvar assign = require(410);\n\nvar domEvent = require(429),\n    Event = require(248),\n    ClickTrap = require(243),\n    Cursor = require(246);\n\nvar EventBusEvent = require(106).Event;\n\nvar DRAG_ACTIVE_CLS = 'djs-drag-active';\n\n\nfunction suppressEvent(event) {\n  if (event instanceof MouseEvent) {\n    Event.stopEvent(event, true);\n  } else {\n    Event.preventDefault(event);\n  }\n}\n\nfunction getLength(point) {\n  return Math.sqrt(Math.pow(point.x, 2) + Math.pow(point.y, 2));\n}\n\nfunction substract(p1, p2) {\n  return {\n    x: p1.x - p2.x,\n    y: p1.y - p2.y\n  };\n}\n\n/**\n * A helper that fires canvas localized drag events and realizes\n * the general \"drag-and-drop\" look and feel.\n *\n * Calling {@link Dragging#activate} activates dragging on a canvas.\n *\n * It provides the following:\n *\n *   * emits life cycle events, namespaced with a prefix assigned\n *     during dragging activation\n *   * sets and restores the cursor\n *   * sets and restores the selection\n *   * ensures there can be only one drag operation active at a time\n *\n * Dragging may be canceled manually by calling {@link Dragging#cancel}\n * or by pressing ESC.\n *\n *\n * ## Life-cycle events\n *\n * Dragging can be in three different states, off, initialized\n * and active.\n *\n * (1) off: no dragging operation is in progress\n * (2) initialized: a new drag operation got initialized but not yet\n *                  started (i.e. because of no initial move)\n * (3) started: dragging is in progress\n *\n * Eventually dragging will be off again after a drag operation has\n * been ended or canceled via user click or ESC key press.\n *\n * To indicate transitions between these states dragging emits generic\n * life-cycle events with the `drag.` prefix _and_ events namespaced\n * to a prefix choosen by a user during drag initialization.\n *\n * The following events are emitted (appropriately prefixed) via\n * the {@link EventBus}.\n *\n * * `init`\n * * `start`\n * * `move`\n * * `end`\n * * `ended` (dragging already in off state)\n * * `cancel` (only if previously started)\n * * `canceled` (dragging already in off state, only if previously started)\n * * `cleanup`\n *\n *\n * @example\n *\n * function MyDragComponent(eventBus, dragging) {\n *\n *   eventBus.on('mydrag.start', function(event) {\n *     console.log('yes, we start dragging');\n *   });\n *\n *   eventBus.on('mydrag.move', function(event) {\n *     console.log('canvas local coordinates', event.x, event.y, event.dx, event.dy);\n *\n *     // local drag data is passed with the event\n *     event.context.foo; // \"BAR\"\n *\n *     // the original mouse event, too\n *     event.originalEvent; // MouseEvent(...)\n *   });\n *\n *   eventBus.on('element.click', function(event) {\n *     dragging.init(event, 'mydrag', {\n *       cursor: 'grabbing',\n *       data: {\n *         context: {\n *           foo: \"BAR\"\n *         }\n *       }\n *     });\n *   });\n * }\n */\nfunction Dragging(eventBus, canvas, selection) {\n\n  var defaultOptions = {\n    threshold: 5,\n    trapClick: true\n  };\n\n  // the currently active drag operation\n  // dragging is active as soon as this context exists.\n  //\n  // it is visually _active_ only when a context.active flag is set to true.\n  var context;\n\n  /* convert a global event into local coordinates */\n  function toLocalPoint(globalPosition) {\n\n    var viewbox = canvas.viewbox();\n\n    var clientRect = canvas._container.getBoundingClientRect();\n\n    return {\n      x: viewbox.x + round((globalPosition.x - clientRect.left) / viewbox.scale),\n      y: viewbox.y + round((globalPosition.y - clientRect.top) / viewbox.scale)\n    };\n  }\n\n  // helpers\n\n  function fire(type, dragContext) {\n    dragContext = dragContext || context;\n\n    var event = assign(new EventBusEvent(), dragContext.payload, dragContext.data);\n\n    // default integration\n    if (eventBus.fire('drag.' + type, event) === false) {\n      return false;\n    }\n\n    return eventBus.fire(dragContext.prefix + '.' + type, event);\n  }\n\n  // event listeners\n\n  function move(event, activate) {\n    var payload = context.payload,\n        displacement = context.displacement;\n\n    var globalStart = context.globalStart,\n        globalCurrent = Event.toPoint(event),\n        globalDelta = substract(globalCurrent, globalStart);\n\n    var localStart = context.localStart,\n        localCurrent = toLocalPoint(globalCurrent),\n        localDelta = substract(localCurrent, localStart);\n\n    // activate context explicitly or once threshold is reached\n    if (!context.active && (activate || getLength(globalDelta) > context.threshold)) {\n\n      // fire start event with original\n      // starting coordinates\n\n      assign(payload, {\n        x: localStart.x + displacement.x,\n        y: localStart.y + displacement.y,\n        dx: 0,\n        dy: 0\n      }, { originalEvent: event });\n\n      if (false === fire('start')) {\n        return cancel();\n      }\n\n      context.active = true;\n\n      // unset selection and remember old selection\n      // the previous (old) selection will always passed\n      // with the event via the event.previousSelection property\n      if (!context.keepSelection) {\n        payload.previousSelection = selection.get();\n        selection.select(null);\n      }\n\n      // allow custom cursor\n      if (context.cursor) {\n        Cursor.set(context.cursor);\n      }\n\n      // indicate dragging via marker on root element\n      canvas.addMarker(canvas.getRootElement(), DRAG_ACTIVE_CLS);\n    }\n\n    suppressEvent(event);\n\n    if (context.active) {\n\n      // update payload with actual coordinates\n      assign(payload, {\n        x: localCurrent.x + displacement.x,\n        y: localCurrent.y + displacement.y,\n        dx: localDelta.x,\n        dy: localDelta.y\n      }, { originalEvent: event });\n\n      // emit move event\n      fire('move');\n    }\n  }\n\n  function end(event) {\n    var previousContext,\n        returnValue = true;\n\n    if (context.active) {\n\n      if (event) {\n        context.payload.originalEvent = event;\n\n        // suppress original event (click, ...)\n        // because we just ended a drag operation\n        suppressEvent(event);\n      }\n\n      // implementations may stop restoring the\n      // original state (selections, ...) by preventing the\n      // end events default action\n      returnValue = fire('end');\n    }\n\n    if (returnValue === false) {\n      fire('rejected');\n    }\n\n    previousContext = cleanup(returnValue !== true);\n\n    // last event to be fired when all drag operations are done\n    // at this point in time no drag operation is in progress anymore\n    fire('ended', previousContext);\n  }\n\n\n  // cancel active drag operation if the user presses\n  // the ESC key on the keyboard\n\n  function checkCancel(event) {\n\n    if (event.which === 27) {\n      event.preventDefault();\n\n      cancel();\n    }\n  }\n\n\n  // prevent ghost click that might occur after a finished\n  // drag and drop session\n\n  function trapClickAndEnd(event) {\n\n    var untrap;\n\n    // trap the click in case we are part of an active\n    // drag operation. This will effectively prevent\n    // the ghost click that cannot be canceled otherwise.\n    if (context.active) {\n      untrap = ClickTrap.install();\n      setTimeout(untrap, 400);\n    }\n\n    end(event);\n  }\n\n  function trapTouch(event) {\n    move(event);\n  }\n\n  // update the drag events hover (djs.model.Base) and hoverGfx (Snap<SVGElement>)\n  // properties during hover and out and fire {prefix}.hover and {prefix}.out properties\n  // respectively\n\n  function hover(event) {\n    var payload = context.payload;\n\n    payload.hoverGfx = event.gfx;\n    payload.hover = event.element;\n\n    fire('hover');\n  }\n\n  function out(event) {\n    fire('out');\n\n    var payload = context.payload;\n\n    payload.hoverGfx = null;\n    payload.hover = null;\n  }\n\n\n  // life-cycle methods\n\n  function cancel(restore) {\n    var previousContext;\n\n    if (!context) {\n      return;\n    }\n\n    var wasActive = context.active;\n\n    if (wasActive) {\n      fire('cancel');\n    }\n\n    previousContext = cleanup(restore);\n\n    if (wasActive) {\n      // last event to be fired when all drag operations are done\n      // at this point in time no drag operation is in progress anymore\n      fire('canceled', previousContext);\n    }\n  }\n\n  function cleanup(restore) {\n    var previousContext,\n        endDrag;\n\n    fire('cleanup');\n\n    // reset cursor\n    Cursor.unset();\n\n    if (context.trapClick) {\n      endDrag = trapClickAndEnd;\n    } else {\n      endDrag = end;\n    }\n\n    // reset dom listeners\n    domEvent.unbind(document, 'mousemove', move);\n\n    domEvent.unbind(document, 'mousedown', endDrag, true);\n    domEvent.unbind(document, 'mouseup', endDrag, true);\n\n    domEvent.unbind(document, 'keyup', checkCancel);\n\n    domEvent.unbind(document, 'touchstart', trapTouch, true);\n    domEvent.unbind(document, 'touchcancel', cancel, true);\n    domEvent.unbind(document, 'touchmove', move, true);\n    domEvent.unbind(document, 'touchend', end, true);\n\n    eventBus.off('element.hover', hover);\n    eventBus.off('element.out', out);\n\n    // remove drag marker on root element\n    canvas.removeMarker(canvas.getRootElement(), DRAG_ACTIVE_CLS);\n\n    // restore selection, unless it has changed\n    var previousSelection = context.payload.previousSelection;\n\n    if (restore !== false && previousSelection && !selection.get().length) {\n      selection.select(previousSelection);\n    }\n\n    previousContext = context;\n\n    context = null;\n\n    return previousContext;\n  }\n\n  /**\n   * Initialize a drag operation.\n   *\n   * If `localPosition` is given, drag events will be emitted\n   * relative to it.\n   *\n   * @param {MouseEvent|TouchEvent} [event]\n   * @param {Point} [localPosition] actual diagram local position this drag operation should start at\n   * @param {String} prefix\n   * @param {Object} [options]\n   */\n  function init(event, relativeTo, prefix, options) {\n\n    // only one drag operation may be active, at a time\n    if (context) {\n      cancel(false);\n    }\n\n    if (typeof relativeTo === 'string') {\n      options = prefix;\n      prefix = relativeTo;\n      relativeTo = null;\n    }\n\n    options = assign({}, defaultOptions, options || {});\n\n    var data = options.data || {},\n        originalEvent,\n        globalStart,\n        endDrag;\n\n    if (options.trapClick) {\n      endDrag = trapClickAndEnd;\n    } else {\n      endDrag = end;\n    }\n\n    if (event) {\n      originalEvent = Event.getOriginal(event) || event;\n      globalStart = Event.toPoint(event);\n\n      suppressEvent(event);\n    } else {\n      originalEvent = null;\n      globalStart = { x: 0, y: 0 };\n    }\n\n    var localStart = toLocalPoint(globalStart);\n\n    if (!relativeTo) {\n      relativeTo = localStart;\n    }\n\n    context = assign({\n      prefix: prefix,\n      data: data,\n      payload: {},\n      globalStart: globalStart,\n      displacement: substract(relativeTo, localStart),\n      localStart: localStart\n    }, options);\n\n    // skip dom registration if trigger\n    // is set to manual (during testing)\n    if (!options.manual) {\n\n      // add dom listeners\n\n      // fixes TouchEvent not being available on desktop Firefox\n      if (typeof TouchEvent !== 'undefined' && originalEvent instanceof TouchEvent) {\n        domEvent.bind(document, 'touchstart', trapTouch, true);\n        domEvent.bind(document, 'touchcancel', cancel, true);\n        domEvent.bind(document, 'touchmove', move, true);\n        domEvent.bind(document, 'touchend', end, true);\n      } else {\n        // assume we use the mouse to interact per default\n        domEvent.bind(document, 'mousemove', move);\n\n        domEvent.bind(document, 'mousedown', endDrag, true);\n        domEvent.bind(document, 'mouseup', endDrag, true);\n      }\n\n      domEvent.bind(document, 'keyup', checkCancel);\n\n      eventBus.on('element.hover', hover);\n      eventBus.on('element.out', out);\n    }\n\n    fire('init');\n\n    if (options.autoActivate) {\n      move(event, true);\n    }\n  }\n\n  // cancel on diagram destruction\n  eventBus.on('diagram.destroy', cancel);\n\n\n  // API\n\n  this.init = init;\n  this.move = move;\n  this.hover = hover;\n  this.out = out;\n  this.end = end;\n\n  this.cancel = cancel;\n\n  // for introspection\n\n  this.context = function() {\n    return context;\n  };\n\n  this.setOptions = function(options) {\n    assign(defaultOptions, options);\n  };\n}\n\nDragging.$inject = [ 'eventBus', 'canvas', 'selection' ];\n\nmodule.exports = Dragging;\n","'use strict';\n\nvar domClosest = require(426);\n\nvar Snap = require(267);\n\nvar Event = require(248);\n\nfunction getGfx(target) {\n  var node = domClosest(target, 'svg, .djs-element', true);\n  return node && new Snap(node);\n}\n\n\n/**\n * Browsers may swallow the hover event if users are to\n * fast with the mouse.\n *\n * @see http://stackoverflow.com/questions/7448468/why-cant-i-reliably-capture-a-mouseout-event\n *\n * The fix implemented in this component ensure that we\n * have a hover state after a successive drag.move event.\n *\n * @param {EventBus} eventBus\n * @param {Dragging} dragging\n * @param {ElementRegistry} elementRegistry\n */\nfunction HoverFix(eventBus, dragging, elementRegistry) {\n\n  var self = this;\n\n  // we wait for a specific sequence of events before\n  // emitting a fake drag.hover event.\n  //\n  // Event Sequence:\n  //\n  // drag.start\n  // drag.move\n  // drag.move >> ensure we are hovering\n  //\n  eventBus.on('drag.start', function(event) {\n\n    eventBus.once('drag.move', function() {\n\n      eventBus.once('drag.move', function(event) {\n\n        self.ensureHover(event);\n      });\n    });\n  });\n\n  /**\n   * Make sure we are god damn hovering!\n   *\n   * @param {Event} dragging event\n   */\n  this.ensureHover = function(event) {\n\n    if (event.hover) {\n      return;\n    }\n\n    var originalEvent = event.originalEvent,\n        position,\n        target,\n        element,\n        gfx;\n\n    if (!(originalEvent instanceof MouseEvent)) {\n      return;\n    }\n\n    position = Event.toPoint(originalEvent);\n\n    // damn expensive operation, ouch!\n    target = document.elementFromPoint(position.x, position.y);\n\n    gfx = getGfx(target);\n\n    if (gfx) {\n      element = elementRegistry.get(gfx);\n\n      dragging.hover({ element: element, gfx: gfx });\n    }\n  };\n\n}\n\nHoverFix.$inject = [ 'eventBus', 'dragging', 'elementRegistry' ];\n\nmodule.exports = HoverFix;","module.exports = {\n  __init__: [\n    'hoverFix'\n  ],\n  __depends__: [\n    require(214)\n  ],\n  dragging: [ 'type', require(141) ],\n  hoverFix: [ 'type', require(142) ]\n};","'use strict';\n\nvar forEach = require(283),\n    isArray = require(401);\n\nvar NOT_REGISTERED_ERROR = 'is not a registered action',\n    IS_REGISTERED_ERROR = 'is already registered';\n\n\n/**\n * An interface that provides access to modeling actions by decoupling\n * the one who requests the action to be triggered and the trigger itself.\n *\n * It's possible to add new actions by registering them with ´registerAction´ and likewise\n * unregister existing ones with ´unregisterAction´.\n *\n */\nfunction EditorActions(eventBus, commandStack, modeling, selection,\n  zoomScroll, copyPaste, canvas, rules, mouseTracking) {\n\n  this._actions = {\n    undo: function() {\n      commandStack.undo();\n    },\n    redo: function() {\n      commandStack.redo();\n    },\n    copy: function() {\n      var selectedElements = selection.get();\n\n      copyPaste.copy(selectedElements);\n    },\n    paste: function() {\n      var context = mouseTracking.getHoverContext();\n\n      copyPaste.paste(context);\n    },\n    stepZoom: function(opts) {\n      zoomScroll.stepZoom(opts.value);\n    },\n    zoom: function(opts) {\n      canvas.zoom(opts.value);\n    },\n    removeSelection: function() {\n      var selectedElements = selection.get();\n\n      if (selectedElements.length) {\n        var allowed = rules.allowed('elements.delete', { elements: selectedElements }),\n            removableElements;\n\n        if (allowed === false) {\n          return;\n        }\n        else if (isArray(allowed)) {\n          removableElements = allowed;\n        }\n        else {\n          removableElements = selectedElements;\n        }\n\n        if (removableElements.length) {\n          modeling.removeElements(removableElements.slice());\n        }\n      }\n    },\n    moveCanvas: function(opts) {\n      var dx = 0,\n          dy = 0,\n          invertY = opts.invertY,\n          speed = opts.speed;\n\n      var actualSpeed = speed / Math.min(Math.sqrt(canvas.viewbox().scale), 1);\n\n      switch (opts.direction) {\n      case 'left':    // Left\n        dx = actualSpeed;\n        break;\n      case 'up':    // Up\n        dy = actualSpeed;\n        break;\n      case 'right':    // Right\n        dx = -actualSpeed;\n        break;\n      case 'down':    // Down\n        dy = -actualSpeed;\n        break;\n      }\n\n      if (dy && invertY) {\n        dy = -dy;\n      }\n\n      canvas.scroll({ dx: dx, dy: dy });\n    }\n  };\n}\n\nEditorActions.$inject = [\n  'eventBus',\n  'commandStack',\n  'modeling',\n  'selection',\n  'zoomScroll',\n  'copyPaste',\n  'canvas',\n  'rules',\n  'mouseTracking'\n];\n\nmodule.exports = EditorActions;\n\n\n/**\n * Triggers a registered action\n *\n * @param  {String} action\n * @param  {Object} opts\n *\n * @return {Unknown} Returns what the registered listener returns\n */\nEditorActions.prototype.trigger = function(action, opts) {\n  if (!this._actions[action]) {\n    throw error(action, NOT_REGISTERED_ERROR);\n  }\n\n  return this._actions[action](opts);\n};\n\n\n/**\n * Registers a collections of actions.\n * The key of the object will be the name of the action.\n *\n * @example\n * ´´´\n * var actions = {\n *   spaceTool: function() {\n *     spaceTool.activateSelection();\n *   },\n *   lassoTool: function() {\n *     lassoTool.activateSelection();\n *   }\n * ];\n *\n * editorActions.register(actions);\n *\n * editorActions.isRegistered('spaceTool'); // true\n * ´´´\n *\n * @param  {Object} actions\n */\nEditorActions.prototype.register = function(actions, listener) {\n  if (typeof actions === 'string') {\n    return this._registerAction(actions, listener);\n  }\n\n  forEach(actions, function(listener, action) {\n    this._registerAction(action, listener);\n  }, this);\n};\n\n/**\n * Registers a listener to an action key\n *\n * @param  {String} action\n * @param  {Function} listener\n */\nEditorActions.prototype._registerAction = function(action, listener) {\n  if (this.isRegistered(action)) {\n    throw error(action, IS_REGISTERED_ERROR);\n  }\n\n  this._actions[action] = listener;\n};\n\n/**\n * Unregister an existing action\n *\n * @param {String} action\n */\nEditorActions.prototype.unregister = function(action) {\n  if (!this.isRegistered(action)) {\n    throw error(action, NOT_REGISTERED_ERROR);\n  }\n\n  this._actions[action] = undefined;\n};\n\n/**\n * Returns the number of actions that are currently registered\n *\n * @return {Number}\n */\nEditorActions.prototype.length = function() {\n  return Object.keys(this._actions).length;\n};\n\n/**\n * Checks wether the given action is registered\n *\n * @param {String} action\n *\n * @return {Boolean}\n */\nEditorActions.prototype.isRegistered = function(action) {\n  return !!this._actions[action];\n};\n\n\nfunction error(action, message) {\n  return new Error(action + ' ' + message);\n}\n","module.exports = {\n  __depends__: [\n    require(214),\n    require(136),\n    require(241)\n  ],\n  __init__: [ 'editorActions' ],\n  editorActions: [ 'type', require(144) ]\n};\n","'use strict';\n\nvar MARKER_OK = 'connect-ok',\n    MARKER_NOT_OK = 'connect-not-ok';\n\n\nfunction GlobalConnect(eventBus, dragging, connect, canvas, toolManager) {\n  var self = this;\n\n  this._dragging = dragging;\n\n  toolManager.registerTool('global-connect', {\n    tool: 'global-connect',\n    dragging: 'global-connect.drag'\n  });\n\n  eventBus.on('global-connect.hover', function(event) {\n    var context = event.context,\n        startTarget = event.hover;\n\n    var canStartConnect = context.canStartConnect = self.canStartConnect(startTarget);\n\n    // simply ignore hover\n    if (canStartConnect === null) {\n      return;\n    }\n\n    context.startTarget = startTarget;\n\n    canvas.addMarker(startTarget, canStartConnect ? MARKER_OK : MARKER_NOT_OK);\n  });\n\n\n  eventBus.on([ 'global-connect.out', 'global-connect.cleanup' ], function(event) {\n    var startTarget = event.context.startTarget,\n        canStartConnect = event.context.canStartConnect;\n\n    if (startTarget) {\n      canvas.removeMarker(startTarget, canStartConnect ? MARKER_OK : MARKER_NOT_OK);\n    }\n  });\n\n\n  eventBus.on([ 'global-connect.ended' ], function(event) {\n    var context = event.context,\n        startTarget = context.startTarget,\n        startPosition = {\n          x: event.x,\n          y: event.y\n        };\n\n    var canStartConnect = self.canStartConnect(startTarget);\n\n    if (!canStartConnect) {\n      return;\n    }\n\n    eventBus.once('element.out', function() {\n      eventBus.once([ 'connect.ended', 'connect.canceled' ], function() {\n        eventBus.fire('global-connect.drag.ended');\n      });\n\n      connect.start(null, startTarget, startPosition);\n    });\n\n    return false;\n  });\n}\n\nGlobalConnect.$inject = [ 'eventBus', 'dragging', 'connect', 'canvas', 'toolManager' ];\n\nmodule.exports = GlobalConnect;\n\n\n/**\n * Initiates tool activity.\n */\nGlobalConnect.prototype.start = function(event) {\n  this._dragging.init(event, 'global-connect', {\n    trapClick: false,\n    data: {\n      context: {}\n    }\n  });\n};\n\n\nGlobalConnect.prototype.toggle = function() {\n  if (this.isActive()) {\n    this._dragging.cancel();\n  } else {\n    this.start();\n  }\n};\n\nGlobalConnect.prototype.isActive = function() {\n  var context = this._dragging.context();\n\n  return context && /^global-connect/.test(context.prefix);\n};\n\n\nGlobalConnect.prototype.registerProvider = function(provider) {\n  this._provider = provider;\n};\n\n\n/**\n * Check if source shape can initiate connection.\n *\n * @param  {Shape} startTarget\n * @return {Boolean}\n */\nGlobalConnect.prototype.canStartConnect = function(startTarget) {\n  return this._provider.canStartConnect(startTarget);\n};\n","module.exports = {\n  __depends__: [\n    require(132),\n    require(208),\n    require(143),\n    require(223)\n  ],\n  globalConnect: [ 'type', require(146) ]\n};\n","'use strict';\n\nvar hasPrimaryModifier = require(254).hasPrimaryModifier;\n\n\nvar HIGH_PRIORITY = 1500;\nvar HAND_CURSOR = 'grab';\n\nfunction HandTool(eventBus, canvas, dragging, toolManager) {\n  this._dragging = dragging;\n\n\n  toolManager.registerTool('hand', {\n    tool: 'hand',\n    dragging: 'hand.move'\n  });\n\n  eventBus.on('element.mousedown', HIGH_PRIORITY, function(event) {\n    if (hasPrimaryModifier(event)) {\n      this.activateMove(event.originalEvent);\n\n      return false;\n    }\n  }, this);\n\n\n  eventBus.on('hand.end', function(event) {\n    var target = event.originalEvent.target;\n\n    // only reactive on diagram click\n    // on some occasions, event.hover is not set and we have to check if the target is an svg\n    if (!event.hover && !(target instanceof SVGElement)) {\n      return false;\n    }\n\n    eventBus.once('hand.ended', function() {\n      this.activateMove(event.originalEvent, { reactivate: true });\n    }, this);\n\n  }, this);\n\n\n  eventBus.on('hand.move.move', function(event) {\n    var scale = canvas.viewbox().scale;\n\n    canvas.scroll({\n      dx: event.dx * scale,\n      dy: event.dy * scale\n    });\n  });\n\n  eventBus.on('hand.move.end', function(event) {\n    var context = event.context,\n        reactivate = context.reactivate;\n\n    // Don't reactivate if the user is using the keyboard keybinding\n    if (!hasPrimaryModifier(event) && reactivate) {\n\n      eventBus.once('hand.move.ended', function(event) {\n        this.activateHand(event.originalEvent, true, true);\n      }, this);\n\n    }\n\n    return false;\n  }, this);\n\n}\n\nHandTool.$inject = [\n  'eventBus',\n  'canvas',\n  'dragging',\n  'toolManager'\n];\n\nmodule.exports = HandTool;\n\n\nHandTool.prototype.activateMove = function(event, autoActivate, context) {\n  if (typeof autoActivate === 'object') {\n    context = autoActivate;\n    autoActivate = false;\n  }\n\n  this._dragging.init(event, 'hand.move', {\n    autoActivate: autoActivate,\n    cursor: HAND_CURSOR,\n    data: {\n      context: context || {}\n    }\n  });\n};\n\nHandTool.prototype.activateHand = function(event, autoActivate, reactivate) {\n  this._dragging.init(event, 'hand', {\n    trapClick: false,\n    autoActivate: autoActivate,\n    cursor: HAND_CURSOR,\n    data: {\n      context: {\n        reactivate: reactivate\n      }\n    }\n  });\n};\n\nHandTool.prototype.toggle = function() {\n  if (this.isActive()) {\n    this._dragging.cancel();\n  } else {\n    this.activateHand();\n  }\n};\n\nHandTool.prototype.isActive = function() {\n  var context = this._dragging.context();\n\n  return context && /^hand/.test(context.prefix);\n};\n","'use strict';\n\nmodule.exports = {\n  __depends__: [ require(223) ],\n  __init__: [ 'handTool' ],\n  handTool: [ 'type', require(148) ]\n};\n","'use strict';\n\nvar forEach = require(283),\n    domDelegate = require(427);\n\n\nvar isPrimaryButton = require(254).isPrimaryButton;\n\nvar Snap = require(267);\n\nvar renderUtil = require(258);\n\nvar createLine = renderUtil.createLine,\n    updateLine = renderUtil.updateLine;\n\nvar LOW_PRIORITY = 500;\n\n/**\n * A plugin that provides interaction events for diagram elements.\n *\n * It emits the following events:\n *\n *   * element.hover\n *   * element.out\n *   * element.click\n *   * element.dblclick\n *   * element.mousedown\n *\n * Each event is a tuple { element, gfx, originalEvent }.\n *\n * Canceling the event via Event#preventDefault() prevents the original DOM operation.\n *\n * @param {EventBus} eventBus\n */\nfunction InteractionEvents(eventBus, elementRegistry, styles) {\n\n  var HIT_STYLE = styles.cls('djs-hit', [ 'no-fill', 'no-border' ], {\n    stroke: 'white',\n    strokeWidth: 15\n  });\n\n  /**\n   * Fire an interaction event.\n   *\n   * @param {String} type local event name, e.g. element.click.\n   * @param {DOMEvent} event native event\n   * @param {djs.model.Base} [element] the diagram element to emit the event on;\n   *                                   defaults to the event target\n   */\n  function fire(type, event, element) {\n\n    // only react on left mouse button interactions\n    // for interaction events\n    if (!isPrimaryButton(event)) {\n      return;\n    }\n\n    var target, gfx, returnValue;\n\n    if (!element) {\n      target = event.delegateTarget || event.target;\n\n      if (target) {\n        gfx = new Snap(target);\n        element = elementRegistry.get(gfx);\n      }\n    } else {\n      gfx = elementRegistry.getGraphics(element);\n    }\n\n    if (!gfx || !element) {\n      return;\n    }\n\n    returnValue = eventBus.fire(type, { element: element, gfx: gfx, originalEvent: event });\n\n    if (returnValue === false) {\n      event.stopPropagation();\n      event.preventDefault();\n    }\n  }\n\n  // TODO(nikku): document this\n  var handlers = {};\n\n  function mouseHandler(type) {\n\n    var fn = handlers[type];\n\n    if (!fn) {\n      fn = handlers[type] = function(event) {\n        fire(type, event);\n      };\n    }\n\n    return fn;\n  }\n\n  var bindings = {\n    mouseover: 'element.hover',\n    mouseout: 'element.out',\n    click: 'element.click',\n    dblclick: 'element.dblclick',\n    mousedown: 'element.mousedown',\n    mouseup: 'element.mouseup'\n  };\n\n\n  ///// manual event trigger\n\n  /**\n   * Trigger an interaction event (based on a native dom event)\n   * on the target shape or connection.\n   *\n   * @param {String} eventName the name of the triggered DOM event\n   * @param {MouseEvent} event\n   * @param {djs.model.Base} targetElement\n   */\n  function triggerMouseEvent(eventName, event, targetElement) {\n\n    // i.e. element.mousedown...\n    var localEventName = bindings[eventName];\n\n    if (!localEventName) {\n      throw new Error('unmapped DOM event name <' + eventName + '>');\n    }\n\n    return fire(localEventName, event, targetElement);\n  }\n\n\n  var elementSelector = 'svg, .djs-element';\n\n  ///// event registration\n\n  function registerEvent(node, event, localEvent) {\n    var handler = mouseHandler(localEvent);\n    handler.$delegate = domDelegate.bind(node, elementSelector, event, handler);\n  }\n\n  function unregisterEvent(node, event, localEvent) {\n    domDelegate.unbind(node, event, mouseHandler(localEvent).$delegate);\n  }\n\n  function registerEvents(svg) {\n    forEach(bindings, function(val, key) {\n      registerEvent(svg.node, key, val);\n    });\n  }\n\n  function unregisterEvents(svg) {\n    forEach(bindings, function(val, key) {\n      unregisterEvent(svg.node, key, val);\n    });\n  }\n\n  eventBus.on('canvas.destroy', function(event) {\n    unregisterEvents(event.svg);\n  });\n\n  eventBus.on('canvas.init', function(event) {\n    registerEvents(event.svg);\n  });\n\n\n  eventBus.on([ 'shape.added', 'connection.added' ], function(event) {\n    var element = event.element,\n        gfx = event.gfx,\n        hit;\n\n    if (element.waypoints) {\n      hit = createLine(element.waypoints);\n    } else {\n      hit = Snap.create('rect', { x: 0, y: 0, width: element.width, height: element.height });\n    }\n\n    hit.attr(HIT_STYLE).appendTo(gfx.node);\n  });\n\n  // Update djs-hit on change.\n  // A low priortity is necessary, because djs-hit of labels has to be updated\n  // after the label bounds have been updated in the renderer.\n  eventBus.on('shape.changed', LOW_PRIORITY, function(event) {\n\n    var element = event.element,\n        gfx = event.gfx,\n        hit = gfx.select('.djs-hit');\n\n    hit.attr({\n      width: element.width,\n      height: element.height\n    });\n  });\n\n  eventBus.on('connection.changed', function(event) {\n\n    var element = event.element,\n        gfx = event.gfx,\n        hit = gfx.select('.djs-hit');\n\n    updateLine(hit, element.waypoints);\n  });\n\n\n  // API\n\n  this.fire = fire;\n\n  this.triggerMouseEvent = triggerMouseEvent;\n\n  this.mouseHandler = mouseHandler;\n\n  this.registerEvent = registerEvent;\n  this.unregisterEvent = unregisterEvent;\n}\n\n\nInteractionEvents.$inject = [ 'eventBus', 'elementRegistry', 'styles' ];\n\nmodule.exports = InteractionEvents;\n\n\n/**\n * An event indicating that the mouse hovered over an element\n *\n * @event element.hover\n *\n * @type {Object}\n * @property {djs.model.Base} element\n * @property {Snap<Element>} gfx\n * @property {Event} originalEvent\n */\n\n/**\n * An event indicating that the mouse has left an element\n *\n * @event element.out\n *\n * @type {Object}\n * @property {djs.model.Base} element\n * @property {Snap<Element>} gfx\n * @property {Event} originalEvent\n */\n\n/**\n * An event indicating that the mouse has clicked an element\n *\n * @event element.click\n *\n * @type {Object}\n * @property {djs.model.Base} element\n * @property {Snap<Element>} gfx\n * @property {Event} originalEvent\n */\n\n/**\n * An event indicating that the mouse has double clicked an element\n *\n * @event element.dblclick\n *\n * @type {Object}\n * @property {djs.model.Base} element\n * @property {Snap<Element>} gfx\n * @property {Event} originalEvent\n */\n\n/**\n * An event indicating that the mouse has gone down on an element.\n *\n * @event element.mousedown\n *\n * @type {Object}\n * @property {djs.model.Base} element\n * @property {Snap<Element>} gfx\n * @property {Event} originalEvent\n */\n\n/**\n * An event indicating that the mouse has gone up on an element.\n *\n * @event element.mouseup\n *\n * @type {Object}\n * @property {djs.model.Base} element\n * @property {Snap<Element>} gfx\n * @property {Event} originalEvent\n */\n","module.exports = {\n  __init__: [ 'interactionEvents' ],\n  interactionEvents: [ 'type', require(150) ]\n};","'use strict';\n\nvar domEvent = require(429),\n    domMatches = require(430);\n\n/**\n * A keyboard abstraction that may be activated and\n * deactivated by users at will, consuming key events\n * and triggering diagram actions.\n *\n * The implementation fires the following key events that allow\n * other components to hook into key handling:\n *\n *  - keyboard.bind\n *  - keyboard.unbind\n *  - keyboard.init\n *  - keyboard.destroy\n *\n * All events contain the fields (node, listeners).\n *\n * A default binding for the keyboard may be specified via the\n * `keyboard.bindTo` configuration option.\n *\n * @param {Config} config\n * @param {EventBus} eventBus\n * @param {EditorActions} editorActions\n */\nfunction Keyboard(config, eventBus, editorActions) {\n  var self = this;\n\n  this._config = config || {};\n  this._eventBus = eventBus;\n  this._editorActions = editorActions;\n\n  this._listeners = [];\n\n  // our key handler is a singleton that passes\n  // (keycode, modifiers) to each listener.\n  //\n  // listeners must indicate that they handled a key event\n  // by returning true. This stops the event propagation.\n  //\n  this._keyHandler = function(event) {\n\n    var i, l,\n        target = event.target,\n        listeners = self._listeners,\n        code = event.keyCode || event.charCode || -1;\n\n    if (target && (domMatches(target, 'input, textarea') || target.contentEditable === 'true')) {\n      return;\n    }\n\n    for (i = 0; (l = listeners[i]); i++) {\n      if (l(code, event)) {\n        event.preventDefault();\n        event.stopPropagation();\n      }\n    }\n  };\n\n  // properly clean dom registrations\n  eventBus.on('diagram.destroy', function() {\n    self._fire('destroy');\n\n    self.unbind();\n    self._listeners = null;\n  });\n\n  eventBus.on('diagram.init', function() {\n    self._fire('init');\n\n    if (config && config.bindTo) {\n      self.bind(config.bindTo);\n    }\n  });\n\n  this._init();\n}\n\nKeyboard.$inject = [\n  'config.keyboard',\n  'eventBus',\n  'editorActions'\n];\n\nmodule.exports = Keyboard;\n\n\nKeyboard.prototype.bind = function(node) {\n  // make sure that the keyboard is only bound once to the DOM\n  this.unbind();\n\n  this._node = node;\n\n  // bind key events\n  domEvent.bind(node, 'keydown', this._keyHandler, true);\n\n  this._fire('bind');\n};\n\nKeyboard.prototype.getBinding = function() {\n  return this._node;\n};\n\nKeyboard.prototype.unbind = function() {\n  var node = this._node;\n\n  if (node) {\n    this._fire('unbind');\n\n    // unbind key events\n    domEvent.unbind(node, 'keydown', this._keyHandler, true);\n  }\n\n  this._node = null;\n};\n\nKeyboard.prototype._fire = function(event) {\n  this._eventBus.fire('keyboard.' + event, { node: this._node, listeners: this._listeners });\n};\n\nKeyboard.prototype._init = function() {\n\n  var listeners = this._listeners;\n\n  var editorActions = this._editorActions,\n      config = this._config;\n\n  // init default listeners\n\n  // undo\n  // (CTRL|CMD) + Z\n  function undo(key, modifiers) {\n\n    if (isCmd(modifiers) && !isShift(modifiers) && key === 90) {\n      editorActions.trigger('undo');\n\n      return true;\n    }\n  }\n\n  // redo\n  // CTRL + Y\n  // CMD + SHIFT + Z\n  function redo(key, modifiers) {\n\n    if (isCmd(modifiers) && (key === 89 || (key === 90 && isShift(modifiers)))) {\n      editorActions.trigger('redo');\n\n      return true;\n    }\n  }\n\n  // copy\n  // CTRL/CMD + C\n  function copy(key, modifiers) {\n\n    if (isCmd(modifiers) && (key === 67)) {\n      editorActions.trigger('copy');\n\n      return true;\n    }\n  }\n\n  // paste\n  // CTRL/CMD + V\n  function paste(key, modifiers) {\n\n    if (isCmd(modifiers) && (key === 86)) {\n      editorActions.trigger('paste');\n\n      return true;\n    }\n  }\n\n  /**\n   * zoom in one step\n   * CTRL + +\n   *\n   * 107 = numpad plus\n   * 187 = regular plus\n   * 171 = regular plus in Firefox (german keyboard layout)\n   *  61 = regular plus in Firefox (US keyboard layout)\n   */\n  function zoomIn(key, modifiers) {\n\n    if ((key === 107 || key === 187 || key === 171 || key === 61) && isCmd(modifiers)) {\n      editorActions.trigger('stepZoom', { value: 1 });\n\n      return true;\n    }\n  }\n\n  /**\n   * zoom out one step\n   * CTRL + -\n   *\n   * 109 = numpad minus\n   * 189 = regular minus\n   * 173 = regular minus in Firefox (US and german keyboard layout)\n   */\n  function zoomOut(key, modifiers) {\n\n    if ((key === 109 || key === 189 || key === 173)  && isCmd(modifiers)) {\n      editorActions.trigger('stepZoom', { value: -1 });\n\n      return true;\n    }\n  }\n\n  /**\n   * zoom to the default level\n   * CTRL + 0\n   *\n   * 96 = numpad zero\n   * 48 = regular zero\n   */\n  function zoomDefault(key, modifiers) {\n\n    if ((key === 96 || key === 48) && isCmd(modifiers)) {\n      editorActions.trigger('zoom', { value: 1 });\n\n      return true;\n    }\n  }\n\n  // delete selected element\n  // DEL\n  function removeSelection(key, modifiers) {\n\n    if (key === 46) {\n      editorActions.trigger('removeSelection');\n\n      return true;\n    }\n  }\n\n  // move canvas left\n  // left arrow\n  //\n  // 37 = Left\n  // 38 = Up\n  // 39 = Right\n  // 40 = Down\n  function moveCanvas(key, modifiers) {\n\n    if ([37, 38, 39, 40].indexOf(key) >= 0) {\n\n      var opts = {\n        invertY: config.invertY,\n        speed: (config.speed || 50)\n      };\n\n      switch (key) {\n      case 37:    // Left\n        opts.direction = 'left';\n        break;\n      case 38:    // Up\n        opts.direction = 'up';\n        break;\n      case 39:    // Right\n        opts.direction = 'right';\n        break;\n      case 40:    // Down\n        opts.direction = 'down';\n        break;\n      }\n\n      editorActions.trigger('moveCanvas', opts);\n\n      return true;\n    }\n  }\n\n  listeners.push(undo);\n  listeners.push(redo);\n  listeners.push(copy);\n  listeners.push(paste);\n  listeners.push(removeSelection);\n  listeners.push(zoomIn);\n  listeners.push(zoomOut);\n  listeners.push(zoomDefault);\n  listeners.push(moveCanvas);\n};\n\n\n/**\n * Add a listener function that is notified with (key, modifiers) whenever\n * the keyboard is bound and the user presses a key.\n *\n * @param {Function} listenerFn\n */\nKeyboard.prototype.addListener = function(listenerFn) {\n  this._listeners.push(listenerFn);\n};\n\nKeyboard.prototype.hasModifier = hasModifier;\nKeyboard.prototype.isCmd = isCmd;\nKeyboard.prototype.isShift = isShift;\n\n\nfunction hasModifier(modifiers) {\n  return (modifiers.ctrlKey || modifiers.metaKey || modifiers.shiftKey || modifiers.altKey);\n}\n\nfunction isCmd(modifiers) {\n  return modifiers.ctrlKey || modifiers.metaKey;\n}\n\nfunction isShift(modifiers) {\n  return modifiers.shiftKey;\n}\n","module.exports = {\n  __init__: [ 'keyboard' ],\n  keyboard: [ 'type', require(152) ]\n};\n","'use strict';\n\nvar forEach = require(283),\n    filter = require(281),\n    inherits = require(270);\n\nvar LOW_PRIORITY = 250,\n    HIGH_PRIORITY = 1400;\n\nvar CommandInterceptor = require(100);\n\n\n/**\n * A handler that makes sure labels are properly moved with\n * their label targets.\n */\nfunction LabelSupport(eventBus, modeling, movePreview) {\n\n  CommandInterceptor.call(this, eventBus);\n\n  // remove labels from the collection that are being\n  // moved with other elements anyway\n  eventBus.on('shape.move.start', HIGH_PRIORITY, function(e) {\n\n    var context = e.context,\n        shapes = context.shapes,\n        validatedShapes = context.validatedShapes;\n\n    context.shapes = removeLabels(shapes);\n    context.validatedShapes = removeLabels(validatedShapes);\n  });\n\n\n  // add labels to visual's group\n  eventBus.on('shape.move.start', LOW_PRIORITY, function(e) {\n\n    var context = e.context,\n        shapes = context.shapes;\n\n    var labels = [];\n\n    forEach(shapes, function(element) {\n      var label = element.label;\n\n      if (label && !label.hidden && context.shapes.indexOf(label) === -1) {\n        labels.push(label);\n      }\n\n      if (element.labelTarget) {\n        labels.push(element);\n      }\n    });\n\n    forEach(labels, function(label) {\n      movePreview.makeDraggable(context, label, true);\n    });\n\n  });\n\n  // move labels after the other shapes are done moving\n  this.postExecuted([ 'elements.move' ], function(e) {\n    var context = e.context,\n        closure = context.closure,\n        enclosedElements = closure.enclosedElements;\n\n    // ensure we move all labels with their respective elements\n    // if they have not been moved already\n\n    forEach(enclosedElements, function(e) {\n      if (e.label && !enclosedElements[e.label.id]) {\n        modeling.moveShape(e.label, context.delta, e.parent);\n      }\n    });\n\n  });\n\n}\n\ninherits(LabelSupport, CommandInterceptor);\n\nLabelSupport.$inject = [ 'eventBus', 'modeling', 'movePreview' ];\n\nmodule.exports = LabelSupport;\n\n\n/**\n * Return a filtered list of elements that do not\n * contain attached elements with hosts being part\n * of the selection.\n *\n * @param  {Array<djs.model.Base>} elements\n *\n * @return {Array<djs.model.Base>} filtered\n */\nfunction removeLabels(elements) {\n\n  return filter(elements, function(element) {\n\n    // filter out labels that are move together\n    // with their label targets\n    return elements.indexOf(element.labelTarget) === -1;\n  });\n}\n","module.exports = {\n  __depends__: [\n    require(187)\n  ],\n  __init__: [ 'labelSupport'],\n  labelSupport: [ 'type', require(154) ]\n};\n","'use strict';\n\nvar values = require(419);\n\nvar getEnclosedElements = require(247).getEnclosedElements;\n\nvar hasSecondaryModifier = require(254).hasSecondaryModifier;\n\nvar Snap = require(267);\n\nvar LASSO_TOOL_CURSOR = 'crosshair';\n\n\nfunction LassoTool(eventBus, canvas, dragging, elementRegistry, selection, toolManager) {\n\n  this._selection = selection;\n  this._dragging = dragging;\n\n  var self = this;\n\n  // lasso visuals implementation\n\n  /**\n  * A helper that realizes the selection box visual\n  */\n  var visuals = {\n\n    create: function(context) {\n      var container = canvas.getDefaultLayer(),\n          frame;\n\n      frame = context.frame = Snap.create('rect', {\n        class: 'djs-lasso-overlay',\n        width:  1,\n        height: 1,\n        x: 0,\n        y: 0\n      });\n\n      frame.appendTo(container);\n    },\n\n    update: function(context) {\n      var frame = context.frame,\n          bbox  = context.bbox;\n\n      frame.attr({\n        x: bbox.x,\n        y: bbox.y,\n        width: bbox.width,\n        height: bbox.height\n      });\n    },\n\n    remove: function(context) {\n\n      if (context.frame) {\n        context.frame.remove();\n      }\n    }\n  };\n\n  toolManager.registerTool('lasso', {\n    tool: 'lasso.selection',\n    dragging: 'lasso'\n  });\n\n  eventBus.on('lasso.selection.end', function(event) {\n    var target = event.originalEvent.target;\n\n    // only reactive on diagram click\n    // on some occasions, event.hover is not set and we have to check if the target is an svg\n    if (!event.hover && !(target instanceof SVGElement)) {\n      return;\n    }\n\n    eventBus.once('lasso.selection.ended', function() {\n      self.activateLasso(event.originalEvent, true);\n    });\n  });\n\n  // lasso interaction implementation\n\n  eventBus.on('lasso.end', function(event) {\n\n    var bbox = toBBox(event);\n\n    var elements = elementRegistry.filter(function(element) {\n      return element;\n    });\n\n    self.select(elements, bbox);\n  });\n\n  eventBus.on('lasso.start', function(event) {\n\n    var context = event.context;\n\n    context.bbox = toBBox(event);\n    visuals.create(context);\n  });\n\n  eventBus.on('lasso.move', function(event) {\n\n    var context = event.context;\n\n    context.bbox = toBBox(event);\n    visuals.update(context);\n  });\n\n  eventBus.on('lasso.end', function(event) {\n\n    var context = event.context;\n\n    visuals.remove(context);\n  });\n\n  eventBus.on('lasso.cleanup', function(event) {\n\n    var context = event.context;\n\n    visuals.remove(context);\n  });\n\n\n  // event integration\n\n  eventBus.on('element.mousedown', 1500, function(event) {\n\n    if (hasSecondaryModifier(event)) {\n      self.activateLasso(event.originalEvent);\n\n      event.stopPropagation();\n    }\n  });\n}\n\nLassoTool.$inject = [\n  'eventBus',\n  'canvas',\n  'dragging',\n  'elementRegistry',\n  'selection',\n  'toolManager'\n];\n\nmodule.exports = LassoTool;\n\n\nLassoTool.prototype.activateLasso = function(event, autoActivate) {\n\n  this._dragging.init(event, 'lasso', {\n    autoActivate: autoActivate,\n    cursor: LASSO_TOOL_CURSOR,\n    data: {\n      context: {}\n    }\n  });\n};\n\nLassoTool.prototype.activateSelection = function(event) {\n\n  this._dragging.init(event, 'lasso.selection', {\n    trapClick: false,\n    cursor: LASSO_TOOL_CURSOR,\n    data: {\n      context: {}\n    }\n  });\n};\n\nLassoTool.prototype.select = function(elements, bbox) {\n  var selectedElements = getEnclosedElements(elements, bbox);\n\n  this._selection.select(values(selectedElements));\n};\n\nLassoTool.prototype.toggle = function() {\n  if (this.isActive()) {\n    this._dragging.cancel();\n  } else {\n    this.activateSelection();\n  }\n};\n\nLassoTool.prototype.isActive = function() {\n  var context = this._dragging.context();\n\n  return context && /^lasso/.test(context.prefix);\n};\n\n\n\nfunction toBBox(event) {\n\n  var start = {\n\n    x: event.x - event.dx,\n    y: event.y - event.dy\n  };\n\n  var end = {\n    x: event.x,\n    y: event.y\n  };\n\n  var bbox;\n\n  if ((start.x <= end.x && start.y < end.y) ||\n      (start.x < end.x && start.y <= end.y)) {\n\n    bbox = {\n      x: start.x,\n      y: start.y,\n      width:  end.x - start.x,\n      height: end.y - start.y\n    };\n  } else if ((start.x >= end.x && start.y < end.y) ||\n             (start.x > end.x && start.y <= end.y)) {\n\n    bbox = {\n      x: end.x,\n      y: start.y,\n      width:  start.x - end.x,\n      height: end.y - start.y\n    };\n  } else if ((start.x <= end.x && start.y > end.y) ||\n             (start.x < end.x && start.y >= end.y)) {\n\n    bbox = {\n      x: start.x,\n      y: end.y,\n      width:  end.x - start.x,\n      height: start.y - end.y\n    };\n  } else if ((start.x >= end.x && start.y > end.y) ||\n             (start.x > end.x && start.y >= end.y)) {\n\n    bbox = {\n      x: end.x,\n      y: end.y,\n      width:  start.x - end.x,\n      height: start.y - end.y\n    };\n  } else {\n\n    bbox = {\n      x: end.x,\n      y: end.y,\n      width:  0,\n      height: 0\n    };\n  }\n  return bbox;\n}\n","'use strict';\n\nmodule.exports = {\n  __depends__: [ require(223) ],\n  __init__: [ 'lassoTool' ],\n  lassoTool: [ 'type', require(156) ]\n};\n","'use strict';\n\nvar forEach = require(283);\n\nvar model = require(235);\n\n\n/**\n * The basic modeling entry point.\n *\n * @param {EventBus} eventBus\n * @param {ElementFactory} elementFactory\n * @param {CommandStack} commandStack\n */\nfunction Modeling(eventBus, elementFactory, commandStack) {\n  this._eventBus = eventBus;\n  this._elementFactory = elementFactory;\n  this._commandStack = commandStack;\n\n  var self = this;\n\n  eventBus.on('diagram.init', function() {\n    // register modeling handlers\n    self.registerHandlers(commandStack);\n  });\n}\n\nModeling.$inject = [ 'eventBus', 'elementFactory', 'commandStack' ];\n\nmodule.exports = Modeling;\n\n\nModeling.prototype.getHandlers = function() {\n  return {\n    'shape.append': require(160),\n    'shape.create': require(163),\n    'shape.delete': require(166),\n    'shape.move': require(171),\n    'shape.resize': require(176),\n    'shape.replace': require(175),\n    'shape.toggleCollapse': require(178),\n\n    'spaceTool': require(177),\n\n    'label.create': require(162),\n\n    'connection.create': require(161),\n    'connection.delete': require(164),\n    'connection.move': require(169),\n    'connection.layout': require(168),\n\n    'connection.updateWaypoints': require(180),\n\n    'connection.reconnectStart': require(174),\n    'connection.reconnectEnd': require(174),\n\n    'elements.move': require(170),\n    'elements.delete': require(165),\n\n    'elements.distribute': require(167),\n    'elements.align': require(159),\n\n    'element.updateAttachment': require(179),\n\n    'elements.paste': require(173)\n  };\n};\n\n/**\n * Register handlers with the command stack\n *\n * @param {CommandStack} commandStack\n */\nModeling.prototype.registerHandlers = function(commandStack) {\n  forEach(this.getHandlers(), function(handler, id) {\n    commandStack.registerHandler(id, handler);\n  });\n};\n\n\n///// modeling helpers /////////////////////////////////////////\n\nModeling.prototype.moveShape = function(shape, delta, newParent, newParentIndex, hints) {\n\n  if (typeof newParentIndex === 'object') {\n    hints = newParentIndex;\n    newParentIndex = null;\n  }\n\n  var context = {\n    shape: shape,\n    delta:  delta,\n    newParent: newParent,\n    newParentIndex: newParentIndex,\n    hints: hints || {}\n  };\n\n  this._commandStack.execute('shape.move', context);\n};\n\n\n/**\n * Update the attachment of the given shape.\n *\n * @param  {djs.mode.Base} shape\n * @param  {djs.model.Base} [newHost]\n */\nModeling.prototype.updateAttachment = function(shape, newHost) {\n  var context = {\n    shape: shape,\n    newHost: newHost\n  };\n\n  this._commandStack.execute('element.updateAttachment', context);\n};\n\n/**\n * Move a number of shapes to a new target, either setting it as\n * the new parent or attaching it.\n *\n * @param {Array<djs.mode.Base>} shapes\n * @param {Point} delta\n * @param {djs.model.Base} [target]\n * @param {Boolean} [isAttach=false]\n * @param {Object} [hints]\n */\nModeling.prototype.moveElements = function(shapes, delta, target, isAttach, hints) {\n  if (typeof isAttach === 'object') {\n    hints = isAttach;\n    isAttach = undefined;\n  }\n\n  var newParent = target,\n      newHost;\n\n  if (isAttach === true) {\n    newHost = target;\n    newParent = target.parent;\n  }\n\n  if (isAttach === false) {\n    newHost = null;\n  }\n\n  var context = {\n    shapes: shapes,\n    delta: delta,\n    newParent: newParent,\n    newHost: newHost,\n    hints: hints || {}\n  };\n\n  this._commandStack.execute('elements.move', context);\n};\n\nModeling.prototype.moveConnection = function(connection, delta, newParent, newParentIndex, hints) {\n\n  if (typeof newParentIndex === 'object') {\n    hints = newParentIndex;\n    newParentIndex = undefined;\n  }\n\n  var context = {\n    connection: connection,\n    delta: delta,\n    newParent: newParent,\n    newParentIndex: newParentIndex,\n    hints: hints || {}\n  };\n\n  this._commandStack.execute('connection.move', context);\n};\n\n\nModeling.prototype.layoutConnection = function(connection, hints) {\n  var context = {\n    connection: connection,\n    hints: hints || {}\n  };\n\n  this._commandStack.execute('connection.layout', context);\n};\n\n/**\n * Create connection.\n *\n * @param {djs.model.Base} source\n * @param {djs.model.Base} target\n * @param {Number} [targetIndex]\n * @param {Object|djs.model.Connection} connection\n * @param {djs.model.Base} parent\n * @param {Object} hints\n *\n * @return {djs.model.Connection} the created connection.\n */\nModeling.prototype.createConnection = function(source, target, targetIndex, connection, parent, hints) {\n\n  if (typeof targetIndex === 'object') {\n    hints = parent;\n    parent = connection;\n    connection = targetIndex;\n    targetIndex = undefined;\n  }\n\n  connection = this._create('connection', connection);\n\n  var context = {\n    source: source,\n    target: target,\n    parent: parent,\n    parentIndex: targetIndex,\n    connection: connection,\n    hints: hints\n  };\n\n  this._commandStack.execute('connection.create', context);\n\n  return context.connection;\n};\n\nModeling.prototype.createShape = function(shape, position, target, targetIndex, isAttach, hints) {\n\n  if (typeof targetIndex !== 'number') {\n    hints = isAttach;\n    isAttach = targetIndex;\n  }\n\n  if (typeof isAttach !== 'boolean') {\n    hints = isAttach;\n    isAttach = false;\n  }\n\n  shape = this._create('shape', shape);\n\n  var context = {\n    position: position,\n    shape: shape,\n    parent: target,\n    parentIndex: targetIndex,\n    host: shape.host,\n    hints: hints || {}\n  };\n\n  if (isAttach) {\n    context.parent = target.parent;\n    context.host = target;\n  }\n\n  this._commandStack.execute('shape.create', context);\n\n  return context.shape;\n};\n\n\nModeling.prototype.createLabel = function(labelTarget, position, label, parent) {\n\n  label = this._create('label', label);\n\n  var context = {\n    labelTarget: labelTarget,\n    position: position,\n    parent: parent || labelTarget.parent,\n    shape: label\n  };\n\n  this._commandStack.execute('label.create', context);\n\n  return context.shape;\n};\n\n\nModeling.prototype.appendShape = function(source, shape, position, parent, connection, connectionParent) {\n\n  shape = this._create('shape', shape);\n\n  var context = {\n    source: source,\n    position: position,\n    parent: parent,\n    shape: shape,\n    connection: connection,\n    connectionParent: connectionParent\n  };\n\n  this._commandStack.execute('shape.append', context);\n\n  return context.shape;\n};\n\n\nModeling.prototype.removeElements = function(elements) {\n  var context = {\n    elements: elements\n  };\n\n  this._commandStack.execute('elements.delete', context);\n};\n\n\nModeling.prototype.distributeElements = function(groups, axis, dimension) {\n  var context = {\n    groups: groups,\n    axis: axis,\n    dimension: dimension\n  };\n\n  this._commandStack.execute('elements.distribute', context);\n};\n\n\nModeling.prototype.removeShape = function(shape, hints) {\n  var context = {\n    shape: shape,\n    hints: hints || {}\n  };\n\n  this._commandStack.execute('shape.delete', context);\n};\n\n\nModeling.prototype.removeConnection = function(connection, hints) {\n  var context = {\n    connection: connection,\n    hints: hints || {}\n  };\n\n  this._commandStack.execute('connection.delete', context);\n};\n\nModeling.prototype.replaceShape = function(oldShape, newShape, hints) {\n  var context = {\n    oldShape: oldShape,\n    newData: newShape,\n    hints: hints || {}\n  };\n\n  this._commandStack.execute('shape.replace', context);\n\n  return context.newShape;\n};\n\nModeling.prototype.pasteElements = function(tree, topParent, position) {\n  var context = {\n    tree: tree,\n    topParent: topParent,\n    position: position\n  };\n\n  this._commandStack.execute('elements.paste', context);\n};\n\nModeling.prototype.alignElements = function(elements, alignment) {\n  var context = {\n    elements: elements,\n    alignment: alignment\n  };\n\n  this._commandStack.execute('elements.align', context);\n};\n\nModeling.prototype.resizeShape = function(shape, newBounds) {\n  var context = {\n    shape: shape,\n    newBounds: newBounds\n  };\n\n  this._commandStack.execute('shape.resize', context);\n};\n\nModeling.prototype.createSpace = function(movingShapes, resizingShapes, delta, direction) {\n  var context = {\n    movingShapes: movingShapes,\n    resizingShapes: resizingShapes,\n    delta: delta,\n    direction: direction\n  };\n\n  this._commandStack.execute('spaceTool', context);\n};\n\nModeling.prototype.updateWaypoints = function(connection, newWaypoints, hints) {\n  var context = {\n    connection: connection,\n    newWaypoints: newWaypoints,\n    hints: hints || {}\n  };\n\n  this._commandStack.execute('connection.updateWaypoints', context);\n};\n\nModeling.prototype.reconnectStart = function(connection, newSource, dockingOrPoints) {\n  var context = {\n    connection: connection,\n    newSource: newSource,\n    dockingOrPoints: dockingOrPoints\n  };\n\n  this._commandStack.execute('connection.reconnectStart', context);\n};\n\nModeling.prototype.reconnectEnd = function(connection, newTarget, dockingOrPoints) {\n  var context = {\n    connection: connection,\n    newTarget: newTarget,\n    dockingOrPoints: dockingOrPoints\n  };\n\n  this._commandStack.execute('connection.reconnectEnd', context);\n};\n\nModeling.prototype.connect = function(source, target, attrs, hints) {\n  return this.createConnection(source, target, attrs || {}, source.parent, hints);\n};\n\nModeling.prototype._create = function(type, attrs) {\n  if (attrs instanceof model.Base) {\n    return attrs;\n  } else {\n    return this._elementFactory.create(type, attrs);\n  }\n};\n\nModeling.prototype.toggleCollapse = function(shape, hints) {\n  var context = {\n    shape: shape,\n    hints: hints || {}\n  };\n\n  this._commandStack.execute('shape.toggleCollapse', context);\n};\n","'use strict';\n\nvar forEach = require(283);\n\n/**\n * A handler that align elements in a certain way.\n *\n */\nfunction AlignElements(modeling, canvas) {\n  this._modeling = modeling;\n  this._canvas = canvas;\n}\n\nAlignElements.$inject = [ 'modeling', 'canvas' ];\n\nmodule.exports = AlignElements;\n\n\nAlignElements.prototype.preExecute = function(context) {\n  var modeling = this._modeling;\n\n  var elements = context.elements,\n      alignment = context.alignment;\n\n\n  forEach(elements, function(element) {\n    var delta = {\n      x: 0,\n      y: 0\n    };\n\n    if (alignment.left) {\n      delta.x = alignment.left - element.x;\n\n    } else if (alignment.right) {\n      delta.x = (alignment.right - element.width) - element.x;\n\n    } else if (alignment.center) {\n      delta.x = (alignment.center - Math.round(element.width / 2)) - element.x;\n\n    } else if (alignment.top) {\n      delta.y = alignment.top - element.y;\n\n    } else if (alignment.bottom) {\n      delta.y = (alignment.bottom - element.height) - element.y;\n\n    } else if (alignment.middle) {\n      delta.y = (alignment.middle - Math.round(element.height / 2)) - element.y;\n    }\n\n    modeling.moveElements([ element ], delta, element.parent);\n  });\n};\n\nAlignElements.prototype.postExecute = function(context) {\n\n};\n","'use strict';\n\nvar any = require(279);\n\nvar inherits = require(270);\n\n\n/**\n * A handler that implements reversible appending of shapes\n * to a source shape.\n *\n * @param {canvas} Canvas\n * @param {elementFactory} ElementFactory\n * @param {modeling} Modeling\n */\nfunction AppendShapeHandler(modeling) {\n  this._modeling = modeling;\n}\n\ninherits(AppendShapeHandler, require(172));\n\n\nAppendShapeHandler.$inject = [ 'modeling' ];\n\nmodule.exports = AppendShapeHandler;\n\n\n////// api /////////////////////////////////////////////\n\n/**\n * Creates a new shape\n *\n * @param {Object} context\n * @param {ElementDescriptor} context.shape the new shape\n * @param {ElementDescriptor} context.source the source object\n * @param {ElementDescriptor} context.parent the parent object\n * @param {Point} context.position position of the new element\n */\nAppendShapeHandler.prototype.preExecute = function(context) {\n\n  if (!context.source) {\n    throw new Error('source required');\n  }\n\n  var parent = context.parent || context.source.parent,\n      shape = this._modeling.createShape(context.shape, context.position, parent);\n\n  context.shape = shape;\n};\n\nAppendShapeHandler.prototype.postExecute = function(context) {\n  var parent = context.connectionParent || context.shape.parent;\n\n  if (!existsConnection(context.source, context.shape)) {\n\n    // create connection\n    this._modeling.connect(context.source, context.shape, context.connection, parent);\n  }\n};\n\n\nfunction existsConnection(source, target) {\n  return any(source.outgoing, function(c) {\n    return c.target === target;\n  });\n}","'use strict';\n\n\nfunction CreateConnectionHandler(canvas, layouter) {\n  this._canvas = canvas;\n  this._layouter = layouter;\n}\n\nCreateConnectionHandler.$inject = [ 'canvas', 'layouter' ];\n\nmodule.exports = CreateConnectionHandler;\n\n\n\n////// api /////////////////////////////////////////\n\n/**\n * Appends a shape to a target shape\n *\n * @param {Object} context\n * @param {djs.element.Base} context.source the source object\n * @param {djs.element.Base} context.target the parent object\n * @param {Point} context.position position of the new element\n */\nCreateConnectionHandler.prototype.execute = function(context) {\n\n  var connection = context.connection,\n      source = context.source,\n      target = context.target,\n      parent = context.parent,\n      hints = context.hints;\n\n  if (!source || !target) {\n    throw new Error('source and target required');\n  }\n\n  if (!parent) {\n    throw new Error('parent required');\n  }\n\n  connection.source = source;\n  connection.target = target;\n\n  if (!connection.waypoints) {\n    connection.waypoints = this._layouter.layoutConnection(connection, hints);\n  }\n\n  // add connection\n  this._canvas.addConnection(connection, parent);\n\n  return connection;\n};\n\nCreateConnectionHandler.prototype.revert = function(context) {\n  var connection = context.connection;\n\n  this._canvas.removeConnection(connection);\n\n  connection.source = null;\n  connection.target = null;\n};","'use strict';\n\nvar inherits = require(270);\n\nvar CreateShapeHandler = require(163);\n\n\n/**\n * A handler that attaches a label to a given target shape.\n *\n * @param {canvas} Canvas\n */\nfunction CreateLabelHandler(canvas) {\n  CreateShapeHandler.call(this, canvas);\n}\n\ninherits(CreateLabelHandler, CreateShapeHandler);\n\nCreateLabelHandler.$inject = [ 'canvas' ];\n\nmodule.exports = CreateLabelHandler;\n\n\n\n////// api /////////////////////////////////////////\n\n\nvar originalExecute = CreateShapeHandler.prototype.execute;\n\n/**\n * Appends a label to a target shape.\n *\n * @method CreateLabelHandler#execute\n *\n * @param {Object} context\n * @param {ElementDescriptor} context.target the element the label is attached to\n * @param {ElementDescriptor} context.parent the parent object\n * @param {Point} context.position position of the new element\n */\nCreateLabelHandler.prototype.execute = function(context) {\n\n  var label = context.shape;\n\n  ensureValidDimensions(label);\n\n  label.labelTarget = context.labelTarget;\n\n  return originalExecute.call(this, context);\n};\n\nvar originalRevert = CreateShapeHandler.prototype.revert;\n\n/**\n * Undo append by removing the shape\n */\nCreateLabelHandler.prototype.revert = function(context) {\n  context.shape.labelTarget = null;\n\n  return originalRevert.call(this, context);\n};\n\n\n////// helpers /////////////////////////////////////////\n\nfunction ensureValidDimensions(label) {\n  // make sure a label has valid { width, height } dimensions\n  [ 'width', 'height' ].forEach(function(prop) {\n    if (typeof label[prop] === 'undefined') {\n      label[prop] = 0;\n    }\n  });\n}","'use strict';\n\nvar assign = require(410);\n\nvar round = Math.round;\n\n\n/**\n * A handler that implements reversible addition of shapes.\n *\n * @param {canvas} Canvas\n */\nfunction CreateShapeHandler(canvas) {\n  this._canvas = canvas;\n}\n\nCreateShapeHandler.$inject = [ 'canvas' ];\n\nmodule.exports = CreateShapeHandler;\n\n\n\n////// api /////////////////////////////////////////\n\n\n/**\n * Appends a shape to a target shape\n *\n * @param {Object} context\n * @param {djs.model.Base} context.parent the parent object\n * @param {Point} context.position position of the new element\n */\nCreateShapeHandler.prototype.execute = function(context) {\n\n  var shape = context.shape,\n      positionOrBounds = context.position,\n      parent = context.parent,\n      parentIndex = context.parentIndex;\n\n  if (!parent) {\n    throw new Error('parent required');\n  }\n\n  if (!positionOrBounds) {\n    throw new Error('position required');\n  }\n\n  // (1) add at event center position _or_ at given bounds\n  if (positionOrBounds.width !== undefined) {\n    assign(shape, positionOrBounds);\n  } else {\n    assign(shape, {\n      x: positionOrBounds.x - round(shape.width / 2),\n      y: positionOrBounds.y - round(shape.height / 2)\n    });\n  }\n\n  // (2) add to canvas\n  this._canvas.addShape(shape, parent, parentIndex);\n\n  return shape;\n};\n\n\n/**\n * Undo append by removing the shape\n */\nCreateShapeHandler.prototype.revert = function(context) {\n\n  // (3) remove form canvas\n  this._canvas.removeShape(context.shape);\n};","'use strict';\n\nvar Collections = require(244);\n\n\n/**\n * A handler that implements reversible deletion of Connections.\n *\n */\nfunction DeleteConnectionHandler(canvas, modeling) {\n  this._canvas = canvas;\n  this._modeling = modeling;\n}\n\nDeleteConnectionHandler.$inject = [ 'canvas', 'modeling' ];\n\nmodule.exports = DeleteConnectionHandler;\n\n\n/**\n * - Remove attached label\n */\nDeleteConnectionHandler.prototype.preExecute = function(context) {\n\n  var connection = context.connection;\n\n  // Remove label\n  if (connection.label) {\n    this._modeling.removeShape(connection.label);\n  }\n};\n\nDeleteConnectionHandler.prototype.execute = function(context) {\n\n  var connection = context.connection,\n      parent = connection.parent;\n\n  context.parent = parent;\n  context.parentIndex = Collections.indexOf(parent.children, connection);\n\n  context.source = connection.source;\n  context.target = connection.target;\n\n  this._canvas.removeConnection(connection);\n\n  connection.source = null;\n  connection.target = null;\n  connection.label  = null;\n\n  return connection;\n};\n\n/**\n * Command revert implementation.\n */\nDeleteConnectionHandler.prototype.revert = function(context) {\n\n  var connection = context.connection,\n      parent = context.parent,\n      parentIndex = context.parentIndex;\n\n  connection.source = context.source;\n  connection.target = context.target;\n\n  // restore previous location in old parent\n  Collections.add(parent.children, connection, parentIndex);\n\n  this._canvas.addConnection(connection, parent);\n\n  return connection;\n};\n","'use strict';\n\nvar forEach = require(283),\n    inherits = require(270);\n\n\nfunction DeleteElementsHandler(modeling, elementRegistry) {\n  this._modeling = modeling;\n  this._elementRegistry = elementRegistry;\n}\n\ninherits(DeleteElementsHandler, require(172));\n\nDeleteElementsHandler.$inject = [ 'modeling', 'elementRegistry' ];\n\nmodule.exports = DeleteElementsHandler;\n\n\nDeleteElementsHandler.prototype.postExecute = function(context) {\n\n  var modeling = this._modeling,\n      elementRegistry = this._elementRegistry,\n      elements = context.elements;\n\n  forEach(elements, function(element) {\n\n    // element may have been removed with previous\n    // remove operations already (e.g. in case of nesting)\n    if (!elementRegistry.get(element.id)) {\n      return;\n    }\n\n    if (element.waypoints) {\n      modeling.removeConnection(element);\n    } else {\n      modeling.removeShape(element);\n    }\n  });\n};","'use strict';\n\nvar Collections = require(244);\n\nvar saveClear = require(257).saveClear;\n\n\n/**\n * A handler that implements reversible deletion of shapes.\n *\n */\nfunction DeleteShapeHandler(canvas, modeling) {\n  this._canvas = canvas;\n  this._modeling = modeling;\n}\n\nDeleteShapeHandler.$inject = [ 'canvas', 'modeling' ];\n\nmodule.exports = DeleteShapeHandler;\n\n\n/**\n * - Remove connections\n * - Remove all direct children\n */\nDeleteShapeHandler.prototype.preExecute = function(context) {\n\n  var modeling = this._modeling;\n\n  var shape = context.shape,\n      label = shape.label;\n\n  // Clean up on removeShape(label)\n  if (shape.labelTarget) {\n    context.labelTarget = shape.labelTarget;\n    shape.labelTarget = null;\n  }\n\n  // Remove label\n  if (label) {\n    this._modeling.removeShape(label, { nested: true });\n  }\n\n  // remove connections\n  saveClear(shape.incoming, function(connection) {\n    // To make sure that the connection isn't removed twice\n    // For example if a container is removed\n    modeling.removeConnection(connection, { nested: true });\n  });\n\n  saveClear(shape.outgoing, function(connection) {\n    modeling.removeConnection(connection, { nested: true });\n  });\n\n\n  // remove children\n  saveClear(shape.children, function(e) {\n    modeling.removeShape(e, { nested: true });\n  });\n};\n\n/**\n * Remove shape and remember the parent\n */\nDeleteShapeHandler.prototype.execute = function(context) {\n  var canvas = this._canvas;\n\n  var shape = context.shape,\n      oldParent = shape.parent;\n\n  context.oldParent = oldParent;\n  context.oldParentIndex = Collections.indexOf(oldParent.children, shape);\n\n  shape.label = null;\n\n  canvas.removeShape(shape);\n\n  return shape;\n};\n\n\n/**\n * Command revert implementation\n */\nDeleteShapeHandler.prototype.revert = function(context) {\n\n  var canvas = this._canvas;\n\n  var shape = context.shape,\n      oldParent = context.oldParent,\n      oldParentIndex = context.oldParentIndex,\n      labelTarget = context.labelTarget;\n\n  // restore previous location in old oldParent\n  Collections.add(oldParent.children, shape, oldParentIndex);\n\n  if (labelTarget) {\n    labelTarget.label = shape;\n  }\n\n  canvas.addShape(shape, oldParent);\n\n  return shape;\n};\n","'use strict';\n\nvar forEach = require(283),\n    sortBy = require(291);\n\n/**\n * A handler that distributes elements evenly.\n */\nfunction DistributeElements(modeling) {\n  this._modeling = modeling;\n}\n\nDistributeElements.$inject = [ 'modeling' ];\n\nmodule.exports = DistributeElements;\n\nvar OFF_AXIS = {\n  x: 'y',\n  y: 'x'\n};\n\nDistributeElements.prototype.preExecute = function(context) {\n  var modeling = this._modeling;\n\n  var groups = context.groups,\n      axis = context.axis,\n      dimension = context.dimension;\n\n  function updateRange(group, element) {\n    group.range.min = Math.min(element[axis], group.range.min);\n    group.range.max = Math.max(element[axis] + element[dimension], group.range.max);\n  }\n\n  function center(element) {\n    return element[axis] + element[dimension] / 2;\n  }\n\n  function lastIdx(arr) {\n    return arr.length - 1;\n  }\n\n  function rangeDiff(range) {\n    return range.max - range.min;\n  }\n\n  function centerElement(refCenter, element) {\n    var delta = { y: 0 };\n\n    delta[axis] = refCenter - center(element);\n\n    if (delta[axis]) {\n\n      delta[OFF_AXIS[axis]] = 0;\n\n      modeling.moveElements([ element ], delta, element.parent);\n    }\n  }\n\n  var firstGroup = groups[0],\n      lastGroupIdx = lastIdx(groups),\n      lastGroup = groups[ lastGroupIdx ];\n\n  var margin,\n      spaceInBetween,\n      groupsSize = 0; // the size of each range\n\n  forEach(groups, function(group, idx) {\n    var sortedElements,\n        refElem,\n        refCenter;\n\n    if (group.elements.length < 2) {\n      if (idx && idx !== groups.length - 1) {\n        updateRange(group, group.elements[0]);\n\n        groupsSize += rangeDiff(group.range);\n      }\n      return;\n    }\n\n    sortedElements = sortBy(group.elements, axis);\n\n    refElem = sortedElements[0];\n\n    if (idx === lastGroupIdx) {\n      refElem = sortedElements[lastIdx(sortedElements)];\n    }\n\n    refCenter = center(refElem);\n\n    // wanna update the ranges after the shapes have been centered\n    group.range = null;\n\n    forEach(sortedElements, function(element) {\n\n      centerElement(refCenter, element);\n\n      if (group.range === null) {\n        group.range = {\n          min: element[axis],\n          max: element[axis] + element[dimension]\n        };\n\n        return;\n      }\n\n      // update group's range after centering the range elements\n      updateRange(group, element);\n    });\n\n    if (idx && idx !== groups.length - 1) {\n      groupsSize += rangeDiff(group.range);\n    }\n  });\n\n  spaceInBetween = Math.abs(lastGroup.range.min - firstGroup.range.max);\n\n  margin = Math.round((spaceInBetween - groupsSize) / (groups.length - 1));\n\n  if (margin < groups.length - 1) {\n    return;\n  }\n\n  forEach(groups, function(group, groupIdx) {\n    var delta = {},\n        prevGroup;\n\n    if (group === firstGroup || group === lastGroup) {\n      return;\n    }\n\n    prevGroup = groups[groupIdx - 1];\n\n    group.range.max = 0;\n\n    forEach(group.elements, function(element, idx) {\n      delta[OFF_AXIS[axis]] = 0;\n      delta[axis] = (prevGroup.range.max - element[axis]) + margin;\n\n      if (group.range.min !== element[axis]) {\n        delta[axis] += element[axis] - group.range.min;\n      }\n\n      if (delta[axis]) {\n        modeling.moveElements([ element ], delta, element.parent);\n      }\n\n      group.range.max = Math.max(element[axis] + element[dimension], idx ? group.range.max : 0);\n    });\n  });\n};\n\nDistributeElements.prototype.postExecute = function(context) {\n\n};\n","'use strict';\n\nvar assign = require(410);\n\n\n/**\n * A handler that implements reversible moving of shapes.\n */\nfunction LayoutConnectionHandler(layouter, canvas) {\n  this._layouter = layouter;\n  this._canvas = canvas;\n}\n\nLayoutConnectionHandler.$inject = [ 'layouter', 'canvas' ];\n\nmodule.exports = LayoutConnectionHandler;\n\nLayoutConnectionHandler.prototype.execute = function(context) {\n\n  var connection = context.connection,\n      parent = connection.parent,\n      connectionSiblings = parent.children;\n\n  var oldIndex = connectionSiblings.indexOf(connection);\n\n  var oldWaypoints = connection.waypoints;\n\n  assign(context, {\n    oldWaypoints: oldWaypoints,\n    oldIndex: oldIndex\n  });\n\n  sendToFront(connection);\n\n  connection.waypoints = this._layouter.layoutConnection(connection, context.hints);\n\n  return connection;\n};\n\nLayoutConnectionHandler.prototype.revert = function(context) {\n\n  var connection = context.connection,\n      parent = connection.parent,\n      connectionSiblings = parent.children,\n      currentIndex = connectionSiblings.indexOf(connection),\n      oldIndex = context.oldIndex;\n\n  connection.waypoints = context.oldWaypoints;\n\n  if (oldIndex !== currentIndex) {\n\n    // change position of connection in shape\n    connectionSiblings.splice(currentIndex, 1);\n    connectionSiblings.splice(oldIndex, 0, connection);\n  }\n\n  return connection;\n};\n\n\n////////////// helpers /////////////////////////////////////\n\n\n// connections should have a higher z-order as there source and targets\nfunction sendToFront(connection) {\n\n  var connectionSiblings = connection.parent.children;\n\n  var connectionIdx = connectionSiblings.indexOf(connection),\n      sourceIdx = findIndex(connectionSiblings, connection.source),\n      targetIdx = findIndex(connectionSiblings, connection.target),\n\n      // ensure we do not send the connection back\n      // if it is already in front\n      insertIndex = Math.max(sourceIdx + 1, targetIdx + 1, connectionIdx);\n\n  if (connectionIdx < insertIndex) {\n    connectionSiblings.splice(insertIndex, 0, connection); // add to new position\n    connectionSiblings.splice(connectionIdx, 1); // remove from old position\n  }\n\n  function findIndex(array, obj) {\n\n    var index = array.indexOf(obj);\n    if (index < 0 && obj) {\n      var parent = obj.parent;\n      index = findIndex(array, parent);\n    }\n    return index;\n  }\n\n  return insertIndex;\n}\n","'use strict';\n\nvar forEach = require(283);\n\nvar Collections = require(244);\n\n\n/**\n * A handler that implements reversible moving of connections.\n *\n * The handler differs from the layout connection handler in a sense\n * that it preserves the connection layout.\n */\nfunction MoveConnectionHandler() { }\n\nmodule.exports = MoveConnectionHandler;\n\n\nMoveConnectionHandler.prototype.execute = function(context) {\n\n  var connection = context.connection,\n      delta = context.delta;\n\n  var newParent = context.newParent || connection.parent,\n      newParentIndex = context.newParentIndex,\n      oldParent = connection.parent;\n\n  // save old parent in context\n  context.oldParent = oldParent;\n  context.oldParentIndex = Collections.remove(oldParent.children, connection);\n\n  // add to new parent at position\n  Collections.add(newParent.children, connection, newParentIndex);\n\n  // update parent\n  connection.parent = newParent;\n\n  // update waypoint positions\n  forEach(connection.waypoints, function(p) {\n    p.x += delta.x;\n    p.y += delta.y;\n\n    if (p.original) {\n      p.original.x += delta.x;\n      p.original.y += delta.y;\n    }\n  });\n\n  return connection;\n};\n\nMoveConnectionHandler.prototype.revert = function(context) {\n\n  var connection = context.connection,\n      newParent = connection.parent,\n      oldParent = context.oldParent,\n      oldParentIndex = context.oldParentIndex,\n      delta = context.delta;\n\n  // remove from newParent\n  Collections.remove(newParent.children, connection);\n\n  // restore previous location in old parent\n  Collections.add(oldParent.children, connection, oldParentIndex);\n\n  // restore parent\n  connection.parent = oldParent;\n\n  // revert to old waypoint positions\n  forEach(connection.waypoints, function(p) {\n    p.x -= delta.x;\n    p.y -= delta.y;\n\n    if (p.original) {\n      p.original.x -= delta.x;\n      p.original.y -= delta.y;\n    }\n  });\n\n  return connection;\n};","'use strict';\n\nvar MoveHelper = require(182);\n\n\n/**\n * A handler that implements reversible moving of shapes.\n */\nfunction MoveElementsHandler(modeling) {\n  this._helper = new MoveHelper(modeling);\n}\n\nMoveElementsHandler.$inject = [ 'modeling' ];\n\nmodule.exports = MoveElementsHandler;\n\nMoveElementsHandler.prototype.preExecute = function(context) {\n  context.closure = this._helper.getClosure(context.shapes);\n};\n\nMoveElementsHandler.prototype.postExecute = function(context) {\n\n  var hints = context.hints,\n      primaryShape;\n\n  if (hints && hints.primaryShape) {\n    primaryShape = hints.primaryShape;\n    hints.oldParent = primaryShape.parent;\n  }\n\n  this._helper.moveClosure(context.closure, context.delta, context.newParent, context.newHost, primaryShape);\n};\n\n\nMoveElementsHandler.prototype.execute = function(context) { };\nMoveElementsHandler.prototype.revert = function(context) { };\n","'use strict';\n\nvar assign = require(410),\n    forEach = require(283),\n    pick = require(417);\n\nvar MoveHelper = require(182),\n    Collections = require(244);\n\nvar getMovedSourceAnchor = require(181).getMovedSourceAnchor,\n    getMovedTargetAnchor = require(181).getMovedTargetAnchor;\n\n\n/**\n * A handler that implements reversible moving of shapes.\n */\nfunction MoveShapeHandler(modeling) {\n  this._modeling = modeling;\n\n  this._helper = new MoveHelper(modeling);\n}\n\nMoveShapeHandler.$inject = [ 'modeling' ];\n\nmodule.exports = MoveShapeHandler;\n\n\nMoveShapeHandler.prototype.execute = function(context) {\n\n  var shape = context.shape,\n      delta = context.delta,\n      newParent = context.newParent || shape.parent,\n      newParentIndex = context.newParentIndex,\n      oldParent = shape.parent;\n\n  context.oldBounds = pick(shape, [ 'x', 'y', 'width', 'height']);\n\n  // save old parent in context\n  context.oldParent = oldParent;\n  context.oldParentIndex = Collections.remove(oldParent.children, shape);\n\n  // add to new parent at position\n  Collections.add(newParent.children, shape, newParentIndex);\n\n  // update shape parent + position\n  assign(shape, {\n    parent: newParent,\n    x: shape.x + delta.x,\n    y: shape.y + delta.y\n  });\n\n  return shape;\n};\n\nMoveShapeHandler.prototype.postExecute = function(context) {\n\n  var shape = context.shape,\n      delta = context.delta,\n      hints = context.hints;\n\n  var modeling = this._modeling;\n\n  if (hints.layout !== false) {\n\n    forEach(shape.incoming, function(c) {\n      modeling.layoutConnection(c, {\n        connectionEnd: getMovedTargetAnchor(c, shape, delta)\n      });\n    });\n\n    forEach(shape.outgoing, function(c) {\n      modeling.layoutConnection(c, {\n        connectionStart: getMovedSourceAnchor(c, shape, delta)\n      });\n    });\n  }\n\n  if (hints.recurse !== false) {\n    this.moveChildren(context);\n  }\n};\n\nMoveShapeHandler.prototype.revert = function(context) {\n\n  var shape = context.shape,\n      oldParent = context.oldParent,\n      oldParentIndex = context.oldParentIndex,\n      delta = context.delta;\n\n  // restore previous location in old parent\n  Collections.add(oldParent.children, shape, oldParentIndex);\n\n  // revert to old position and parent\n  assign(shape, {\n    parent: oldParent,\n    x: shape.x - delta.x,\n    y: shape.y - delta.y\n  });\n\n  return shape;\n};\n\nMoveShapeHandler.prototype.moveChildren = function(context) {\n\n  var delta = context.delta,\n      shape = context.shape;\n\n  this._helper.moveRecursive(shape.children, delta, null);\n};\n\nMoveShapeHandler.prototype.getNewParent = function(context) {\n  return context.newParent || context.shape.parent;\n};\n","'use strict';\n\nfunction NoopHandler() {}\n\nmodule.exports = NoopHandler;\n\nNoopHandler.prototype.execute = function() {};\nNoopHandler.prototype.revert = function() {};","'use strict';\n\nvar forEach = require(283),\n    map = require(286),\n    sortBy = require(291),\n    clone = require(399);\n\nvar inherits = require(270);\n\n\n\nfunction removeProperties(element, properties) {\n  forEach(properties, function(prop) {\n    if (element[prop]) {\n      delete element[prop];\n    }\n  });\n}\n\n/**\n * A handler that implements pasting of elements onto the diagram.\n *\n * @param {eventBus} EventBus\n * @param {canvas} Canvas\n * @param {selection} Selection\n * @param {elementFactory} ElementFactory\n * @param {modeling} Modeling\n * @param {rules} Rules\n */\nfunction PasteHandler(eventBus, canvas, selection, elementFactory, modeling, rules) {\n  this._eventBus = eventBus;\n  this._canvas = canvas;\n  this._selection = selection;\n  this._elementFactory = elementFactory;\n  this._modeling = modeling;\n  this._rules = rules;\n}\n\ninherits(PasteHandler, require(172));\n\n\nPasteHandler.$inject = [\n  'eventBus',\n  'canvas',\n  'selection',\n  'elementFactory',\n  'modeling',\n  'rules'\n];\n\nmodule.exports = PasteHandler;\n\n\n////// api /////////////////////////////////////////////\n\n/**\n * Creates a new shape\n *\n * @param {Object} context\n * @param {Object} context.tree the new shape\n * @param {Element} context.topParent the paste target\n */\nPasteHandler.prototype.preExecute = function(context) {\n  var eventBus = this._eventBus;\n\n  var tree = context.tree,\n      topParent = context.topParent,\n      position = context.position;\n\n  tree.createdElements = {};\n\n  tree.labels = [];\n\n  forEach(tree, function(elements, depthStr) {\n    var depth = parseInt(depthStr, 10);\n\n    if (isNaN(depth)) {\n      return;\n    }\n\n    // set the parent on the top level elements\n    if (!depth) {\n      elements = map(elements, function(descriptor) {\n        descriptor.parent = topParent;\n\n        return descriptor;\n      });\n    }\n\n    // Order by priority for element creation\n    elements = sortBy(elements, 'priority');\n\n    forEach(elements, function(descriptor) {\n      var id = descriptor.id,\n          parent = descriptor.parent,\n          isAttach = false,\n          hints,\n          newPosition;\n\n      var element = clone(descriptor);\n\n      if (depth) {\n        element.parent = this._getCreatedElement(parent, tree);\n      }\n\n      // this happens when shapes have not been created due to rules\n      if (!parent) {\n        return;\n      }\n\n      eventBus.fire('element.paste', {\n        createdElements: tree.createdElements,\n        descriptor: element\n      });\n\n      // in case the parent changed during 'element.paste'\n      parent = element.parent;\n\n      if (element.waypoints) {\n        element = this._createConnection(element, parent, position, tree);\n\n        if (element) {\n          tree.createdElements[id] = {\n            element: element,\n            descriptor: descriptor\n          };\n        }\n\n        return;\n      }\n\n      // supply not-root information as hint\n      if (element.parent !== topParent) {\n        hints = { root: false };\n      }\n\n      // set host\n      if (element.host) {\n        isAttach = true;\n\n        parent = this._getCreatedElement(element.host, tree);\n      }\n\n      // handle labels\n      if (element.labelTarget) {\n        return tree.labels.push(element);\n      }\n\n      newPosition = {\n        x: Math.round(position.x + element.delta.x + (element.width / 2)),\n        y: Math.round(position.y + element.delta.y + (element.height / 2))\n      };\n\n      removeProperties(element, [ 'id', 'parent', 'delta', 'host', 'priority' ]);\n\n      element = this._createShape(element, parent, newPosition, isAttach, hints);\n\n      if (element) {\n        tree.createdElements[id] = {\n          element: element,\n          descriptor: descriptor\n        };\n      }\n    }, this);\n  }, this);\n};\n\n// move label's to their relative position\nPasteHandler.prototype.postExecute = function(context) {\n  var modeling = this._modeling,\n      selection = this._selection;\n\n  var tree = context.tree,\n      labels = tree.labels,\n      topLevelElements = [];\n\n  forEach(labels, function(labelDescriptor) {\n    var labelTarget = this._getCreatedElement(labelDescriptor.labelTarget, tree),\n        label, labelTargetPos, newPosition;\n\n    if (!labelTarget) {\n      return;\n    }\n\n    label = labelTarget.label;\n\n    if (!label) {\n      return;\n    }\n\n    labelTargetPos = {\n      x: labelTarget.x,\n      y: labelTarget.y\n    };\n\n    if (labelTarget.waypoints) {\n      labelTargetPos = labelTarget.waypoints[0];\n    }\n\n    newPosition = {\n      x: Math.round((labelTargetPos.x - label.x) + labelDescriptor.delta.x),\n      y: Math.round((labelTargetPos.y - label.y) + labelDescriptor.delta.y)\n    };\n\n    modeling.moveShape(label, newPosition, labelTarget.parent);\n  }, this);\n\n  forEach(tree[0], function(descriptor) {\n    var id = descriptor.id,\n        toplevel = tree.createdElements[id];\n\n    if (toplevel) {\n      topLevelElements.push(toplevel.element);\n    }\n  });\n\n  selection.select(topLevelElements);\n};\n\n\nPasteHandler.prototype._createConnection = function(element, parent, parentCenter, tree) {\n  var modeling = this._modeling,\n      rules = this._rules;\n\n  var connection, source, target, canPaste;\n\n  element.waypoints = map(element.waypoints, function(waypoint, idx) {\n    return {\n      x: Math.round(parentCenter.x + element.delta[idx].x),\n      y: Math.round(parentCenter.y + element.delta[idx].y)\n    };\n  });\n\n  source = this._getCreatedElement(element.source, tree);\n  target = this._getCreatedElement(element.target, tree);\n\n  if (!source || !target) {\n    return null;\n  }\n\n  canPaste = rules.allowed('element.paste', {\n    source: source,\n    target: target\n  });\n\n  if (!canPaste) {\n    return null;\n  }\n\n  removeProperties(element, [ 'id', 'parent', 'delta', 'source', 'target', 'width', 'height', 'priority' ]);\n\n  connection = modeling.createConnection(source, target, element, parent);\n\n  return connection;\n};\n\n\nPasteHandler.prototype._createShape = function(element, parent, position, isAttach, hints) {\n  var modeling = this._modeling,\n      elementFactory = this._elementFactory,\n      rules = this._rules;\n\n  var canPaste = rules.allowed('element.paste', {\n    element: element,\n    position: position,\n    parent: parent\n  });\n\n  if (!canPaste) {\n    return null;\n  }\n\n  var shape = elementFactory.createShape(element);\n\n  modeling.createShape(shape, position, parent, isAttach, hints);\n\n  return shape;\n};\n\n\nPasteHandler.prototype._getCreatedElement = function(id, tree) {\n  return tree.createdElements[id] && tree.createdElements[id].element;\n};\n","'use strict';\n\nvar isArray = require(401);\n\n\n/**\n * Reconnect connection handler\n */\nfunction ReconnectConnectionHandler() { }\n\nReconnectConnectionHandler.$inject = [ ];\n\nmodule.exports = ReconnectConnectionHandler;\n\nReconnectConnectionHandler.prototype.execute = function(context) {\n\n  var newSource = context.newSource,\n      newTarget = context.newTarget,\n      connection = context.connection,\n      dockingOrPoints = context.dockingOrPoints,\n      oldWaypoints = connection.waypoints,\n      newWaypoints;\n\n  if (!newSource && !newTarget) {\n    throw new Error('newSource or newTarget are required');\n  }\n\n  if (newSource && newTarget) {\n    throw new Error('must specify either newSource or newTarget');\n  }\n\n  context.oldWaypoints = oldWaypoints;\n\n  if (isArray(dockingOrPoints)) {\n    newWaypoints = dockingOrPoints;\n  } else {\n    newWaypoints = oldWaypoints.slice();\n\n    newWaypoints.splice(newSource ? 0 : -1, 1, dockingOrPoints);\n  }\n\n  if (newSource) {\n    context.oldSource = connection.source;\n    connection.source = newSource;\n  }\n\n  if (newTarget) {\n    context.oldTarget = connection.target;\n    connection.target = newTarget;\n  }\n\n  connection.waypoints = newWaypoints;\n\n  return connection;\n};\n\nReconnectConnectionHandler.prototype.revert = function(context) {\n\n  var newSource = context.newSource,\n      newTarget = context.newTarget,\n      connection = context.connection;\n\n  if (newSource) {\n    connection.source = context.oldSource;\n  }\n\n  if (newTarget) {\n    connection.target = context.oldTarget;\n  }\n\n  connection.waypoints = context.oldWaypoints;\n\n  return connection;\n};","'use strict';\n\nvar forEach = require(283);\n\n\n/**\n * A handler that implements reversible replacing of shapes.\n * Internally the old shape will be removed and the new shape will be added.\n *\n *\n * @class\n * @constructor\n *\n * @param {canvas} Canvas\n */\nfunction ReplaceShapeHandler(modeling, rules) {\n  this._modeling = modeling;\n  this._rules = rules;\n}\n\nReplaceShapeHandler.$inject = [ 'modeling', 'rules' ];\n\nmodule.exports = ReplaceShapeHandler;\n\n\n\n////// api /////////////////////////////////////////\n\n\n/**\n * Replaces a shape with an replacement Element.\n *\n * The newData object should contain type, x, y.\n *\n * If possible also the incoming/outgoing connection\n * will be restored.\n *\n * @param {Object} context\n */\nReplaceShapeHandler.prototype.preExecute = function(context) {\n\n  var self = this,\n      modeling = this._modeling,\n      rules = this._rules;\n\n  var oldShape = context.oldShape,\n      newData = context.newData,\n      hints = context.hints,\n      newShape;\n\n  function canReconnect(type, source, target, connection) {\n    return rules.allowed(type, {\n      source: source,\n      target: target,\n      connection: connection\n    });\n  }\n\n\n  // (1) place a new shape at the given position\n\n  var position = {\n    x: newData.x,\n    y: newData.y\n  };\n\n  newShape = context.newShape = context.newShape || self.createShape(newData, position, oldShape.parent);\n\n\n  // (2) update the host\n\n  if (oldShape.host) {\n    modeling.updateAttachment(newShape, oldShape.host);\n  }\n\n\n  // (3) adopt all children from the old shape\n\n  var children;\n\n  if (hints.moveChildren !== false) {\n    children = oldShape.children.slice();\n\n    modeling.moveElements(children, { x: 0, y: 0 }, newShape);\n  }\n\n  // (4) reconnect connections to the new shape (where allowed)\n\n  var incoming = oldShape.incoming.slice(),\n      outgoing = oldShape.outgoing.slice();\n\n  forEach(incoming, function(connection) {\n    var waypoints = connection.waypoints,\n        docking = waypoints[waypoints.length - 1],\n        source = connection.source,\n        allowed = canReconnect('connection.reconnectEnd', source, newShape, connection);\n\n    if (allowed) {\n      self.reconnectEnd(connection, newShape, docking);\n    }\n  });\n\n  forEach(outgoing, function(connection) {\n    var waypoints = connection.waypoints,\n        docking = waypoints[0],\n        target = connection.target,\n        allowed = canReconnect('connection.reconnectStart', newShape, target, connection);\n\n    if (allowed) {\n      self.reconnectStart(connection, newShape, docking);\n    }\n\n  });\n};\n\n\nReplaceShapeHandler.prototype.postExecute = function(context) {\n  var modeling = this._modeling;\n\n  var oldShape = context.oldShape,\n      newShape = context.newShape;\n\n  // if an element gets resized on replace, layout the connection again\n  forEach(newShape.incoming, function(c) {\n    modeling.layoutConnection(c, { endChanged: true });\n  });\n\n  forEach(newShape.outgoing, function(c) {\n    modeling.layoutConnection(c, { startChanged: true });\n  });\n\n  modeling.removeShape(oldShape);\n};\n\n\nReplaceShapeHandler.prototype.execute = function(context) {};\n\nReplaceShapeHandler.prototype.revert = function(context) {};\n\n\nReplaceShapeHandler.prototype.createShape = function(shape, position, target) {\n  var modeling = this._modeling;\n  return modeling.createShape(shape, position, target);\n};\n\n\nReplaceShapeHandler.prototype.reconnectStart = function(connection, newSource, dockingPoint) {\n  var modeling = this._modeling;\n  modeling.reconnectStart(connection, newSource, dockingPoint);\n};\n\n\nReplaceShapeHandler.prototype.reconnectEnd = function(connection, newTarget, dockingPoint) {\n  var modeling = this._modeling;\n  modeling.reconnectEnd(connection, newTarget, dockingPoint);\n};\n","'use strict';\n\nvar assign = require(410),\n    forEach = require(283);\n\nvar getResizedSourceAnchor = require(181).getResizedSourceAnchor,\n    getResizedTargetAnchor = require(181).getResizedTargetAnchor;\n\n/**\n * A handler that implements reversible resizing of shapes.\n *\n * @param {Modeling} modeling\n */\nfunction ResizeShapeHandler(modeling) {\n  this._modeling = modeling;\n}\n\nResizeShapeHandler.$inject = [ 'modeling' ];\n\nmodule.exports = ResizeShapeHandler;\n\n/**\n * {\n *   shape: {....}\n *   newBounds: {\n *     width:  20,\n *     height: 40,\n *     x:       5,\n *     y:      10\n *   }\n *\n * }\n */\nResizeShapeHandler.prototype.execute = function(context) {\n\n  var shape = context.shape,\n      newBounds = context.newBounds;\n\n  if (newBounds.x === undefined || newBounds.y === undefined ||\n      newBounds.width === undefined || newBounds.height === undefined) {\n    throw new Error('newBounds must have {x, y, width, height} properties');\n  }\n\n  if (newBounds.width < 10 || newBounds.height < 10) {\n    throw new Error('width and height cannot be less than 10px');\n  }\n\n  // save old bbox in context\n  context.oldBounds = {\n    width:  shape.width,\n    height: shape.height,\n    x:      shape.x,\n    y:      shape.y\n  };\n\n  // update shape\n  assign(shape, {\n    width:  newBounds.width,\n    height: newBounds.height,\n    x:      newBounds.x,\n    y:      newBounds.y\n  });\n\n  return shape;\n};\n\nResizeShapeHandler.prototype.postExecute = function(context) {\n\n  var shape = context.shape,\n      oldBounds = context.oldBounds;\n\n  var modeling = this._modeling;\n\n  forEach(shape.incoming, function(c) {\n    modeling.layoutConnection(c, {\n      connectionEnd: getResizedTargetAnchor(c, shape, oldBounds)\n    });\n  });\n\n  forEach(shape.outgoing, function(c) {\n    modeling.layoutConnection(c, {\n      connectionStart: getResizedSourceAnchor(c, shape, oldBounds)\n    });\n  });\n\n};\n\nResizeShapeHandler.prototype.revert = function(context) {\n\n  var shape = context.shape,\n      oldBounds = context.oldBounds;\n\n  // restore previous bbox\n  assign(shape, {\n    width:  oldBounds.width,\n    height: oldBounds.height,\n    x:      oldBounds.x,\n    y:      oldBounds.y\n  });\n\n  return shape;\n};\n","'use strict';\n\nvar forEach = require(283);\n\nvar SpaceUtil = require(220);\n\n/**\n * A handler that implements reversible creating and removing of space.\n *\n * It executes in two phases:\n *\n *  (1) resize all affected resizeShapes\n *  (2) move all affected moveElements\n */\nfunction SpaceToolHandler(modeling) {\n  this._modeling = modeling;\n}\n\nSpaceToolHandler.$inject = [ 'modeling' ];\n\nmodule.exports = SpaceToolHandler;\n\n\nSpaceToolHandler.prototype.preExecute = function(context) {\n\n  // resize\n  var modeling = this._modeling,\n      resizingShapes = context.resizingShapes,\n      delta = context.delta,\n      direction = context.direction;\n\n  forEach(resizingShapes, function(shape) {\n    var newBounds = SpaceUtil.resizeBounds(shape, direction, delta);\n\n    modeling.resizeShape(shape, newBounds);\n  });\n};\n\nSpaceToolHandler.prototype.postExecute = function(context) {\n  // move\n  var modeling = this._modeling,\n      movingShapes = context.movingShapes,\n      delta = context.delta;\n\n  modeling.moveElements(movingShapes, delta, undefined, false, { autoResize: false });\n};\n\nSpaceToolHandler.prototype.execute = function(context) {};\nSpaceToolHandler.prototype.revert = function(context) {};\n","'use strict';\n\n/**\n * A handler that toggles the collapsed state of an element\n * and the visibility of all its children.\n *\n * @param {Modeling} modeling\n */\nfunction ToggleShapeCollapseHandler(modeling) {\n  this._modeling = modeling;\n}\n\nToggleShapeCollapseHandler.$inject = [ 'modeling' ];\n\nmodule.exports = ToggleShapeCollapseHandler;\n\n\nToggleShapeCollapseHandler.prototype.execute = function(context) {\n\n  var shape = context.shape,\n      children = shape.children;\n\n  // remember previous visibility of children\n  context.oldChildrenVisibility = getElementsVisibility(children);\n\n  // toggle state\n  shape.collapsed = !shape.collapsed;\n\n  // hide/show children\n  setHidden(children, shape.collapsed);\n\n  return [shape].concat(children);\n};\n\n\nToggleShapeCollapseHandler.prototype.revert = function(context) {\n\n  var shape = context.shape,\n      oldChildrenVisibility = context.oldChildrenVisibility;\n\n  var children = shape.children;\n\n  // set old visability of children\n  restoreVisibility(children, oldChildrenVisibility);\n\n  // retoggle state\n  shape.collapsed = !shape.collapsed;\n\n  return [shape].concat(children);\n};\n\n\n/////// helpers ///////////////////////////////\n\n/**\n * Return a map { elementId -> hiddenState}.\n *\n * @param {Array<djs.model.Shape>} elements\n *\n * @return {Object}\n */\nfunction getElementsVisibility(elements) {\n\n  var result = {};\n\n  elements.forEach(function(e) {\n    result[e.id] = e.hidden;\n  });\n\n  return result;\n}\n\n\nfunction setHidden(elements, newHidden) {\n  elements.forEach(function(element) {\n    element.hidden = newHidden;\n  });\n}\n\nfunction restoreVisibility(elements, lastState) {\n  elements.forEach(function(e) {\n    e.hidden = lastState[e.id];\n  });\n}\n","'use strict';\n\nvar Collections = require(244);\n\n/**\n * A handler that implements reversible attaching/detaching of shapes.\n */\nfunction UpdateAttachmentHandler(modeling) {\n  this._modeling = modeling;\n}\n\nmodule.exports = UpdateAttachmentHandler;\n\nUpdateAttachmentHandler.$inject = [ 'modeling' ];\n\n\nUpdateAttachmentHandler.prototype.execute = function(context) {\n  var shape = context.shape,\n      newHost = context.newHost,\n      oldHost = shape.host;\n\n  // (0) detach from old host\n  context.oldHost = oldHost;\n  context.attacherIdx = removeAttacher(oldHost, shape);\n\n  // (1) attach to new host\n  addAttacher(newHost, shape);\n\n  // (2) update host\n  shape.host = newHost;\n\n  return shape;\n};\n\nUpdateAttachmentHandler.prototype.revert = function(context) {\n  var shape = context.shape,\n      newHost = context.newHost,\n      oldHost = context.oldHost,\n      attacherIdx = context.attacherIdx;\n\n  // (2) update host\n  shape.host = oldHost;\n\n  // (1) attach to new host\n  removeAttacher(newHost, shape);\n\n  // (0) detach from old host\n  addAttacher(oldHost, shape, attacherIdx);\n\n  return shape;\n};\n\n\nfunction removeAttacher(host, attacher) {\n  // remove attacher from host\n  return Collections.remove(host && host.attachers, attacher);\n}\n\nfunction addAttacher(host, attacher, idx) {\n\n  if (!host) {\n    return;\n  }\n\n  var attachers = host.attachers;\n\n  if (!attachers) {\n    host.attachers = attachers = [];\n  }\n\n  Collections.add(attachers, attacher, idx);\n}\n","'use strict';\n\nfunction UpdateWaypointsHandler() { }\n\nmodule.exports = UpdateWaypointsHandler;\n\nUpdateWaypointsHandler.prototype.execute = function(context) {\n\n  var connection = context.connection,\n      newWaypoints = context.newWaypoints;\n\n  context.oldWaypoints = connection.waypoints;\n\n  connection.waypoints = newWaypoints;\n\n  return connection;\n};\n\nUpdateWaypointsHandler.prototype.revert = function(context) {\n\n  var connection = context.connection,\n      oldWaypoints = context.oldWaypoints;\n\n  connection.waypoints = oldWaypoints;\n\n  return connection;\n};","'use strict';\n\nvar getNewAttachPoint = require(242).getNewAttachPoint;\n\nfunction getResizedSourceAnchor(connection, shape, oldBounds) {\n\n  var waypoints = safeGetWaypoints(connection),\n      oldAnchor = waypoints[0];\n\n  return getNewAttachPoint(oldAnchor.original || oldAnchor, oldBounds, shape);\n}\n\nmodule.exports.getResizedSourceAnchor = getResizedSourceAnchor;\n\n\nfunction getResizedTargetAnchor(connection, shape, oldBounds) {\n\n  var waypoints = safeGetWaypoints(connection),\n      oldAnchor = waypoints[waypoints.length - 1];\n\n  return getNewAttachPoint(oldAnchor.original || oldAnchor, oldBounds, shape);\n}\n\nmodule.exports.getResizedTargetAnchor = getResizedTargetAnchor;\n\n\nfunction getMovedSourceAnchor(connection, source, moveDelta) {\n  return getResizedSourceAnchor(connection, source, substractPosition(source, moveDelta));\n}\n\nmodule.exports.getMovedSourceAnchor = getMovedSourceAnchor;\n\n\nfunction getMovedTargetAnchor(connection, target, moveDelta) {\n  return getResizedTargetAnchor(connection, target, substractPosition(target, moveDelta));\n}\n\nmodule.exports.getMovedTargetAnchor = getMovedTargetAnchor;\n\n\n//////// helpers ////////////////////////////////////\n\nfunction substractPosition(bounds, delta) {\n  return {\n    x: bounds.x - delta.x,\n    y: bounds.y - delta.y,\n    width: bounds.width,\n    height: bounds.height\n  };\n}\n\n\n/**\n * Return waypoints of given connection; throw if non exists (should not happen!!).\n *\n * @param {Connection} connection\n *\n * @return {Array<Point>}\n */\nfunction safeGetWaypoints(connection) {\n\n  var waypoints = connection.waypoints;\n\n  if (!waypoints.length) {\n    throw new Error('connection#' + connection.id + ': no waypoints');\n  }\n\n  return waypoints;\n}\n","'use strict';\n\nvar forEach = require(283);\n\nvar Elements = require(247);\n\nvar getMovedSourceAnchor = require(181).getMovedSourceAnchor,\n    getMovedTargetAnchor = require(181).getMovedTargetAnchor;\n\n/**\n * A helper that is able to carry out serialized move operations on multiple elements.\n *\n * @param {Modeling} modeling\n */\nfunction MoveHelper(modeling) {\n  this._modeling = modeling;\n}\n\nmodule.exports = MoveHelper;\n\n/**\n * Move the specified elements and all children by the given delta.\n *\n * This moves all enclosed connections, too and layouts all affected\n * external connections.\n *\n * @param  {Array<djs.model.Base>} elements\n * @param  {Point} delta\n * @param  {djs.model.Base} newParent applied to the first level of shapes\n *\n * @return {Array<djs.model.Base>} list of touched elements\n */\nMoveHelper.prototype.moveRecursive = function(elements, delta, newParent) {\n  if (!elements) {\n    return [];\n  } else {\n    return this.moveClosure(this.getClosure(elements), delta, newParent);\n  }\n};\n\n/**\n * Move the given closure of elmements.\n *\n * @param {Object} closure\n * @param {Point} delta\n * @param {djs.model.Base} [newParent]\n * @param {djs.model.Base} [newHost]\n */\nMoveHelper.prototype.moveClosure = function(closure, delta, newParent, newHost, primaryShape) {\n  var modeling = this._modeling;\n\n  var allShapes = closure.allShapes,\n      allConnections = closure.allConnections,\n      enclosedConnections = closure.enclosedConnections,\n      topLevel = closure.topLevel,\n      keepParent = false;\n\n  if (primaryShape && primaryShape.parent === newParent) {\n    keepParent = true;\n  }\n\n  // move all shapes\n  forEach(allShapes, function(shape) {\n\n    // move the element according to the given delta\n    modeling.moveShape(shape, delta, topLevel[shape.id] && !keepParent && newParent, {\n      recurse: false,\n      layout: false\n    });\n  });\n\n  // move all child connections / layout external connections\n  forEach(allConnections, function(c) {\n\n    var sourceMoved = !!allShapes[c.source.id],\n        targetMoved = !!allShapes[c.target.id];\n\n    if (enclosedConnections[c.id] && sourceMoved && targetMoved) {\n      modeling.moveConnection(c, delta, topLevel[c.id] && !keepParent && newParent);\n    } else {\n      modeling.layoutConnection(c, {\n        connectionStart: sourceMoved && getMovedSourceAnchor(c, c.source, delta),\n        connectionEnd: targetMoved && getMovedTargetAnchor(c, c.target, delta)\n      });\n    }\n  });\n};\n\n/**\n * Returns the closure for the selected elements\n *\n * @param  {Array<djs.model.Base>} elements\n * @return {Object} closure\n */\nMoveHelper.prototype.getClosure = function(elements) {\n  return Elements.getClosure(elements);\n};\n","'use strict';\n\nvar bind = require(293);\n\n\nfunction MouseTracking(eventBus, canvas) {\n  this._eventBus = eventBus;\n  this._canvas = canvas;\n\n  this._init();\n}\n\nMouseTracking.$inject = [\n  'eventBus',\n  'canvas'\n];\n\nmodule.exports = MouseTracking;\n\n\nMouseTracking.prototype.getHoverContext = function() {\n  var viewbox = this._canvas.viewbox();\n\n  return {\n    element: this._hoverElement,\n    point: {\n      x: viewbox.x + Math.round(this._mouseX / viewbox.scale),\n      y: viewbox.y + Math.round(this._mouseY / viewbox.scale)\n    }\n  };\n};\n\nMouseTracking.prototype._init = function() {\n  var eventBus = this._eventBus,\n      canvas = this._canvas;\n\n  var container = canvas.getContainer();\n\n  this._setMousePosition = bind(this._setMousePosition, this);\n\n  container.addEventListener('mousemove', this._setMousePosition);\n\n  eventBus.on('diagram.destroy', function() {\n    container.removeEventListener('mousemove', this._setMousePosition);\n  }, this);\n\n  eventBus.on('element.hover', this._setHoverElement, this);\n};\n\n\nMouseTracking.prototype._setHoverElement = function(event) {\n  this._hoverElement = event.element;\n};\n\n\nMouseTracking.prototype._setMousePosition = function(event) {\n  this._mouseX = event.layerX;\n  this._mouseY = event.layerY;\n};\n","'use strict';\n\nmodule.exports = {\n  __init__: [ 'mouseTracking' ],\n  mouseTracking: [ 'type', require(183) ]\n};\n","'use strict';\n\nvar assign = require(410),\n    filter = require(281),\n    groupBy = require(284);\n\nvar LOW_PRIORITY = 500,\n    MEDIUM_PRIORITY = 1250,\n    HIGH_PRIORITY = 1500;\n\nvar getOriginalEvent = require(248).getOriginal;\n\nvar round = Math.round;\n\nfunction mid(element) {\n  return {\n    x: element.x + round(element.width / 2),\n    y: element.y + round(element.height / 2)\n  };\n}\n\n/**\n * A plugin that makes shapes draggable / droppable.\n *\n * @param {EventBus} eventBus\n * @param {Dragging} dragging\n * @param {Modeling} modeling\n * @param {Selection} selection\n * @param {Rules} rules\n */\nfunction MoveEvents(eventBus, dragging, modeling, selection, rules) {\n\n  // rules\n\n  function canMove(shapes, delta, position, target) {\n\n    return rules.allowed('elements.move', {\n      shapes: shapes,\n      delta: delta,\n      position: position,\n      target: target\n    });\n  }\n\n\n  // move events\n\n  // assign a high priority to this handler to setup the environment\n  // others may hook up later, e.g. at default priority and modify\n  // the move environment.\n  //\n  // This sets up the context with\n  //\n  // * shape: the primary shape being moved\n  // * shapes: a list of shapes to be moved\n  // * validatedShapes: a list of shapes that are being checked\n  //                    against the rules before and during move\n  //\n  eventBus.on('shape.move.start', HIGH_PRIORITY, function(event) {\n\n    var context = event.context,\n        shape = event.shape,\n        shapes = selection.get().slice();\n\n    // move only single shape if the dragged element\n    // is not part of the current selection\n    if (shapes.indexOf(shape) === -1) {\n      shapes = [ shape ];\n    }\n\n    // ensure we remove nested elements in the collection\n    // and add attachers for a proper dragger\n    shapes = removeNested(shapes);\n\n    // attach shapes to drag context\n    assign(context, {\n      shapes: shapes,\n      validatedShapes: shapes,\n      shape: shape\n    });\n  });\n\n\n  // assign a high priority to this handler to setup the environment\n  // others may hook up later, e.g. at default priority and modify\n  // the move environment\n  //\n  eventBus.on('shape.move.start', MEDIUM_PRIORITY, function(event) {\n\n    var context = event.context,\n        validatedShapes = context.validatedShapes,\n        canExecute;\n\n    canExecute = context.canExecute = canMove(validatedShapes);\n\n    // check if we can move the elements\n    if (!canExecute) {\n      // suppress move operation\n      event.stopPropagation();\n\n      return false;\n    }\n  });\n\n  // assign a low priority to this handler\n  // to let others modify the move event before we update\n  // the context\n  //\n  eventBus.on('shape.move.move', LOW_PRIORITY, function(event) {\n\n    var context = event.context,\n        validatedShapes = context.validatedShapes,\n        hover = event.hover,\n        delta = { x: event.dx, y: event.dy },\n        position = { x: event.x, y: event.y },\n        canExecute;\n\n    // check if we can move the elements\n    canExecute = canMove(validatedShapes, delta, position, hover);\n\n    context.delta = delta;\n    context.canExecute = canExecute;\n\n    // simply ignore move over\n    if (canExecute === null) {\n      context.target = null;\n\n      return;\n    }\n\n    context.target = hover;\n  });\n\n  eventBus.on('shape.move.end', function(event) {\n\n    var context = event.context;\n\n    var delta = context.delta,\n        canExecute = context.canExecute,\n        isAttach = canExecute === 'attach',\n        shapes = context.shapes;\n\n    if (!canExecute) {\n      return false;\n    }\n\n    // ensure we have actual pixel values deltas\n    // (important when zoom level was > 1 during move)\n    delta.x = round(delta.x);\n    delta.y = round(delta.y);\n\n    modeling.moveElements(shapes, delta, context.target, isAttach, { primaryShape: context.shape });\n  });\n\n\n  // move activation\n\n  eventBus.on('element.mousedown', function(event) {\n\n    var originalEvent = getOriginalEvent(event);\n\n    if (!originalEvent) {\n      throw new Error('must supply DOM mousedown event');\n    }\n\n    start(originalEvent, event.element);\n  });\n\n\n  function start(event, element, activate) {\n\n    // do not move connections or the root element\n    if (element.waypoints || !element.parent) {\n      return;\n    }\n\n    var referencePoint = mid(element);\n\n    dragging.init(event, referencePoint, 'shape.move', {\n      cursor: 'grabbing',\n      autoActivate: activate,\n      data: {\n        shape: element,\n        context: {}\n      }\n    });\n  }\n\n  // API\n\n  this.start = start;\n}\n\nMoveEvents.$inject = [ 'eventBus', 'dragging', 'modeling', 'selection', 'rules' ];\n\nmodule.exports = MoveEvents;\n\n\n/**\n * Return a filtered list of elements that do not contain\n * those nested into others.\n *\n * @param  {Array<djs.model.Base>} elements\n *\n * @return {Array<djs.model.Base>} filtered\n */\nfunction removeNested(elements) {\n\n  var ids = groupBy(elements, 'id');\n\n  return filter(elements, function(element) {\n    while ((element = element.parent)) {\n\n      // parent in selection\n      if (ids[element.id]) {\n        return false;\n      }\n    }\n\n    return true;\n  });\n}\n","'use strict';\n\nvar flatten = require(272),\n    forEach = require(283),\n    filter = require(281),\n    find = require(282),\n    size = require(289),\n    groupBy = require(284),\n    map = require(286);\n\nvar Elements = require(247);\n\nvar LOW_PRIORITY = 500;\n\nvar MARKER_DRAGGING = 'djs-dragging',\n    MARKER_OK = 'drop-ok',\n    MARKER_NOT_OK = 'drop-not-ok',\n    MARKER_NEW_PARENT = 'new-parent',\n    MARKER_ATTACH = 'attach-ok';\n\n/**\n * Provides previews for moving shapes when moving.\n *\n * @param {EventBus} eventBus\n * @param {ElementRegistry} elementRegistry\n * @param {Canvas} canvas\n * @param {Styles} styles\n */\nfunction MovePreview(eventBus, elementRegistry, canvas, styles, previewSupport) {\n\n  function getVisualDragShapes(shapes) {\n    var elements = getAllDraggedElements(shapes);\n\n    var filteredElements = removeEdges(elements);\n\n    return filteredElements;\n  }\n\n  function getAllDraggedElements(shapes) {\n    var allShapes = Elements.selfAndAllChildren(shapes, true);\n\n    var allConnections = map(allShapes, function(shape) {\n      return (shape.incoming || []).concat(shape.outgoing || []);\n    });\n\n    return flatten(allShapes.concat(allConnections), true);\n  }\n\n  /**\n   * Sets drop marker on an element.\n   */\n  function setMarker(element, marker) {\n\n    [ MARKER_ATTACH, MARKER_OK, MARKER_NOT_OK, MARKER_NEW_PARENT ].forEach(function(m) {\n\n      if (m === marker) {\n        canvas.addMarker(element, m);\n      } else {\n        canvas.removeMarker(element, m);\n      }\n    });\n  }\n\n  function makeDraggable(context, element, addMarker) {\n\n    previewSupport.addDragger(element, context.dragGroup);\n\n    if (addMarker) {\n      canvas.addMarker(element, MARKER_DRAGGING);\n    }\n\n    if (context.allDraggedElements) {\n      context.allDraggedElements.push(element);\n    } else {\n      context.allDraggedElements = [ element ];\n    }\n  }\n\n  // expose to other components\n  // that plug into the drag behavior\n  this.makeDraggable = makeDraggable;\n\n  // add previews\n  eventBus.on('shape.move.start', LOW_PRIORITY, function(event) {\n\n    var context = event.context,\n        dragShapes = context.shapes,\n        allDraggedElements = context.allDraggedElements;\n\n    var visuallyDraggedShapes = getVisualDragShapes(dragShapes);\n\n    if (!context.dragGroup) {\n      context.dragGroup = canvas.getDefaultLayer().group()\n        .attr(styles.cls('djs-drag-group', [ 'no-events' ]));\n    }\n\n    // add previews\n    visuallyDraggedShapes.forEach(function(shape) {\n      previewSupport.addDragger(shape, context.dragGroup);\n    });\n\n    // cache all dragged elements / gfx\n    // so that we can quickly undo their state changes later\n    if (!allDraggedElements) {\n      allDraggedElements = getAllDraggedElements(dragShapes);\n    } else {\n      allDraggedElements = flatten(allDraggedElements, getAllDraggedElements(dragShapes));\n    }\n\n    // add dragging marker\n    forEach(allDraggedElements, function(e) {\n      canvas.addMarker(e, MARKER_DRAGGING);\n    });\n\n    context.allDraggedElements = allDraggedElements;\n\n    // determine, if any of the dragged elements have different parents\n    context.differentParents = haveDifferentParents(dragShapes);\n  });\n\n  // update previews\n  eventBus.on('shape.move.move', LOW_PRIORITY, function(event) {\n\n    var context = event.context,\n        dragGroup = context.dragGroup,\n        target = context.target,\n        parent = context.shape.parent,\n        canExecute = context.canExecute;\n\n    if (target) {\n      if (canExecute === 'attach') {\n        setMarker(target, MARKER_ATTACH);\n      } else if (context.canExecute && target && target.id !== parent.id) {\n        setMarker(target, MARKER_NEW_PARENT);\n      } else {\n        setMarker(target, context.canExecute ? MARKER_OK : MARKER_NOT_OK);\n      }\n    }\n\n    dragGroup.translate(event.dx, event.dy);\n  });\n\n  eventBus.on([ 'shape.move.out', 'shape.move.cleanup' ], function(event) {\n    var context = event.context,\n        target = context.target;\n\n    if (target) {\n      setMarker(target, null);\n    }\n  });\n\n  // remove previews\n  eventBus.on('shape.move.cleanup', function(event) {\n\n    var context = event.context,\n        allDraggedElements = context.allDraggedElements,\n        dragGroup = context.dragGroup;\n\n\n    // remove dragging marker\n    forEach(allDraggedElements, function(e) {\n      canvas.removeMarker(e, MARKER_DRAGGING);\n    });\n\n    if (dragGroup) {\n      dragGroup.remove();\n    }\n  });\n}\n\nMovePreview.$inject = [ 'eventBus', 'elementRegistry', 'canvas', 'styles', 'previewSupport' ];\n\nmodule.exports = MovePreview;\n\n////////// helpers //////////\n\n// returns elements minus all connections\n// where source or target is not elements\nfunction removeEdges(elements) {\n\n  var filteredElements = filter(elements, function(element) {\n\n    if (!isConnection(element)) {\n      return true;\n    } else {\n      var srcFound = find(elements, element.source);\n      var targetFound = find(elements, element.target);\n\n      return srcFound && targetFound;\n    }\n  });\n\n  return filteredElements;\n}\n\nfunction haveDifferentParents(elements) {\n  return size(groupBy(elements, function(e) { return e.parent && e.parent.id; })) !== 1;\n}\n\n/**\n * Checks if an element is a connection.\n */\nfunction isConnection(element) {\n  return element.waypoints;\n}\n","module.exports = {\n  __depends__: [\n    require(151),\n    require(214),\n    require(190),\n    require(208),\n    require(143),\n    require(198)\n  ],\n  __init__: [ 'move', 'movePreview' ],\n  move: [ 'type', require(185) ],\n  movePreview: [ 'type', require(186) ]\n};\n","'use strict';\n\nvar inherits = require(270);\n\nvar CommandInterceptor = require(100);\n\n\n/**\n * An abstract provider that allows modelers to implement a custom\n * ordering of diagram elements on the canvas.\n *\n * It makes sure that the order is always preserved during element\n * creation and move operations.\n *\n * In order to use this behavior, inherit from it and override\n * the method {@link OrderingProvider#getOrdering}.\n *\n * @example\n *\n * ```javascript\n * function CustomOrderingProvider(eventBus) {\n *   OrderingProvider.call(this, eventBus);\n *\n *   this.getOrdering = function(element, newParent) {\n *     // always insert elements at the front\n *     // when moving\n *     return {\n *       index: 0,\n *       parent: newParent\n *     };\n *   };\n * }\n * ```\n *\n * @param {EventBus} eventBus\n */\nfunction OrderingProvider(eventBus) {\n\n  CommandInterceptor.call(this, eventBus);\n\n\n  var self = this;\n\n  this.preExecute([ 'shape.create', 'connection.create' ], function(event) {\n\n    var context = event.context,\n        element = context.shape || context.connection,\n        parent = context.parent;\n\n    var ordering = self.getOrdering(element, parent);\n\n    if (ordering) {\n\n      if (ordering.parent !== undefined) {\n        context.parent = ordering.parent;\n      }\n\n      context.parentIndex = ordering.index;\n    }\n  });\n\n  this.preExecute([ 'shape.move', 'connection.move' ], function(event) {\n\n    var context = event.context,\n        element = context.shape || context.connection,\n        parent = context.newParent || element.parent;\n\n    var ordering = self.getOrdering(element, parent);\n\n    if (ordering) {\n\n      if (ordering.parent !== undefined) {\n        context.newParent = ordering.parent;\n      }\n\n      context.newParentIndex = ordering.index;\n    }\n  });\n}\n\n/**\n * Return a custom ordering of the element, both in terms\n * of parent element and index in the new parent.\n *\n * Implementors of this method must return an object with\n * `parent` _and_ `index` in it.\n *\n * @param {djs.model.Base} element\n * @param {djs.model.Shape} newParent\n *\n * @return {Object} ordering descriptor\n */\nOrderingProvider.prototype.getOrdering = function(element, newParent) {\n  return null;\n};\n\ninherits(OrderingProvider, CommandInterceptor);\n\nmodule.exports = OrderingProvider;","'use strict';\n\nvar getBBox = require(247).getBBox;\n\nvar LOW_PRIORITY = 500;\n\n/**\n * @class\n *\n * A plugin that adds an outline to shapes and connections that may be activated and styled\n * via CSS classes.\n *\n * @param {EventBus} eventBus\n * @param {Styles} styles\n * @param {ElementRegistry} elementRegistry\n */\nfunction Outline(eventBus, styles, elementRegistry) {\n\n  this.offset = 6;\n\n  var OUTLINE_STYLE = styles.cls('djs-outline', [ 'no-fill' ]);\n\n  var self = this;\n\n  function createOutline(gfx, bounds) {\n    return gfx.rect(10, 10, 0, 0).attr(OUTLINE_STYLE);\n  }\n\n  // A low priortity is necessary, because outlines of labels have to be updated\n  // after the label bounds have been updated in the renderer.\n  eventBus.on([ 'shape.added', 'shape.changed' ], LOW_PRIORITY, function(event) {\n    var element = event.element,\n        gfx     = event.gfx;\n\n    var outline = gfx.select('.djs-outline');\n\n    if (!outline) {\n      outline = createOutline(gfx, element);\n    }\n\n    self.updateShapeOutline(outline, element);\n  });\n\n  eventBus.on([ 'connection.added', 'connection.changed' ], function(event) {\n    var element = event.element,\n        gfx     = event.gfx;\n\n    var outline = gfx.select('.djs-outline');\n\n    if (!outline) {\n      outline = createOutline(gfx, element);\n    }\n\n    self.updateConnectionOutline(outline, element);\n  });\n}\n\n\n/**\n * Updates the outline of a shape respecting the dimension of the\n * element and an outline offset.\n *\n * @param  {SVGElement} outline\n * @param  {djs.model.Base} element\n */\nOutline.prototype.updateShapeOutline = function(outline, element) {\n\n  outline.attr({\n    x: -this.offset,\n    y: -this.offset,\n    width: element.width + this.offset * 2,\n    height: element.height + this.offset * 2\n  });\n\n};\n\n\n/**\n * Updates the outline of a connection respecting the bounding box of\n * the connection and an outline offset.\n *\n * @param  {SVGElement} outline\n * @param  {djs.model.Base} element\n */\nOutline.prototype.updateConnectionOutline = function(outline, connection) {\n\n  var bbox = getBBox(connection);\n\n  outline.attr({\n    x: bbox.x - this.offset,\n    y: bbox.y - this.offset,\n    width: bbox.width + this.offset * 2,\n    height: bbox.height + this.offset * 2\n  });\n\n};\n\n\nOutline.$inject = ['eventBus', 'styles', 'elementRegistry'];\n\nmodule.exports = Outline;\n","'use strict';\n\nmodule.exports = {\n  __init__: [ 'outline' ],\n  outline: [ 'type', require(189) ]\n};","'use strict';\n\nvar isArray = require(401),\n    isString = require(407),\n    isObject = require(405),\n    assign = require(410),\n    forEach = require(283),\n    find = require(282),\n    filter = require(281);\n\nvar domify = require(428),\n    domClasses = require(424),\n    domAttr = require(423),\n    domRemove = require(432),\n    domClear = require(425);\n\nvar getBBox = require(247).getBBox;\n\n// document wide unique overlay ids\nvar ids = new (require(251))('ov');\n\n\nfunction createRoot(parent) {\n  var root = domify('<div class=\"djs-overlay-container\" style=\"position: absolute; width: 0; height: 0;\" />');\n  parent.insertBefore(root, parent.firstChild);\n\n  return root;\n}\n\n\nfunction setPosition(el, x, y) {\n  assign(el.style, { left: x + 'px', top: y + 'px' });\n}\n\nfunction setVisible(el, visible) {\n  el.style.display = visible === false ? 'none' : '';\n}\n\n/**\n * A service that allows users to attach overlays to diagram elements.\n *\n * The overlay service will take care of overlay positioning during updates.\n *\n * @example\n *\n * // add a pink badge on the top left of the shape\n * overlays.add(someShape, {\n *   position: {\n *     top: -5,\n *     left: -5\n *   },\n *   html: '<div style=\"width: 10px; background: fuchsia; color: white;\">0</div>'\n * });\n *\n * // or add via shape id\n *\n * overlays.add('some-element-id', {\n *   position: {\n *     top: -5,\n *     left: -5\n *   }\n *   html: '<div style=\"width: 10px; background: fuchsia; color: white;\">0</div>'\n * });\n *\n * // or add with optional type\n *\n * overlays.add(someShape, 'badge', {\n *   position: {\n *     top: -5,\n *     left: -5\n *   }\n *   html: '<div style=\"width: 10px; background: fuchsia; color: white;\">0</div>'\n * });\n *\n *\n * // remove an overlay\n *\n * var id = overlays.add(...);\n * overlays.remove(id);\n *\n * @param {EventBus} eventBus\n * @param {Canvas} canvas\n * @param {ElementRegistry} elementRegistry\n */\nfunction Overlays(eventBus, canvas, elementRegistry) {\n\n  this._eventBus = eventBus;\n  this._canvas = canvas;\n  this._elementRegistry = elementRegistry;\n\n  this._ids = ids;\n\n  this._overlayDefaults = {\n    show: {\n      minZoom: 0.7,\n      maxZoom: 5.0\n    }\n  };\n\n  /**\n   * Mapping overlayId -> overlay\n   */\n  this._overlays = {};\n\n  /**\n   * Mapping elementId -> overlay container\n   */\n  this._overlayContainers = [];\n\n  // root html element for all overlays\n  this._overlayRoot = createRoot(canvas.getContainer());\n\n  this._init();\n}\n\n\nOverlays.$inject = [ 'eventBus', 'canvas', 'elementRegistry' ];\n\nmodule.exports = Overlays;\n\n\n/**\n * Returns the overlay with the specified id or a list of overlays\n * for an element with a given type.\n *\n * @example\n *\n * // return the single overlay with the given id\n * overlays.get('some-id');\n *\n * // return all overlays for the shape\n * overlays.get({ element: someShape });\n *\n * // return all overlays on shape with type 'badge'\n * overlays.get({ element: someShape, type: 'badge' });\n *\n * // shape can also be specified as id\n * overlays.get({ element: 'element-id', type: 'badge' });\n *\n *\n * @param {Object} search\n * @param {String} [search.id]\n * @param {String|djs.model.Base} [search.element]\n * @param {String} [search.type]\n *\n * @return {Object|Array<Object>} the overlay(s)\n */\nOverlays.prototype.get = function(search) {\n\n  if (isString(search)) {\n    search = { id: search };\n  }\n\n  if (isString(search.element)) {\n    search.element = this._elementRegistry.get(search.element);\n  }\n\n  if (search.element) {\n    var container = this._getOverlayContainer(search.element, true);\n\n    // return a list of overlays when searching by element (+type)\n    if (container) {\n      return search.type ? filter(container.overlays, { type: search.type }) : container.overlays.slice();\n    } else {\n      return [];\n    }\n  } else\n  if (search.type) {\n    return filter(this._overlays, { type: search.type });\n  } else {\n    // return single element when searching by id\n    return search.id ? this._overlays[search.id] : null;\n  }\n};\n\n/**\n * Adds a HTML overlay to an element.\n *\n * @param {String|djs.model.Base}   element   attach overlay to this shape\n * @param {String}                  [type]    optional type to assign to the overlay\n * @param {Object}                  overlay   the overlay configuration\n *\n * @param {String|DOMElement}       overlay.html                 html element to use as an overlay\n * @param {Object}                  [overlay.show]               show configuration\n * @param {Number}                  [overlay.show.minZoom]       minimal zoom level to show the overlay\n * @param {Number}                  [overlay.show.maxZoom]       maximum zoom level to show the overlay\n * @param {Object}                  overlay.position             where to attach the overlay\n * @param {Number}                  [overlay.position.left]      relative to element bbox left attachment\n * @param {Number}                  [overlay.position.top]       relative to element bbox top attachment\n * @param {Number}                  [overlay.position.bottom]    relative to element bbox bottom attachment\n * @param {Number}                  [overlay.position.right]     relative to element bbox right attachment\n *\n * @return {String}                 id that may be used to reference the overlay for update or removal\n */\nOverlays.prototype.add = function(element, type, overlay) {\n\n  if (isObject(type)) {\n    overlay = type;\n    type = null;\n  }\n\n  if (!element.id) {\n    element = this._elementRegistry.get(element);\n  }\n\n  if (!overlay.position) {\n    throw new Error('must specifiy overlay position');\n  }\n\n  if (!overlay.html) {\n    throw new Error('must specifiy overlay html');\n  }\n\n  if (!element) {\n    throw new Error('invalid element specified');\n  }\n\n  var id = this._ids.next();\n\n  overlay = assign({}, this._overlayDefaults, overlay, {\n    id: id,\n    type: type,\n    element: element,\n    html: overlay.html\n  });\n\n  this._addOverlay(overlay);\n\n  return id;\n};\n\n\n/**\n * Remove an overlay with the given id or all overlays matching the given filter.\n *\n * @see Overlays#get for filter options.\n *\n * @param {String} [id]\n * @param {Object} [filter]\n */\nOverlays.prototype.remove = function(filter) {\n\n  var overlays = this.get(filter) || [];\n\n  if (!isArray(overlays)) {\n    overlays = [ overlays ];\n  }\n\n  var self = this;\n\n  forEach(overlays, function(overlay) {\n\n    var container = self._getOverlayContainer(overlay.element, true);\n\n    if (overlay) {\n      domRemove(overlay.html);\n      domRemove(overlay.htmlContainer);\n\n      delete overlay.htmlContainer;\n      delete overlay.element;\n\n      delete self._overlays[overlay.id];\n    }\n\n    if (container) {\n      var idx = container.overlays.indexOf(overlay);\n      if (idx !== -1) {\n        container.overlays.splice(idx, 1);\n      }\n    }\n  });\n\n};\n\n\nOverlays.prototype.show = function() {\n  setVisible(this._overlayRoot);\n};\n\n\nOverlays.prototype.hide = function() {\n  setVisible(this._overlayRoot, false);\n};\n\nOverlays.prototype.clear = function() {\n  this._overlays = {};\n\n  this._overlayContainers = [];\n\n  domClear(this._overlayRoot);\n};\n\nOverlays.prototype._updateOverlayContainer = function(container) {\n  var element = container.element,\n      html = container.html;\n\n  // update container left,top according to the elements x,y coordinates\n  // this ensures we can attach child elements relative to this container\n\n  var x = element.x,\n      y = element.y;\n\n  if (element.waypoints) {\n    var bbox = getBBox(element);\n    x = bbox.x;\n    y = bbox.y;\n  }\n\n  setPosition(html, x, y);\n\n  domAttr(container.html, 'data-container-id', element.id);\n};\n\n\nOverlays.prototype._updateOverlay = function(overlay) {\n\n  var position = overlay.position,\n      htmlContainer = overlay.htmlContainer,\n      element = overlay.element;\n\n  // update overlay html relative to shape because\n  // it is already positioned on the element\n\n  // update relative\n  var left = position.left,\n      top = position.top;\n\n  if (position.right !== undefined) {\n\n    var width;\n\n    if (element.waypoints) {\n      width = getBBox(element).width;\n    } else {\n      width = element.width;\n    }\n\n    left = position.right * -1 + width;\n  }\n\n  if (position.bottom !== undefined) {\n\n    var height;\n\n    if (element.waypoints) {\n      height = getBBox(element).height;\n    } else {\n      height = element.height;\n    }\n\n    top = position.bottom * -1 + height;\n  }\n\n  setPosition(htmlContainer, left || 0, top || 0);\n};\n\nOverlays.prototype._createOverlayContainer = function(element) {\n  var html = domify('<div class=\"djs-overlays\" style=\"position: absolute\" />');\n\n  this._overlayRoot.appendChild(html);\n\n  var container = {\n    html: html,\n    element: element,\n    overlays: []\n  };\n\n  this._updateOverlayContainer(container);\n\n  this._overlayContainers.push(container);\n\n  return container;\n};\n\n\nOverlays.prototype._updateRoot = function(viewbox) {\n  var a = viewbox.scale || 1;\n  var d = viewbox.scale || 1;\n\n  var matrix = 'matrix(' + a + ',0,0,' + d + ',' + (-1 * viewbox.x * a) + ',' + (-1 * viewbox.y * d) + ')';\n\n  this._overlayRoot.style.transform = matrix;\n  this._overlayRoot.style['-ms-transform'] = matrix;\n  this._overlayRoot.style['-webkit-transform'] = matrix;\n};\n\n\nOverlays.prototype._getOverlayContainer = function(element, raw) {\n  var container = find(this._overlayContainers, function(c) {\n    return c.element === element;\n  });\n\n\n  if (!container && !raw) {\n    return this._createOverlayContainer(element);\n  }\n\n  return container;\n};\n\n\n\n\n\nOverlays.prototype._addOverlay = function(overlay) {\n\n  var id = overlay.id,\n      element = overlay.element,\n      html = overlay.html,\n      htmlContainer,\n      overlayContainer;\n\n  // unwrap jquery (for those who need it)\n  if (html.get) {\n    html = html.get(0);\n  }\n\n  // create proper html elements from\n  // overlay HTML strings\n  if (isString(html)) {\n    html = domify(html);\n  }\n\n  overlayContainer = this._getOverlayContainer(element);\n\n  htmlContainer = domify('<div class=\"djs-overlay\" data-overlay-id=\"' + id + '\" style=\"position: absolute\">');\n\n  htmlContainer.appendChild(html);\n\n  if (overlay.type) {\n    domClasses(htmlContainer).add('djs-overlay-' + overlay.type);\n  }\n\n  overlay.htmlContainer = htmlContainer;\n\n  overlayContainer.overlays.push(overlay);\n  overlayContainer.html.appendChild(htmlContainer);\n\n  this._overlays[id] = overlay;\n\n  this._updateOverlay(overlay);\n  this._updateOverlayVisibilty(overlay, this._canvas.viewbox());\n};\n\nOverlays.prototype._updateOverlayVisibilty = function(overlay, viewbox) {\n  var show = overlay.show,\n      htmlContainer = overlay.htmlContainer,\n      visible = true;\n\n  if (show) {\n    if (show.minZoom > viewbox.scale ||\n        show.maxZoom < viewbox.scale) {\n      visible = false;\n    }\n\n    setVisible(htmlContainer, visible);\n  }\n};\n\nOverlays.prototype._updateOverlaysVisibilty = function(viewbox) {\n\n  var self = this;\n\n  forEach(this._overlays, function(overlay) {\n    self._updateOverlayVisibilty(overlay, viewbox);\n  });\n};\n\n\nOverlays.prototype._init = function() {\n\n  var eventBus = this._eventBus;\n\n  var self = this;\n\n\n  // scroll/zoom integration\n\n  function updateViewbox(viewbox) {\n    self._updateRoot(viewbox);\n    self._updateOverlaysVisibilty(viewbox);\n\n    self.show();\n  }\n\n  eventBus.on('canvas.viewbox.changing', function(event) {\n    self.hide();\n  });\n\n  eventBus.on('canvas.viewbox.changed', function(event) {\n    updateViewbox(event.viewbox);\n  });\n\n\n  // remove integration\n\n  eventBus.on([ 'shape.remove', 'connection.remove' ], function(e) {\n    var element = e.element;\n    var overlays = self.get({ element: element });\n\n    forEach(overlays, function(o) {\n      self.remove(o.id);\n    });\n\n    var container = self._getOverlayContainer(element);\n\n    if (container) {\n      domRemove(container.html);\n      var i = self._overlayContainers.indexOf(container);\n      if (i !== -1) {\n        self._overlayContainers.splice(i, 1);\n      }\n    }\n  });\n\n\n  // move integration\n\n  eventBus.on([\n    'element.changed'\n  ], function(e) {\n    var element = e.element;\n\n    var container = self._getOverlayContainer(element, true);\n\n    if (container) {\n      forEach(container.overlays, function(overlay) {\n        self._updateOverlay(overlay);\n      });\n\n      self._updateOverlayContainer(container);\n    }\n  });\n\n\n  // marker integration, simply add them on the overlays as classes, too.\n\n  eventBus.on('element.marker.update', function(e) {\n    var container = self._getOverlayContainer(e.element, true);\n    if (container) {\n      domClasses(container.html)[e.add ? 'add' : 'remove'](e.marker);\n    }\n  });\n\n\n  // clear overlays with diagram\n\n  eventBus.on('diagram.clear', this.clear, this);\n};\n","module.exports = {\n  __init__: [ 'overlays' ],\n  overlays: [ 'type', require(191) ]\n};","'use strict';\n\nvar isFunction = require(402),\n    forEach = require(283);\n\nvar domify = require(428),\n    domQuery = require(431),\n    domAttr = require(423),\n    domClear = require(425),\n    domClasses = require(424),\n    domMatches = require(430),\n    domDelegate = require(427),\n    domEvent = require(429);\n\n\nvar toggleSelector = '.djs-palette-toggle',\n    entrySelector = '.entry',\n    elementSelector = toggleSelector + ', ' + entrySelector;\n\n\n/**\n * A palette containing modeling elements.\n */\nfunction Palette(eventBus, canvas, dragging) {\n\n  this._eventBus = eventBus;\n  this._canvas = canvas;\n  this._dragging = dragging;\n\n  this._providers = [];\n\n  var self = this;\n\n  eventBus.on('tool-manager.update', function(event) {\n    var tool = event.tool;\n\n    self.updateToolHighlight(tool);\n  });\n\n  eventBus.on('i18n.changed', function() {\n    self._update();\n  });\n}\n\nPalette.$inject = [ 'eventBus', 'canvas', 'dragging' ];\n\nmodule.exports = Palette;\n\n\n/**\n * Register a provider with the palette\n *\n * @param  {PaletteProvider} provider\n */\nPalette.prototype.registerProvider = function(provider) {\n  this._providers.push(provider);\n\n  if (!this._container) {\n    this._init();\n  }\n\n  this._update();\n};\n\n\n/**\n * Returns the palette entries for a given element\n *\n * @return {Array<PaletteEntryDescriptor>} list of entries\n */\nPalette.prototype.getEntries = function() {\n\n  var entries = {};\n\n  // loop through all providers and their entries.\n  // group entries by id so that overriding an entry is possible\n  forEach(this._providers, function(provider) {\n    var e = provider.getPaletteEntries();\n\n    forEach(e, function(entry, id) {\n      entries[id] = entry;\n    });\n  });\n\n  return entries;\n};\n\n\n/**\n * Initialize\n */\nPalette.prototype._init = function() {\n  var canvas = this._canvas,\n      eventBus = this._eventBus;\n\n  var parent = canvas.getContainer(),\n      container = this._container = domify(Palette.HTML_MARKUP),\n      self = this;\n\n  parent.appendChild(container);\n\n  domDelegate.bind(container, elementSelector, 'click', function(event) {\n\n    var target = event.delegateTarget;\n\n    if (domMatches(target, toggleSelector)) {\n      return self.toggle();\n    }\n\n    self.trigger('click', event);\n  });\n\n  // prevent drag propagation\n  domEvent.bind(container, 'mousedown', function(event) {\n    event.stopPropagation();\n  });\n\n  // prevent drag propagation\n  domDelegate.bind(container, entrySelector, 'dragstart', function(event) {\n    self.trigger('dragstart', event);\n  });\n\n  eventBus.fire('palette.create', {\n    html: container\n  });\n\n  eventBus.on('canvas.resized', function() {\n    if (parent.clientHeight < 650) {\n      domClasses(container).add('two-column');\n    } else {\n      domClasses(container).remove('two-column');\n    }\n  });\n};\n\n\nPalette.prototype._update = function() {\n\n  var entriesContainer = domQuery('.djs-palette-entries', this._container),\n      entries = this._entries = this.getEntries();\n\n  domClear(entriesContainer);\n\n  forEach(entries, function(entry, id) {\n\n    var grouping = entry.group || 'default';\n\n    var container = domQuery('[data-group=' + grouping + ']', entriesContainer);\n    if (!container) {\n      container = domify('<div class=\"group\" data-group=\"' + grouping + '\"></div>');\n      entriesContainer.appendChild(container);\n    }\n\n    var html = entry.html || (\n      entry.separator ?\n        '<hr class=\"separator\" />' :\n        '<div class=\"entry\" draggable=\"true\"></div>');\n\n\n    var control = domify(html);\n    container.appendChild(control);\n\n    if (!entry.separator) {\n      domAttr(control, 'data-action', id);\n\n      if (entry.title) {\n        domAttr(control, 'title', entry.title);\n      }\n\n      if (entry.className) {\n        domClasses(control).add(entry.className);\n      }\n\n      if (entry.imageUrl) {\n        control.appendChild(domify('<img src=\"' + entry.imageUrl + '\">'));\n      }\n    }\n  });\n\n  // open after update\n  this.open(true);\n};\n\n\n/**\n * Trigger an action available on the palette\n *\n * @param  {String} action\n * @param  {Event} event\n */\nPalette.prototype.trigger = function(action, event, autoActivate) {\n  var entries = this._entries,\n      entry,\n      handler,\n      originalEvent,\n      button = event.delegateTarget || event.target;\n\n  if (!button) {\n    return event.preventDefault();\n  }\n\n  entry = entries[domAttr(button, 'data-action')];\n\n  // when user clicks on the palette and not on an action\n  if (!entry) {\n    return;\n  }\n\n  handler = entry.action;\n\n  originalEvent = event.originalEvent || event;\n\n  // simple action (via callback function)\n  if (isFunction(handler)) {\n    if (action === 'click') {\n      handler(originalEvent, autoActivate);\n    }\n  } else {\n    if (handler[action]) {\n      handler[action](originalEvent, autoActivate);\n    }\n  }\n\n  // silence other actions\n  event.preventDefault();\n};\n\n\n/**\n * Close the palette\n */\nPalette.prototype.close = function() {\n  domClasses(this._container).remove('open');\n};\n\n\n/**\n * Open the palette\n */\nPalette.prototype.open = function() {\n  domClasses(this._container).add('open');\n};\n\n\nPalette.prototype.toggle = function(open) {\n  if (this.isOpen()) {\n    this.close();\n  } else {\n    this.open();\n  }\n};\n\nPalette.prototype.isActiveTool = function(tool) {\n  return tool && this._activeTool === tool;\n};\n\nPalette.prototype.updateToolHighlight = function(name) {\n  var entriesContainer,\n      toolsContainer;\n\n  if (!this._toolsContainer) {\n    entriesContainer = domQuery('.djs-palette-entries', this._container);\n\n    this._toolsContainer = domQuery('[data-group=tools]', entriesContainer);\n  }\n\n  toolsContainer = this._toolsContainer;\n\n  forEach(toolsContainer.children, function(tool) {\n    var actionName = tool.getAttribute('data-action');\n\n    if (!actionName) {\n      return;\n    }\n\n    actionName = actionName.replace('-tool', '');\n\n    if (tool.classList.contains('entry') && actionName === name) {\n      domClasses(tool).add('highlighted-entry');\n    } else {\n      domClasses(tool).remove('highlighted-entry');\n    }\n  });\n};\n\n\n/**\n * Return true if the palette is opened.\n *\n * @example\n *\n * palette.open();\n *\n * if (palette.isOpen()) {\n *   // yes, we are open\n * }\n *\n * @return {boolean} true if palette is opened\n */\nPalette.prototype.isOpen = function() {\n  return this._container && domClasses(this._container).has('open');\n};\n\n\n/* markup definition */\n\nPalette.HTML_MARKUP =\n  '<div class=\"djs-palette\">' +\n    '<div class=\"djs-palette-entries\"></div>' +\n    '<div class=\"djs-palette-toggle\"></div>' +\n  '</div>';\n","'use strict';\n\nmodule.exports = {\n  __depends__: [ require(223) ],\n  __init__: [ 'palette' ],\n  palette: [ 'type', require(193) ]\n};\n","'use strict';\n\nvar forEach = require(283),\n    assign = require(410),\n    find = require(282);\n\nvar domDelegate = require(427),\n    domify = require(428),\n    domClasses = require(424),\n    domAttr = require(423),\n    domRemove = require(432);\n\nvar DATA_REF = 'data-id';\n\n/**\n * A popup menu that can be used to display a list of actions anywhere in the canvas.\n *\n * @param {EventBus} eventBus\n * @param {Canvas} canvas\n *\n * @class\n * @constructor\n */\nfunction PopupMenu(eventBus, canvas) {\n\n  this._eventBus = eventBus;\n  this._canvas  = canvas;\n  this._providers = {};\n}\n\nPopupMenu.$inject = [ 'eventBus', 'canvas' ];\n\n/**\n * Registers a popup menu provider\n *\n * @param  {String} id\n * @param  {Object} provider\n *\n * @example\n * popupMenu.registerProvider('myMenuID', {\n *   getEntries: function(element) {\n *     return [\n *       {\n *          id: 'entry-1',\n *          label: 'My Entry',\n *          action: 'alert(\"I have been clicked!\")'\n *        }\n *      ];\n *    }\n *  });\n * })\n */\nPopupMenu.prototype.registerProvider = function(id, provider) {\n  this._providers[id] = provider;\n};\n\n\n/**\n * Create a popup menu according to a given element. The id refers to the ID\n * of the provider that must be registered before.\n *\n * @param  {String} id provider id\n * @param  {Object} element\n *\n * @return {PopupMenu} popup menu instance\n */\nPopupMenu.prototype.create = function(id, element) {\n\n  var provider = this._providers[id];\n\n  if (!provider) {\n    throw new Error('Provider is not registered: ' + id);\n  }\n\n  if (!element) {\n    throw new Error('Element is missing');\n  }\n\n  var current = this._current = {\n    provider: provider,\n    className: id,\n    element: element\n  };\n\n  if (provider.getHeaderEntries) {\n    current.headerEntries = provider.getHeaderEntries(element);\n  }\n\n  current.entries = provider.getEntries(element);\n\n  return this;\n};\n\n\n/**\n * Determine if the popup menu has entries.\n *\n * @return {Boolean} true if empty\n */\nPopupMenu.prototype.isEmpty = function() {\n\n  var current = this._current;\n\n  return current.entries.length === 0 && current.headerEntries && current.headerEntries.length === 0;\n};\n\n\n/**\n * Open popup menu at given position\n *\n * @param {Object} position\n *\n * @return {Object} popup menu instance\n */\nPopupMenu.prototype.open = function(position) {\n\n  if (!position) {\n    throw new Error('the position argument is missing');\n  }\n\n  // make sure, only one popup menu is open at a time\n  if (this.isOpen()) {\n    this.close();\n  }\n\n  var current = this._current,\n      canvas = this._canvas,\n      parent = canvas.getContainer();\n\n  current.position = position;\n\n  current.container = this._createContainer();\n\n  if (current.headerEntries) {\n    var headerEntriesContainer = this._createEntries(current.headerEntries, 'djs-popup-header');\n\n    current.container.appendChild(headerEntriesContainer);\n  }\n\n  if (current.entries) {\n    var entriesContainer = this._createEntries(current.entries, 'djs-popup-body');\n\n    current.container.appendChild(entriesContainer);\n  }\n\n  this._attachContainer(current.container, parent, position.cursor);\n\n  return this;\n};\n\n\n/**\n * Removes the popup menu and unbinds the event handlers.\n */\nPopupMenu.prototype.close = function() {\n\n  if (!this.isOpen()) {\n    return;\n  }\n\n  this._unbindHandlers();\n  domRemove(this._current.container);\n  this._current.container = null;\n};\n\n\n/**\n * Determine if an open popup menu exist.\n *\n * @return {Boolean} true if open\n */\nPopupMenu.prototype.isOpen = function() {\n  return !!this._current.container;\n};\n\n\n/**\n * Trigger an action associated with an entry.\n *\n * @param {Object} event\n *\n * @return the result of the action callback, if any\n */\nPopupMenu.prototype.trigger = function(event) {\n\n  // silence other actions\n  event.preventDefault();\n\n  var element = event.delegateTarget || event.target,\n      entryId = domAttr(element, DATA_REF);\n\n  var entry = this._getEntry(entryId);\n\n  if (entry.action) {\n    return entry.action.call(null, event, entry);\n  }\n};\n\n/**\n * Gets an entry instance (either entry or headerEntry) by id.\n *\n * @param  {String} entryId\n *\n * @return {Object} entry instance\n */\nPopupMenu.prototype._getEntry = function(entryId) {\n\n  var search = { id: entryId };\n\n  var entry = find(this._current.entries, search) || find(this._current.headerEntries, search);\n\n  if (!entry) {\n    throw new Error('entry not found');\n  }\n\n  return entry;\n};\n\n\n/**\n * Creates the popup menu container.\n *\n * @return {Object} a DOM container\n */\nPopupMenu.prototype._createContainer = function() {\n  var container = domify('<div class=\"djs-popup\">'),\n      position = this._current.position,\n      className = this._current.className;\n\n  assign(container.style, {\n    position: 'absolute',\n    left: position.x + 'px',\n    top: position.y + 'px',\n    visibility: 'hidden'\n  });\n\n  domClasses(container).add(className);\n\n  return container;\n};\n\n\n/**\n * Attaches the container to the DOM and binds the event handlers.\n *\n * @param {Object} container\n * @param {Object} parent\n */\nPopupMenu.prototype._attachContainer = function(container, parent, cursor) {\n  var self = this;\n\n   // Event handler\n  domDelegate.bind(container, '.entry' ,'click', function(event) {\n    self.trigger(event);\n  });\n\n  // apply canvas zoom level\n  var zoom = this._canvas.zoom();\n\n  container.style.transformOrigin = 'top left';\n  container.style.transform = 'scale(' + zoom + ')';\n\n  // Attach to DOM\n  parent.appendChild(container);\n\n  if (cursor) {\n    this._assureIsInbounds(container, cursor);\n  }\n\n  // Add Handler\n  this._bindHandlers();\n};\n\n\n/**\n * Make sure that the menu is always fully shown\n *\n * @method function\n *\n * @param  {Object} container\n * @param  {Position} cursor {x, y}\n */\nPopupMenu.prototype._assureIsInbounds = function(container, cursor) {\n  var canvas = this._canvas,\n      clientRect = canvas._container.getBoundingClientRect();\n\n  var containerX = container.offsetLeft,\n      containerY = container.offsetTop,\n      containerWidth = container.scrollWidth,\n      containerHeight = container.scrollHeight,\n      overAxis = {},\n      left, top;\n\n  var cursorPosition = {\n    x: cursor.x - clientRect.left,\n    y: cursor.y - clientRect.top\n  };\n\n  if (containerX + containerWidth > clientRect.width) {\n    overAxis.x = true;\n  }\n\n  if (containerY + containerHeight > clientRect.height) {\n    overAxis.y = true;\n  }\n\n  if (overAxis.x && overAxis.y) {\n    left = cursorPosition.x - containerWidth + 'px';\n    top = cursorPosition.y - containerHeight + 'px';\n  } else if (overAxis.x) {\n    left = cursorPosition.x - containerWidth + 'px';\n    top = cursorPosition.y + 'px';\n  } else if (overAxis.y && cursorPosition.y < containerHeight) {\n    left = cursorPosition.x + 'px';\n    top = 10 + 'px';\n  } else if (overAxis.y) {\n    left = cursorPosition.x + 'px';\n    top = cursorPosition.y - containerHeight + 'px';\n  }\n\n  assign(container.style, { left: left, top: top }, { visibility: 'visible', 'z-index': 1000 });\n};\n\n\n/**\n * Creates a list of entries and returns them as a DOM container.\n *\n * @param {Array<Object>} entries an array of entry objects\n * @param {String} className the class name of the entry container\n *\n * @return {Object} a DOM container\n */\nPopupMenu.prototype._createEntries = function(entries, className) {\n\n  var entriesContainer = domify('<div>'),\n      self = this;\n\n  domClasses(entriesContainer).add(className);\n\n  forEach(entries, function(entry) {\n    var entryContainer = self._createEntry(entry, entriesContainer);\n    entriesContainer.appendChild(entryContainer);\n  });\n\n  return entriesContainer;\n};\n\n\n/**\n * Creates a single entry and returns it as a DOM container.\n *\n * @param  {Object} entry\n *\n * @return {Object} a DOM container\n */\nPopupMenu.prototype._createEntry = function(entry) {\n\n  if (!entry.id) {\n    throw new Error ('every entry must have the id property set');\n  }\n\n  var entryContainer = domify('<div>'),\n      entryClasses = domClasses(entryContainer);\n\n  entryClasses.add('entry');\n\n  if (entry.className) {\n    entryClasses.add(entry.className);\n  }\n\n  domAttr(entryContainer, DATA_REF, entry.id);\n\n  if (entry.label) {\n    var label = domify('<span>');\n    label.textContent = entry.label;\n    entryContainer.appendChild(label);\n  }\n\n  if (entry.imageUrl) {\n    entryContainer.appendChild(domify('<img src=\"' + entry.imageUrl + '\" />'));\n  }\n\n  if (entry.active === true) {\n    entryClasses.add('active');\n  }\n\n  if (entry.disabled === true) {\n    entryClasses.add('disabled');\n  }\n\n  if (entry.title) {\n    entryContainer.title = entry.title;\n  }\n\n  return entryContainer;\n};\n\n\n/**\n * Binds the `close` method to 'contextPad.close' & 'canvas.viewbox.changed'.\n */\nPopupMenu.prototype._bindHandlers = function() {\n\n  var eventBus = this._eventBus,\n      self = this;\n\n  function close() {\n    self.close();\n  }\n\n  eventBus.once('contextPad.close', close);\n  eventBus.once('canvas.viewbox.changing', close);\n  eventBus.once('commandStack.changed', close);\n};\n\n\n/**\n * Unbinds the `close` method to 'contextPad.close' & 'canvas.viewbox.changing'.\n */\nPopupMenu.prototype._unbindHandlers = function() {\n\n  var eventBus = this._eventBus,\n      self = this;\n\n  function close() {\n    self.close();\n  }\n\n  eventBus.off('contextPad.close', close);\n  eventBus.off('canvas.viewbox.changed', close);\n  eventBus.off('commandStack.changed', close);\n};\n\nmodule.exports = PopupMenu;\n","'use strict';\n\nmodule.exports = {\n  __init__: [ 'popupMenu' ],\n  popupMenu: [ 'type', require(195) ]\n};\n","'use strict';\r\n\r\nvar forEach = require(283);\r\n\r\nvar Snap = require(267);\r\n\r\n/**\r\n * Adds support for previews of moving/resizing elements.\r\n */\r\nfunction PreviewSupport(elementRegistry, canvas, styles) {\r\n  this._elementRegistry = elementRegistry;\r\n  this._canvas = canvas;\r\n  this._styles = styles;\r\n}\r\n\r\nmodule.exports = PreviewSupport;\r\n\r\nPreviewSupport.$inject = [ 'elementRegistry', 'canvas', 'styles' ];\r\n\r\n\r\n/**\r\n * Returns graphics of an element.\r\n *\r\n * @param {djs.model.Base} element\r\n *\r\n * @return {Snap<SVGElement>}\r\n */\r\nPreviewSupport.prototype.getGfx = function(element) {\r\n  return this._elementRegistry.getGraphics(element);\r\n};\r\n\r\n/**\r\n * Adds a move preview of a given shape to a given snapsvg group.\r\n *\r\n * @param {djs.model.Base} element\r\n * @param {Snap<SVGElement>} group\r\n *\r\n * @return {Snap<SVGElement>} dragger\r\n */\r\nPreviewSupport.prototype.addDragger = function(shape, group) {\r\n  var gfx = this.getGfx(shape);\r\n  var dragger = gfx.clone();\r\n  var bbox = gfx.getBBox();\r\n\r\n  // remove markers from connections\r\n  if (isConnection(shape)) {\r\n    removeMarkers(dragger);\r\n  }\r\n\r\n  dragger.attr(this._styles.cls('djs-dragger', [], {\r\n    x: bbox.x,\r\n    y: bbox.y\r\n  }));\r\n\r\n  group.add(dragger);\r\n\r\n  return dragger;\r\n};\r\n\r\n/**\r\n * Adds a resize preview of a given shape to a given snapsvg group.\r\n *\r\n * @param {djs.model.Base} element\r\n * @param {Snap<SVGElement>} group\r\n *\r\n * @return {Snap<SVGElement>} frame\r\n */\r\nPreviewSupport.prototype.addFrame = function(shape, group) {\r\n\r\n  var frame = Snap.create('rect', {\r\n    class: 'djs-resize-overlay',\r\n    width:  shape.width,\r\n    height: shape.height,\r\n    x: shape.x,\r\n    y: shape.y\r\n  });\r\n\r\n  group.add(frame);\r\n\r\n  return frame;\r\n};\r\n\r\n////////// helpers //////////\r\n\r\n/**\r\n * Removes all svg marker references from an SVG.\r\n *\r\n * @param {Snap<SVGElement>} gfx\r\n */\r\nfunction removeMarkers(gfx) {\r\n\r\n  if (gfx.node) {\r\n\r\n    // snapsvg paper element\r\n    forEach(gfx.node.childNodes, function(childNode) {\r\n      if (childNode.node) {\r\n\r\n        // recursion\r\n        removeMarkers(childNode.node);\r\n\r\n      } else if (childNode.childNodes) {\r\n\r\n        forEach(childNode.childNodes, function(childNodeChild) {\r\n\r\n          // recursion\r\n          removeMarkers(childNodeChild);\r\n        });\r\n\r\n      }\r\n    });\r\n\r\n  } else {\r\n\r\n    // plain svg element\r\n    gfx.style.markerStart = '';\r\n    gfx.style.markerEnd = '';\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * Checks if an element is a connection.\r\n */\r\nfunction isConnection(element) {\r\n  return element.waypoints;\r\n}\r\n","'use strict';\n\nmodule.exports = {\n  __init__: [ 'previewSupport' ],\n  previewSupport: [ 'type', require(197) ]\n};\n","'use strict';\n\n\n/**\n * Service that allow replacing of elements.\n *\n *\n * @class\n * @constructor\n */\nfunction Replace(modeling) {\n\n  this._modeling = modeling;\n}\n\nmodule.exports = Replace;\n\nReplace.$inject = [ 'modeling' ];\n\n/**\n * @param {Element} oldElement - Element to be replaced\n * @param {Object}  newElementData - Containing information about the new Element, for example height, width, type.\n * @param {Object}  options - Custom options that will be attached to the context. It can be used to inject data\n *                            that is needed in the command chain. For example it could be used in\n *                            eventbus.on('commandStack.shape.replace.postExecute') to change shape attributes after\n *                            shape creation.\n */\nReplace.prototype.replaceElement = function(oldElement, newElementData, options) {\n\n  var modeling = this._modeling;\n\n  var newElement = null;\n\n  if (oldElement.waypoints) {\n    // TODO\n    // modeling.replaceConnection\n  } else {\n    // set center of element for modeling API\n    // if no new width / height is given use old elements size\n    newElementData.x = Math.ceil(oldElement.x + (newElementData.width || oldElement.width) / 2);\n    newElementData.y = Math.ceil(oldElement.y + (newElementData.height || oldElement.height) / 2);\n\n    newElement = modeling.replaceShape(oldElement, newElementData, options);\n  }\n\n  return newElement;\n};\n","'use strict';\n\nmodule.exports = {\n  __init__: [ 'replace' ],\n  replace: [ 'type', require(199) ]\n};\n","'use strict';\n\nvar pick = require(417),\n    assign = require(410);\n\nvar ResizeUtil = require(204);\n\nvar asTRBL = require(233).asTRBL,\n    roundBounds = require(233).roundBounds;\n\nvar DEFAULT_MIN_WIDTH = 10;\n\n\n/**\n * A component that provides resizing of shapes on the canvas.\n *\n * The following components are part of shape resize:\n *\n *  * adding resize handles,\n *  * creating a visual during resize\n *  * checking resize rules\n *  * committing a change once finished\n *\n *\n * ## Customizing\n *\n * It's possible to customize the resizing behaviour by intercepting 'resize.start'\n * and providing the following parameters through the 'context':\n *\n *   * minDimensions ({ width, height }): minimum shape dimensions\n *\n *   * childrenBoxPadding ({ left, top, bottom, right } || number):\n *     gap between the minimum bounding box and the container\n *\n * f.ex:\n *\n * ```javascript\n * eventBus.on('resize.start', 1500, function(event) {\n *   var context = event.context,\n *\n *  context.minDimensions = { width: 140, height: 120 };\n *\n *  // Passing general padding\n *  context.childrenBoxPadding = 30;\n *\n *  // Passing padding to a specific side\n *  context.childrenBoxPadding.left = 20;\n * });\n * ```\n */\nfunction Resize(eventBus, rules, modeling, dragging) {\n\n  this._dragging = dragging;\n  this._rules = rules;\n\n  var self = this;\n\n  eventBus.on('resize.start', function(event) {\n\n    var context = event.context,\n        resizeConstraints = context.resizeConstraints,\n        // evaluate minBounds for backwards compatibility\n        minBounds = context.minBounds;\n\n    if (resizeConstraints === undefined) {\n\n      if (minBounds === undefined) {\n        minBounds = self.computeMinResizeBox(context);\n      }\n\n      context.resizeConstraints = {\n        min: asTRBL(minBounds)\n      };\n    }\n  });\n\n  eventBus.on('resize.move', function(event) {\n\n    var context = event.context,\n        shape = context.shape,\n        direction = context.direction,\n        resizeConstraints = context.resizeConstraints,\n        delta,\n        newBounds;\n\n    delta = {\n      x: event.dx,\n      y: event.dy\n    };\n\n    context.delta = delta;\n\n    newBounds = ResizeUtil.resizeBounds(shape, direction, delta);\n\n    // ensure constraints during resize\n    context.newBounds = ResizeUtil.ensureConstraints(newBounds, resizeConstraints);\n\n    // update + cache executable state\n    context.canExecute = self.canResize(context);\n  });\n\n  eventBus.on('resize.end', function(event) {\n    var context = event.context,\n        shape = context.shape,\n        canExecute = context.canExecute,\n        newBounds = context.newBounds;\n\n    if (canExecute) {\n      // ensure we have actual pixel values for new bounds\n      // (important when zoom level was > 1 during move)\n      newBounds = roundBounds(newBounds);\n\n      // perform the actual resize\n      modeling.resizeShape(shape, newBounds);\n    }\n  });\n}\n\n\nResize.prototype.canResize = function(context) {\n  var rules = this._rules;\n\n  var ctx = pick(context, [ 'newBounds', 'shape', 'delta', 'direction' ]);\n\n  return rules.allowed('shape.resize', ctx);\n};\n\n/**\n * Activate a resize operation\n *\n * You may specify additional contextual information and must specify a\n * resize direction during activation of the resize event.\n *\n * @param {MouseEvent} event\n * @param {djs.model.Shape} shape\n * @param {Object|String} contextOrDirection\n */\nResize.prototype.activate = function(event, shape, contextOrDirection) {\n  var dragging = this._dragging,\n      context,\n      direction;\n\n  if (typeof contextOrDirection === 'string') {\n    contextOrDirection = {\n      direction: contextOrDirection\n    };\n  }\n\n  context = assign({ shape: shape }, contextOrDirection);\n\n  direction = context.direction;\n\n  if (!direction) {\n    throw new Error('must provide a direction (nw|se|ne|sw)');\n  }\n\n  dragging.init(event, 'resize', {\n    autoActivate: true,\n    cursor: 'resize-' + (/nw|se/.test(direction) ? 'nwse' : 'nesw'),\n    data: {\n      shape: shape,\n      context: context\n    }\n  });\n};\n\nResize.prototype.computeMinResizeBox = function(context) {\n  var shape = context.shape,\n      direction = context.direction,\n      minDimensions,\n      childrenBounds;\n\n  minDimensions = context.minDimensions || {\n    width: DEFAULT_MIN_WIDTH,\n    height: DEFAULT_MIN_WIDTH\n  };\n\n  // get children bounds\n  childrenBounds = ResizeUtil.computeChildrenBBox(shape, context.childrenBoxPadding);\n\n  // get correct minimum bounds from given resize direction\n  // basically ensures that the minBounds is max(childrenBounds, minDimensions)\n  return ResizeUtil.getMinResizeBounds(direction, shape, minDimensions, childrenBounds);\n};\n\n\nResize.$inject = [ 'eventBus', 'rules', 'modeling', 'dragging' ];\n\nmodule.exports = Resize;\n","'use strict';\n\nvar forEach = require(283);\n\nvar Snap = require(267);\n\nvar HANDLE_OFFSET = -2,\n    HANDLE_SIZE  = 5,\n    HANDLE_HIT_SIZE = 20;\n\nvar CLS_RESIZER   = 'djs-resizer';\n\nvar domEvent = require(429);\n\nvar isPrimaryButton = require(254).isPrimaryButton;\n\nvar asTRBL = require(233).asTRBL;\n\n\n/**\n * This component is responsible for adding resize handles.\n *\n * @param {EventBus} eventBus\n * @param {Canvas} canvas\n * @param {Selection} selection\n * @param {Resize} resize\n */\nfunction ResizeHandles(eventBus, canvas, selection, resize) {\n\n  this._resize = resize;\n  this._canvas = canvas;\n\n  var self = this;\n\n  eventBus.on('selection.changed', function(e) {\n    var newSelection = e.newSelection;\n\n    // remove old selection markers\n    self.removeResizers();\n\n    // add new selection markers ONLY if single selection\n    if (newSelection.length === 1) {\n      forEach(newSelection, self.addResizer, self);\n    }\n  });\n\n  eventBus.on('shape.changed', function(e) {\n    var shape = e.element;\n\n    if (selection.isSelected(shape)) {\n      self.removeResizers();\n\n      self.addResizer(shape);\n    }\n  });\n}\n\n\nResizeHandles.prototype.makeDraggable = function(element, gfx, direction) {\n  var resize = this._resize;\n\n  function startResize(event) {\n    // only trigger on left mouse button\n    if (isPrimaryButton(event)) {\n      resize.activate(event, element, direction);\n    }\n  }\n\n  domEvent.bind(gfx.node, 'mousedown', startResize);\n  domEvent.bind(gfx.node, 'touchstart', startResize);\n};\n\n\nResizeHandles.prototype._createResizer = function(element, x, y, rotation, direction) {\n  var resizersParent = this._getResizersParent();\n\n  var group = resizersParent.group()\n                  .addClass(CLS_RESIZER)\n                  .addClass(CLS_RESIZER + '-' + element.id)\n                  .addClass(CLS_RESIZER + '-' + direction);\n\n  var origin = -HANDLE_SIZE + HANDLE_OFFSET;\n\n  // Create four drag indicators on the outline\n  group.rect(origin, origin, HANDLE_SIZE, HANDLE_SIZE).addClass(CLS_RESIZER + '-visual');\n  group.rect(origin, origin, HANDLE_HIT_SIZE, HANDLE_HIT_SIZE).addClass(CLS_RESIZER + '-hit');\n\n  var matrix = new Snap.Matrix().translate(x, y).rotate(rotation, 0, 0);\n\n  group.transform(matrix);\n\n  return group;\n};\n\nResizeHandles.prototype.createResizer = function(element, direction) {\n  var resizer;\n\n  var trbl = asTRBL(element);\n\n  if (direction === 'nw') {\n    resizer = this._createResizer(element, trbl.left, trbl.top, 0, direction);\n  } else if (direction === 'ne') {\n    resizer = this._createResizer(element, trbl.right, trbl.top, 90, direction);\n  } else if (direction === 'se') {\n    resizer = this._createResizer(element, trbl.right, trbl.bottom, 180, direction);\n  } else {\n    resizer = this._createResizer(element, trbl.left, trbl.bottom, 270, direction);\n  }\n\n  this.makeDraggable(element, resizer, direction);\n};\n\n// resize handles implementation ///////////////////////////////\n\n/**\n * Add resizers for a given element.\n *\n * @param {djs.model.Shape} shape\n */\nResizeHandles.prototype.addResizer = function(shape) {\n  var resize = this._resize;\n\n  if (!resize.canResize({ shape: shape })) {\n    return;\n  }\n\n  this.createResizer(shape, 'nw');\n  this.createResizer(shape, 'ne');\n  this.createResizer(shape, 'se');\n  this.createResizer(shape, 'sw');\n};\n\n/**\n * Remove all resizers\n */\nResizeHandles.prototype.removeResizers = function() {\n\n  var resizersParent = this._getResizersParent();\n\n  var resizers = resizersParent.selectAll('.' + CLS_RESIZER);\n\n  forEach(resizers, function(resizer) {\n    resizer.remove();\n  });\n};\n\nResizeHandles.prototype._getResizersParent = function() {\n  return this._canvas.getLayer('resizers');\n};\n\nResizeHandles.$inject = [ 'eventBus', 'canvas', 'selection', 'resize' ];\n\nmodule.exports = ResizeHandles;\n","'use strict';\n\nvar MARKER_RESIZING = 'djs-resizing',\n    MARKER_RESIZE_NOT_OK = 'resize-not-ok';\n\nvar LOW_PRIORITY = 500;\n\n/**\n * Provides previews for resizing shapes when resizing.\n *\n * @param {EventBus} eventBus\n * @param {ElementRegistry} elementRegistry\n * @param {Canvas} canvas\n * @param {Styles} styles\n */\nfunction ResizePreview(eventBus, elementRegistry, canvas, styles, previewSupport) {\n\n  // add and update previews\n  eventBus.on('resize.move', LOW_PRIORITY, function(event) {\n    var context = event.context,\n        shape = context.shape,\n        bounds = context.newBounds,\n        frame = context.frame;\n\n    if (!frame) {\n      frame = context.frame = previewSupport.addFrame(shape, canvas.getDefaultLayer());\n\n      canvas.addMarker(shape, MARKER_RESIZING);\n    }\n\n    if (bounds.width > 5) {\n      frame.attr({ x: bounds.x, width: bounds.width });\n    }\n\n    if (bounds.height > 5) {\n      frame.attr({ y: bounds.y, height: bounds.height });\n    }\n\n    frame[context.canExecute ? 'removeClass' : 'addClass'](MARKER_RESIZE_NOT_OK);\n  });\n\n  // remove previews\n  eventBus.on('resize.cleanup', function(event) {\n    var context = event.context,\n        shape = context.shape,\n        frame = context.frame;\n\n    if (frame) {\n      context.frame.remove();\n    }\n\n    canvas.removeMarker(shape, MARKER_RESIZING);\n  });\n}\n\nResizePreview.$inject = [ 'eventBus', 'elementRegistry', 'canvas', 'styles', 'previewSupport'];\n\nmodule.exports = ResizePreview;\n","'use strict';\n\nvar filter = require(281);\n\nvar max = Math.max,\n    min = Math.min;\n\nvar DEFAULT_CHILD_BOX_PADDING = 20;\n\nvar getBBox = require(247).getBBox;\n\n\nvar asTRBL = require(233).asTRBL,\n    asBounds = require(233).asBounds;\n\nfunction isNumber(a) {\n  return typeof a === 'number';\n}\n\n/**\n * Substract a TRBL from another\n *\n * @param  {TRBL} trblA\n * @param  {TRBL} trblB\n *\n * @return {TRBL}\n */\nmodule.exports.substractTRBL = function(trblA, trblB) {\n  return {\n    top: trblA.top - trblB.top,\n    right: trblA.right - trblB.right,\n    bottom: trblA.bottom - trblB.bottom,\n    left: trblA.left - trblB.left\n  };\n};\n\n/**\n * Resize the given bounds by the specified delta from a given anchor point.\n *\n * @param {Bounds} bounds the bounding box that should be resized\n * @param {String} direction in which the element is resized (nw, ne, se, sw)\n * @param {Point} delta of the resize operation\n *\n * @return {Bounds} resized bounding box\n */\nmodule.exports.resizeBounds = function(bounds, direction, delta) {\n\n  var dx = delta.x,\n      dy = delta.y;\n\n  switch (direction) {\n\n  case 'nw':\n    return {\n      x: bounds.x + dx,\n      y: bounds.y + dy,\n      width: bounds.width - dx,\n      height: bounds.height - dy\n    };\n\n  case 'sw':\n    return {\n      x: bounds.x + dx,\n      y: bounds.y,\n      width: bounds.width - dx,\n      height: bounds.height + dy\n    };\n\n  case 'ne':\n    return {\n      x: bounds.x,\n      y: bounds.y + dy,\n      width: bounds.width + dx,\n      height: bounds.height - dy\n    };\n\n  case 'se':\n    return {\n      x: bounds.x,\n      y: bounds.y,\n      width: bounds.width + dx,\n      height: bounds.height + dy\n    };\n\n  default:\n    throw new Error('unrecognized direction: ' + direction);\n  }\n};\n\n\n/**\n * Resize the given bounds by applying the passed\n * { top, right, bottom, left } delta.\n *\n * @param {Bounds} bounds\n * @param {TRBL} trblResize\n *\n * @return {Bounds}\n */\nmodule.exports.resizeTRBL = function(bounds, resize) {\n  return {\n    x: bounds.x + (resize.left || 0),\n    y: bounds.y + (resize.top || 0),\n    width: bounds.width - (resize.left || 0) + (resize.right || 0),\n    height: bounds.height - (resize.top || 0) + (resize.bottom || 0)\n  };\n};\n\n\nmodule.exports.reattachPoint = function(bounds, newBounds, point) {\n\n  var sx = bounds.width / newBounds.width,\n      sy = bounds.height / newBounds.height;\n\n  return {\n    x: Math.round((newBounds.x + newBounds.width / 2)) - Math.floor(((bounds.x + bounds.width / 2) - point.x) / sx),\n    y: Math.round((newBounds.y + newBounds.height / 2)) - Math.floor(((bounds.y + bounds.height / 2) - point.y) / sy)\n  };\n};\n\n\nfunction applyConstraints(attr, trbl, resizeConstraints) {\n\n  var value = trbl[attr],\n      minValue = resizeConstraints.min && resizeConstraints.min[attr],\n      maxValue = resizeConstraints.max && resizeConstraints.max[attr];\n\n  if (isNumber(minValue)) {\n    value = (/top|left/.test(attr) ? min : max)(value, minValue);\n  }\n\n  if (isNumber(maxValue)) {\n    value = (/top|left/.test(attr) ? max : min)(value, maxValue);\n  }\n\n  return value;\n}\n\nmodule.exports.ensureConstraints = function(currentBounds, resizeConstraints) {\n\n  if (!resizeConstraints) {\n    return currentBounds;\n  }\n\n  var currentTrbl = asTRBL(currentBounds);\n\n  return asBounds({\n    top: applyConstraints('top', currentTrbl, resizeConstraints),\n    right: applyConstraints('right', currentTrbl, resizeConstraints),\n    bottom: applyConstraints('bottom', currentTrbl, resizeConstraints),\n    left: applyConstraints('left', currentTrbl, resizeConstraints)\n  });\n};\n\n\nmodule.exports.getMinResizeBounds = function(direction, currentBounds, minDimensions, childrenBounds) {\n\n  var currentBox = asTRBL(currentBounds);\n\n  var minBox = {\n    top: /n/.test(direction) ? currentBox.bottom - minDimensions.height : currentBox.top,\n    left: /w/.test(direction) ? currentBox.right - minDimensions.width : currentBox.left,\n    bottom: /s/.test(direction) ? currentBox.top + minDimensions.height : currentBox.bottom,\n    right: /e/.test(direction) ? currentBox.left + minDimensions.width : currentBox.right\n  };\n\n  var childrenBox = childrenBounds ? asTRBL(childrenBounds) : minBox;\n\n  var combinedBox = {\n    top: min(minBox.top, childrenBox.top),\n    left: min(minBox.left, childrenBox.left),\n    bottom: max(minBox.bottom, childrenBox.bottom),\n    right: max(minBox.right, childrenBox.right)\n  };\n\n  return asBounds(combinedBox);\n};\n\nfunction asPadding(mayBePadding, defaultValue) {\n  if (typeof mayBePadding !== 'undefined') {\n    return mayBePadding;\n  } else {\n    return DEFAULT_CHILD_BOX_PADDING;\n  }\n}\n\nfunction addPadding(bbox, padding) {\n  var left, right, top, bottom;\n\n  if (typeof padding === 'object') {\n    left = asPadding(padding.left);\n    right = asPadding(padding.right);\n    top = asPadding(padding.top);\n    bottom = asPadding(padding.bottom);\n  } else {\n    left = right = top = bottom = asPadding(padding);\n  }\n\n  return {\n    x: bbox.x - left,\n    y: bbox.y - top,\n    width: bbox.width + left + right,\n    height: bbox.height + top + bottom\n  };\n}\n\nmodule.exports.addPadding = addPadding;\n\n\n/**\n * Is the given element part of the resize\n * targets min boundary box?\n *\n * This is the default implementation which excludes\n * connections and labels.\n *\n * @param {djs.model.Base} element\n */\nfunction isBBoxChild(element) {\n\n  // exclude connections\n  if (element.waypoints) {\n    return false;\n  }\n\n  // exclude labels\n  if (element.type === 'label') {\n    return false;\n  }\n\n  return true;\n}\n\n/**\n * Return children bounding computed from a shapes children\n * or a list of prefiltered children.\n *\n * @param  {djs.model.Shape|Array<djs.model.Shape>} shapeOrChildren\n * @param  {Number|Object} padding\n *\n * @return {Bounds}\n */\nfunction computeChildrenBBox(shapeOrChildren, padding) {\n\n  var elements;\n\n  // compute based on shape\n  if (shapeOrChildren.length === undefined) {\n    // grab all the children that are part of the\n    // parents children box\n    elements = filter(shapeOrChildren.children, isBBoxChild);\n\n  } else {\n    elements = shapeOrChildren;\n  }\n\n  if (elements.length) {\n    return addPadding(getBBox(elements), padding);\n  }\n}\n\nmodule.exports.computeChildrenBBox = computeChildrenBBox;\n","module.exports = {\n  __depends__: [\n    require(208),\n    require(143),\n    require(198)\n  ],\n  __init__: [ 'resize', 'resizePreview', 'resizeHandles' ],\n  resize: [ 'type', require(201) ],\n  resizePreview: [ 'type', require(203) ],\n  resizeHandles: [ 'type', require(202) ]\n};\n","\n'use strict';\n\nvar inherits = require(270);\n\nvar CommandInterceptor = require(100);\n\n/**\n * A basic provider that may be extended to implement modeling rules.\n *\n * Extensions should implement the init method to actually add their custom\n * modeling checks. Checks may be added via the #addRule(action, fn) method.\n *\n * @param {EventBus} eventBus\n */\nfunction RuleProvider(eventBus) {\n  CommandInterceptor.call(this, eventBus);\n\n  this.init();\n}\n\nRuleProvider.$inject = [ 'eventBus' ];\n\ninherits(RuleProvider, CommandInterceptor);\n\nmodule.exports = RuleProvider;\n\n\n/**\n * Adds a modeling rule for the given action, implemented through\n * a callback function.\n *\n * The function will receive the modeling specific action context\n * to perform its check. It must return `false` to disallow the\n * action from happening or `true` to allow the action.\n *\n * A rule provider may pass over the evaluation to lower priority\n * rules by returning return nothing (or <code>undefined</code>).\n *\n * @example\n *\n * ResizableRules.prototype.init = function() {\n *\n *   //**\n *    * Return `true`, `false` or nothing to denote\n *    * _allowed_, _not allowed_ and _continue evaluating_.\n *    *//\n *   this.addRule('shape.resize', function(context) {\n *\n *     var shape = context.shape;\n *\n *     if (!context.newBounds) {\n *       // check general resizability\n *       if (!shape.resizable) {\n *         return false;\n *       }\n *\n *       // not returning anything (read: undefined)\n *       // will continue the evaluation of other rules\n *       // (with lower priority)\n *       return;\n *     } else {\n *       // element must have minimum size of 10*10 points\n *       return context.newBounds.width > 10 && context.newBounds.height > 10;\n *     }\n *   });\n * };\n *\n * @param {String|Array<String>} actions the identifier for the modeling action to check\n * @param {Number} [priority] the priority at which this rule is being applied\n * @param {Function} fn the callback function that performs the actual check\n */\nRuleProvider.prototype.addRule = function(actions, priority, fn) {\n\n  var self = this;\n\n  if (typeof actions === 'string') {\n    actions = [ actions ];\n  }\n\n  actions.forEach(function(action) {\n\n    self.canExecute(action, priority, function(context, action, event) {\n      return fn(context);\n    }, true);\n  });\n};\n\n/**\n * Implement this method to add new rules during provider initialization.\n */\nRuleProvider.prototype.init = function() {};","'use strict';\n\n/**\n * A service that provides rules for certain diagram actions.\n *\n * The default implementation will hook into the {@link CommandStack}\n * to perform the actual rule evaluation. Make sure to provide the\n * `commandStack` service with this module if you plan to use it.\n *\n * Together with this implementation you may use the {@link RuleProvider}\n * to implement your own rule checkers.\n *\n * This module is ment to be easily replaced, thus the tiny foot print.\n *\n * @param {Injector} injector\n */\nfunction Rules(injector) {\n  this._commandStack = injector.get('commandStack', false);\n}\n\nRules.$inject = [ 'injector' ];\n\nmodule.exports = Rules;\n\n\n/**\n * Returns whether or not a given modeling action can be executed\n * in the specified context.\n *\n * This implementation will respond with allow unless anyone\n * objects.\n *\n * @param {String} action the action to be checked\n * @param {Object} [context] the context to check the action in\n *\n * @return {Boolean} returns true, false or null depending on whether the\n *                   operation is allowed, not allowed or should be ignored.\n */\nRules.prototype.allowed = function(action, context) {\n  var allowed = true;\n\n  var commandStack = this._commandStack;\n\n  if (commandStack) {\n    allowed = commandStack.canExecute(action, context);\n  }\n\n  // map undefined to true, i.e. no rules\n  return allowed === undefined ? true : allowed;\n};","module.exports = {\n  __init__: [ 'rules' ],\n  rules: [ 'type', require(207) ]\n};\n","'use strict';\n\nvar domClear = require(425),\n    domDelegate = require(427),\n    domQuery = require(431),\n    domClasses = require(424),\n    domAttr = require(423),\n    domify = require(428);\n\nvar getBoundingBox = require(247).getBBox;\n\n\n/**\n * Provides searching infrastructure\n */\nfunction SearchPad(canvas, eventBus, overlays, selection) {\n  this._open = false;\n  this._results = [];\n  this._eventMaps = [];\n\n  this._canvas = canvas;\n  this._eventBus = eventBus;\n  this._overlays = overlays;\n  this._selection = selection;\n\n  // setup elements\n  this._container = domify(SearchPad.BOX_HTML);\n  this._searchInput = domQuery(SearchPad.INPUT_SELECTOR, this._container);\n  this._resultsContainer = domQuery(SearchPad.RESULTS_CONTAINER_SELECTOR, this._container);\n\n  // attach search pad\n  this._canvas.getContainer().appendChild(this._container);\n\n  // cleanup on destroy\n  eventBus.on([ 'canvas.destroy', 'diagram.destroy' ], this.close, this);\n}\n\n\nSearchPad.$inject = [\n  'canvas',\n  'eventBus',\n  'overlays',\n  'selection'\n];\n\n\n/**\n * Binds and keeps track of all event listereners\n */\nSearchPad.prototype._bindEvents = function() {\n  var self = this;\n\n  function listen(el, selector, type, fn) {\n    self._eventMaps.push({\n      el: el,\n      type: type,\n      listener: domDelegate.bind(el, selector, type, fn)\n    });\n  }\n\n  // close search on clicking anywhere outside\n  listen(document, 'html', 'click', function(e) {\n    self.close();\n  }, true);\n\n  // stop event from propagating and closing search\n  // focus on input\n  listen(this._container, SearchPad.INPUT_SELECTOR, 'click', function(e) {\n    e.stopPropagation();\n    e.delegateTarget.focus();\n  });\n\n  // preselect result on hover\n  listen(this._container, SearchPad.RESULT_SELECTOR, 'mouseover', function(e) {\n    e.stopPropagation();\n    self._scrollToNode(e.delegateTarget);\n    self._preselect(e.delegateTarget);\n  });\n\n  // selects desired result on mouse click\n  listen(this._container, SearchPad.RESULT_SELECTOR, 'click', function(e) {\n    e.stopPropagation();\n    self._select(e.delegateTarget);\n  });\n\n  // prevent cursor in input from going left and right when using up/down to\n  // navigate results\n  listen(this._container, SearchPad.INPUT_SELECTOR, 'keydown', function(e) {\n    // up\n    if (e.keyCode === 38) {\n      e.preventDefault();\n    }\n\n    // down\n    if (e.keyCode === 40) {\n      e.preventDefault();\n    }\n  });\n\n  // handle keyboard input\n  listen(this._container, SearchPad.INPUT_SELECTOR, 'keyup', function(e) {\n    // escape\n    if (e.keyCode === 27) {\n      return self.close();\n    }\n\n    // enter\n    if (e.keyCode === 13) {\n      var selected = self._getCurrentResult();\n\n      return selected ? self._select(selected) : self.close();\n    }\n\n    // up\n    if (e.keyCode === 38) {\n      return self._scrollToDirection(true);\n    }\n\n    // down\n    if (e.keyCode === 40) {\n      return self._scrollToDirection();\n    }\n\n    // left && right\n    // do not search while navigating text input\n    if (e.keyCode === 37 || e.keyCode === 39) {\n      return;\n    }\n\n    // anything else\n    self._search(e.delegateTarget.value);\n  });\n};\n\n\n/**\n * Unbinds all previously established listeners\n */\nSearchPad.prototype._unbindEvents = function() {\n  this._eventMaps.forEach(function(m) {\n    domDelegate.unbind(m.el, m.type, m.listener);\n  });\n};\n\n\n/**\n * Performs a search for the given pattern.\n *\n * @param  {String} pattern\n */\nSearchPad.prototype._search = function(pattern) {\n  var self = this;\n\n  this._clearResults();\n\n  // do not search on empty query\n  if (!pattern || pattern === '') {\n    return;\n  }\n\n  var searchResults = this._searchProvider.find(pattern);\n\n  if (!searchResults.length) {\n    return;\n  }\n\n  // append new results\n  searchResults.forEach(function(result) {\n    var id = result.element.id;\n    var node = self._createResultNode(result, id);\n    self._results[id] = {\n      element: result.element,\n      node: node\n    };\n  });\n\n  // preselect first result\n  var node = domQuery(SearchPad.RESULT_SELECTOR, this._resultsContainer);\n  this._scrollToNode(node);\n  this._preselect(node);\n};\n\n\n/**\n * Navigate to the previous/next result. Defaults to next result.\n * @param  {Boolean} previous\n */\nSearchPad.prototype._scrollToDirection = function(previous) {\n  var selected = this._getCurrentResult();\n  if (!selected) {\n    return;\n  }\n\n  var node = previous ? selected.previousElementSibling : selected.nextElementSibling;\n  if (node) {\n    this._scrollToNode(node);\n    this._preselect(node);\n  }\n};\n\n\n/**\n * Scroll to the node if it is not visible.\n *\n * @param  {Element} node\n */\nSearchPad.prototype._scrollToNode = function(node) {\n  if (!node || node === this._getCurrentResult()) {\n    return;\n  }\n\n  var nodeOffset = node.offsetTop;\n  var containerScroll = this._resultsContainer.scrollTop;\n\n  var bottomScroll = nodeOffset - this._resultsContainer.clientHeight + node.clientHeight;\n\n  if (nodeOffset < containerScroll) {\n    this._resultsContainer.scrollTop = nodeOffset;\n  } else if (containerScroll < bottomScroll) {\n    this._resultsContainer.scrollTop = bottomScroll;\n  }\n};\n\n\n/**\n * Clears all results data.\n */\nSearchPad.prototype._clearResults = function() {\n  domClear(this._resultsContainer);\n\n  this._results = [];\n\n  this._resetOverlay();\n\n  this._eventBus.fire('searchPad.cleared');\n};\n\n\n/**\n * Get currently selected result.\n *\n * @return {Element}\n */\nSearchPad.prototype._getCurrentResult = function() {\n  return domQuery(SearchPad.RESULT_SELECTED_SELECTOR, this._resultsContainer);\n};\n\n\n/**\n * Create result DOM element within results container\n * that corresponds to a search result.\n *\n * 'result' : one of the elements returned by SearchProvider\n * 'id' : id attribute value to assign to the new DOM node\n * return : created DOM element\n *\n * @param  {SearchResult} result\n * @param  {String} id\n * @return {Element}\n */\nSearchPad.prototype._createResultNode = function(result, id) {\n  var node = domify(SearchPad.RESULT_HTML);\n\n  // create only if available\n  if (result.primaryTokens.length > 0) {\n    createInnerTextNode(node, result.primaryTokens, SearchPad.RESULT_PRIMARY_HTML);\n  }\n\n  // secondary tokens (represent element ID) are allways available\n  createInnerTextNode(node, result.secondaryTokens, SearchPad.RESULT_SECONDARY_HTML);\n\n  domAttr(node, SearchPad.RESULT_ID_ATTRIBUTE, id);\n\n  this._resultsContainer.appendChild(node);\n\n  return node;\n};\n\n\n/**\n * Register search element provider.\n *\n * SearchProvider.find - provides search function over own elements\n *  (pattern) => [{ text: <String>, element: <Element>}, ...]\n *\n * @param  {SearchProvider} provider\n */\nSearchPad.prototype.registerProvider = function(provider) {\n  this._searchProvider = provider;\n};\n\n\n/**\n * Open search pad.\n */\nSearchPad.prototype.open = function() {\n  if (!this._searchProvider) {\n    throw new Error('no search provider registered');\n  }\n\n  if (this.isOpen()) {\n    return;\n  }\n\n  this._bindEvents();\n\n  this._open = true;\n\n  domClasses(this._container).add('open');\n\n  this._searchInput.focus();\n\n  this._eventBus.fire('searchPad.opened');\n};\n\n\n/**\n * Close search pad.\n */\nSearchPad.prototype.close = function() {\n  if (!this.isOpen()) {\n    return;\n  }\n\n  this._unbindEvents();\n\n  this._open = false;\n\n  domClasses(this._container).remove('open');\n\n  this._clearResults();\n\n  this._searchInput.value = '';\n  this._searchInput.blur();\n\n  this._resetOverlay();\n\n  this._eventBus.fire('searchPad.closed');\n};\n\n\n/**\n * Toggles search pad on/off.\n */\nSearchPad.prototype.toggle = function() {\n  this.isOpen() ? this.close() : this.open();\n};\n\n\n/**\n * Report state of search pad.\n */\nSearchPad.prototype.isOpen = function() {\n  return this._open;\n};\n\n\n/**\n * Preselect result entry.\n *\n * @param  {Element} element\n */\nSearchPad.prototype._preselect = function(node) {\n  var selectedNode = this._getCurrentResult();\n\n  // already selected\n  if (node === selectedNode) {\n    return;\n  }\n\n  // removing preselection from current node\n  if (selectedNode) {\n    domClasses(selectedNode).remove(SearchPad.RESULT_SELECTED_CLASS);\n  }\n\n  var id = domAttr(node, SearchPad.RESULT_ID_ATTRIBUTE);\n  var element = this._results[id].element;\n\n  domClasses(node).add(SearchPad.RESULT_SELECTED_CLASS);\n\n  this._resetOverlay(element);\n\n  this._centerViewbox(element);\n\n  this._selection.select(element);\n\n  this._eventBus.fire('searchPad.preselected', element);\n};\n\n\n/**\n * Select result node.\n *\n * @param  {Element} element\n */\nSearchPad.prototype._select = function(node) {\n  var id = domAttr(node, SearchPad.RESULT_ID_ATTRIBUTE);\n  var element = this._results[id].element;\n\n  this.close();\n\n  this._resetOverlay();\n\n  this._centerViewbox(element);\n\n  this._selection.select(element);\n\n  this._eventBus.fire('searchPad.selected', element);\n};\n\n\n/**\n * Center viewbox on the element middle point.\n *\n * @param  {Element} element\n */\nSearchPad.prototype._centerViewbox = function(element) {\n  var viewbox = this._canvas.viewbox();\n\n  var box = getBoundingBox(element);\n\n  var newViewbox = {\n    x: (box.x + box.width/2) - viewbox.outer.width/2,\n    y: (box.y + box.height/2) - viewbox.outer.height/2,\n    width: viewbox.outer.width,\n    height: viewbox.outer.height\n  };\n\n  this._canvas.viewbox(newViewbox);\n\n  this._canvas.zoom(viewbox.scale);\n};\n\n\n/**\n * Reset overlay removes and, optionally, set\n * overlay to a new element.\n *\n * @param  {Element} element\n */\nSearchPad.prototype._resetOverlay = function(element) {\n  if (this._overlayId) {\n    this._overlays.remove(this._overlayId);\n  }\n\n  if (element) {\n    var box = getBoundingBox(element);\n    var overlay = constructOverlay(box);\n    this._overlayId = this._overlays.add(element, overlay);\n  }\n};\n\n\nmodule.exports = SearchPad;\n\n/**\n * Construct overlay object for the given bounding box.\n *\n * @param  {BoundingBox} box\n * @return {Object}\n */\nfunction constructOverlay(box) {\n\n  var offset = 6;\n  var w = box.width + offset * 2;\n  var h = box.height + offset * 2;\n\n  var styles = [\n    'width: '+ w +'px',\n    'height: '+ h + 'px'\n  ].join('; ');\n\n  return {\n    position: {\n      bottom: h - offset,\n      right: w - offset\n    },\n    show: true,\n    html: '<div style=\"' + styles + '\" class=\"' + SearchPad.OVERLAY_CLASS + '\"></div>'\n  };\n}\n\n\n/**\n * Creates and appends child node from result tokens and HTML template.\n *\n * @param  {Element} node\n * @param  {Array<Object>} tokens\n * @param  {String} template\n */\nfunction createInnerTextNode(parentNode, tokens, template) {\n  var text = createHtmlText(tokens);\n  var childNode = domify(template);\n  childNode.innerHTML = text;\n  parentNode.appendChild(childNode);\n}\n\n/**\n * Create internal HTML markup from result tokens.\n * Caters for highlighting pattern matched tokens.\n *\n * @param  {Array<Object>} tokens\n * @return {String}\n */\nfunction createHtmlText(tokens) {\n  var htmlText = '';\n\n  tokens.forEach(function(t) {\n    if (t.matched) {\n      htmlText += '<strong class=\"' + SearchPad.RESULT_HIGHLIGHT_CLASS + '\">' + t.matched + '</strong>';\n    } else {\n      htmlText += t.normal;\n    }\n  });\n\n  return htmlText !== '' ? htmlText : null;\n}\n\n\n/**\n * CONSTANTS\n */\nSearchPad.CONTAINER_SELECTOR = '.djs-search-container';\nSearchPad.INPUT_SELECTOR = '.djs-search-input input';\nSearchPad.RESULTS_CONTAINER_SELECTOR = '.djs-search-results';\nSearchPad.RESULT_SELECTOR = '.djs-search-result';\nSearchPad.RESULT_SELECTED_CLASS = 'djs-search-result-selected';\nSearchPad.RESULT_SELECTED_SELECTOR = '.' + SearchPad.RESULT_SELECTED_CLASS;\nSearchPad.RESULT_ID_ATTRIBUTE = 'data-result-id';\nSearchPad.RESULT_HIGHLIGHT_CLASS = 'djs-search-highlight';\nSearchPad.OVERLAY_CLASS = 'djs-search-overlay';\n\nSearchPad.BOX_HTML =\n  '<div class=\"djs-search-container djs-draggable djs-scrollable\">' +\n    '<div class=\"djs-search-input\">' +\n      '<input type=\"text\"/>' +\n    '</div>' +\n    '<div class=\"djs-search-results\"></div>' +\n  '</div>';\n\nSearchPad.RESULT_HTML =\n  '<div class=\"djs-search-result\"></div>';\n\nSearchPad.RESULT_PRIMARY_HTML =\n  '<div class=\"djs-search-result-primary\"></div>';\n\nSearchPad.RESULT_SECONDARY_HTML =\n  '<p class=\"djs-search-result-secondary\"></p>';\n","module.exports = {\n  __depends__: [\n    require(192),\n    require(214)\n  ],\n  searchPad: [ 'type', require(209) ]\n};\n","'use strict';\n\nvar isArray = require(401),\n    forEach = require(283);\n\n\n/**\n * A service that offers the current selection in a diagram.\n * Offers the api to control the selection, too.\n *\n * @class\n *\n * @param {EventBus} eventBus the event bus\n */\nfunction Selection(eventBus) {\n\n  this._eventBus = eventBus;\n\n  this._selectedElements = [];\n\n  var self = this;\n\n  eventBus.on([ 'shape.remove', 'connection.remove' ], function(e) {\n    var element = e.element;\n    self.deselect(element);\n  });\n\n  eventBus.on([ 'diagram.clear' ], function(e) {\n    self.select(null);\n  });\n}\n\nSelection.$inject = [ 'eventBus' ];\n\nmodule.exports = Selection;\n\n\nSelection.prototype.deselect = function(element) {\n  var selectedElements = this._selectedElements;\n\n  var idx = selectedElements.indexOf(element);\n\n  if (idx !== -1) {\n    var oldSelection = selectedElements.slice();\n\n    selectedElements.splice(idx, 1);\n\n    this._eventBus.fire('selection.changed', { oldSelection: oldSelection, newSelection: selectedElements });\n  }\n};\n\n\nSelection.prototype.get = function() {\n  return this._selectedElements;\n};\n\nSelection.prototype.isSelected = function(element) {\n  return this._selectedElements.indexOf(element) !== -1;\n};\n\n\n/**\n * This method selects one or more elements on the diagram.\n *\n * By passing an additional add parameter you can decide whether or not the element(s)\n * should be added to the already existing selection or not.\n *\n * @method Selection#select\n *\n * @param  {Object|Object[]} elements element or array of elements to be selected\n * @param  {boolean} [add] whether the element(s) should be appended to the current selection, defaults to false\n */\nSelection.prototype.select = function(elements, add) {\n  var selectedElements = this._selectedElements,\n      oldSelection = selectedElements.slice();\n\n  if (!isArray(elements)) {\n    elements = elements ? [ elements ] : [];\n  }\n\n  // selection may be cleared by passing an empty array or null\n  // to the method\n  if (add) {\n    forEach(elements, function(element) {\n      if (selectedElements.indexOf(element) !== -1) {\n        // already selected\n        return;\n      } else {\n        selectedElements.push(element);\n      }\n    });\n  } else {\n    this._selectedElements = selectedElements = elements.slice();\n  }\n\n  this._eventBus.fire('selection.changed', { oldSelection: oldSelection, newSelection: selectedElements });\n};\n","'use strict';\n\nvar hasPrimaryModifier = require(254).hasPrimaryModifier;\n\nvar find = require(282);\n\n\nfunction SelectionBehavior(eventBus, selection, canvas, elementRegistry) {\n\n  eventBus.on('create.end', 500, function(e) {\n\n    // select the created shape after a\n    // successful create operation\n    if (e.context.canExecute) {\n      selection.select(e.context.shape);\n    }\n  });\n\n  eventBus.on('connect.end', 500, function(e) {\n\n    // select the connect end target\n    // after a connect operation\n    if (e.context.canExecute && e.context.target) {\n      selection.select(e.context.target);\n    }\n  });\n\n  eventBus.on('shape.move.end', 500, function(e) {\n    var previousSelection = e.previousSelection || [];\n\n    var shape = elementRegistry.get(e.context.shape.id);\n\n    // make sure at least the main moved element is being\n    // selected after a move operation\n    var inSelection = find(previousSelection, function(selectedShape) {\n      return shape.id === selectedShape.id;\n    });\n\n    if (!inSelection) {\n      selection.select(shape);\n    }\n  });\n\n  // Shift + click selection\n  eventBus.on('element.click', function(event) {\n\n    var element = event.element;\n\n    // do not select the root element\n    // or connections\n    if (element === canvas.getRootElement()) {\n      element = null;\n    }\n\n    var isSelected = selection.isSelected(element),\n        isMultiSelect = selection.get().length > 1;\n\n    // mouse-event: SELECTION_KEY\n    var add = hasPrimaryModifier(event);\n\n    // select OR deselect element in multi selection\n    if (isSelected && isMultiSelect) {\n      if (add) {\n        return selection.deselect(element);\n      } else {\n        return selection.select(element);\n      }\n    } else\n    if (!isSelected) {\n      selection.select(element, add);\n    } else {\n      selection.deselect(element);\n    }\n  });\n}\n\nSelectionBehavior.$inject = [ 'eventBus', 'selection', 'canvas', 'elementRegistry' ];\nmodule.exports = SelectionBehavior;\n","'use strict';\n\nvar forEach = require(283);\n\nvar MARKER_HOVER = 'hover',\n    MARKER_SELECTED = 'selected';\n\n\n/**\n * A plugin that adds a visible selection UI to shapes and connections\n * by appending the <code>hover</code> and <code>selected</code> classes to them.\n *\n * @class\n *\n * Makes elements selectable, too.\n *\n * @param {EventBus} events\n * @param {SelectionService} selection\n * @param {Canvas} canvas\n */\nfunction SelectionVisuals(events, canvas, selection, graphicsFactory, styles) {\n\n  this._multiSelectionBox = null;\n\n  function addMarker(e, cls) {\n    canvas.addMarker(e, cls);\n  }\n\n  function removeMarker(e, cls) {\n    canvas.removeMarker(e, cls);\n  }\n\n  events.on('element.hover', function(event) {\n    addMarker(event.element, MARKER_HOVER);\n  });\n\n  events.on('element.out', function(event) {\n    removeMarker(event.element, MARKER_HOVER);\n  });\n\n  events.on('selection.changed', function(event) {\n\n    function deselect(s) {\n      removeMarker(s, MARKER_SELECTED);\n    }\n\n    function select(s) {\n      addMarker(s, MARKER_SELECTED);\n    }\n\n    var oldSelection = event.oldSelection,\n        newSelection = event.newSelection;\n\n    forEach(oldSelection, function(e) {\n      if (newSelection.indexOf(e) === -1) {\n        deselect(e);\n      }\n    });\n\n    forEach(newSelection, function(e) {\n      if (oldSelection.indexOf(e) === -1) {\n        select(e);\n      }\n    });\n  });\n}\n\nSelectionVisuals.$inject = [\n  'eventBus',\n  'canvas',\n  'selection',\n  'graphicsFactory',\n  'styles'\n];\n\nmodule.exports = SelectionVisuals;\n","module.exports = {\n  __init__: [ 'selectionVisuals', 'selectionBehavior' ],\n  __depends__: [\n    require(151),\n    require(190)\n  ],\n  selection: [ 'type', require(211) ],\n  selectionVisuals: [ 'type', require(213) ],\n  selectionBehavior: [ 'type', require(212) ]\n};\n","'use strict';\n\nvar forEach = require(283);\n\nvar snapTo = require(216).snapTo;\n\n\n/**\n * A snap context, containing the (possibly incomplete)\n * mappings of drop targets (to identify the snapping)\n * to computed snap points.\n */\nfunction SnapContext() {\n\n  /**\n   * Map<String, SnapPoints> mapping drop targets to\n   * a list of possible snappings.\n   *\n   * @type {Object}\n   */\n  this._targets = {};\n\n  /**\n   * Map<String, Point> initial positioning of element\n   * regarding various snap directions.\n   *\n   * @type {Object}\n   */\n  this._snapOrigins = {};\n\n  /**\n   * List of snap locations\n   *\n   * @type {Array<String>}\n   */\n  this._snapLocations = [];\n\n  /**\n   * Map<String, Array<Point>> of default snapping locations\n   *\n   * @type {Object}\n   */\n  this._defaultSnaps = {};\n}\n\n\nSnapContext.prototype.getSnapOrigin = function(snapLocation) {\n  return this._snapOrigins[snapLocation];\n};\n\n\nSnapContext.prototype.setSnapOrigin = function(snapLocation, initialValue) {\n  this._snapOrigins[snapLocation] = initialValue;\n\n  if (this._snapLocations.indexOf(snapLocation) === -1) {\n    this._snapLocations.push(snapLocation);\n  }\n};\n\n\nSnapContext.prototype.addDefaultSnap = function(type, point) {\n\n  var snapValues = this._defaultSnaps[type];\n\n  if (!snapValues) {\n    snapValues = this._defaultSnaps[type] = [];\n  }\n\n  snapValues.push(point);\n};\n\n/**\n * Return a number of initialized snaps, i.e. snap locations such as\n * top-left, mid, bottom-right and so forth.\n *\n * @return {Array<String>} snapLocations\n */\nSnapContext.prototype.getSnapLocations = function() {\n  return this._snapLocations;\n};\n\n/**\n * Set the snap locations for this context.\n *\n * The order of locations determines precedence.\n *\n * @param {Array<String>} snapLocations\n */\nSnapContext.prototype.setSnapLocations = function(snapLocations) {\n  this._snapLocations = snapLocations;\n};\n\n/**\n * Get snap points for a given target\n *\n * @param {Element|String} target\n */\nSnapContext.prototype.pointsForTarget = function(target) {\n\n  var targetId = target.id || target;\n\n  var snapPoints = this._targets[targetId];\n\n  if (!snapPoints) {\n    snapPoints = this._targets[targetId] = new SnapPoints();\n    snapPoints.initDefaults(this._defaultSnaps);\n  }\n\n  return snapPoints;\n};\n\nmodule.exports = SnapContext;\n\n\n/**\n * Creates the snap points and initializes them with the\n * given default values.\n *\n * @param {Object<String, Array<Point>>} [defaultPoints]\n */\nfunction SnapPoints(defaultSnaps) {\n\n  /**\n   * Map<String, Map<(x|y), Array<Number>>> mapping snap locations,\n   * i.e. top-left, bottom-right, center to actual snap values.\n   *\n   * @type {Object}\n   */\n  this._snapValues = {};\n}\n\nSnapPoints.prototype.add = function(snapLocation, point) {\n\n  var snapValues = this._snapValues[snapLocation];\n\n  if (!snapValues) {\n    snapValues = this._snapValues[snapLocation] = { x: [], y: [] };\n  }\n\n  if (snapValues.x.indexOf(point.x) === -1) {\n    snapValues.x.push(point.x);\n  }\n\n  if (snapValues.y.indexOf(point.y) === -1) {\n    snapValues.y.push(point.y);\n  }\n};\n\n\nSnapPoints.prototype.snap = function(point, snapLocation, axis, tolerance) {\n  var snappingValues = this._snapValues[snapLocation];\n  \n  return snappingValues && snapTo(point[axis], snappingValues[axis], tolerance);\n};\n\n/**\n * Initialize a number of default snapping points.\n *\n * @param  {Object} defaultSnaps\n */\nSnapPoints.prototype.initDefaults = function(defaultSnaps) {\n\n  var self = this;\n\n  forEach(defaultSnaps || {}, function(snapPoints, snapLocation) {\n    forEach(snapPoints, function(point) {\n      self.add(snapLocation, point);\n    });\n  });\n};","'use strict';\n\nvar abs = Math.abs,\n    round = Math.round;\n\n\n/**\n * Snap value to a collection of reference values.\n *\n * @param  {Number} value\n * @param  {Array<Number>} values\n * @param  {Number} [tolerance=10]\n *\n * @return {Number} the value we snapped to or null, if none snapped\n */\nfunction snapTo(value, values, tolerance) {\n  tolerance = tolerance === undefined ? 10 : tolerance;\n\n  var idx, snapValue;\n\n  for (idx = 0; idx < values.length; idx++) {\n    snapValue = values[idx];\n\n    if (abs(snapValue - value) <= tolerance) {\n      return snapValue;\n    }\n  }\n}\n\nmodule.exports.snapTo = snapTo;\n\n\nfunction topLeft(bounds) {\n  return {\n    x: bounds.x,\n    y: bounds.y\n  };\n}\n\nmodule.exports.topLeft = topLeft;\n\n\nfunction mid(bounds, defaultValue) {\n\n  if (!bounds || isNaN(bounds.x) || isNaN(bounds.y)) {\n    return defaultValue;\n  }\n\n  return {\n    x: round(bounds.x + bounds.width / 2),\n    y: round(bounds.y + bounds.height / 2)\n  };\n}\n\nmodule.exports.mid = mid;\n\n\nfunction bottomRight(bounds) {\n  return {\n    x: bounds.x + bounds.width,\n    y: bounds.y + bounds.height\n  };\n}\n\nmodule.exports.bottomRight = bottomRight;\n\n\n/**\n * Retrieve the snap state of the given event.\n *\n * @param  {Event} event\n * @param  {String} axis\n *\n * @return {Boolean} the snapped state\n *\n */\nmodule.exports.isSnapped = function(event, axis) {\n  var snapped = event.snapped;\n\n  if (!snapped) {\n    return false;\n  }\n\n  if (typeof axis === 'string') {\n    return snapped[axis];\n  }\n\n  return snapped.x && snapped.y;\n};\n\n/**\n * Set the given event as snapped.\n *\n * This method may change the x and/or y position of the shape\n * from the given event!\n *\n * @param {Event} event\n * @param {String} axis\n * @param {Number|Boolean} value\n *\n * @return {Number} old value\n */\nmodule.exports.setSnapped = function(event, axis, value) {\n  if (typeof axis !== 'string') {\n    throw new Error('axis must be in [x, y]');\n  }\n\n  if (typeof value !== 'number' && value !== false) {\n    throw new Error('value must be Number or false');\n  }\n\n  var delta,\n      previousValue = event[axis];\n\n  var snapped = event.snapped = (event.snapped || {});\n\n\n  if (value === false) {\n    snapped[axis] = false;\n  } else {\n    snapped[axis] = true;\n\n    delta = value - previousValue;\n\n    event[axis] += delta;\n    event['d' + axis] += delta;\n  }\n\n  return previousValue;\n};","'use strict';\n\nvar filter = require(281),\n    forEach = require(283),\n    debounce = require(294);\n\n\nvar mid = require(216).mid;\n\nvar SnapContext = require(215);\n\nvar SnapUtil = require(216);\n\nvar HIGHER_PRIORITY = 1250;\n\nvar isSnapped = SnapUtil.isSnapped,\n    setSnapped = SnapUtil.setSnapped;\n\n\n/**\n * A general purpose snapping component for diagram elements.\n *\n * @param {EventBus} eventBus\n * @param {Canvas} canvas\n */\nfunction Snapping(eventBus, canvas) {\n\n  this._canvas = canvas;\n\n  var self = this;\n\n  eventBus.on([ 'shape.move.start', 'create.start' ], function(event) {\n    self.initSnap(event);\n  });\n\n  eventBus.on([ 'shape.move.move', 'shape.move.end', 'create.move', 'create.end' ], HIGHER_PRIORITY, function(event) {\n\n    if (event.originalEvent && event.originalEvent.ctrlKey) {\n      return;\n    }\n\n    if (isSnapped(event)) {\n      return;\n    }\n\n    self.snap(event);\n  });\n\n  eventBus.on([ 'shape.move.cleanup', 'create.cleanup' ], function(event) {\n    self.hide();\n  });\n\n  // delay hide by 1000 seconds since last match\n  this._asyncHide = debounce(this.hide, 1000);\n}\n\nSnapping.$inject = [ 'eventBus', 'canvas' ];\n\nmodule.exports = Snapping;\n\n\nSnapping.prototype.initSnap = function(event) {\n\n  var context = event.context,\n      shape = context.shape,\n      snapContext = context.snapContext;\n\n  if (!snapContext) {\n    snapContext = context.snapContext = new SnapContext();\n  }\n\n  var snapMid = mid(shape, event);\n\n  snapContext.setSnapOrigin('mid', {\n    x: snapMid.x - event.x,\n    y: snapMid.y - event.y\n  });\n\n  return snapContext;\n};\n\n\nSnapping.prototype.snap = function(event) {\n\n  var context = event.context,\n      snapContext = context.snapContext,\n      shape = context.shape,\n      target = context.target,\n      snapLocations = snapContext.getSnapLocations();\n\n  if (!target) {\n    return;\n  }\n\n  var snapPoints = snapContext.pointsForTarget(target);\n\n  if (!snapPoints.initialized) {\n    this.addTargetSnaps(snapPoints, shape, target);\n\n    snapPoints.initialized = true;\n  }\n\n\n  var snapping = {\n    x: isSnapped(event, 'x'),\n    y: isSnapped(event, 'y')\n  };\n\n\n  forEach(snapLocations, function(location) {\n\n    var snapOrigin = snapContext.getSnapOrigin(location);\n\n    var snapCurrent = {\n      x: event.x + snapOrigin.x,\n      y: event.y + snapOrigin.y\n    };\n\n    // snap on both axis, if not snapped already\n    forEach([ 'x', 'y' ], function(axis) {\n      var locationSnapping;\n\n      if (!snapping[axis]) {\n        locationSnapping = snapPoints.snap(snapCurrent, location, axis, 7);\n\n        if (locationSnapping !== undefined) {\n          snapping[axis] = {\n            value: locationSnapping,\n            originValue: locationSnapping - snapOrigin[axis]\n          };\n        }\n      }\n    });\n\n    // no more need to snap, drop out of interation\n    if (snapping.x && snapping.y) {\n      return false;\n    }\n  });\n\n\n  // show snap visuals\n\n  this.showSnapLine('vertical', snapping.x && snapping.x.value);\n  this.showSnapLine('horizontal', snapping.y && snapping.y.value);\n\n\n  // adjust event { x, y, dx, dy } and mark as snapping\n  forEach([ 'x', 'y' ], function(axis) {\n\n    var axisSnapping = snapping[axis];\n\n    if (typeof axisSnapping === 'object') {\n      // set as snapped and adjust the x and/or y position of the event\n      setSnapped(event, axis, axisSnapping.originValue);\n    }\n  });\n};\n\n\nSnapping.prototype._createLine = function(orientation) {\n\n  var root = this._canvas.getLayer('snap');\n\n  var line = root.path('M0,0 L0,0').addClass('djs-snap-line');\n\n  return {\n    update: function(position) {\n\n      if (typeof position !== 'number') {\n        line.attr({ display: 'none' });\n      } else {\n        if (orientation === 'horizontal') {\n          line.attr({\n            path: 'M-100000,' + position + ' L+100000,' + position,\n            display: ''\n          });\n        } else {\n          line.attr({\n            path: 'M ' + position + ',-100000 L ' + position + ', +100000',\n            display: ''\n          });\n        }\n      }\n    }\n  };\n};\n\n\nSnapping.prototype._createSnapLines = function() {\n\n  this._snapLines = {\n    horizontal: this._createLine('horizontal'),\n    vertical: this._createLine('vertical')\n  };\n};\n\nSnapping.prototype.showSnapLine = function(orientation, position) {\n\n  var line = this.getSnapLine(orientation);\n\n  if (line) {\n    line.update(position);\n  }\n\n  this._asyncHide();\n};\n\nSnapping.prototype.getSnapLine = function(orientation) {\n  if (!this._snapLines) {\n    this._createSnapLines();\n  }\n\n  return this._snapLines[orientation];\n};\n\nSnapping.prototype.hide = function() {\n  forEach(this._snapLines, function(l) {\n    l.update();\n  });\n};\n\nSnapping.prototype.addTargetSnaps = function(snapPoints, shape, target) {\n\n  var siblings = this.getSiblings(shape, target);\n\n  forEach(siblings, function(s) {\n    snapPoints.add('mid', mid(s));\n  });\n\n};\n\nSnapping.prototype.getSiblings = function(element, target) {\n\n  // snap to all non connection siblings\n  return target && filter(target.children, function(e) {\n    return !e.hidden && !e.labelTarget && !e.waypoints && e.host !== element && e !== element;\n  });\n};","'use strict';\n\nvar SpaceUtil = require(220);\n\nvar Cursor = require(246);\n\nvar hasPrimaryModifier = require(254).hasPrimaryModifier;\n\nvar abs = Math.abs,\n    round = Math.round;\n\nvar HIGH_PRIORITY = 1500,\n    SPACE_TOOL_CURSOR = 'crosshair';\n\nvar AXIS_TO_DIMENSION = { x: 'width', y: 'height' },\n    AXIS_INVERTED = { x: 'y', y: 'x' };\n\nvar getAllChildren = require(247).selfAndAllChildren;\n\nvar assign = require(410),\n    forEach = require(283);\n\n\n/**\n * A tool that allows users to create and remove space in a diagram.\n *\n * The tool needs to be activated manually via {@link SpaceTool#activate(MouseEvent)}.\n */\nfunction SpaceTool(eventBus, dragging, canvas, modeling, rules, toolManager) {\n\n  this._canvas = canvas;\n  this._dragging = dragging;\n  this._modeling = modeling;\n  this._rules = rules;\n  this._toolManager = toolManager;\n\n  var self = this;\n\n  toolManager.registerTool('space', {\n    tool: 'spaceTool.selection',\n    dragging: 'spaceTool'\n  });\n\n  eventBus.on('spaceTool.selection.end', function(event) {\n    var target = event.originalEvent.target;\n\n    // only reactive on diagram click\n    // on some occasions, event.hover is not set and we have to check if the target is an svg\n    if (!event.hover && !(target instanceof SVGElement)) {\n      return;\n    }\n\n    eventBus.once('spaceTool.selection.ended', function() {\n      self.activateMakeSpace(event.originalEvent);\n    });\n  });\n\n\n  eventBus.on('spaceTool.move', HIGH_PRIORITY , function(event) {\n\n    var context = event.context;\n\n    if (!context.initialized) {\n      context.initialized = self.initializeMakeSpace(event, context);\n    }\n  });\n\n\n  eventBus.on('spaceTool.end', function(event) {\n\n    var context = event.context,\n        axis = context.axis,\n        direction = context.direction,\n        movingShapes = context.movingShapes,\n        resizingShapes = context.resizingShapes;\n\n    // skip if create space has not been initialized yet\n    if (!context.initialized) {\n      return;\n    }\n\n    var delta = { x: round(event.dx), y: round(event.dy) };\n    delta[ AXIS_INVERTED[ axis ] ] = 0;\n\n    var insideBounds = true;\n\n    // check if the space tool cursor is inside of bounds of\n    // any of the shapes that would be resized.\n    forEach(resizingShapes, function(shape) {\n\n      if ((direction === 'w' && event.x > shape.x + shape.width) ||\n          (direction === 'e' && event.x < shape.x) ||\n          (direction === 'n' && event.y > shape.y + shape.height) ||\n          (direction === 's' && event.y < shape.y)) {\n\n        insideBounds = false;\n        return;\n      }\n    });\n\n    if (insideBounds) {\n      // make space only if the cursor is inside bounds\n      self.makeSpace(movingShapes, resizingShapes, delta, direction);\n    }\n\n    eventBus.once('spaceTool.ended', function(event) {\n      // reactivate space tool after usage\n      self.activateSelection(event.originalEvent, true, true);\n    });\n\n  });\n}\n\nSpaceTool.$inject = [ 'eventBus', 'dragging', 'canvas', 'modeling', 'rules', 'toolManager' ];\n\nmodule.exports = SpaceTool;\n\n\n/**\n * Activate space tool selection\n *\n * @param  {MouseEvent} event\n * @param  {Boolean} autoActivate\n */\nSpaceTool.prototype.activateSelection = function(event, autoActivate, reactivate) {\n  this._dragging.init(event, 'spaceTool.selection', {\n    trapClick: false,\n    cursor: SPACE_TOOL_CURSOR,\n    autoActivate: autoActivate,\n    data: {\n      context: {\n        reactivate: reactivate\n      }\n    }\n  });\n};\n\n/**\n * Activate make space\n *\n * @param  {MouseEvent} event\n */\nSpaceTool.prototype.activateMakeSpace = function(event) {\n  this._dragging.init(event, 'spaceTool', {\n    autoActivate: true,\n    cursor: SPACE_TOOL_CURSOR,\n    data: {\n      context: {}\n    }\n  });\n};\n\n/**\n * Actually make space on the diagram\n *\n * @param  {Array<djs.model.Shape>} movingShapes\n * @param  {Array<djs.model.Shape>} resizingShapes\n * @param  {Point} delta\n * @param  {String} direction\n */\nSpaceTool.prototype.makeSpace = function(movingShapes, resizingShapes, delta, direction) {\n  return this._modeling.createSpace(movingShapes, resizingShapes, delta, direction);\n};\n\n/**\n * Initialize make space and return true if that was successful.\n *\n * @param {Event} event\n * @param {Object} context\n *\n * @return {Boolean} true, if successful\n */\nSpaceTool.prototype.initializeMakeSpace = function(event, context) {\n\n  var axis = abs(event.dx) > abs(event.dy) ? 'x' : 'y',\n      offset = event['d' + axis],\n      // start point of create space operation\n      spacePos = event[axis] - offset;\n\n  if (abs(offset) < 5) {\n    return false;\n  }\n\n  // invert the offset in order to remove space when moving left\n  if (offset < 0) {\n    offset *= -1;\n  }\n\n  // inverts the offset to choose the shapes\n  // on the opposite side of the resizer if\n  // a key modifier is pressed\n  if (hasPrimaryModifier(event)) {\n    offset *= -1;\n  }\n\n  var rootShape = this._canvas.getRootElement();\n\n  var allShapes = getAllChildren(rootShape, true);\n\n  var adjustments = this.calculateAdjustments(allShapes, axis, offset, spacePos);\n\n  // store data in context\n  assign(context, adjustments, {\n    axis: axis,\n    direction: SpaceUtil.getDirection(axis, offset)\n  });\n\n  Cursor.set('resize-' + (axis === 'x' ? 'ew' : 'ns'));\n\n  return true;\n};\n\n/**\n * Calculate adjustments needed when making space\n *\n * @param  {Array<djs.model.Shape>} elements\n * @param  {String} axis\n * @param  {Number} offset\n * @param  {Number} spacePos\n *\n * @return {Object}\n */\nSpaceTool.prototype.calculateAdjustments = function(elements, axis, offset, spacePos) {\n\n  var movingShapes = [],\n      resizingShapes = [];\n\n  var rules = this._rules;\n\n  // collect all elements that need to be moved _AND_\n  // resized given on the initial create space position\n  elements.forEach(function(shape) {\n\n    var shapeStart = shape[axis],\n        shapeEnd = shapeStart + shape[AXIS_TO_DIMENSION[axis]];\n\n    // checking if it's root\n    if (!shape.parent) {\n      return;\n    }\n\n    // checking if it's a shape\n    if (shape.waypoints) {\n      return;\n    }\n\n    // shape after spacePos\n    if (offset > 0 && shapeStart > spacePos) {\n      return movingShapes.push(shape);\n    }\n\n    // shape before spacePos\n    if (offset < 0 && shapeEnd < spacePos) {\n      return movingShapes.push(shape);\n    }\n\n    // shape on top of spacePos, resize only if allowed\n    if (shapeStart < spacePos &&\n        shapeEnd > spacePos &&\n        rules.allowed('shape.resize', { shape: shape })) {\n\n      return resizingShapes.push(shape);\n    }\n  });\n\n  return {\n    movingShapes: movingShapes,\n    resizingShapes: resizingShapes\n  };\n};\n\nSpaceTool.prototype.toggle = function() {\n  if (this.isActive()) {\n    this._dragging.cancel();\n  } else {\n    this.activateSelection();\n  }\n};\n\nSpaceTool.prototype.isActive = function() {\n  var context = this._dragging.context();\n\n  return context && /^spaceTool/.test(context.prefix);\n};\n","'use strict';\n\nvar forEach = require(283);\n\nvar MARKER_DRAGGING = 'djs-dragging',\n    MARKER_RESIZING = 'djs-resizing';\n\nvar LOW_PRIORITY = 250;\n\n\n/**\n * Provides previews for selecting/moving/resizing shapes when creating/removing space.\n *\n * @param {EventBus} eventBus\n * @param {ElementRegistry} elementRegistry\n * @param {Canvas} canvas\n * @param {Styles} styles\n */\n\nfunction SpaceToolPreview(eventBus, elementRegistry, canvas, styles, previewSupport) {\n\n  function addPreviewGfx(collection, dragGroup) {\n    forEach(collection, function(element) {\n      previewSupport.addDragger(element, dragGroup);\n\n      canvas.addMarker(element, MARKER_DRAGGING);\n    });\n  }\n\n  // add crosshair\n  eventBus.on('spaceTool.selection.start', function(event) {\n    var space = canvas.getLayer('space'),\n        context = event.context;\n\n    var orientation = {\n      x: 'M 0,-10000 L 0,10000',\n      y: 'M -10000,0 L 10000,0'\n    };\n\n    var crosshairGroup = space.group().attr(styles.cls('djs-crosshair-group', [ 'no-events' ]));\n\n    crosshairGroup.path(orientation.x).addClass('djs-crosshair');\n    crosshairGroup.path(orientation.y).addClass('djs-crosshair');\n\n    context.crosshairGroup = crosshairGroup;\n  });\n\n  // update crosshair\n  eventBus.on('spaceTool.selection.move', function(event) {\n    var crosshairGroup = event.context.crosshairGroup;\n\n    crosshairGroup.translate(event.x, event.y);\n  });\n\n  // remove crosshair\n  eventBus.on('spaceTool.selection.cleanup', function(event) {\n    var context = event.context,\n        crosshairGroup = context.crosshairGroup;\n\n    if (crosshairGroup) {\n      crosshairGroup.remove();\n    }\n  });\n\n  // add and update move/resize previews\n  eventBus.on('spaceTool.move', LOW_PRIORITY, function(event) {\n\n    var context = event.context,\n        line = context.line,\n        axis = context.axis,\n        movingShapes = context.movingShapes,\n        resizingShapes = context.resizingShapes;\n\n    if (!context.initialized) {\n      return;\n    }\n\n    if (!context.dragGroup) {\n      var spaceLayer = canvas.getLayer('space');\n      line = spaceLayer.path('M0,0 L0,0').addClass('djs-crosshair');\n\n      context.line  = line;\n      var dragGroup = canvas.getDefaultLayer().group().attr(styles.cls('djs-drag-group', [ 'no-events' ]));\n\n      // shapes\n      addPreviewGfx(movingShapes, dragGroup);\n\n      // connections\n      var movingConnections = context.movingConnections = elementRegistry.filter(function(element, gfx) {\n        var sourceIsMoving = false;\n\n        forEach(movingShapes, function(shape) {\n          forEach(shape.outgoing, function(connection) {\n            if (element === connection) {\n              sourceIsMoving = true;\n            }\n          });\n        });\n\n        var targetIsMoving = false;\n\n        forEach(movingShapes, function(shape) {\n          forEach(shape.incoming, function(connection) {\n            if (element === connection) {\n              targetIsMoving = true;\n            }\n          });\n        });\n\n        var sourceIsResizing = false;\n\n        forEach(resizingShapes, function(shape) {\n          forEach(shape.outgoing, function(connection) {\n            if (element === connection) {\n              sourceIsResizing = true;\n            }\n          });\n        });\n\n        var targetIsResizing = false;\n\n        forEach(resizingShapes, function(shape) {\n          forEach(shape.incoming, function(connection) {\n            if (element === connection) {\n              targetIsResizing = true;\n            }\n          });\n        });\n\n        return isConnection(element)\n          && (sourceIsMoving || sourceIsResizing)\n          && (targetIsMoving || targetIsResizing);\n      });\n\n\n      addPreviewGfx(movingConnections, dragGroup);\n\n      context.dragGroup = dragGroup;\n    }\n\n    if (!context.frameGroup) {\n      var frameGroup = canvas.getDefaultLayer().group().attr(styles.cls('djs-frame-group', [ 'no-events' ])),\n          frames = [];\n\n      forEach(resizingShapes, function(shape) {\n        var frame = previewSupport.addFrame(shape, frameGroup);\n\n        frames.push({\n          element: frame,\n          initialWidth: frame.getBBox().width,\n          initialHeight: frame.getBBox().height\n        });\n\n        canvas.addMarker(shape, MARKER_RESIZING);\n      });\n\n      context.frameGroup = frameGroup;\n      context.frames = frames;\n    }\n\n    var orientation = {\n      x: 'M' + event.x + ', -10000 L' + event.x + ', 10000',\n      y: 'M -10000, ' + event.y + ' L 10000, ' + event.y\n    };\n\n    line.attr({\n      path: orientation[ axis ],\n      display: ''\n    });\n\n    var opposite = { x: 'y', y: 'x' };\n    var delta = { x: event.dx, y: event.dy };\n    delta[ opposite[ context.axis ] ] = 0;\n\n    // update move previews\n    context.dragGroup.translate(delta.x, delta.y);\n\n    // update resize previews\n    forEach(context.frames, function(frame) {\n      if (frame.initialWidth + delta.x > 5) {\n        frame.element.attr({ width: frame.initialWidth + delta.x });\n      }\n\n      if (frame.initialHeight + delta.y > 5) {\n        frame.element.attr({ height: frame.initialHeight + delta.y });\n      }\n    });\n\n  });\n\n  // remove move/resize previews\n  eventBus.on('spaceTool.cleanup', function(event) {\n\n    var context = event.context,\n        movingShapes = context.movingShapes,\n        movingConnections = context.movingConnections,\n        resizingShapes = context.resizingShapes,\n        line = context.line,\n        dragGroup = context.dragGroup,\n        frameGroup = context.frameGroup;\n\n    // moving shapes\n    forEach(movingShapes, function(shape) {\n      canvas.removeMarker(shape, MARKER_DRAGGING);\n    });\n\n    // moving connections\n    forEach(movingConnections, function(connection) {\n      canvas.removeMarker(connection, MARKER_DRAGGING);\n    });\n\n    if (dragGroup) {\n      line.remove();\n      dragGroup.remove();\n    }\n\n    forEach(resizingShapes, function(shape) {\n      canvas.removeMarker(shape, MARKER_RESIZING);\n    });\n\n    if (frameGroup) {\n      frameGroup.remove();\n    }\n  });\n}\n\nSpaceToolPreview.$inject = [ 'eventBus', 'elementRegistry', 'canvas', 'styles', 'previewSupport' ];\n\nmodule.exports = SpaceToolPreview;\n\n////////// helpers //////////\n\n/**\n * Checks if an element is a connection.\n */\nfunction isConnection(element) {\n  return element.waypoints;\n}\n","'use strict';\n\n/**\n * Get Resize direction given axis + offset\n *\n * @param {String} axis (x|y)\n * @param {Number} offset\n *\n * @return {String} (e|w|n|s)\n */\nfunction getDirection(axis, offset) {\n\n  if (axis === 'x') {\n    if (offset > 0) {\n      return 'e';\n    }\n\n    if (offset < 0) {\n      return 'w';\n    }\n  }\n\n  if (axis === 'y') {\n    if (offset > 0) {\n      return 's';\n    }\n\n    if (offset < 0) {\n      return 'n';\n    }\n  }\n\n  return null;\n}\n\nmodule.exports.getDirection = getDirection;\n\n/**\n * Resize the given bounds by the specified delta from a given anchor point.\n *\n * @param {Bounds} bounds the bounding box that should be resized\n * @param {String} direction in which the element is resized (n, s, e, w)\n * @param {Point} delta of the resize operation\n *\n * @return {Bounds} resized bounding box\n */\nmodule.exports.resizeBounds = function(bounds, direction, delta) {\n\n  var dx = delta.x,\n      dy = delta.y;\n\n  switch (direction) {\n\n  case 'n':\n    return {\n      x: bounds.x,\n      y: bounds.y + dy,\n      width: bounds.width,\n      height: bounds.height - dy\n    };\n\n  case 's':\n    return {\n      x: bounds.x,\n      y: bounds.y,\n      width: bounds.width,\n      height: bounds.height + dy\n    };\n\n  case 'w':\n    return {\n      x: bounds.x + dx,\n      y: bounds.y,\n      width: bounds.width - dx,\n      height: bounds.height\n    };\n\n  case 'e':\n    return {\n      x: bounds.x,\n      y: bounds.y,\n      width: bounds.width + dx,\n      height: bounds.height\n    };\n\n  default:\n    throw new Error('unrecognized direction: ' + direction);\n  }\n};","'use strict';\n\nmodule.exports = {\n  __init__: ['spaceToolPreview'],\n  __depends__: [\n    require(143),\n    require(208),\n    require(223),\n    require(198)\n  ],\n  spaceTool: ['type', require(218)],\n  spaceToolPreview: ['type', require(219) ]\n};\n","'use strict';\n\nvar forEach = require(283);\n\nvar LOW_PRIORITY = 250;\n\n/**\n * The tool manager acts as middle-man between the available tool's and the Palette,\n * it takes care of making sure that the correct active state is set.\n *\n * @param  {Object}    eventBus\n * @param  {Object}    dragging\n */\nfunction ToolManager(eventBus, dragging) {\n  this._eventBus = eventBus;\n  this._dragging = dragging;\n\n  this._tools = [];\n  this._active = null;\n}\n\nToolManager.$inject = [ 'eventBus', 'dragging' ];\n\nmodule.exports = ToolManager;\n\nToolManager.prototype.registerTool = function(name, events) {\n  var tools = this._tools;\n\n  if (!events) {\n    throw new Error('A tool has to be registered with it/'s \"events\"');\n  }\n\n  tools.push(name);\n\n  this.bindEvents(name, events);\n};\n\nToolManager.prototype.isActive = function(tool) {\n  return tool && this._active === tool;\n};\n\nToolManager.prototype.length = function(tool) {\n  return this._tools.length;\n};\n\nToolManager.prototype.setActive = function(tool) {\n  var eventBus = this._eventBus;\n\n  if (this._active !== tool) {\n    this._active = tool;\n\n    eventBus.fire('tool-manager.update', { tool: tool });\n  }\n};\n\nToolManager.prototype.bindEvents = function(name, events) {\n  var eventBus = this._eventBus,\n      dragging = this._dragging;\n\n  var eventsToRegister = [];\n\n  eventBus.on(events.tool + '.init', function(event) {\n    var context = event.context;\n\n    // Active tools that want to reactivate themselves must do this explicitly\n    if (!context.reactivate && this.isActive(name)) {\n      this.setActive(null);\n\n      dragging.cancel();\n      return;\n    }\n\n    this.setActive(name);\n\n  }, this);\n\n  // Todo[ricardo]: add test cases\n  forEach(events, function(event) {\n    eventsToRegister.push(event + '.ended');\n    eventsToRegister.push(event + '.canceled');\n  });\n\n  eventBus.on(eventsToRegister, LOW_PRIORITY, function(event) {\n    var originalEvent = event.originalEvent;\n\n    // We defer the de-activation of the tool to the .activate phase,\n    // so we're able to check if we want to toggle off the current active tool or switch to a new one\n    if (!this._active ||\n        (originalEvent && originalEvent.target.parentElement.getAttribute('data-group') === 'tools')) {\n      return;\n    }\n\n    this.setActive(null);\n  }, this);\n};\n","'use strict';\n\nmodule.exports = {\n  __depends__: [ require(143) ],\n  __init__: [ 'toolManager' ],\n  toolManager: [ 'type', require(222) ]\n};\n","'use strict';\n\nvar isString = require(407),\n    assign = require(410),\n    forEach = require(283);\n\nvar domify = require(428),\n    domAttr = require(423),\n    domClasses = require(424),\n    domRemove = require(432),\n    domDelegate = require(427);\n\n\n// document wide unique tooltip ids\nvar ids = new (require(251))('tt');\n\n\nfunction createRoot(parent) {\n  var root = domify('<div class=\"djs-tooltip-container\" style=\"position: absolute; width: 0; height: 0;\" />');\n  parent.insertBefore(root, parent.firstChild);\n\n  return root;\n}\n\n\nfunction setPosition(el, x, y) {\n  assign(el.style, { left: x + 'px', top: y + 'px' });\n}\n\nfunction setVisible(el, visible) {\n  el.style.display = visible === false ? 'none' : '';\n}\n\n\nvar tooltipClass = 'djs-tooltip',\n    tooltipSelector = '.' + tooltipClass;\n\n/**\n * A service that allows users to render tool tips on the diagram.\n *\n * The tooltip service will take care of updating the tooltip positioning\n * during navigation + zooming.\n *\n * @example\n *\n * ```javascript\n *\n * // add a pink badge on the top left of the shape\n * tooltips.add({\n *   position: {\n *     x: 50,\n *     y: 100\n *   },\n *   html: '<div style=\"width: 10px; background: fuchsia; color: white;\">0</div>'\n * });\n *\n * // or with optional life span\n * tooltips.add({\n *   position: {\n *     top: -5,\n *     left: -5\n *   },\n *   html: '<div style=\"width: 10px; background: fuchsia; color: white;\">0</div>',\n *   ttl: 2000\n * });\n *\n * // remove a tool tip\n * var id = tooltips.add(...);\n * tooltips.remove(id);\n * ```\n *\n * @param {EventBus} eventBus\n * @param {Canvas} canvas\n */\nfunction Tooltips(eventBus, canvas) {\n\n  this._eventBus = eventBus;\n  this._canvas = canvas;\n\n  this._ids = ids;\n\n  this._tooltipDefaults = {\n    show: {\n      minZoom: 0.7,\n      maxZoom: 5.0\n    }\n  };\n\n  /**\n   * Mapping tooltipId -> tooltip\n   */\n  this._tooltips = {};\n\n  // root html element for all tooltips\n  this._tooltipRoot = createRoot(canvas.getContainer());\n\n\n  var self = this;\n\n  domDelegate.bind(this._tooltipRoot, tooltipSelector, 'mousedown', function(event) {\n    event.stopPropagation();\n  });\n\n  domDelegate.bind(this._tooltipRoot, tooltipSelector, 'mouseover', function(event) {\n    self.trigger('mouseover', event);\n  });\n\n  domDelegate.bind(this._tooltipRoot, tooltipSelector, 'mouseout', function(event) {\n    self.trigger('mouseout', event);\n  });\n\n  this._init();\n}\n\n\nTooltips.$inject = [ 'eventBus', 'canvas' ];\n\nmodule.exports = Tooltips;\n\n\n/**\n * Adds a HTML tooltip to the diagram\n *\n * @param {Object}               tooltip   the tooltip configuration\n *\n * @param {String|DOMElement}    tooltip.html                 html element to use as an tooltip\n * @param {Object}               [tooltip.show]               show configuration\n * @param {Number}               [tooltip.show.minZoom]       minimal zoom level to show the tooltip\n * @param {Number}               [tooltip.show.maxZoom]       maximum zoom level to show the tooltip\n * @param {Object}               tooltip.position             where to attach the tooltip\n * @param {Number}               [tooltip.position.left]      relative to element bbox left attachment\n * @param {Number}               [tooltip.position.top]       relative to element bbox top attachment\n * @param {Number}               [tooltip.position.bottom]    relative to element bbox bottom attachment\n * @param {Number}               [tooltip.position.right]     relative to element bbox right attachment\n * @param {Number}               [tooltip.timeout=-1]\n *\n * @return {String}              id that may be used to reference the tooltip for update or removal\n */\nTooltips.prototype.add = function(tooltip) {\n\n  if (!tooltip.position) {\n    throw new Error('must specifiy tooltip position');\n  }\n\n  if (!tooltip.html) {\n    throw new Error('must specifiy tooltip html');\n  }\n\n  var id = this._ids.next();\n\n  tooltip = assign({}, this._tooltipDefaults, tooltip, {\n    id: id\n  });\n\n  this._addTooltip(tooltip);\n\n  if (tooltip.timeout) {\n    this.setTimeout(tooltip);\n  }\n\n  return id;\n};\n\nTooltips.prototype.trigger = function(action, event) {\n\n  var node = event.delegateTarget || event.target;\n\n  var tooltip = this.get(domAttr(node, 'data-tooltip-id'));\n\n  if (!tooltip) {\n    return;\n  }\n\n  if (action === 'mouseover' && tooltip.timeout) {\n    this.clearTimeout(tooltip);\n  }\n\n  if (action === 'mouseout' && tooltip.timeout) {\n    // cut timeout after mouse out\n    tooltip.timeout = 1000;\n\n    this.setTimeout(tooltip);\n  }\n};\n\n/**\n * Get a tooltip with the given id\n *\n * @param {String} id\n */\nTooltips.prototype.get = function(id) {\n\n  if (typeof id !== 'string') {\n    id = id.id;\n  }\n\n  return this._tooltips[id];\n};\n\nTooltips.prototype.clearTimeout = function(tooltip) {\n\n  tooltip = this.get(tooltip);\n\n  if (!tooltip) {\n    return;\n  }\n\n  var removeTimer = tooltip.removeTimer;\n\n  if (removeTimer) {\n    clearTimeout(removeTimer);\n    tooltip.removeTimer = null;\n  }\n};\n\nTooltips.prototype.setTimeout = function(tooltip) {\n\n  tooltip = this.get(tooltip);\n\n  if (!tooltip) {\n    return;\n  }\n\n  this.clearTimeout(tooltip);\n\n  var self = this;\n\n  tooltip.removeTimer = setTimeout(function() {\n    self.remove(tooltip);\n  }, tooltip.timeout);\n};\n\n/**\n * Remove an tooltip with the given id\n *\n * @param {String} id\n */\nTooltips.prototype.remove = function(id) {\n\n  var tooltip = this.get(id);\n\n  if (tooltip) {\n    domRemove(tooltip.html);\n    domRemove(tooltip.htmlContainer);\n\n    delete tooltip.htmlContainer;\n\n    delete this._tooltips[tooltip.id];\n  }\n};\n\n\nTooltips.prototype.show = function() {\n  setVisible(this._tooltipRoot);\n};\n\n\nTooltips.prototype.hide = function() {\n  setVisible(this._tooltipRoot, false);\n};\n\n\nTooltips.prototype._updateRoot = function(viewbox) {\n  var a = viewbox.scale || 1;\n  var d = viewbox.scale || 1;\n\n  var matrix = 'matrix(' + a + ',0,0,' + d + ',' + (-1 * viewbox.x * a) + ',' + (-1 * viewbox.y * d) + ')';\n\n  this._tooltipRoot.style.transform = matrix;\n  this._tooltipRoot.style['-ms-transform'] = matrix;\n};\n\n\nTooltips.prototype._addTooltip = function(tooltip) {\n\n  var id = tooltip.id,\n      html = tooltip.html,\n      htmlContainer,\n      tooltipRoot = this._tooltipRoot;\n\n  // unwrap jquery (for those who need it)\n  if (html.get) {\n    html = html.get(0);\n  }\n\n  // create proper html elements from\n  // tooltip HTML strings\n  if (isString(html)) {\n    html = domify(html);\n  }\n\n  htmlContainer = domify('<div data-tooltip-id=\"' + id + '\" class=\"' + tooltipClass + '\" style=\"position: absolute\">');\n\n  htmlContainer.appendChild(html);\n\n  if (tooltip.type) {\n    domClasses(htmlContainer).add('djs-tooltip-' + tooltip.type);\n  }\n\n  if (tooltip.className) {\n    domClasses(htmlContainer).add(tooltip.className);\n  }\n\n  tooltip.htmlContainer = htmlContainer;\n\n  tooltipRoot.appendChild(htmlContainer);\n\n  this._tooltips[id] = tooltip;\n\n  this._updateTooltip(tooltip);\n};\n\n\nTooltips.prototype._updateTooltip = function(tooltip) {\n\n  var position = tooltip.position,\n      htmlContainer = tooltip.htmlContainer;\n\n  // update overlay html based on tooltip x, y\n\n  setPosition(htmlContainer, position.x, position.y);\n};\n\n\nTooltips.prototype._updateTooltipVisibilty = function(viewbox) {\n\n  forEach(this._tooltips, function(tooltip) {\n    var show = tooltip.show,\n        htmlContainer = tooltip.htmlContainer,\n        visible = true;\n\n    if (show) {\n      if (show.minZoom > viewbox.scale ||\n          show.maxZoom < viewbox.scale) {\n        visible = false;\n      }\n\n      setVisible(htmlContainer, visible);\n    }\n  });\n};\n\nTooltips.prototype._init = function() {\n\n  var self = this;\n\n  // scroll/zoom integration\n\n  function updateViewbox(viewbox) {\n    self._updateRoot(viewbox);\n    self._updateTooltipVisibilty(viewbox);\n\n    self.show();\n  }\n\n  this._eventBus.on('canvas.viewbox.changing', function(event) {\n    self.hide();\n  });\n\n  this._eventBus.on('canvas.viewbox.changed', function(event) {\n    updateViewbox(event.viewbox);\n  });\n};\n","module.exports = {\n  __init__: [ 'tooltips' ],\n  tooltips: [ 'type', require(224) ]\n};","'use strict';\n\nfunction TouchFix(canvas, eventBus) {\n\n  var self = this;\n\n  eventBus.on('canvas.init', function(e) {\n    self.addBBoxMarker(e.svg);\n  });\n}\n\nTouchFix.$inject = [ 'canvas', 'eventBus' ];\n\nmodule.exports = TouchFix;\n\n\n/**\n * Safari mobile (iOS 7) does not fire touchstart event in <SVG> element\n * if there is no shape between 0,0 and viewport elements origin.\n *\n * So touchstart event is only fired when the <g class=\"viewport\"> element was hit.\n * Putting an element over and below the 'viewport' fixes that behavior.\n */\nTouchFix.prototype.addBBoxMarker = function(paper) {\n\n  var markerStyle = {\n    fill: 'none',\n    class: 'outer-bound-marker'\n  };\n\n  paper.rect(-10000, -10000, 10, 10).attr(markerStyle);\n  paper.rect(10000, 10000, 10, 10).attr(markerStyle);\n};\n","'use strict';\n\nvar forEach = require(283),\n    domEvent = require(429),\n    domClosest = require(426),\n    Hammer = require(265),\n    Snap = require(267),\n    Event = require(248);\n\nvar MIN_ZOOM = 0.2,\n    MAX_ZOOM = 4;\n\nvar mouseEvents = [\n  'mousedown',\n  'mouseup',\n  'mouseover',\n  'mouseout',\n  'click',\n  'dblclick'\n];\n\nfunction log() {\n  // console.log.apply(console, arguments);\n}\n\nfunction get(service, injector) {\n  return injector.get(service, false);\n}\n\nfunction createTouchRecognizer(node) {\n\n  function stopEvent(event) {\n    Event.stopEvent(event, true);\n  }\n\n  function stopMouse(event) {\n\n    forEach(mouseEvents, function(e) {\n      domEvent.bind(node, e, stopEvent, true);\n    });\n  }\n\n  function allowMouse(event) {\n    setTimeout(function() {\n      forEach(mouseEvents, function(e) {\n        domEvent.unbind(node, e, stopEvent, true);\n      });\n    }, 500);\n  }\n\n  domEvent.bind(node, 'touchstart', stopMouse, true);\n  domEvent.bind(node, 'touchend', allowMouse, true);\n  domEvent.bind(node, 'touchcancel', allowMouse, true);\n\n  // A touch event recognizer that handles\n  // touch events only (we know, we can already handle\n  // mouse events out of the box)\n\n  var recognizer = new Hammer.Manager(node, {\n    inputClass: Hammer.TouchInput,\n    recognizers: []\n  });\n\n\n  var tap = new Hammer.Tap();\n  var pan = new Hammer.Pan({ threshold: 10 });\n  var press = new Hammer.Press();\n  var pinch = new Hammer.Pinch();\n\n  var doubleTap = new Hammer.Tap({ event: 'doubletap', taps: 2 });\n\n  pinch.requireFailure(pan);\n  pinch.requireFailure(press);\n\n  recognizer.add([ pan, press, pinch, doubleTap, tap ]);\n\n  recognizer.reset = function(force) {\n    var recognizers = this.recognizers,\n        session = this.session;\n\n    if (session.stopped) {\n      return;\n    }\n\n    log('recognizer', 'stop');\n\n    recognizer.stop(force);\n\n    setTimeout(function() {\n      var i, r;\n\n      log('recognizer', 'reset');\n      for (i = 0; (r = recognizers[i]); i++) {\n        r.reset();\n        r.state = 8; // FAILED STATE\n      }\n\n      session.curRecognizer = null;\n    }, 0);\n  };\n\n  recognizer.on('hammer.input', function(event) {\n    if (event.srcEvent.defaultPrevented) {\n      recognizer.reset(true);\n    }\n  });\n\n  return recognizer;\n}\n\n/**\n * A plugin that provides touch events for elements.\n *\n * @param {EventBus} eventBus\n * @param {InteractionEvents} interactionEvents\n */\nfunction TouchInteractionEvents(injector, canvas, eventBus, elementRegistry, interactionEvents) {\n\n  // optional integrations\n  var dragging = get('dragging', injector),\n      move = get('move', injector),\n      contextPad = get('contextPad', injector),\n      palette = get('palette', injector);\n\n  // the touch recognizer\n  var recognizer;\n\n  function handler(type) {\n\n    return function(event) {\n      log('element', type, event);\n\n      interactionEvents.fire(type, event);\n    };\n  }\n\n  function getGfx(target) {\n    var node = domClosest(target, 'svg, .djs-element', true);\n    return node && new Snap(node);\n  }\n\n  function initEvents(svg) {\n\n    // touch recognizer\n    recognizer = createTouchRecognizer(svg);\n\n    recognizer.on('doubletap', handler('element.dblclick'));\n\n    recognizer.on('tap', handler('element.click'));\n\n    function startGrabCanvas(event) {\n\n      log('canvas', 'grab start');\n\n      var lx = 0, ly = 0;\n\n      function update(e) {\n\n        var dx = e.deltaX - lx,\n            dy = e.deltaY - ly;\n\n        canvas.scroll({ dx: dx, dy: dy });\n\n        lx = e.deltaX;\n        ly = e.deltaY;\n      }\n\n      function end(e) {\n        recognizer.off('panmove', update);\n        recognizer.off('panend', end);\n        recognizer.off('pancancel', end);\n\n        log('canvas', 'grab end');\n      }\n\n      recognizer.on('panmove', update);\n      recognizer.on('panend', end);\n      recognizer.on('pancancel', end);\n    }\n\n    function startGrab(event) {\n\n      var gfx = getGfx(event.target),\n          element = gfx && elementRegistry.get(gfx);\n\n      // recognizer\n      if (move && canvas.getRootElement() !== element) {\n        log('element', 'move start', element, event, true);\n        return move.start(event, element, true);\n      } else {\n        startGrabCanvas(event);\n      }\n    }\n\n    function startZoom(e) {\n\n      log('canvas', 'zoom start');\n\n      var zoom = canvas.zoom(),\n          mid = e.center;\n\n      function update(e) {\n\n        var ratio = 1 - (1 - e.scale) / 1.50,\n            newZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, ratio * zoom));\n\n        canvas.zoom(newZoom, mid);\n\n        Event.stopEvent(e, true);\n      }\n\n      function end(e) {\n        recognizer.off('pinchmove', update);\n        recognizer.off('pinchend', end);\n        recognizer.off('pinchcancel', end);\n\n        recognizer.reset(true);\n\n        log('canvas', 'zoom end');\n      }\n\n      recognizer.on('pinchmove', update);\n      recognizer.on('pinchend', end);\n      recognizer.on('pinchcancel', end);\n    }\n\n    recognizer.on('panstart', startGrab);\n    recognizer.on('press', startGrab);\n\n    recognizer.on('pinchstart', startZoom);\n  }\n\n  if (dragging) {\n\n    // simulate hover during dragging\n    eventBus.on('drag.move', function(event) {\n\n      var originalEvent = event.originalEvent;\n\n      if (!originalEvent || originalEvent instanceof MouseEvent) {\n        return;\n      }\n\n      var position = Event.toPoint(originalEvent);\n\n      // this gets really expensive ...\n      var node = document.elementFromPoint(position.x, position.y),\n          gfx = getGfx(node),\n          element = gfx && elementRegistry.get(gfx);\n\n      if (element !== event.hover) {\n        if (event.hover) {\n          dragging.out(event);\n        }\n\n        if (element) {\n          dragging.hover({ element: element, gfx: gfx });\n\n          event.hover = element;\n          event.hoverGfx = gfx;\n        }\n      }\n    });\n  }\n\n  if (contextPad) {\n\n    eventBus.on('contextPad.create', function(event) {\n      var node = event.pad.html;\n\n      // touch recognizer\n      var padRecognizer = createTouchRecognizer(node);\n\n      padRecognizer.on('panstart', function(event) {\n        log('context-pad', 'panstart', event);\n        contextPad.trigger('dragstart', event, true);\n      });\n\n      padRecognizer.on('press', function(event) {\n        log('context-pad', 'press', event);\n        contextPad.trigger('dragstart', event, true);\n      });\n\n      padRecognizer.on('tap', function(event) {\n        log('context-pad', 'tap', event);\n        contextPad.trigger('click', event);\n      });\n    });\n  }\n\n  if (palette) {\n    eventBus.on('palette.create', function(event) {\n      var node = event.html;\n\n      // touch recognizer\n      var padRecognizer = createTouchRecognizer(node);\n\n      padRecognizer.on('panstart', function(event) {\n        log('palette', 'panstart', event);\n        palette.trigger('dragstart', event, true);\n      });\n\n      padRecognizer.on('press', function(event) {\n        log('palette', 'press', event);\n        palette.trigger('dragstart', event, true);\n      });\n\n      padRecognizer.on('tap', function(event) {\n        log('palette', 'tap', event);\n        palette.trigger('click', event);\n      });\n    });\n  }\n\n  eventBus.on('canvas.init', function(event) {\n    initEvents(event.svg.node);\n  });\n}\n\n\nTouchInteractionEvents.$inject = [\n  'injector',\n  'canvas',\n  'eventBus',\n  'elementRegistry',\n  'interactionEvents',\n  'touchFix'\n];\n\nmodule.exports = TouchInteractionEvents;","module.exports = {\n  __depends__: [ require(151) ],\n  __init__: [ 'touchInteractionEvents' ],\n  touchInteractionEvents: [ 'type', require(227) ],\n  touchFix: [ 'type', require(226) ]\n};","module.exports = {\n  translate: [ 'value', require(230) ]\n};","'use strict';\n\n/**\n * A simple translation stub to be used for multi-language support\n * in diagrams. Can be easily replaced with a more sophisticated\n * solution.\n *\n * @example\n *\n * // use it inside any diagram component by injecting `translate`.\n *\n * function MyService(translate) {\n *   alert(translate('HELLO {you}', { you: 'You!' }));\n * }\n *\n * @param {String} template to interpolate\n * @param {Object} [replacements] a map with substitutes\n *\n * @return {String} the translated string\n */\nmodule.exports = function translate(template, replacements) {\n\n  replacements = replacements || {};\n\n  return template.replace(/{([^}]+)}/g, function(_, key) {\n    return replacements[key] || '{' + key + '}';\n  });\n};","'use strict';\n\nvar getMid = require(233).getMid;\n\n\n/**\n * A base connection layouter implementation\n * that layouts the connection by directly connecting\n * mid(source) + mid(target).\n */\nfunction BaseLayouter() {}\n\nmodule.exports = BaseLayouter;\n\n\n/**\n * Return the new layouted waypoints for the given connection.\n *\n * The connection passed is still unchanged; you may figure out about\n * the new connection start / end via the layout hints provided.\n *\n * @param {djs.model.Connection} connection\n * @param {Object} [hints]\n * @param {Point} [hints.connectionStart]\n * @param {Point} [hints.connectionEnd]\n *\n * @return {Array<Point>} the layouted connection waypoints\n */\nBaseLayouter.prototype.layoutConnection = function(connection, hints) {\n\n  hints = hints || {};\n\n  return [\n    hints.connectionStart || getMid(connection.source),\n    hints.connectionEnd || getMid(connection.target)\n  ];\n};\n","'use strict';\n\nvar assign = require(410);\n\nvar LayoutUtil = require(233);\n\n\nfunction dockingToPoint(docking) {\n  // use the dockings actual point and\n  // retain the original docking\n  return assign({ original: docking.point.original || docking.point }, docking.actual);\n}\n\n\n/**\n * A {@link ConnectionDocking} that crops connection waypoints based on\n * the path(s) of the connection source and target.\n *\n * @param {djs.core.ElementRegistry} elementRegistry\n */\nfunction CroppingConnectionDocking(elementRegistry, graphicsFactory) {\n  this._elementRegistry = elementRegistry;\n  this._graphicsFactory = graphicsFactory;\n}\n\nCroppingConnectionDocking.$inject = [ 'elementRegistry', 'graphicsFactory' ];\n\nmodule.exports = CroppingConnectionDocking;\n\n\n/**\n * @inheritDoc ConnectionDocking#getCroppedWaypoints\n */\nCroppingConnectionDocking.prototype.getCroppedWaypoints = function(connection, source, target) {\n\n  source = source || connection.source;\n  target = target || connection.target;\n\n  var sourceDocking = this.getDockingPoint(connection, source, true),\n      targetDocking = this.getDockingPoint(connection, target);\n\n  var croppedWaypoints = connection.waypoints.slice(sourceDocking.idx + 1, targetDocking.idx);\n\n  croppedWaypoints.unshift(dockingToPoint(sourceDocking));\n  croppedWaypoints.push(dockingToPoint(targetDocking));\n\n  return croppedWaypoints;\n};\n\n/**\n * Return the connection docking point on the specified shape\n *\n * @inheritDoc ConnectionDocking#getDockingPoint\n */\nCroppingConnectionDocking.prototype.getDockingPoint = function(connection, shape, dockStart) {\n\n  var waypoints = connection.waypoints,\n      dockingIdx,\n      dockingPoint,\n      croppedPoint;\n\n  dockingIdx = dockStart ? 0 : waypoints.length - 1;\n  dockingPoint = waypoints[dockingIdx];\n\n  croppedPoint = this._getIntersection(shape, connection, dockStart);\n\n  return {\n    point: dockingPoint,\n    actual: croppedPoint || dockingPoint,\n    idx: dockingIdx\n  };\n};\n\n\n////// helper methods ///////////////////////////////////////////////////\n\nCroppingConnectionDocking.prototype._getIntersection = function(shape, connection, takeFirst) {\n\n  var shapePath = this._getShapePath(shape),\n      connectionPath = this._getConnectionPath(connection);\n\n  return LayoutUtil.getElementLineIntersection(shapePath, connectionPath, takeFirst);\n};\n\nCroppingConnectionDocking.prototype._getConnectionPath = function(connection) {\n  return this._graphicsFactory.getConnectionPath(connection);\n};\n\nCroppingConnectionDocking.prototype._getShapePath = function(shape) {\n  return this._graphicsFactory.getShapePath(shape);\n};\n\nCroppingConnectionDocking.prototype._getGfx = function(element) {\n  return this._elementRegistry.getGraphics(element);\n};\n","'use strict';\n\nvar isObject = require(405),\n    sortBy = require(291),\n    pointDistance = require(249).pointDistance;\n\nvar Snap = require(267);\n\n\nfunction roundBounds(bounds) {\n  return {\n    x: Math.round(bounds.x),\n    y: Math.round(bounds.y),\n    width: Math.round(bounds.width),\n    height: Math.round(bounds.height)\n  };\n}\n\nmodule.exports.roundBounds = roundBounds;\n\n\nfunction roundPoint(point) {\n\n  return {\n    x: Math.round(point.x),\n    y: Math.round(point.y)\n  };\n}\n\nmodule.exports.roundPoint = roundPoint;\n\n\n/**\n * Convert the given bounds to a { top, left, bottom, right } descriptor.\n *\n * @param {Bounds|Point} bounds\n *\n * @return {Object}\n */\nfunction asTRBL(bounds) {\n  return {\n    top: bounds.y,\n    right: bounds.x + (bounds.width || 0),\n    bottom: bounds.y + (bounds.height || 0),\n    left: bounds.x\n  };\n}\n\nmodule.exports.asTRBL = asTRBL;\n\n/**\n * Convert a { top, left, bottom, right } to an objects bounds.\n *\n * @param {Object} trbl\n *\n * @return {Bounds}\n */\nfunction asBounds(trbl) {\n  return {\n    x: trbl.left,\n    y: trbl.top,\n    width: trbl.right - trbl.left,\n    height: trbl.bottom - trbl.top\n  };\n}\n\nmodule.exports.asBounds = asBounds;\n\n\n/**\n * Get the mid of the given bounds or point.\n *\n * @param {Bounds|Point} bounds\n *\n * @return {Point}\n */\nfunction getMid(bounds) {\n  return roundPoint({\n    x: bounds.x + (bounds.width || 0) / 2,\n    y: bounds.y + (bounds.height || 0) / 2\n  });\n}\n\nmodule.exports.getMid = getMid;\n\n\n////// orientation utils //////////////////////////////\n\n/**\n * Get orientation of the given rectangle with respect to\n * the reference rectangle.\n *\n * A padding (positive or negative) may be passed to influence\n * horizontal / vertical orientation and intersection.\n *\n * @param {Bounds} rect\n * @param {Bounds} reference\n * @param {Point|Number} padding\n *\n * @return {String} the orientation; one of top, top-left, left, ..., bottom, right or intersect.\n */\nfunction getOrientation(rect, reference, padding) {\n\n  padding = padding || 0;\n\n  // make sure we can use an object, too\n  // for individual { x, y } padding\n  if (!isObject(padding)) {\n    padding = { x: padding, y: padding };\n  }\n\n\n  var rectOrientation = asTRBL(rect),\n      referenceOrientation = asTRBL(reference);\n\n  var top = rectOrientation.bottom + padding.y <= referenceOrientation.top,\n      right = rectOrientation.left - padding.x >= referenceOrientation.right,\n      bottom = rectOrientation.top - padding.y >= referenceOrientation.bottom,\n      left = rectOrientation.right + padding.x <= referenceOrientation.left;\n\n  var vertical = top ? 'top' : (bottom ? 'bottom' : null),\n      horizontal = left ? 'left' : (right ? 'right' : null);\n\n  if (horizontal && vertical) {\n    return vertical + '-' + horizontal;\n  } else {\n    return horizontal || vertical || 'intersect';\n  }\n}\n\nmodule.exports.getOrientation = getOrientation;\n\n\n////// intersection utils //////////////////////////////\n\n/**\n * Get intersection between an element and a line path.\n *\n * @param {PathDef} elementPath\n * @param {PathDef} linePath\n * @param {Boolean} cropStart crop from start or end\n *\n * @return {Point}\n */\nfunction getElementLineIntersection(elementPath, linePath, cropStart) {\n\n  var intersections = getIntersections(elementPath, linePath);\n\n  // recognize intersections\n  // only one -> choose\n  // two close together -> choose first\n  // two or more distinct -> pull out appropriate one\n  // none -> ok (fallback to point itself)\n  if (intersections.length === 1) {\n    return roundPoint(intersections[0]);\n  } else if (intersections.length === 2 && pointDistance(intersections[0], intersections[1]) < 1) {\n    return roundPoint(intersections[0]);\n  } else if (intersections.length > 1) {\n\n    // sort by intersections based on connection segment +\n    // distance from start\n    intersections = sortBy(intersections, function(i) {\n      var distance = Math.floor(i.t2 * 100) || 1;\n\n      distance = 100 - distance;\n\n      distance = (distance < 10 ? '0' : '') + distance;\n\n      // create a sort string that makes sure we sort\n      // line segment ASC + line segment position DESC (for cropStart)\n      // line segment ASC + line segment position ASC (for cropEnd)\n      return i.segment2 + '#' + distance;\n    });\n\n    return roundPoint(intersections[cropStart ? 0 : intersections.length - 1]);\n  }\n\n  return null;\n}\n\nmodule.exports.getElementLineIntersection = getElementLineIntersection;\n\n\nfunction getIntersections(a, b) {\n  return Snap.path.intersection(a, b);\n}\n\nmodule.exports.getIntersections = getIntersections;\n","'use strict';\n\nvar isArray = require(401),\n    find = require(282),\n    without = require(277),\n    assign = require(410);\n\nvar LayoutUtil = require(233),\n    Geometry = require(249);\n\nvar getOrientation = LayoutUtil.getOrientation,\n    getMid = LayoutUtil.getMid,\n    pointsAligned = Geometry.pointsAligned;\n\nvar pointInRect = Geometry.pointInRect,\n    pointDistance = Geometry.pointDistance;\n\nvar INTERSECTION_THRESHOLD = 20,\n    ORIENTATION_THRESHOLD = {\n      'h:h': 20,\n      'v:v': 20,\n      'h:v': -10,\n      'v:h': -10\n    };\n\n\n/**\n * Returns the mid points for a manhattan connection between two points.\n *\n * @example\n *\n * [a]----[x]\n *         |\n *        [x]----[b]\n *\n * @example\n *\n * [a]----[x]\n *         |\n *        [b]\n *\n * @param  {Point} a\n * @param  {Point} b\n * @param  {String} directions\n *\n * @return {Array<Point>}\n */\nmodule.exports.getBendpoints = function(a, b, directions) {\n\n  directions = directions || 'h:h';\n\n  var xmid, ymid;\n\n  // one point, next to a\n  if (directions === 'h:v') {\n    return [ { x: b.x, y: a.y } ];\n  } else\n  // one point, above a\n  if (directions === 'v:h') {\n    return [ { x: a.x, y: b.y } ];\n  } else\n  // vertical edge xmid\n  if (directions === 'h:h') {\n    xmid = Math.round((b.x - a.x) / 2 + a.x);\n\n    return [\n      { x: xmid, y: a.y },\n      { x: xmid, y: b.y }\n    ];\n  } else\n  // horizontal edge ymid\n  if (directions === 'v:v') {\n    ymid = Math.round((b.y - a.y) / 2 + a.y);\n\n    return [\n      { x: a.x, y: ymid },\n      { x: b.x, y: ymid }\n    ];\n  } else {\n    throw new Error(\n      'unknown directions: <' + directions + '>: ' +\n      'directions must be specified as {a direction}:{b direction} (direction in h|v)');\n  }\n};\n\n\n/**\n * Create a connection between the two points according\n * to the manhattan layout (only horizontal and vertical) edges.\n *\n * @param {Point} a\n * @param {Point} b\n *\n * @param {String} [directions='h:h'] specifies manhattan directions for each point as {adirection}:{bdirection}.\n                   A directionfor a point is either `h` (horizontal) or `v` (vertical)\n *\n * @return {Array<Point>}\n */\nmodule.exports.connectPoints = function(a, b, directions) {\n\n  var points = [];\n\n  if (!pointsAligned(a, b)) {\n    points = this.getBendpoints(a, b, directions);\n  }\n\n  points.unshift(a);\n  points.push(b);\n\n  return points;\n};\n\n\n/**\n * Connect two rectangles using a manhattan layouted connection.\n *\n * @param {Bounds} source source rectangle\n * @param {Bounds} target target rectangle\n * @param {Point} [start] source docking\n * @param {Point} [end] target docking\n *\n * @param {Object} [hints]\n * @param {String} [hints.preserveDocking=source] preserve docking on selected side\n * @param {Array<String>} [hints.preferredLayouts]\n * @param {Point|Boolean} [hints.connectionStart] whether the start changed\n * @param {Point|Boolean} [hints.connectionEnd] whether the end changed\n *\n * @return {Array<Point>} connection points\n */\nmodule.exports.connectRectangles = function(source, target, start, end, hints) {\n\n  var preferredLayouts = hints && hints.preferredLayouts || [];\n\n  var preferredLayout = without(preferredLayouts, 'straight')[0] || 'h:h';\n\n  var threshold = ORIENTATION_THRESHOLD[preferredLayout] || 0;\n\n  var orientation = getOrientation(source, target, threshold);\n\n  var directions = getDirections(orientation, preferredLayout);\n\n  start = start || getMid(source);\n  end = end || getMid(target);\n\n  // overlapping elements\n  if (!directions) {\n    return;\n  }\n\n  if (directions === 'h:h') {\n\n    switch (orientation) {\n    case 'top-right':\n    case 'right':\n    case 'bottom-right':\n      start = { original: start, x: source.x, y: start.y };\n      end = { original: end, x: target.x + target.width, y: end.y };\n      break;\n    case 'top-left':\n    case 'left':\n    case 'bottom-left':\n      start = { original: start, x: source.x + source.width, y: start.y };\n      end = { original: end, x: target.x, y: end.y };\n      break;\n    }\n  }\n\n  if (directions === 'v:v') {\n\n    switch (orientation) {\n    case 'top-left':\n    case 'top':\n    case 'top-right':\n      start = { original: start, x: start.x, y: source.y + source.height };\n      end = { original: end, x: end.x, y: target.y };\n      break;\n    case 'bottom-left':\n    case 'bottom':\n    case 'bottom-right':\n      start = { original: start, x: start.x, y: source.y };\n      end = { original: end, x: end.x, y: target.y + target.height };\n      break;\n    }\n  }\n\n  return this.connectPoints(start, end, directions);\n};\n\n/**\n * Repair the connection between two rectangles, of which one has been updated.\n *\n * @param {Bounds} source\n * @param {Bounds} target\n * @param {Point} [start]\n * @param {Point} [end]\n * @param {Array<Point>} waypoints\n * @param {Object} [hints]\n * @param {Array<String>} [hints.preferredLayouts] list of preferred layouts\n * @param {Boolean} [hints.connectionStart]\n * @param {Boolean} [hints.connectionEnd]\n *\n * @return {Array<Point>} repaired waypoints\n */\nmodule.exports.repairConnection = function(source, target, start, end, waypoints, hints) {\n\n  if (isArray(start)) {\n    waypoints = start;\n    hints = end;\n\n    start = getMid(source);\n    end = getMid(target);\n  }\n\n  hints = assign({ preferredLayouts: [] }, hints);\n  waypoints = waypoints || [];\n\n  var preferredLayouts = hints.preferredLayouts,\n      layoutStraight = preferredLayouts.indexOf('straight') !== -1,\n      repairedWaypoints;\n\n  // just layout non-existing or simple connections\n  // attempt to render straight lines, if required\n\n  if (layoutStraight) {\n    // attempt to layout a straight line\n    repairedWaypoints = this.layoutStraight(source, target, start, end, hints);\n  }\n\n  if (!repairedWaypoints) {\n    // check if we layout from start or end\n    if (hints.connectionEnd) {\n      repairedWaypoints = this._repairConnectionSide(target, source, end, waypoints.slice().reverse());\n      repairedWaypoints = repairedWaypoints && repairedWaypoints.reverse();\n    } else\n    if (hints.connectionStart) {\n      repairedWaypoints = this._repairConnectionSide(source, target, start, waypoints);\n    } else\n    // or whether nothing seems to have changed\n    if (waypoints && waypoints.length) {\n      repairedWaypoints = waypoints;\n    }\n  }\n\n  // simply reconnect if nothing else worked\n  if (!repairedWaypoints) {\n    repairedWaypoints = this.connectRectangles(source, target, start, end, hints);\n  }\n\n  return repairedWaypoints;\n};\n\n\nfunction inRange(a, start, end) {\n  return a >= start && a <= end;\n}\n\nfunction isInRange(axis, a, b) {\n  var size = {\n    x: 'width',\n    y: 'height'\n  };\n\n  return inRange(a[axis], b[axis], b[axis] + b[size[axis]]);\n}\n\n/**\n * Layout a straight connection\n *\n * @param {Bounds} source\n * @param {Bounds} target\n * @param {Point} start\n * @param {Point} end\n * @param {Object} [hints]\n *\n * @return {Array<Point>} waypoints if straight layout worked\n */\nmodule.exports.layoutStraight = function(source, target, start, end, hints) {\n  var axis = {},\n      primaryAxis,\n      orientation;\n\n  orientation = getOrientation(source, target);\n\n  // We're only interested in layouting a straight connection\n  // if the shapes are horizontally or vertically aligned\n  if (!/^(top|bottom|left|right)$/.test(orientation)) {\n    return null;\n  }\n\n  if (/top|bottom/.test(orientation)) {\n    primaryAxis = 'x';\n  }\n\n  if (/left|right/.test(orientation)) {\n    primaryAxis = 'y';\n  }\n\n  if (hints.preserveDocking === 'target') {\n\n    if (!isInRange(primaryAxis, end, source)) {\n      return null;\n    }\n\n    axis[primaryAxis] = end[primaryAxis];\n\n    return [\n      {\n        x: axis.x !== undefined ? axis.x : start.x,\n        y: axis.y !== undefined ? axis.y : start.y,\n        original: {\n          x: axis.x !== undefined ? axis.x : start.x,\n          y: axis.y !== undefined ? axis.y : start.y\n        }\n      },\n      {\n        x: end.x,\n        y: end.y\n      }\n    ];\n\n  } else {\n\n    if (!isInRange(primaryAxis, start, target)) {\n      return null;\n    }\n\n    axis[primaryAxis] = start[primaryAxis];\n\n    return [\n      {\n        x: start.x,\n        y: start.y\n      },\n      {\n        x: axis.x !== undefined ? axis.x : end.x,\n        y: axis.y !== undefined ? axis.y : end.y,\n        original: {\n          x: axis.x !== undefined ? axis.x : end.x,\n          y: axis.y !== undefined ? axis.y : end.y\n        }\n      }\n    ];\n  }\n\n};\n\n/**\n * Repair a connection from one side that moved.\n *\n * @param {Bounds} moved\n * @param {Bounds} other\n * @param {Point} newDocking\n * @param {Array<Point>} points originalPoints from moved to other\n *\n * @return {Array<Point>} the repaired points between the two rectangles\n */\nmodule.exports._repairConnectionSide = function(moved, other, newDocking, points) {\n\n  function needsRelayout(moved, other, points) {\n\n    if (points.length < 3) {\n      return true;\n    }\n\n    if (points.length > 4) {\n      return false;\n    }\n\n    // relayout if two points overlap\n    // this is most likely due to\n    return !!find(points, function(p, idx) {\n      var q = points[idx - 1];\n\n      return q && pointDistance(p, q) < 3;\n    });\n  }\n\n  function repairBendpoint(candidate, oldPeer, newPeer) {\n\n    var alignment = pointsAligned(oldPeer, candidate);\n\n    switch (alignment) {\n    case 'v':\n        // repair vertical alignment\n      return { x: candidate.x, y: newPeer.y };\n    case 'h':\n        // repair horizontal alignment\n      return { x: newPeer.x, y: candidate.y };\n    }\n\n    return { x: candidate.x, y: candidate. y };\n  }\n\n  function removeOverlapping(points, a, b) {\n    var i;\n\n    for (i = points.length - 2; i !== 0; i--) {\n\n      // intersects (?) break, remove all bendpoints up to this one and relayout\n      if (pointInRect(points[i], a, INTERSECTION_THRESHOLD) ||\n          pointInRect(points[i], b, INTERSECTION_THRESHOLD)) {\n\n        // return sliced old connection\n        return points.slice(i);\n      }\n    }\n\n    return points;\n  }\n\n\n  // (0) only repair what has layoutable bendpoints\n\n  // (1) if only one bendpoint and on shape moved onto other shapes axis\n  //     (horizontally / vertically), relayout\n\n  if (needsRelayout(moved, other, points)) {\n    return null;\n  }\n\n  var oldDocking = points[0],\n      newPoints = points.slice(),\n      slicedPoints;\n\n  // (2) repair only last line segment and only if it was layouted before\n\n  newPoints[0] = newDocking;\n  newPoints[1] = repairBendpoint(newPoints[1], oldDocking, newDocking);\n\n\n  // (3) if shape intersects with any bendpoint after repair,\n  //     remove all segments up to this bendpoint and repair from there\n\n  slicedPoints = removeOverlapping(newPoints, moved, other);\n\n  if (slicedPoints !== newPoints) {\n    return this._repairConnectionSide(moved, other, newDocking, slicedPoints);\n  }\n\n  return newPoints;\n};\n\n/**\n * Returns the manhattan directions connecting two rectangles\n * with the given orientation.\n *\n * @example\n *\n * getDirections('top'); // -> 'v:v'\n *\n * getDirections('top-right', 'v:h'); // -> 'v:h'\n * getDirections('top-right', 'h:h'); // -> 'h:h'\n *\n *\n * @param {String} orientation\n * @param {String} defaultLayout\n *\n * @return {String}\n */\nfunction getDirections(orientation, defaultLayout) {\n\n  switch (orientation) {\n  case 'intersect':\n    return null;\n\n  case 'top':\n  case 'bottom':\n    return 'v:v';\n\n  case 'left':\n  case 'right':\n    return 'h:h';\n\n    // 'top-left'\n    // 'top-right'\n    // 'bottom-left'\n    // 'bottom-right'\n  default:\n    return defaultLayout;\n  }\n}\n","'use strict';\n\nvar assign = require(410),\n    inherits = require(270);\n\nvar Refs = require(441);\n\nvar parentRefs = new Refs({ name: 'children', enumerable: true, collection: true }, { name: 'parent' }),\n    labelRefs = new Refs({ name: 'label', enumerable: true }, { name: 'labelTarget' }),\n    attacherRefs = new Refs({ name: 'attachers', collection: true }, { name: 'host' }),\n    outgoingRefs = new Refs({ name: 'outgoing', collection: true }, { name: 'source' }),\n    incomingRefs = new Refs({ name: 'incoming', collection: true }, { name: 'target' });\n\n/**\n * @namespace djs.model\n */\n\n/**\n * @memberOf djs.model\n */\n\n/**\n * The basic graphical representation\n *\n * @class\n *\n * @abstract\n */\nfunction Base() {\n\n  /**\n   * The object that backs up the shape\n   *\n   * @name Base#businessObject\n   * @type Object\n   */\n  Object.defineProperty(this, 'businessObject', {\n    writable: true\n  });\n\n  /**\n   * The parent shape\n   *\n   * @name Base#parent\n   * @type Shape\n   */\n  parentRefs.bind(this, 'parent');\n\n  /**\n   * @name Base#label\n   * @type Label\n   */\n  labelRefs.bind(this, 'label');\n\n  /**\n   * The list of outgoing connections\n   *\n   * @name Base#outgoing\n   * @type Array<Connection>\n   */\n  outgoingRefs.bind(this, 'outgoing');\n\n  /**\n   * The list of incoming connections\n   *\n   * @name Base#incoming\n   * @type Array<Connection>\n   */\n  incomingRefs.bind(this, 'incoming');\n}\n\n\n/**\n * A graphical object\n *\n * @class\n * @constructor\n *\n * @extends Base\n */\nfunction Shape() {\n  Base.call(this);\n\n  /**\n   * The list of children\n   *\n   * @name Shape#children\n   * @type Array<Base>\n   */\n  parentRefs.bind(this, 'children');\n\n  /**\n   * @name Shape#host\n   * @type Shape\n   */\n  attacherRefs.bind(this, 'host');\n\n  /**\n   * @name Shape#attachers\n   * @type Shape\n   */\n  attacherRefs.bind(this, 'attachers');\n}\n\ninherits(Shape, Base);\n\n\n/**\n * A root graphical object\n *\n * @class\n * @constructor\n *\n * @extends Shape\n */\nfunction Root() {\n  Shape.call(this);\n}\n\ninherits(Root, Shape);\n\n\n/**\n * A label for an element\n *\n * @class\n * @constructor\n *\n * @extends Shape\n */\nfunction Label() {\n  Shape.call(this);\n\n  /**\n   * The labeled element\n   *\n   * @name Label#labelTarget\n   * @type Base\n   */\n  labelRefs.bind(this, 'labelTarget');\n}\n\ninherits(Label, Shape);\n\n\n/**\n * A connection between two elements\n *\n * @class\n * @constructor\n *\n * @extends Base\n */\nfunction Connection() {\n  Base.call(this);\n\n  /**\n   * The element this connection originates from\n   *\n   * @name Connection#source\n   * @type Base\n   */\n  outgoingRefs.bind(this, 'source');\n\n  /**\n   * The element this connection points to\n   *\n   * @name Connection#target\n   * @type Base\n   */\n  incomingRefs.bind(this, 'target');\n}\n\ninherits(Connection, Base);\n\n\nvar types = {\n  connection: Connection,\n  shape: Shape,\n  label: Label,\n  root: Root\n};\n\n/**\n * Creates a new model element of the specified type\n *\n * @method create\n *\n * @example\n *\n * var shape1 = Model.create('shape', { x: 10, y: 10, width: 100, height: 100 });\n * var shape2 = Model.create('shape', { x: 210, y: 210, width: 100, height: 100 });\n *\n * var connection = Model.create('connection', { waypoints: [ { x: 110, y: 55 }, {x: 210, y: 55 } ] });\n *\n * @param  {String} type lower-cased model name\n * @param  {Object} attrs attributes to initialize the new model instance with\n *\n * @return {Base} the new model instance\n */\nmodule.exports.create = function(type, attrs) {\n  var Type = types[type];\n  if (!Type) {\n    throw new Error('unknown type: <' + type + '>');\n  }\n  return assign(new Type(), attrs);\n};\n\n\nmodule.exports.Base = Base;\nmodule.exports.Root = Root;\nmodule.exports.Shape = Shape;\nmodule.exports.Connection = Connection;\nmodule.exports.Label = Label;\n","'use strict';\n\nvar Cursor = require(246),\n    ClickTrap = require(243),\n    substract = require(253).substract,\n    domEvent = require(429),\n    domClosest = require(426),\n    EventUtil = require(248);\n\n\nfunction length(point) {\n  return Math.sqrt(Math.pow(point.x, 2) + Math.pow(point.y, 2));\n}\n\n\nvar THRESHOLD = 15;\n\n\nfunction MoveCanvas(eventBus, canvas) {\n\n  var container = canvas._container,\n      context;\n\n\n  function handleMove(event) {\n\n    var start = context.start,\n        position = EventUtil.toPoint(event),\n        delta = substract(position, start);\n\n    if (!context.dragging && length(delta) > THRESHOLD) {\n      context.dragging = true;\n\n      // prevent mouse click in this\n      // interaction sequence\n      ClickTrap.install();\n\n      Cursor.set('grab');\n    }\n\n    if (context.dragging) {\n\n      var lastPosition = context.last || context.start;\n\n      delta = substract(position, lastPosition);\n\n      canvas.scroll({\n        dx: delta.x,\n        dy: delta.y\n      });\n\n      context.last = position;\n    }\n\n    // prevent select\n    event.preventDefault();\n  }\n\n\n  function handleEnd(event) {\n    domEvent.unbind(document, 'mousemove', handleMove);\n    domEvent.unbind(document, 'mouseup', handleEnd);\n\n    context = null;\n\n    Cursor.unset();\n  }\n\n  function handleStart(event) {\n    // event is already handled by '.djs-draggable'\n    if (domClosest(event.target, '.djs-draggable')) {\n      return;\n    }\n\n\n    // reject non-left left mouse button or modifier key\n    if (event.button || event.ctrlKey || event.shiftKey || event.altKey) {\n      return;\n    }\n\n    context = {\n      start: EventUtil.toPoint(event)\n    };\n\n    domEvent.bind(document, 'mousemove', handleMove);\n    domEvent.bind(document, 'mouseup', handleEnd);\n  }\n\n  domEvent.bind(container, 'mousedown', handleStart);\n}\n\n\nMoveCanvas.$inject = [ 'eventBus', 'canvas' ];\n\nmodule.exports = MoveCanvas;\n","module.exports = {\n  __init__: [ 'moveCanvas' ],\n  moveCanvas: [ 'type', require(236) ]\n};","module.exports = {\n  __depends__: [ require(228) ]\n};","'use strict';\n\nvar domEvent = require(429),\n    domClosest = require(426);\n\nvar hasPrimaryModifier = require(254).hasPrimaryModifier,\n    hasSecondaryModifier = require(254).hasSecondaryModifier;\n\nvar isMac = require(255).isMac;\n\nvar getStepRange = require(240).getStepRange,\n    cap = require(240).cap;\n\nvar log10 = require(253).log10;\n\nvar bind = require(293);\n\nvar RANGE = { min: 0.2, max: 4 },\n    NUM_STEPS = 10;\n\n\n/**\n * An implementation of zooming and scrolling within the\n * {@link Canvas} via the mouse wheel.\n *\n * Mouse wheel zooming / scrolling may be disabled using\n * the {@link toggle(enabled)} method.\n *\n * Additionally users can define the initial enabled state\n * by passing `{ zoomScroll: { enabled: false } }` at diagram\n * initialization.\n *\n * @param {EventBus} eventBus\n * @param {Canvas} canvas\n * @param {Object} config\n */\nfunction ZoomScroll(eventBus, canvas, config) {\n\n  this._enabled = false;\n\n  this._canvas = canvas;\n  this._container = canvas._container;\n\n  this._handleWheel = bind(this._handleWheel, this);\n\n  var newEnabled = !config || config.enabled !== false;\n\n  var self = this;\n\n  eventBus.on('canvas.init', function(e) {\n    self._init(newEnabled);\n  });\n}\n\nZoomScroll.$inject = [ 'eventBus', 'canvas', 'config.zoomScroll' ];\n\nmodule.exports = ZoomScroll;\n\nZoomScroll.prototype.scroll = function scroll(delta) {\n  this._canvas.scroll(delta);\n};\n\n\nZoomScroll.prototype.reset = function reset() {\n  this._canvas.zoom('fit-viewport');\n};\n\n\nZoomScroll.prototype.zoom = function zoom(direction, position) {\n  var canvas = this._canvas;\n  var currentZoom = canvas.zoom(false);\n\n  var factor = Math.pow(1 + Math.abs(direction) , direction > 0 ? 1 : -1);\n\n  canvas.zoom(cap(RANGE, currentZoom * factor), position);\n};\n\n\nZoomScroll.prototype._handleWheel = function handleWheel(event) {\n  // event is already handled by '.djs-scrollable'\n  if (domClosest(event.target, '.djs-scrollable', true)) {\n    return;\n  }\n\n  var element = this._container;\n\n  event.preventDefault();\n\n  // mouse-event: SELECTION_KEY\n  // mouse-event: AND_KEY\n  var isVerticalScroll = hasPrimaryModifier(event),\n      isHorizontalScroll = hasSecondaryModifier(event);\n\n  var factor;\n\n  if (isVerticalScroll || isHorizontalScroll) {\n\n    if (isMac) {\n      factor = event.deltaMode === 0 ? 1.25 : 50;\n    } else {\n      factor = event.deltaMode === 0 ? 1/40 : 1/2;\n    }\n\n    var delta = {};\n\n    if (isHorizontalScroll) {\n      delta.dx = (factor * (event.deltaX || event.deltaY));\n    } else {\n      delta.dy = (factor * event.deltaY);\n    }\n    this.scroll(delta);\n  } else {\n    factor = (event.deltaMode === 0 ? 1/40 : 1/2);\n\n    var elementRect = element.getBoundingClientRect();\n\n    var offset =  {\n      x: event.clientX - elementRect.left,\n      y: event.clientY - elementRect.top\n    };\n\n    // zoom in relative to diagram {x,y} coordinates\n    this.zoom(event.deltaY * factor / (-5), offset);\n  }\n};\n\n/**\n * Zoom along fixed zoom steps\n *\n * @param {Integer} direction zoom direction (1 for zooming in, -1 for out)\n */\nZoomScroll.prototype.stepZoom = function stepZoom(direction, position) {\n\n  var canvas = this._canvas,\n      stepRange = getStepRange(RANGE, NUM_STEPS);\n\n  direction = direction > 0 ? 1 : -1;\n\n  var currentLinearZoomLevel = log10(canvas.zoom());\n\n  // snap to a proximate zoom step\n  var newLinearZoomLevel = Math.round(currentLinearZoomLevel / stepRange) * stepRange;\n\n  // increase or decrease one zoom step in the given direction\n  newLinearZoomLevel += stepRange * direction;\n\n  // calculate the absolute logarithmic zoom level based on the linear zoom level\n  // (e.g. 2 for an absolute x2 zoom)\n  var newLogZoomLevel = Math.pow(10, newLinearZoomLevel);\n\n  canvas.zoom(cap(RANGE, newLogZoomLevel), position);\n};\n\n\n/**\n * Toggle the zoom scroll ability via mouse wheel.\n *\n * @param  {Boolean} [newEnabled] new enabled state\n */\nZoomScroll.prototype.toggle = function toggle(newEnabled) {\n\n  var element = this._container;\n  var handleWheel = this._handleWheel;\n\n  var oldEnabled = this._enabled;\n\n  if (typeof newEnabled === 'undefined') {\n    newEnabled = !oldEnabled;\n  }\n\n  // only react on actual changes\n  if (oldEnabled !== newEnabled) {\n\n    // add or remove wheel listener based on\n    // changed enabled state\n    domEvent[newEnabled ? 'bind' : 'unbind'](element, 'wheel', handleWheel, false);\n  }\n\n  this._enabled = newEnabled;\n\n  return newEnabled;\n};\n\n\nZoomScroll.prototype._init = function(newEnabled) {\n  this.toggle(newEnabled);\n};\n","'use strict';\n\n\nvar log10 = require(253).log10;\n\n/**\n * Get the linear range between two zoom steps based on the\n * total number of zoom steps (defined as NUM_STEPS)\n */\nmodule.exports.getStepRange = function(range, steps) {\n\n  var minLinearRange = log10(range.min),\n      maxLinearRange = log10(range.max);\n\n  var absoluteLinearRange = Math.abs(minLinearRange) + Math.abs(maxLinearRange);\n\n  return absoluteLinearRange / steps;\n};\n\nmodule.exports.cap = function(range, scale) {\n  return Math.max(range.min, Math.min(range.max, scale));\n};\n","module.exports = {\n  __init__: [ 'zoomScroll' ],\n  zoomScroll: [ 'type', require(239) ]\n};","'use strict';\n\nvar roundPoint = require(233).roundPoint;\n\nvar center = require(256).center,\n    delta = require(256).delta;\n\n\n/**\n * Calculates the absolute point relative to the new element's position\n *\n * @param {point} point [absolute]\n * @param {bounds} oldBounds\n * @param {bounds} newBounds\n *\n * @return {point} point [absolute]\n */\nfunction getNewAttachPoint(point, oldBounds, newBounds) {\n  var oldCenter = center(oldBounds),\n      newCenter = center(newBounds),\n      oldDelta = delta(point, oldCenter);\n\n  var newDelta = {\n    x: oldDelta.x * (newBounds.width / oldBounds.width),\n    y: oldDelta.y * (newBounds.height / oldBounds.height)\n  };\n\n  return roundPoint({\n    x: newCenter.x + newDelta.x,\n    y: newCenter.y + newDelta.y\n  });\n}\n\nmodule.exports.getNewAttachPoint = getNewAttachPoint;\n\n\n/**\n * Calculates the shape's delta relative to a new position\n * of a certain element's bounds\n *\n * @param {djs.model.Shape} point [absolute]\n * @param {bounds} oldBounds\n * @param {bounds} newBounds\n *\n * @return {delta} delta\n */\nfunction getNewAttachShapeDelta(shape, oldBounds, newBounds) {\n  var shapeCenter = center(shape),\n      oldCenter = center(oldBounds),\n      newCenter = center(newBounds),\n      shapeDelta = delta(shape, shapeCenter),\n      oldCenterDelta = delta(shapeCenter, oldCenter);\n\n  var newCenterDelta = {\n    x: oldCenterDelta.x * (newBounds.width / oldBounds.width),\n    y: oldCenterDelta.y * (newBounds.height / oldBounds.height)\n  };\n\n  var newShapeCenter = {\n    x: newCenter.x + newCenterDelta.x,\n    y: newCenter.y + newCenterDelta.y\n  };\n\n  return roundPoint({\n    x: newShapeCenter.x + shapeDelta.x - shape.x,\n    y: newShapeCenter.y + shapeDelta.y - shape.y\n  });\n}\n\nmodule.exports.getNewAttachShapeDelta = getNewAttachShapeDelta;\n","'use strict';\n\nvar domEvent = require(429),\n    stopEvent = require(248).stopEvent;\n\nfunction trap(event) {\n  stopEvent(event);\n\n  toggle(false);\n}\n\nfunction toggle(active) {\n  domEvent[active ? 'bind' : 'unbind'](document.body, 'click', trap, true);\n}\n\n/**\n * Installs a click trap that prevents a ghost click following a dragging operation.\n *\n * @return {Function} a function to immediately remove the installed trap.\n */\nfunction install() {\n\n  toggle(true);\n\n  return function() {\n    toggle(false);\n  };\n}\n\nmodule.exports.install = install;","'use strict';\n\n/**\n * Failsafe remove an element from a collection\n *\n * @param  {Array<Object>} [collection]\n * @param  {Object} [element]\n *\n * @return {Number} the previous index of the element\n */\nmodule.exports.remove = function(collection, element) {\n\n  if (!collection || !element) {\n    return -1;\n  }\n\n  var idx = collection.indexOf(element);\n\n  if (idx !== -1) {\n    collection.splice(idx, 1);\n  }\n\n  return idx;\n};\n\n/**\n * Fail save add an element to the given connection, ensuring\n * it does not yet exist.\n *\n * @param {Array<Object>} collection\n * @param {Object} element\n * @param {Number} idx\n */\nmodule.exports.add = function(collection, element, idx) {\n\n  if (!collection || !element) {\n    return;\n  }\n\n  if (typeof idx !== 'number') {\n    idx = -1;\n  }\n\n  var currentIdx = collection.indexOf(element);\n\n  if (currentIdx !== -1) {\n\n    if (currentIdx === idx) {\n      // nothing to do, position has not changed\n      return;\n    } else {\n\n      if (idx !== -1) {\n        // remove from current position\n        collection.splice(currentIdx, 1);\n      } else {\n        // already exists in collection\n        return;\n      }\n    }\n  }\n\n  if (idx !== -1) {\n    // insert at specified position\n    collection.splice(idx, 0, element);\n  } else {\n    // push to end\n    collection.push(element);\n  }\n};\n\n\n/**\n * Fail save get the index of an element in a collection.\n *\n * @param {Array<Object>} collection\n * @param {Object} element\n *\n * @return {Number} the index or -1 if collection or element do\n *                  not exist or the element is not contained.\n */\nmodule.exports.indexOf = function(collection, element) {\n\n  if (!collection || !element) {\n    return -1;\n  }\n\n  return collection.indexOf(element);\n};\n","'use strict';\n\nvar forEach = require(283);\n\nfunction getTopLevel(elements) {\n  var topLevel = {},\n      parents = [],\n      result = [],\n      clearedParents = [];\n\n  forEach(elements, function(element) {\n    var parent = element.parent;\n\n    if (!topLevel[parent.id]) {\n      topLevel[parent.id] = [];\n    }\n\n    if (parents.indexOf(parent.id) === -1) {\n      parents.push(parent.id);\n    }\n\n    topLevel[parent.id].push(element);\n  });\n\n  forEach(parents, function(parent) {\n    forEach(topLevel[parent], function(element) {\n      if (topLevel[element.id]) {\n        clearedParents.push(element.id);\n      }\n    });\n  });\n\n  forEach(parents, function(parent) {\n    var idx = clearedParents.indexOf(parent);\n\n    if (idx === -1) {\n      result = result.concat(topLevel[parent]);\n    }\n  });\n\n  return result;\n}\n\nmodule.exports.getTopLevel = getTopLevel;\n","'use strict';\n\nvar domClasses = require(424);\n\nvar CURSOR_CLS_PATTERN = /^djs-cursor-.*$/;\n\n\nmodule.exports.set = function(mode) {\n  var classes = domClasses(document.body);\n\n  classes.removeMatching(CURSOR_CLS_PATTERN);\n\n  if (mode) {\n    classes.add('djs-cursor-' + mode);\n  }\n};\n\nmodule.exports.unset = function() {\n  this.set(null);\n};\n\nmodule.exports.has = function(mode) {\n  var classes = domClasses(document.body);\n\n  return classes.has('djs-cursor-' + mode);\n};\n","'use strict';\n\nvar isArray = require(401),\n    isNumber = require(404),\n    groupBy = require(284),\n    forEach = require(283);\n\n/**\n * Adds an element to a collection and returns true if the\n * element was added.\n *\n * @param {Array<Object>} elements\n * @param {Object} e\n * @param {Boolean} unique\n */\nfunction add(elements, e, unique) {\n  var canAdd = !unique || elements.indexOf(e) === -1;\n\n  if (canAdd) {\n    elements.push(e);\n  }\n\n  return canAdd;\n}\n\n/**\n * Iterate over each element in a collection, calling the iterator function `fn`\n * with (element, index, recursionDepth).\n *\n * Recurse into all elements that are returned by `fn`.\n *\n * @param  {Object|Array<Object>} elements\n * @param  {Function} fn iterator function called with (element, index, recursionDepth)\n * @param  {Number} [depth] maximum recursion depth\n */\nfunction eachElement(elements, fn, depth) {\n\n  depth = depth || 0;\n\n  if (!isArray(elements)) {\n    elements = [ elements ];\n  }\n\n  forEach(elements, function(s, i) {\n    var filter = fn(s, i, depth);\n\n    if (isArray(filter) && filter.length) {\n      eachElement(filter, fn, depth + 1);\n    }\n  });\n}\n\n/**\n * Collects self + child elements up to a given depth from a list of elements.\n *\n * @param  {djs.model.Base|Array<djs.model.Base>} elements the elements to select the children from\n * @param  {Boolean} unique whether to return a unique result set (no duplicates)\n * @param  {Number} maxDepth the depth to search through or -1 for infinite\n *\n * @return {Array<djs.model.Base>} found elements\n */\nfunction selfAndChildren(elements, unique, maxDepth) {\n  var result = [],\n      processedChildren = [];\n\n  eachElement(elements, function(element, i, depth) {\n    add(result, element, unique);\n\n    var children = element.children;\n\n    // max traversal depth not reached yet\n    if (maxDepth === -1 || depth < maxDepth) {\n\n      // children exist && children not yet processed\n      if (children && add(processedChildren, children, unique)) {\n        return children;\n      }\n    }\n  });\n\n  return result;\n}\n\n/**\n * Return self + direct children for a number of elements\n *\n * @param  {Array<djs.model.Base>} elements to query\n * @param  {Boolean} allowDuplicates to allow duplicates in the result set\n *\n * @return {Array<djs.model.Base>} the collected elements\n */\nfunction selfAndDirectChildren(elements, allowDuplicates) {\n  return selfAndChildren(elements, !allowDuplicates, 1);\n}\n\n/**\n * Return self + ALL children for a number of elements\n *\n * @param  {Array<djs.model.Base>} elements to query\n * @param  {Boolean} allowDuplicates to allow duplicates in the result set\n *\n * @return {Array<djs.model.Base>} the collected elements\n */\nfunction selfAndAllChildren(elements, allowDuplicates) {\n  return selfAndChildren(elements, !allowDuplicates, -1);\n}\n\n/**\n * Gets the the closure for all selected elements,\n * their connections and their attachment's connections\n *\n * @param {Array<djs.model.Base>} elements\n * @return {Object} enclosure\n */\nfunction getClosure(elements) {\n\n  // original elements passed to this function\n  var topLevel = groupBy(elements, function(e) { return e.id; });\n\n  var allShapes = {},\n      allConnections = {},\n      enclosedElements = {},\n      enclosedConnections = {};\n\n  function handleConnection(c) {\n    if (topLevel[c.source.id] && topLevel[c.target.id]) {\n      topLevel[c.id] = c;\n    }\n\n    // not enclosed as a child, but maybe logically\n    // (connecting two moved elements?)\n    if (allShapes[c.source.id] && allShapes[c.target.id]) {\n      enclosedConnections[c.id] = enclosedElements[c.id] = c;\n    }\n\n    allConnections[c.id] = c;\n  }\n\n  function handleElement(element) {\n\n    enclosedElements[element.id] = element;\n\n    if (element.waypoints) {\n      // remember connection\n      enclosedConnections[element.id] = allConnections[element.id] = element;\n    } else {\n      // remember shape\n      allShapes[element.id] = element;\n\n      // remember all connections\n      forEach(element.incoming, handleConnection);\n\n      forEach(element.outgoing, handleConnection);\n\n      // recurse into children\n      return element.children;\n    }\n  }\n\n  eachElement(elements, handleElement);\n\n  return {\n    allShapes: allShapes,\n    allConnections: allConnections,\n    topLevel: topLevel,\n    enclosedConnections: enclosedConnections,\n    enclosedElements: enclosedElements\n  };\n}\n\n/**\n * Returns the surrounding bbox for all elements in\n * the array or the element primitive.\n *\n * @param {Array<djs.model.Shape>|djs.model.Shape} elements\n * @param {Boolean} stopRecursion\n */\nfunction getBBox(elements, stopRecursion) {\n\n  stopRecursion = !!stopRecursion;\n  if (!isArray(elements)) {\n    elements = [elements];\n  }\n\n  var minX,\n      minY,\n      maxX,\n      maxY;\n\n  forEach(elements, function(element) {\n\n    // If element is a connection the bbox must be computed first\n    var bbox = element;\n    if (element.waypoints && !stopRecursion) {\n      bbox = getBBox(element.waypoints, true);\n    }\n\n    var x = bbox.x,\n        y = bbox.y,\n        height = bbox.height || 0,\n        width  = bbox.width  || 0;\n\n    if (x < minX || minX === undefined) {\n      minX = x;\n    }\n    if (y < minY || minY === undefined) {\n      minY = y;\n    }\n\n    if ((x + width) > maxX || maxX === undefined) {\n      maxX = x + width;\n    }\n    if ((y + height) > maxY || maxY === undefined) {\n      maxY = y + height;\n    }\n  });\n\n  return {\n    x: minX,\n    y: minY,\n    height: maxY - minY,\n    width: maxX - minX\n  };\n}\n\n\n/**\n * Returns all elements that are enclosed from the bounding box.\n *\n *   * If bbox.(width|height) is not specified the method returns\n *     all elements with element.x/y > bbox.x/y\n *   * If only bbox.x or bbox.y is specified, method return all elements with\n *     e.x > bbox.x or e.y > bbox.y\n *\n * @param {Array<djs.model.Shape>} elements List of Elements to search through\n * @param {djs.model.Shape} bbox the enclosing bbox.\n *\n * @return {Array<djs.model.Shape>} enclosed elements\n */\nfunction getEnclosedElements(elements, bbox) {\n\n  var filteredElements = {};\n\n  forEach(elements, function(element) {\n\n    var e = element;\n\n    if (e.waypoints) {\n      e = getBBox(e);\n    }\n\n    if (!isNumber(bbox.y) && (e.x > bbox.x)) {\n      filteredElements[element.id] = element;\n    }\n    if (!isNumber(bbox.x) && (e.y > bbox.y)) {\n      filteredElements[element.id] = element;\n    }\n    if (e.x > bbox.x && e.y > bbox.y) {\n      if (isNumber(bbox.width) && isNumber(bbox.height) &&\n          e.width  + e.x < bbox.width  + bbox.x &&\n          e.height + e.y < bbox.height + bbox.y) {\n\n        filteredElements[element.id] = element;\n      } else if (!isNumber(bbox.width) || !isNumber(bbox.height)) {\n        filteredElements[element.id] = element;\n      }\n    }\n  });\n\n  return filteredElements;\n}\n\n\nmodule.exports.add = add;\nmodule.exports.eachElement = eachElement;\nmodule.exports.selfAndDirectChildren = selfAndDirectChildren;\nmodule.exports.selfAndAllChildren = selfAndAllChildren;\nmodule.exports.getBBox = getBBox;\nmodule.exports.getEnclosedElements = getEnclosedElements;\n\nmodule.exports.getClosure = getClosure;\n\n\nfunction getElementType(element) {\n\n  if ('waypoints' in element) {\n    return 'connection';\n  }\n\n  if ('x' in element) {\n    return 'shape';\n  }\n\n  return 'root';\n}\n\nmodule.exports.getType = getElementType;","'use strict';\n\nfunction __preventDefault(event) {\n  return event && event.preventDefault();\n}\n\nfunction __stopPropagation(event, immediate) {\n  if (!event) {\n    return;\n  }\n\n  if (event.stopPropagation) {\n    event.stopPropagation();\n  }\n\n  if (immediate && event.stopImmediatePropagation) {\n    event.stopImmediatePropagation();\n  }\n}\n\n\nfunction getOriginal(event) {\n  return event.originalEvent || event.srcEvent;\n}\n\nmodule.exports.getOriginal = getOriginal;\n\n\nfunction stopEvent(event, immediate) {\n  stopPropagation(event, immediate);\n  preventDefault(event);\n}\n\nmodule.exports.stopEvent = stopEvent;\n\n\nfunction preventDefault(event) {\n  __preventDefault(event);\n  __preventDefault(getOriginal(event));\n}\n\nmodule.exports.preventDefault = preventDefault;\n\n\nfunction stopPropagation(event, immediate) {\n  __stopPropagation(event, immediate);\n  __stopPropagation(getOriginal(event), immediate);\n}\n\nmodule.exports.stopPropagation = stopPropagation;\n\n\nfunction toPoint(event) {\n\n  if (event.pointers && event.pointers.length) {\n    event = event.pointers[0];\n  }\n\n  if (event.touches && event.touches.length) {\n    event = event.touches[0];\n  }\n\n  return event ? {\n    x: event.clientX,\n    y: event.clientY\n  } : null;\n}\n\nmodule.exports.toPoint = toPoint;\n","'use strict';\n\n/**\n * Computes the distance between two points\n *\n * @param  {Point}  p\n * @param  {Point}  q\n *\n * @return {Number}  distance\n */\nfunction pointDistance(a, b) {\n  if (!a || !b) {\n    return -1;\n  }\n\n  return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));\n}\n\nmodule.exports.pointDistance = pointDistance;\n\n\n/**\n * Returns true if the point r is on the line between p and y\n *\n * @param  {Point}  p\n * @param  {Point}  q\n * @param  {Point}  r\n *\n * @return {Boolean}\n */\nmodule.exports.pointsOnLine = function(p, q, r) {\n\n  if (!p || !q || !r) {\n    return false;\n  }\n\n  var val = (q.x - p.x) * (r.y - p.y) - (q.y - p.y) * (r.x - p.x),\n      dist = pointDistance(p, q);\n\n  // @see http://stackoverflow.com/a/907491/412190\n  return Math.abs(val / dist) < 5;\n};\n\n\nvar ALIGNED_THRESHOLD = 2;\n\n/**\n * Returns whether two points are in a horizontal or vertical line.\n *\n * @param {Point} a\n * @param {Point} b\n *\n * @return {String|Boolean} returns false if the points are not\n *                          aligned or 'h|v' if they are aligned\n *                          horizontally / vertically.\n */\nfunction pointsAligned(a, b) {\n  if (Math.abs(a.x - b.x) <= ALIGNED_THRESHOLD) {\n    return 'h';\n  }\n\n  if (Math.abs(a.y - b.y) <= ALIGNED_THRESHOLD) {\n    return 'v';\n  }\n\n  return false;\n}\n\nmodule.exports.pointsAligned = pointsAligned;\n\n\n/**\n * Returns true if the point p is inside the rectangle rect\n *\n * @param  {Point}  p\n * @param  {Rect}   rect\n * @param  {Number} tolerance\n *\n * @return {Boolean}\n */\nmodule.exports.pointInRect = function(p, rect, tolerance) {\n  tolerance = tolerance || 0;\n\n  return p.x > rect.x - tolerance &&\n         p.y > rect.y - tolerance &&\n         p.x < rect.x + rect.width + tolerance &&\n         p.y < rect.y + rect.height + tolerance;\n};\n\n/**\n * Returns a point in the middle of points p and q\n *\n * @param  {Point}  p\n * @param  {Point}  q\n *\n * @return {Point} middle point\n */\nmodule.exports.getMidPoint = function(p, q) {\n  return {\n    x: Math.round(p.x + ((q.x - p.x) / 2.0)),\n    y: Math.round(p.y + ((q.y - p.y) / 2.0))\n  };\n};\n","'use strict';\n\n/**\n * SVGs for elements are generated by the {@link GraphicsFactory}.\n *\n * This utility gives quick access to the important semantic\n * parts of an element.\n */\n\n/**\n * Returns the visual part of a diagram element\n *\n * @param {Snap<SVGElement>} gfx\n *\n * @return {Snap<SVGElement>}\n */\nfunction getVisual(gfx) {\n  return gfx.select('.djs-visual');\n}\n\n/**\n * Returns the children for a given diagram element.\n *\n * @param {Snap<SVGElement>} gfx\n * @return {Snap<SVGElement>}\n */\nfunction getChildren(gfx) {\n  return gfx.parent().children()[1];\n}\n\n/**\n * Returns the visual bbox of an element\n *\n * @param {Snap<SVGElement>} gfx\n *\n * @return {Bounds}\n */\nfunction getBBox(gfx) {\n  return getVisual(gfx).select('*').getBBox();\n}\n\n\nmodule.exports.getVisual = getVisual;\nmodule.exports.getChildren = getChildren;\nmodule.exports.getBBox = getBBox;","'use strict';\n\n/**\n * Util that provides unique IDs.\n *\n * @class djs.util.IdGenerator\n * @constructor\n * @memberOf djs.util\n *\n * The ids can be customized via a given prefix and contain a random value to avoid collisions.\n *\n * @param {String} prefix a prefix to prepend to generated ids (for better readability)\n */\nfunction IdGenerator(prefix) {\n\n  this._counter = 0;\n  this._prefix = (prefix ? prefix + '-' : '') + Math.floor(Math.random() * 1000000000) + '-';\n}\n\nmodule.exports = IdGenerator;\n\n/**\n * Returns a next unique ID.\n *\n * @method djs.util.IdGenerator#next\n *\n * @returns {String} the id\n */\nIdGenerator.prototype.next = function() {\n  return this._prefix + (++this._counter);\n};\n","'use strict';\n\nvar pointDistance = require(249).pointDistance;\n\nvar Snap = require(267);\n\nvar round = Math.round,\n    max = Math.max;\n\n\nfunction circlePath(center, r) {\n  var x = center.x,\n      y = center.y;\n\n  return [\n    ['M', x, y],\n    ['m', 0, -r],\n    ['a', r, r, 0, 1, 1, 0, 2 * r],\n    ['a', r, r, 0, 1, 1, 0, -2 * r],\n    ['z']\n  ];\n}\n\nfunction linePath(points) {\n  var segments = [];\n\n  points.forEach(function(p, idx) {\n    segments.push([ idx === 0 ? 'M' : 'L', p.x, p.y ]);\n  });\n\n  return segments;\n}\n\n\nvar INTERSECTION_THRESHOLD = 10;\n\nfunction getBendpointIntersection(waypoints, reference) {\n\n  var i, w;\n\n  for (i = 0; (w = waypoints[i]); i++) {\n\n    if (pointDistance(w, reference) <= INTERSECTION_THRESHOLD) {\n      return {\n        point: waypoints[i],\n        bendpoint: true,\n        index: i\n      };\n    }\n  }\n\n  return null;\n}\n\nfunction getPathIntersection(waypoints, reference) {\n\n  var intersections = Snap.path.intersection(circlePath(reference, INTERSECTION_THRESHOLD), linePath(waypoints));\n\n  var a = intersections[0],\n      b = intersections[intersections.length - 1],\n      idx;\n\n  if (!a) {\n    // no intersection\n    return null;\n  }\n\n  if (a !== b) {\n\n    if (a.segment2 !== b.segment2) {\n      // we use the bendpoint in between both segments\n      // as the intersection point\n\n      idx = max(a.segment2, b.segment2) - 1;\n\n      return {\n        point: waypoints[idx],\n        bendpoint: true,\n        index: idx\n      };\n    }\n\n    return {\n      point: {\n        x: (round(a.x + b.x) / 2),\n        y: (round(a.y + b.y) / 2)\n      },\n      index: a.segment2\n    };\n  }\n\n  return {\n    point: {\n      x: round(a.x),\n      y: round(a.y)\n    },\n    index: a.segment2\n  };\n}\n\n/**\n * Returns the closest point on the connection towards a given reference point.\n *\n * @param  {Array<Point>} waypoints\n * @param  {Point} reference\n *\n * @return {Object} intersection data (segment, point)\n */\nmodule.exports.getApproxIntersection = function(waypoints, reference) {\n  return getBendpointIntersection(waypoints, reference) || getPathIntersection(waypoints, reference);\n};","'use strict';\n\n/**\n * Get the logarithm of x with base 10\n * @param  {Integer} value\n */\nfunction log10(x) {\n  return Math.log(x) / Math.log(10);\n}\n\nmodule.exports.log10 = log10;\n\n\nfunction substract(p1, p2) {\n  return {\n    x: p1.x - p2.x,\n    y: p1.y - p2.y\n  };\n}\n\nmodule.exports.substract = substract;\n","'use strict';\n\nvar getOriginalEvent = require(248).getOriginal;\n\nvar isMac = require(255).isMac;\n\n\nfunction isPrimaryButton(event) {\n  // button === 0 -> left áka primary mouse button\n  return !(getOriginalEvent(event) || event).button;\n}\n\nmodule.exports.isPrimaryButton = isPrimaryButton;\n\nmodule.exports.isMac = isMac;\n\nmodule.exports.hasPrimaryModifier = function(event) {\n  var originalEvent = getOriginalEvent(event) || event;\n\n  if (!isPrimaryButton(event)) {\n    return false;\n  }\n\n  // Use alt as primary modifier key for mac OS\n  if (isMac()) {\n    return originalEvent.metaKey;\n  } else {\n    return originalEvent.ctrlKey;\n  }\n};\n\n\nmodule.exports.hasSecondaryModifier = function(event) {\n  var originalEvent = getOriginalEvent(event) || event;\n\n  return isPrimaryButton(event) && originalEvent.shiftKey;\n};\n","'use strict';\n\nmodule.exports.isMac = function isMac() {\n  return (/mac/i).test(navigator.platform);\n};","'use strict';\n\nfunction center(bounds) {\n  return {\n    x: bounds.x + (bounds.width / 2),\n    y: bounds.y + (bounds.height / 2)\n  };\n}\n\nmodule.exports.center = center;\n\n\nfunction delta(a, b) {\n  return {\n    x: a.x - b.x,\n    y: a.y - b.y\n  };\n}\n\nmodule.exports.delta = delta;\n","'use strict';\n\n\n/**\n * Remove from the beginning of a collection until it is empty.\n *\n * This is a null-safe operation that ensures elements\n * are being removed from the given collection until the\n * collection is empty.\n *\n * The implementation deals with the fact that a remove operation\n * may touch, i.e. remove multiple elements in the collection\n * at a time.\n *\n * @param {Array<Object>} [collection]\n * @param {Function} removeFn\n *\n * @return {Array<Object>} the cleared collection\n */\nmodule.exports.saveClear = function(collection, removeFn) {\n\n  if (typeof removeFn !== 'function') {\n    throw new Error('removeFn iterator must be a function');\n  }\n\n  if (!collection) {\n    return;\n  }\n\n  var e;\n\n  while ((e = collection[0])) {\n    removeFn(e);\n  }\n\n  return collection;\n};\n","'use strict';\n\nvar Snap = require(267);\n\n\nmodule.exports.componentsToPath = function(elements) {\n  return elements.join(',').replace(/,?([A-z]),?/g, '$1');\n};\n\nfunction toSVGPoints(points) {\n  var result = '';\n\n  for (var i = 0, p; (p = points[i]); i++) {\n    result += p.x + ',' + p.y + ' ';\n  }\n\n  return result;\n}\n\nmodule.exports.toSVGPoints = toSVGPoints;\n\nmodule.exports.createLine = function(points, attrs) {\n  return Snap.create('polyline', { points: toSVGPoints(points) }).attr(attrs || {});\n};\n\nmodule.exports.updateLine = function(gfx, points) {\n  return gfx.attr({ points: toSVGPoints(points) });\n};\n","'use strict';\n\nvar isObject = require(405),\n    assign = require(410),\n    pick = require(417),\n    forEach = require(283),\n    reduce = require(287),\n    merge = require(414);\n\nvar Snap = require(267);\n\nvar DEFAULT_BOX_PADDING = 0;\n\nvar DEFAULT_LABEL_SIZE = {\n  width: 150,\n  height: 50\n};\n\n\nfunction parseAlign(align) {\n\n  var parts = align.split('-');\n\n  return {\n    horizontal: parts[0] || 'center',\n    vertical: parts[1] || 'top'\n  };\n}\n\nfunction parsePadding(padding) {\n\n  if (isObject(padding)) {\n    return assign({ top: 0, left: 0, right: 0, bottom: 0 }, padding);\n  } else {\n    return {\n      top: padding,\n      left: padding,\n      right: padding,\n      bottom: padding\n    };\n  }\n}\n\nfunction getTextBBox(text, fakeText) {\n  fakeText.textContent = text;\n  return pick(fakeText.getBBox(), [ 'width', 'height' ]);\n}\n\n\n/**\n * Layout the next line and return the layouted element.\n *\n * Alters the lines passed.\n *\n * @param  {Array<String>} lines\n * @return {Object} the line descriptor, an object { width, height, text }\n */\nfunction layoutNext(lines, maxWidth, fakeText) {\n\n  var originalLine = lines.shift(),\n      fitLine = originalLine;\n\n  var textBBox;\n\n  for (;;) {\n    textBBox = getTextBBox(fitLine, fakeText);\n\n    textBBox.width = fitLine ? textBBox.width : 0;\n\n    // try to fit\n    if (fitLine === ' ' || fitLine === '' || textBBox.width < Math.round(maxWidth) || fitLine.length < 4) {\n      return fit(lines, fitLine, originalLine, textBBox);\n    }\n\n    fitLine = shortenLine(fitLine, textBBox.width, maxWidth);\n  }\n}\n\nfunction fit(lines, fitLine, originalLine, textBBox) {\n  if (fitLine.length < originalLine.length) {\n    var nextLine = lines[0] || '',\n        remainder = originalLine.slice(fitLine.length).trim();\n\n    if (/-/s*$/.test(remainder)) {\n      nextLine = remainder + nextLine.replace(/^/s+/, '');\n    } else {\n      nextLine = remainder + ' ' + nextLine;\n    }\n\n    lines[0] = nextLine;\n  }\n  return { width: textBBox.width, height: textBBox.height, text: fitLine };\n}\n\n\n/**\n * Shortens a line based on spacing and hyphens.\n * Returns the shortened result on success.\n *\n * @param  {String} line\n * @param  {Number} maxLength the maximum characters of the string\n * @return {String} the shortened string\n */\nfunction semanticShorten(line, maxLength) {\n  var parts = line.split(/(/s|-)/g),\n      part,\n      shortenedParts = [],\n      length = 0;\n\n  // try to shorten via spaces + hyphens\n  if (parts.length > 1) {\n    while ((part = parts.shift())) {\n      if (part.length + length < maxLength) {\n        shortenedParts.push(part);\n        length += part.length;\n      } else {\n        // remove previous part, too if hyphen does not fit anymore\n        if (part === '-') {\n          shortenedParts.pop();\n        }\n\n        break;\n      }\n    }\n  }\n\n  return shortenedParts.join('');\n}\n\n\nfunction shortenLine(line, width, maxWidth) {\n  var length = Math.max(line.length * (maxWidth / width), 1);\n\n  // try to shorten semantically (i.e. based on spaces and hyphens)\n  var shortenedLine = semanticShorten(line, length);\n\n  if (!shortenedLine) {\n\n    // force shorten by cutting the long word\n    shortenedLine = line.slice(0, Math.max(Math.round(length - 1), 1));\n  }\n\n  return shortenedLine;\n}\n\n\n/**\n * Creates a new label utility\n *\n * @param {Object} config\n * @param {Dimensions} config.size\n * @param {Number} config.padding\n * @param {Object} config.style\n * @param {String} config.align\n */\nfunction Text(config) {\n\n  this._config = assign({}, {\n    size: DEFAULT_LABEL_SIZE,\n    padding: DEFAULT_BOX_PADDING,\n    style: {},\n    align: 'center-top'\n  }, config || {});\n}\n\n\n/**\n * Create a label in the parent node.\n *\n * @method Text#createText\n *\n * @param {SVGElement} parent the parent to draw the label on\n * @param {String} text the text to render on the label\n * @param {Object} options\n * @param {String} options.align how to align in the bounding box.\n *                             Any of { 'center-middle', 'center-top' }, defaults to 'center-top'.\n * @param {String} options.style style to be applied to the text\n *\n * @return {SVGText} the text element created\n */\nText.prototype.createText = function(parent, text, options) {\n\n  var box = merge({}, this._config.size, options.box || {}),\n      style = merge({}, this._config.style, options.style || {}),\n      align = parseAlign(options.align || this._config.align),\n      padding = parsePadding(options.padding !== undefined ? options.padding : this._config.padding);\n\n  var lines = text.split(//r?/n/g),\n      layouted = [];\n\n  var maxWidth = box.width - padding.left - padding.right;\n\n  // FF regression: ensure text is shown during rendering\n  // by attaching it directly to the body\n  var fakeText = parent.paper.text(0, 0, '').attr(style).node;\n\n  while (lines.length) {\n    layouted.push(layoutNext(lines, maxWidth, fakeText));\n  }\n\n  var totalHeight = reduce(layouted, function(sum, line, idx) {\n    return sum + line.height;\n  }, 0);\n\n  // the y position of the next line\n  var y, x;\n\n  switch (align.vertical) {\n  case 'middle':\n    y = (box.height - totalHeight) / 2 - layouted[0].height / 4;\n    break;\n\n  default:\n    y = padding.top;\n  }\n\n  var textElement = parent.text().attr(style);\n\n  forEach(layouted, function(line) {\n    y += line.height;\n\n    switch (align.horizontal) {\n    case 'left':\n      x = padding.left;\n      break;\n\n    case 'right':\n      x = (maxWidth - padding.right - line.width);\n      break;\n\n    default:\n        // aka center\n      x = Math.max(((maxWidth - line.width) / 2 + padding.left), 0);\n    }\n\n\n    var tspan = Snap.create('tspan', { x: x, y: y }).node;\n    tspan.textContent = line.text;\n\n    textElement.append(tspan);\n  });\n\n  // remove fake text\n  fakeText.parentNode.removeChild(fakeText);\n\n  return textElement;\n};\n\n\nmodule.exports = Text;\n","\nvar isArray = function(obj) {\n  return Object.prototype.toString.call(obj) === '[object Array]';\n};\n\nvar annotate = function() {\n  var args = Array.prototype.slice.call(arguments);\n  \n  if (args.length === 1 && isArray(args[0])) {\n    args = args[0];\n  }\n\n  var fn = args.pop();\n\n  fn.$inject = args;\n\n  return fn;\n};\n\n\n// Current limitations:\n// - can't put into \"function arg\" comments\n// function /* (no parenthesis like this) */ (){}\n// function abc( /* xx (no parenthesis like this) */ a, b) {}\n//\n// Just put the comment before function or inside:\n// /* (((this is fine))) */ function(a, b) {}\n// function abc(a) { /* (((this is fine))) */}\n\nvar FN_ARGS = /^function/s*[^/(]*/(/s*([^/)]*)/)/m;\nvar FN_ARG = ////*([^/*]*)/*///m;\n\nvar parse = function(fn) {\n  if (typeof fn !== 'function') {\n    throw new Error('Cannot annotate \"' + fn + '\". Expected a function!');\n  }\n\n  var match = fn.toString().match(FN_ARGS);\n  return match[1] && match[1].split(',').map(function(arg) {\n    match = arg.match(FN_ARG);\n    return match ? match[1].trim() : arg.trim();\n  }) || [];\n};\n\n\nexports.annotate = annotate;\nexports.parse = parse;\nexports.isArray = isArray;\n","module.exports = {\n  annotate: require(260).annotate,\n  Module: require(263),\n  Injector: require(262)\n};\n","var Module = require(263);\nvar autoAnnotate = require(260).parse;\nvar annotate = require(260).annotate;\nvar isArray = require(260).isArray;\n\n\nvar Injector = function(modules, parent) {\n  parent = parent || {\n    get: function(name, strict) {\n      currentlyResolving.push(name);\n\n      if (strict === false) {\n        return null;\n      } else {\n        throw error('No provider for \"' + name + '\"!');\n      }\n    }\n  };\n\n  var currentlyResolving = [];\n  var providers = this._providers = Object.create(parent._providers || null);\n  var instances = this._instances = Object.create(null);\n\n  var self = instances.injector = this;\n\n  var error = function(msg) {\n    var stack = currentlyResolving.join(' -> ');\n    currentlyResolving.length = 0;\n    return new Error(stack ? msg + ' (Resolving: ' + stack + ')' : msg);\n  };\n\n  /**\n   * Return a named service.\n   *\n   * @param {String} name\n   * @param {Boolean} [strict=true] if false, resolve missing services to null\n   *\n   * @return {Object}\n   */\n  var get = function(name, strict) {\n    if (!providers[name] && name.indexOf('.') !== -1) {\n      var parts = name.split('.');\n      var pivot = get(parts.shift());\n\n      while(parts.length) {\n        pivot = pivot[parts.shift()];\n      }\n\n      return pivot;\n    }\n\n    if (Object.hasOwnProperty.call(instances, name)) {\n      return instances[name];\n    }\n\n    if (Object.hasOwnProperty.call(providers, name)) {\n      if (currentlyResolving.indexOf(name) !== -1) {\n        currentlyResolving.push(name);\n        throw error('Cannot resolve circular dependency!');\n      }\n\n      currentlyResolving.push(name);\n      instances[name] = providers[name][0](providers[name][1]);\n      currentlyResolving.pop();\n\n      return instances[name];\n    }\n\n    return parent.get(name, strict);\n  };\n\n  var instantiate = function(Type) {\n    var instance = Object.create(Type.prototype);\n    var returned = invoke(Type, instance);\n\n    return typeof returned === 'object' ? returned : instance;\n  };\n\n  var invoke = function(fn, context) {\n    if (typeof fn !== 'function') {\n      if (isArray(fn)) {\n        fn = annotate(fn.slice());\n      } else {\n        throw new Error('Cannot invoke \"' + fn + '\". Expected a function!');\n      }\n    }\n\n    var inject = fn.$inject && fn.$inject || autoAnnotate(fn);\n    var dependencies = inject.map(function(dep) {\n      return get(dep);\n    });\n\n    // TODO(vojta): optimize without apply\n    return fn.apply(context, dependencies);\n  };\n\n\n  var createPrivateInjectorFactory = function(privateChildInjector) {\n    return annotate(function(key) {\n      return privateChildInjector.get(key);\n    });\n  };\n\n  var createChild = function(modules, forceNewInstances) {\n    if (forceNewInstances && forceNewInstances.length) {\n      var fromParentModule = Object.create(null);\n      var matchedScopes = Object.create(null);\n\n      var privateInjectorsCache = [];\n      var privateChildInjectors = [];\n      var privateChildFactories = [];\n\n      var provider;\n      var cacheIdx;\n      var privateChildInjector;\n      var privateChildInjectorFactory;\n      for (var name in providers) {\n        provider = providers[name];\n\n        if (forceNewInstances.indexOf(name) !== -1) {\n          if (provider[2] === 'private') {\n            cacheIdx = privateInjectorsCache.indexOf(provider[3]);\n            if (cacheIdx === -1) {\n              privateChildInjector = provider[3].createChild([], forceNewInstances);\n              privateChildInjectorFactory = createPrivateInjectorFactory(privateChildInjector);\n              privateInjectorsCache.push(provider[3]);\n              privateChildInjectors.push(privateChildInjector);\n              privateChildFactories.push(privateChildInjectorFactory);\n              fromParentModule[name] = [privateChildInjectorFactory, name, 'private', privateChildInjector];\n            } else {\n              fromParentModule[name] = [privateChildFactories[cacheIdx], name, 'private', privateChildInjectors[cacheIdx]];\n            }\n          } else {\n            fromParentModule[name] = [provider[2], provider[1]];\n          }\n          matchedScopes[name] = true;\n        }\n\n        if ((provider[2] === 'factory' || provider[2] === 'type') && provider[1].$scope) {\n          /*jshint -W083 */\n          forceNewInstances.forEach(function(scope) {\n            if (provider[1].$scope.indexOf(scope) !== -1) {\n              fromParentModule[name] = [provider[2], provider[1]];\n              matchedScopes[scope] = true;\n            }\n          });\n        }\n      }\n\n      forceNewInstances.forEach(function(scope) {\n        if (!matchedScopes[scope]) {\n          throw new Error('No provider for \"' + scope + '\". Cannot use provider from the parent!');\n        }\n      });\n\n      modules.unshift(fromParentModule);\n    }\n\n    return new Injector(modules, self);\n  };\n\n  var factoryMap = {\n    factory: invoke,\n    type: instantiate,\n    value: function(value) {\n      return value;\n    }\n  };\n\n  modules.forEach(function(module) {\n\n    function arrayUnwrap(type, value) {\n      if (type !== 'value' && isArray(value)) {\n        value = annotate(value.slice());\n      }\n\n      return value;\n    }\n\n    // TODO(vojta): handle wrong inputs (modules)\n    if (module instanceof Module) {\n      module.forEach(function(provider) {\n        var name = provider[0];\n        var type = provider[1];\n        var value = provider[2];\n\n        providers[name] = [factoryMap[type], arrayUnwrap(type, value), type];\n      });\n    } else if (typeof module === 'object') {\n      if (module.__exports__) {\n        var clonedModule = Object.keys(module).reduce(function(m, key) {\n          if (key.substring(0, 2) !== '__') {\n            m[key] = module[key];\n          }\n          return m;\n        }, Object.create(null));\n\n        var privateInjector = new Injector((module.__modules__ || []).concat([clonedModule]), self);\n        var getFromPrivateInjector = annotate(function(key) {\n          return privateInjector.get(key);\n        });\n        module.__exports__.forEach(function(key) {\n          providers[key] = [getFromPrivateInjector, key, 'private', privateInjector];\n        });\n      } else {\n        Object.keys(module).forEach(function(name) {\n          if (module[name][2] === 'private') {\n            providers[name] = module[name];\n            return;\n          }\n\n          var type = module[name][0];\n          var value = module[name][1];\n\n          providers[name] = [factoryMap[type], arrayUnwrap(type, value), type];\n        });\n      }\n    }\n  });\n\n  // public API\n  this.get = get;\n  this.invoke = invoke;\n  this.instantiate = instantiate;\n  this.createChild = createChild;\n};\n\nmodule.exports = Injector;\n","var Module = function() {\n  var providers = [];\n\n  this.factory = function(name, factory) {\n    providers.push([name, 'factory', factory]);\n    return this;\n  };\n\n  this.value = function(name, value) {\n    providers.push([name, 'value', value]);\n    return this;\n  };\n\n  this.type = function(name, type) {\n    providers.push([name, 'type', type]);\n    return this;\n  };\n\n  this.forEach = function(iterator) {\n    providers.forEach(iterator);\n  };\n};\n\nmodule.exports = Module;\n","// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n// \n// http://www.apache.org/licenses/LICENSE-2.0\n// \n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n// ┌────────────────────────────────────────────────────────────┐ //\n// │ Eve 0.4.2 - JavaScript Events Library                      │ //\n// ├────────────────────────────────────────────────────────────┤ //\n// │ Author Dmitry Baranovskiy (http://dmitry.baranovskiy.com/) │ //\n// └────────────────────────────────────────────────────────────┘ //\n\n(function (glob) {\n    var version = \"0.4.2\",\n        has = \"hasOwnProperty\",\n        separator = /[/.//]/,\n        comaseparator = //s*,/s*/,\n        wildcard = \"*\",\n        fun = function () {},\n        numsort = function (a, b) {\n            return a - b;\n        },\n        current_event,\n        stop,\n        events = {n: {}},\n        firstDefined = function () {\n            for (var i = 0, ii = this.length; i < ii; i++) {\n                if (typeof this[i] != \"undefined\") {\n                    return this[i];\n                }\n            }\n        },\n        lastDefined = function () {\n            var i = this.length;\n            while (--i) {\n                if (typeof this[i] != \"undefined\") {\n                    return this[i];\n                }\n            }\n        },\n    /*/\n     * eve\n     [ method ]\n\n     * Fires event with given `name`, given scope and other parameters.\n\n     > Arguments\n\n     - name (string) name of the *event*, dot (`.`) or slash (`/`) separated\n     - scope (object) context for the event handlers\n     - varargs (...) the rest of arguments will be sent to event handlers\n\n     = (object) array of returned values from the listeners. Array has two methods `.firstDefined()` and `.lastDefined()` to get first or last not `undefined` value.\n    /*/\n        eve = function (name, scope) {\n            name = String(name);\n            var e = events,\n                oldstop = stop,\n                args = Array.prototype.slice.call(arguments, 2),\n                listeners = eve.listeners(name),\n                z = 0,\n                f = false,\n                l,\n                indexed = [],\n                queue = {},\n                out = [],\n                ce = current_event,\n                errors = [];\n            out.firstDefined = firstDefined;\n            out.lastDefined = lastDefined;\n            current_event = name;\n            stop = 0;\n            for (var i = 0, ii = listeners.length; i < ii; i++) if (\"zIndex\" in listeners[i]) {\n                indexed.push(listeners[i].zIndex);\n                if (listeners[i].zIndex < 0) {\n                    queue[listeners[i].zIndex] = listeners[i];\n                }\n            }\n            indexed.sort(numsort);\n            while (indexed[z] < 0) {\n                l = queue[indexed[z++]];\n                out.push(l.apply(scope, args));\n                if (stop) {\n                    stop = oldstop;\n                    return out;\n                }\n            }\n            for (i = 0; i < ii; i++) {\n                l = listeners[i];\n                if (\"zIndex\" in l) {\n                    if (l.zIndex == indexed[z]) {\n                        out.push(l.apply(scope, args));\n                        if (stop) {\n                            break;\n                        }\n                        do {\n                            z++;\n                            l = queue[indexed[z]];\n                            l && out.push(l.apply(scope, args));\n                            if (stop) {\n                                break;\n                            }\n                        } while (l)\n                    } else {\n                        queue[l.zIndex] = l;\n                    }\n                } else {\n                    out.push(l.apply(scope, args));\n                    if (stop) {\n                        break;\n                    }\n                }\n            }\n            stop = oldstop;\n            current_event = ce;\n            return out;\n        };\n        // Undocumented. Debug only.\n        eve._events = events;\n    /*/\n     * eve.listeners\n     [ method ]\n\n     * Internal method which gives you array of all event handlers that will be triggered by the given `name`.\n\n     > Arguments\n\n     - name (string) name of the event, dot (`.`) or slash (`/`) separated\n\n     = (array) array of event handlers\n    /*/\n    eve.listeners = function (name) {\n        var names = name.split(separator),\n            e = events,\n            item,\n            items,\n            k,\n            i,\n            ii,\n            j,\n            jj,\n            nes,\n            es = [e],\n            out = [];\n        for (i = 0, ii = names.length; i < ii; i++) {\n            nes = [];\n            for (j = 0, jj = es.length; j < jj; j++) {\n                e = es[j].n;\n                items = [e[names[i]], e[wildcard]];\n                k = 2;\n                while (k--) {\n                    item = items[k];\n                    if (item) {\n                        nes.push(item);\n                        out = out.concat(item.f || []);\n                    }\n                }\n            }\n            es = nes;\n        }\n        return out;\n    };\n    \n    /*/\n     * eve.on\n     [ method ]\n     **\n     * Binds given event handler with a given name. You can use wildcards “`*`” for the names:\n     | eve.on(\"*.under.*\", f);\n     | eve(\"mouse.under.floor\"); // triggers f\n     * Use @eve to trigger the listener.\n     **\n     > Arguments\n     **\n     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards\n     - f (function) event handler function\n     **\n     = (function) returned function accepts a single numeric parameter that represents z-index of the handler. It is an optional feature and only used when you need to ensure that some subset of handlers will be invoked in a given order, despite of the order of assignment. \n     > Example:\n     | eve.on(\"mouse\", eatIt)(2);\n     | eve.on(\"mouse\", scream);\n     | eve.on(\"mouse\", catchIt)(1);\n     * This will ensure that `catchIt` function will be called before `eatIt`.\n     *\n     * If you want to put your handler before non-indexed handlers, specify a negative value.\n     * Note: I assume most of the time you don’t need to worry about z-index, but it’s nice to have this feature “just in case”.\n    /*/\n    eve.on = function (name, f) {\n        name = String(name);\n        if (typeof f != \"function\") {\n            return function () {};\n        }\n        var names = name.split(comaseparator);\n        for (var i = 0, ii = names.length; i < ii; i++) {\n            (function (name) {\n                var names = name.split(separator),\n                    e = events,\n                    exist;\n                for (var i = 0, ii = names.length; i < ii; i++) {\n                    e = e.n;\n                    e = e.hasOwnProperty(names[i]) && e[names[i]] || (e[names[i]] = {n: {}});\n                }\n                e.f = e.f || [];\n                for (i = 0, ii = e.f.length; i < ii; i++) if (e.f[i] == f) {\n                    exist = true;\n                    break;\n                }\n                !exist && e.f.push(f);\n            }(names[i]));\n        }\n        return function (zIndex) {\n            if (+zIndex == +zIndex) {\n                f.zIndex = +zIndex;\n            }\n        };\n    };\n    /*/\n     * eve.f\n     [ method ]\n     **\n     * Returns function that will fire given event with optional arguments.\n     * Arguments that will be passed to the result function will be also\n     * concated to the list of final arguments.\n     | el.onclick = eve.f(\"click\", 1, 2);\n     | eve.on(\"click\", function (a, b, c) {\n     |     console.log(a, b, c); // 1, 2, [event object]\n     | });\n     > Arguments\n     - event (string) event name\n     - varargs (…) and any other arguments\n     = (function) possible event handler function\n    /*/\n    eve.f = function (event) {\n        var attrs = [].slice.call(arguments, 1);\n        return function () {\n            eve.apply(null, [event, null].concat(attrs).concat([].slice.call(arguments, 0)));\n        };\n    };\n    /*/\n     * eve.stop\n     [ method ]\n     **\n     * Is used inside an event handler to stop the event, preventing any subsequent listeners from firing.\n    /*/\n    eve.stop = function () {\n        stop = 1;\n    };\n    /*/\n     * eve.nt\n     [ method ]\n     **\n     * Could be used inside event handler to figure out actual name of the event.\n     **\n     > Arguments\n     **\n     - subname (string) #optional subname of the event\n     **\n     = (string) name of the event, if `subname` is not specified\n     * or\n     = (boolean) `true`, if current event’s name contains `subname`\n    /*/\n    eve.nt = function (subname) {\n        if (subname) {\n            return new RegExp(\"(?://.|///|^)\" + subname + \"(?://.|///|$)\").test(current_event);\n        }\n        return current_event;\n    };\n    /*/\n     * eve.nts\n     [ method ]\n     **\n     * Could be used inside event handler to figure out actual name of the event.\n     **\n     **\n     = (array) names of the event\n    /*/\n    eve.nts = function () {\n        return current_event.split(separator);\n    };\n    /*/\n     * eve.off\n     [ method ]\n     **\n     * Removes given function from the list of event listeners assigned to given name.\n     * If no arguments specified all the events will be cleared.\n     **\n     > Arguments\n     **\n     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards\n     - f (function) event handler function\n    /*/\n    /*/\n     * eve.unbind\n     [ method ]\n     **\n     * See @eve.off\n    /*/\n    eve.off = eve.unbind = function (name, f) {\n        if (!name) {\n            eve._events = events = {n: {}};\n            return;\n        }\n        var names = name.split(comaseparator);\n        if (names.length > 1) {\n            for (var i = 0, ii = names.length; i < ii; i++) {\n                eve.off(names[i], f);\n            }\n            return;\n        }\n        names = name.split(separator);\n        var e,\n            key,\n            splice,\n            i, ii, j, jj,\n            cur = [events];\n        for (i = 0, ii = names.length; i < ii; i++) {\n            for (j = 0; j < cur.length; j += splice.length - 2) {\n                splice = [j, 1];\n                e = cur[j].n;\n                if (names[i] != wildcard) {\n                    if (e[names[i]]) {\n                        splice.push(e[names[i]]);\n                    }\n                } else {\n                    for (key in e) if (e[has](key)) {\n                        splice.push(e[key]);\n                    }\n                }\n                cur.splice.apply(cur, splice);\n            }\n        }\n        for (i = 0, ii = cur.length; i < ii; i++) {\n            e = cur[i];\n            while (e.n) {\n                if (f) {\n                    if (e.f) {\n                        for (j = 0, jj = e.f.length; j < jj; j++) if (e.f[j] == f) {\n                            e.f.splice(j, 1);\n                            break;\n                        }\n                        !e.f.length && delete e.f;\n                    }\n                    for (key in e.n) if (e.n[has](key) && e.n[key].f) {\n                        var funcs = e.n[key].f;\n                        for (j = 0, jj = funcs.length; j < jj; j++) if (funcs[j] == f) {\n                            funcs.splice(j, 1);\n                            break;\n                        }\n                        !funcs.length && delete e.n[key].f;\n                    }\n                } else {\n                    delete e.f;\n                    for (key in e.n) if (e.n[has](key) && e.n[key].f) {\n                        delete e.n[key].f;\n                    }\n                }\n                e = e.n;\n            }\n        }\n    };\n    /*/\n     * eve.once\n     [ method ]\n     **\n     * Binds given event handler with a given name to only run once then unbind itself.\n     | eve.once(\"login\", f);\n     | eve(\"login\"); // triggers f\n     | eve(\"login\"); // no listeners\n     * Use @eve to trigger the listener.\n     **\n     > Arguments\n     **\n     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards\n     - f (function) event handler function\n     **\n     = (function) same return function as @eve.on\n    /*/\n    eve.once = function (name, f) {\n        var f2 = function () {\n            eve.unbind(name, f2);\n            return f.apply(this, arguments);\n        };\n        return eve.on(name, f2);\n    };\n    /*/\n     * eve.version\n     [ property (string) ]\n     **\n     * Current version of the library.\n    /*/\n    eve.version = version;\n    eve.toString = function () {\n        return \"You are running Eve \" + version;\n    };\n    (typeof module != \"undefined\" && module.exports) ? (module.exports = eve) : (typeof define === \"function\" && define.amd ? (define(\"eve\", [], function() { return eve; })) : (glob.eve = eve));\n})(this);\n","/*! Hammer.JS - v2.0.7 - 2016-04-22\n * http://hammerjs.github.io/\n *\n * Copyright (c) 2016 Jorik Tangelder;\n * Licensed under the MIT license */\n(function(window, document, exportName, undefined) {\n  'use strict';\n\nvar VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];\nvar TEST_ELEMENT = document.createElement('div');\n\nvar TYPE_FUNCTION = 'function';\n\nvar round = Math.round;\nvar abs = Math.abs;\nvar now = Date.now;\n\n/**\n * set a timeout with a given scope\n * @param {Function} fn\n * @param {Number} timeout\n * @param {Object} context\n * @returns {number}\n */\nfunction setTimeoutContext(fn, timeout, context) {\n    return setTimeout(bindFn(fn, context), timeout);\n}\n\n/**\n * if the argument is an array, we want to execute the fn on each entry\n * if it aint an array we don't want to do a thing.\n * this is used by all the methods that accept a single and array argument.\n * @param {*|Array} arg\n * @param {String} fn\n * @param {Object} [context]\n * @returns {Boolean}\n */\nfunction invokeArrayArg(arg, fn, context) {\n    if (Array.isArray(arg)) {\n        each(arg, context[fn], context);\n        return true;\n    }\n    return false;\n}\n\n/**\n * walk objects and arrays\n * @param {Object} obj\n * @param {Function} iterator\n * @param {Object} context\n */\nfunction each(obj, iterator, context) {\n    var i;\n\n    if (!obj) {\n        return;\n    }\n\n    if (obj.forEach) {\n        obj.forEach(iterator, context);\n    } else if (obj.length !== undefined) {\n        i = 0;\n        while (i < obj.length) {\n            iterator.call(context, obj[i], i, obj);\n            i++;\n        }\n    } else {\n        for (i in obj) {\n            obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);\n        }\n    }\n}\n\n/**\n * wrap a method with a deprecation warning and stack trace\n * @param {Function} method\n * @param {String} name\n * @param {String} message\n * @returns {Function} A new function wrapping the supplied method.\n */\nfunction deprecate(method, name, message) {\n    var deprecationMessage = 'DEPRECATED METHOD: ' + name + '/n' + message + ' AT /n';\n    return function() {\n        var e = new Error('get-stack-trace');\n        var stack = e && e.stack ? e.stack.replace(/^[^/(]+?[/n$]/gm, '')\n            .replace(/^/s+at/s+/gm, '')\n            .replace(/^Object.<anonymous>/s*/(/gm, '{anonymous}()@') : 'Unknown Stack Trace';\n\n        var log = window.console && (window.console.warn || window.console.log);\n        if (log) {\n            log.call(window.console, deprecationMessage, stack);\n        }\n        return method.apply(this, arguments);\n    };\n}\n\n/**\n * extend object.\n * means that properties in dest will be overwritten by the ones in src.\n * @param {Object} target\n * @param {...Object} objects_to_assign\n * @returns {Object} target\n */\nvar assign;\nif (typeof Object.assign !== 'function') {\n    assign = function assign(target) {\n        if (target === undefined || target === null) {\n            throw new TypeError('Cannot convert undefined or null to object');\n        }\n\n        var output = Object(target);\n        for (var index = 1; index < arguments.length; index++) {\n            var source = arguments[index];\n            if (source !== undefined && source !== null) {\n                for (var nextKey in source) {\n                    if (source.hasOwnProperty(nextKey)) {\n                        output[nextKey] = source[nextKey];\n                    }\n                }\n            }\n        }\n        return output;\n    };\n} else {\n    assign = Object.assign;\n}\n\n/**\n * extend object.\n * means that properties in dest will be overwritten by the ones in src.\n * @param {Object} dest\n * @param {Object} src\n * @param {Boolean} [merge=false]\n * @returns {Object} dest\n */\nvar extend = deprecate(function extend(dest, src, merge) {\n    var keys = Object.keys(src);\n    var i = 0;\n    while (i < keys.length) {\n        if (!merge || (merge && dest[keys[i]] === undefined)) {\n            dest[keys[i]] = src[keys[i]];\n        }\n        i++;\n    }\n    return dest;\n}, 'extend', 'Use `assign`.');\n\n/**\n * merge the values from src in the dest.\n * means that properties that exist in dest will not be overwritten by src\n * @param {Object} dest\n * @param {Object} src\n * @returns {Object} dest\n */\nvar merge = deprecate(function merge(dest, src) {\n    return extend(dest, src, true);\n}, 'merge', 'Use `assign`.');\n\n/**\n * simple class inheritance\n * @param {Function} child\n * @param {Function} base\n * @param {Object} [properties]\n */\nfunction inherit(child, base, properties) {\n    var baseP = base.prototype,\n        childP;\n\n    childP = child.prototype = Object.create(baseP);\n    childP.constructor = child;\n    childP._super = baseP;\n\n    if (properties) {\n        assign(childP, properties);\n    }\n}\n\n/**\n * simple function bind\n * @param {Function} fn\n * @param {Object} context\n * @returns {Function}\n */\nfunction bindFn(fn, context) {\n    return function boundFn() {\n        return fn.apply(context, arguments);\n    };\n}\n\n/**\n * let a boolean value also be a function that must return a boolean\n * this first item in args will be used as the context\n * @param {Boolean|Function} val\n * @param {Array} [args]\n * @returns {Boolean}\n */\nfunction boolOrFn(val, args) {\n    if (typeof val == TYPE_FUNCTION) {\n        return val.apply(args ? args[0] || undefined : undefined, args);\n    }\n    return val;\n}\n\n/**\n * use the val2 when val1 is undefined\n * @param {*} val1\n * @param {*} val2\n * @returns {*}\n */\nfunction ifUndefined(val1, val2) {\n    return (val1 === undefined) ? val2 : val1;\n}\n\n/**\n * addEventListener with multiple events at once\n * @param {EventTarget} target\n * @param {String} types\n * @param {Function} handler\n */\nfunction addEventListeners(target, types, handler) {\n    each(splitStr(types), function(type) {\n        target.addEventListener(type, handler, false);\n    });\n}\n\n/**\n * removeEventListener with multiple events at once\n * @param {EventTarget} target\n * @param {String} types\n * @param {Function} handler\n */\nfunction removeEventListeners(target, types, handler) {\n    each(splitStr(types), function(type) {\n        target.removeEventListener(type, handler, false);\n    });\n}\n\n/**\n * find if a node is in the given parent\n * @method hasParent\n * @param {HTMLElement} node\n * @param {HTMLElement} parent\n * @return {Boolean} found\n */\nfunction hasParent(node, parent) {\n    while (node) {\n        if (node == parent) {\n            return true;\n        }\n        node = node.parentNode;\n    }\n    return false;\n}\n\n/**\n * small indexOf wrapper\n * @param {String} str\n * @param {String} find\n * @returns {Boolean} found\n */\nfunction inStr(str, find) {\n    return str.indexOf(find) > -1;\n}\n\n/**\n * split string on whitespace\n * @param {String} str\n * @returns {Array} words\n */\nfunction splitStr(str) {\n    return str.trim().split(//s+/g);\n}\n\n/**\n * find if a array contains the object using indexOf or a simple polyFill\n * @param {Array} src\n * @param {String} find\n * @param {String} [findByKey]\n * @return {Boolean|Number} false when not found, or the index\n */\nfunction inArray(src, find, findByKey) {\n    if (src.indexOf && !findByKey) {\n        return src.indexOf(find);\n    } else {\n        var i = 0;\n        while (i < src.length) {\n            if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {\n                return i;\n            }\n            i++;\n        }\n        return -1;\n    }\n}\n\n/**\n * convert array-like objects to real arrays\n * @param {Object} obj\n * @returns {Array}\n */\nfunction toArray(obj) {\n    return Array.prototype.slice.call(obj, 0);\n}\n\n/**\n * unique array with objects based on a key (like 'id') or just by the array's value\n * @param {Array} src [{id:1},{id:2},{id:1}]\n * @param {String} [key]\n * @param {Boolean} [sort=False]\n * @returns {Array} [{id:1},{id:2}]\n */\nfunction uniqueArray(src, key, sort) {\n    var results = [];\n    var values = [];\n    var i = 0;\n\n    while (i < src.length) {\n        var val = key ? src[i][key] : src[i];\n        if (inArray(values, val) < 0) {\n            results.push(src[i]);\n        }\n        values[i] = val;\n        i++;\n    }\n\n    if (sort) {\n        if (!key) {\n            results = results.sort();\n        } else {\n            results = results.sort(function sortUniqueArray(a, b) {\n                return a[key] > b[key];\n            });\n        }\n    }\n\n    return results;\n}\n\n/**\n * get the prefixed property\n * @param {Object} obj\n * @param {String} property\n * @returns {String|Undefined} prefixed\n */\nfunction prefixed(obj, property) {\n    var prefix, prop;\n    var camelProp = property[0].toUpperCase() + property.slice(1);\n\n    var i = 0;\n    while (i < VENDOR_PREFIXES.length) {\n        prefix = VENDOR_PREFIXES[i];\n        prop = (prefix) ? prefix + camelProp : property;\n\n        if (prop in obj) {\n            return prop;\n        }\n        i++;\n    }\n    return undefined;\n}\n\n/**\n * get a unique id\n * @returns {number} uniqueId\n */\nvar _uniqueId = 1;\nfunction uniqueId() {\n    return _uniqueId++;\n}\n\n/**\n * get the window object of an element\n * @param {HTMLElement} element\n * @returns {DocumentView|Window}\n */\nfunction getWindowForElement(element) {\n    var doc = element.ownerDocument || element;\n    return (doc.defaultView || doc.parentWindow || window);\n}\n\nvar MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;\n\nvar SUPPORT_TOUCH = ('ontouchstart' in window);\nvar SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;\nvar SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);\n\nvar INPUT_TYPE_TOUCH = 'touch';\nvar INPUT_TYPE_PEN = 'pen';\nvar INPUT_TYPE_MOUSE = 'mouse';\nvar INPUT_TYPE_KINECT = 'kinect';\n\nvar COMPUTE_INTERVAL = 25;\n\nvar INPUT_START = 1;\nvar INPUT_MOVE = 2;\nvar INPUT_END = 4;\nvar INPUT_CANCEL = 8;\n\nvar DIRECTION_NONE = 1;\nvar DIRECTION_LEFT = 2;\nvar DIRECTION_RIGHT = 4;\nvar DIRECTION_UP = 8;\nvar DIRECTION_DOWN = 16;\n\nvar DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;\nvar DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;\nvar DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;\n\nvar PROPS_XY = ['x', 'y'];\nvar PROPS_CLIENT_XY = ['clientX', 'clientY'];\n\n/**\n * create new input type manager\n * @param {Manager} manager\n * @param {Function} callback\n * @returns {Input}\n * @constructor\n */\nfunction Input(manager, callback) {\n    var self = this;\n    this.manager = manager;\n    this.callback = callback;\n    this.element = manager.element;\n    this.target = manager.options.inputTarget;\n\n    // smaller wrapper around the handler, for the scope and the enabled state of the manager,\n    // so when disabled the input events are completely bypassed.\n    this.domHandler = function(ev) {\n        if (boolOrFn(manager.options.enable, [manager])) {\n            self.handler(ev);\n        }\n    };\n\n    this.init();\n\n}\n\nInput.prototype = {\n    /**\n     * should handle the inputEvent data and trigger the callback\n     * @virtual\n     */\n    handler: function() { },\n\n    /**\n     * bind the events\n     */\n    init: function() {\n        this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);\n        this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);\n        this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n    },\n\n    /**\n     * unbind the events\n     */\n    destroy: function() {\n        this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);\n        this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);\n        this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n    }\n};\n\n/**\n * create new input type manager\n * called by the Manager constructor\n * @param {Hammer} manager\n * @returns {Input}\n */\nfunction createInputInstance(manager) {\n    var Type;\n    var inputClass = manager.options.inputClass;\n\n    if (inputClass) {\n        Type = inputClass;\n    } else if (SUPPORT_POINTER_EVENTS) {\n        Type = PointerEventInput;\n    } else if (SUPPORT_ONLY_TOUCH) {\n        Type = TouchInput;\n    } else if (!SUPPORT_TOUCH) {\n        Type = MouseInput;\n    } else {\n        Type = TouchMouseInput;\n    }\n    return new (Type)(manager, inputHandler);\n}\n\n/**\n * handle input events\n * @param {Manager} manager\n * @param {String} eventType\n * @param {Object} input\n */\nfunction inputHandler(manager, eventType, input) {\n    var pointersLen = input.pointers.length;\n    var changedPointersLen = input.changedPointers.length;\n    var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));\n    var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));\n\n    input.isFirst = !!isFirst;\n    input.isFinal = !!isFinal;\n\n    if (isFirst) {\n        manager.session = {};\n    }\n\n    // source event is the normalized value of the domEvents\n    // like 'touchstart, mouseup, pointerdown'\n    input.eventType = eventType;\n\n    // compute scale, rotation etc\n    computeInputData(manager, input);\n\n    // emit secret event\n    manager.emit('hammer.input', input);\n\n    manager.recognize(input);\n    manager.session.prevInput = input;\n}\n\n/**\n * extend the data with some usable properties like scale, rotate, velocity etc\n * @param {Object} manager\n * @param {Object} input\n */\nfunction computeInputData(manager, input) {\n    var session = manager.session;\n    var pointers = input.pointers;\n    var pointersLength = pointers.length;\n\n    // store the first input to calculate the distance and direction\n    if (!session.firstInput) {\n        session.firstInput = simpleCloneInputData(input);\n    }\n\n    // to compute scale and rotation we need to store the multiple touches\n    if (pointersLength > 1 && !session.firstMultiple) {\n        session.firstMultiple = simpleCloneInputData(input);\n    } else if (pointersLength === 1) {\n        session.firstMultiple = false;\n    }\n\n    var firstInput = session.firstInput;\n    var firstMultiple = session.firstMultiple;\n    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;\n\n    var center = input.center = getCenter(pointers);\n    input.timeStamp = now();\n    input.deltaTime = input.timeStamp - firstInput.timeStamp;\n\n    input.angle = getAngle(offsetCenter, center);\n    input.distance = getDistance(offsetCenter, center);\n\n    computeDeltaXY(session, input);\n    input.offsetDirection = getDirection(input.deltaX, input.deltaY);\n\n    var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);\n    input.overallVelocityX = overallVelocity.x;\n    input.overallVelocityY = overallVelocity.y;\n    input.overallVelocity = (abs(overallVelocity.x) > abs(overallVelocity.y)) ? overallVelocity.x : overallVelocity.y;\n\n    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;\n    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;\n\n    input.maxPointers = !session.prevInput ? input.pointers.length : ((input.pointers.length >\n        session.prevInput.maxPointers) ? input.pointers.length : session.prevInput.maxPointers);\n\n    computeIntervalInputData(session, input);\n\n    // find the correct target\n    var target = manager.element;\n    if (hasParent(input.srcEvent.target, target)) {\n        target = input.srcEvent.target;\n    }\n    input.target = target;\n}\n\nfunction computeDeltaXY(session, input) {\n    var center = input.center;\n    var offset = session.offsetDelta || {};\n    var prevDelta = session.prevDelta || {};\n    var prevInput = session.prevInput || {};\n\n    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {\n        prevDelta = session.prevDelta = {\n            x: prevInput.deltaX || 0,\n            y: prevInput.deltaY || 0\n        };\n\n        offset = session.offsetDelta = {\n            x: center.x,\n            y: center.y\n        };\n    }\n\n    input.deltaX = prevDelta.x + (center.x - offset.x);\n    input.deltaY = prevDelta.y + (center.y - offset.y);\n}\n\n/**\n * velocity is calculated every x ms\n * @param {Object} session\n * @param {Object} input\n */\nfunction computeIntervalInputData(session, input) {\n    var last = session.lastInterval || input,\n        deltaTime = input.timeStamp - last.timeStamp,\n        velocity, velocityX, velocityY, direction;\n\n    if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {\n        var deltaX = input.deltaX - last.deltaX;\n        var deltaY = input.deltaY - last.deltaY;\n\n        var v = getVelocity(deltaTime, deltaX, deltaY);\n        velocityX = v.x;\n        velocityY = v.y;\n        velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;\n        direction = getDirection(deltaX, deltaY);\n\n        session.lastInterval = input;\n    } else {\n        // use latest velocity info if it doesn't overtake a minimum period\n        velocity = last.velocity;\n        velocityX = last.velocityX;\n        velocityY = last.velocityY;\n        direction = last.direction;\n    }\n\n    input.velocity = velocity;\n    input.velocityX = velocityX;\n    input.velocityY = velocityY;\n    input.direction = direction;\n}\n\n/**\n * create a simple clone from the input used for storage of firstInput and firstMultiple\n * @param {Object} input\n * @returns {Object} clonedInputData\n */\nfunction simpleCloneInputData(input) {\n    // make a simple copy of the pointers because we will get a reference if we don't\n    // we only need clientXY for the calculations\n    var pointers = [];\n    var i = 0;\n    while (i < input.pointers.length) {\n        pointers[i] = {\n            clientX: round(input.pointers[i].clientX),\n            clientY: round(input.pointers[i].clientY)\n        };\n        i++;\n    }\n\n    return {\n        timeStamp: now(),\n        pointers: pointers,\n        center: getCenter(pointers),\n        deltaX: input.deltaX,\n        deltaY: input.deltaY\n    };\n}\n\n/**\n * get the center of all the pointers\n * @param {Array} pointers\n * @return {Object} center contains `x` and `y` properties\n */\nfunction getCenter(pointers) {\n    var pointersLength = pointers.length;\n\n    // no need to loop when only one touch\n    if (pointersLength === 1) {\n        return {\n            x: round(pointers[0].clientX),\n            y: round(pointers[0].clientY)\n        };\n    }\n\n    var x = 0, y = 0, i = 0;\n    while (i < pointersLength) {\n        x += pointers[i].clientX;\n        y += pointers[i].clientY;\n        i++;\n    }\n\n    return {\n        x: round(x / pointersLength),\n        y: round(y / pointersLength)\n    };\n}\n\n/**\n * calculate the velocity between two points. unit is in px per ms.\n * @param {Number} deltaTime\n * @param {Number} x\n * @param {Number} y\n * @return {Object} velocity `x` and `y`\n */\nfunction getVelocity(deltaTime, x, y) {\n    return {\n        x: x / deltaTime || 0,\n        y: y / deltaTime || 0\n    };\n}\n\n/**\n * get the direction between two points\n * @param {Number} x\n * @param {Number} y\n * @return {Number} direction\n */\nfunction getDirection(x, y) {\n    if (x === y) {\n        return DIRECTION_NONE;\n    }\n\n    if (abs(x) >= abs(y)) {\n        return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n    }\n    return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n}\n\n/**\n * calculate the absolute distance between two points\n * @param {Object} p1 {x, y}\n * @param {Object} p2 {x, y}\n * @param {Array} [props] containing x and y keys\n * @return {Number} distance\n */\nfunction getDistance(p1, p2, props) {\n    if (!props) {\n        props = PROPS_XY;\n    }\n    var x = p2[props[0]] - p1[props[0]],\n        y = p2[props[1]] - p1[props[1]];\n\n    return Math.sqrt((x * x) + (y * y));\n}\n\n/**\n * calculate the angle between two coordinates\n * @param {Object} p1\n * @param {Object} p2\n * @param {Array} [props] containing x and y keys\n * @return {Number} angle\n */\nfunction getAngle(p1, p2, props) {\n    if (!props) {\n        props = PROPS_XY;\n    }\n    var x = p2[props[0]] - p1[props[0]],\n        y = p2[props[1]] - p1[props[1]];\n    return Math.atan2(y, x) * 180 / Math.PI;\n}\n\n/**\n * calculate the rotation degrees between two pointersets\n * @param {Array} start array of pointers\n * @param {Array} end array of pointers\n * @return {Number} rotation\n */\nfunction getRotation(start, end) {\n    return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);\n}\n\n/**\n * calculate the scale factor between two pointersets\n * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\n * @param {Array} start array of pointers\n * @param {Array} end array of pointers\n * @return {Number} scale\n */\nfunction getScale(start, end) {\n    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);\n}\n\nvar MOUSE_INPUT_MAP = {\n    mousedown: INPUT_START,\n    mousemove: INPUT_MOVE,\n    mouseup: INPUT_END\n};\n\nvar MOUSE_ELEMENT_EVENTS = 'mousedown';\nvar MOUSE_WINDOW_EVENTS = 'mousemove mouseup';\n\n/**\n * Mouse events input\n * @constructor\n * @extends Input\n */\nfunction MouseInput() {\n    this.evEl = MOUSE_ELEMENT_EVENTS;\n    this.evWin = MOUSE_WINDOW_EVENTS;\n\n    this.pressed = false; // mousedown state\n\n    Input.apply(this, arguments);\n}\n\ninherit(MouseInput, Input, {\n    /**\n     * handle mouse events\n     * @param {Object} ev\n     */\n    handler: function MEhandler(ev) {\n        var eventType = MOUSE_INPUT_MAP[ev.type];\n\n        // on start we want to have the left mouse button down\n        if (eventType & INPUT_START && ev.button === 0) {\n            this.pressed = true;\n        }\n\n        if (eventType & INPUT_MOVE && ev.which !== 1) {\n            eventType = INPUT_END;\n        }\n\n        // mouse must be down\n        if (!this.pressed) {\n            return;\n        }\n\n        if (eventType & INPUT_END) {\n            this.pressed = false;\n        }\n\n        this.callback(this.manager, eventType, {\n            pointers: [ev],\n            changedPointers: [ev],\n            pointerType: INPUT_TYPE_MOUSE,\n            srcEvent: ev\n        });\n    }\n});\n\nvar POINTER_INPUT_MAP = {\n    pointerdown: INPUT_START,\n    pointermove: INPUT_MOVE,\n    pointerup: INPUT_END,\n    pointercancel: INPUT_CANCEL,\n    pointerout: INPUT_CANCEL\n};\n\n// in IE10 the pointer types is defined as an enum\nvar IE10_POINTER_TYPE_ENUM = {\n    2: INPUT_TYPE_TOUCH,\n    3: INPUT_TYPE_PEN,\n    4: INPUT_TYPE_MOUSE,\n    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816\n};\n\nvar POINTER_ELEMENT_EVENTS = 'pointerdown';\nvar POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';\n\n// IE10 has prefixed support, and case-sensitive\nif (window.MSPointerEvent && !window.PointerEvent) {\n    POINTER_ELEMENT_EVENTS = 'MSPointerDown';\n    POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';\n}\n\n/**\n * Pointer events input\n * @constructor\n * @extends Input\n */\nfunction PointerEventInput() {\n    this.evEl = POINTER_ELEMENT_EVENTS;\n    this.evWin = POINTER_WINDOW_EVENTS;\n\n    Input.apply(this, arguments);\n\n    this.store = (this.manager.session.pointerEvents = []);\n}\n\ninherit(PointerEventInput, Input, {\n    /**\n     * handle mouse events\n     * @param {Object} ev\n     */\n    handler: function PEhandler(ev) {\n        var store = this.store;\n        var removePointer = false;\n\n        var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');\n        var eventType = POINTER_INPUT_MAP[eventTypeNormalized];\n        var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;\n\n        var isTouch = (pointerType == INPUT_TYPE_TOUCH);\n\n        // get index of the event in the store\n        var storeIndex = inArray(store, ev.pointerId, 'pointerId');\n\n        // start and mouse must be down\n        if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {\n            if (storeIndex < 0) {\n                store.push(ev);\n                storeIndex = store.length - 1;\n            }\n        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n            removePointer = true;\n        }\n\n        // it not found, so the pointer hasn't been down (so it's probably a hover)\n        if (storeIndex < 0) {\n            return;\n        }\n\n        // update the event in the store\n        store[storeIndex] = ev;\n\n        this.callback(this.manager, eventType, {\n            pointers: store,\n            changedPointers: [ev],\n            pointerType: pointerType,\n            srcEvent: ev\n        });\n\n        if (removePointer) {\n            // remove from the store\n            store.splice(storeIndex, 1);\n        }\n    }\n});\n\nvar SINGLE_TOUCH_INPUT_MAP = {\n    touchstart: INPUT_START,\n    touchmove: INPUT_MOVE,\n    touchend: INPUT_END,\n    touchcancel: INPUT_CANCEL\n};\n\nvar SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';\nvar SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';\n\n/**\n * Touch events input\n * @constructor\n * @extends Input\n */\nfunction SingleTouchInput() {\n    this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;\n    this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;\n    this.started = false;\n\n    Input.apply(this, arguments);\n}\n\ninherit(SingleTouchInput, Input, {\n    handler: function TEhandler(ev) {\n        var type = SINGLE_TOUCH_INPUT_MAP[ev.type];\n\n        // should we handle the touch events?\n        if (type === INPUT_START) {\n            this.started = true;\n        }\n\n        if (!this.started) {\n            return;\n        }\n\n        var touches = normalizeSingleTouches.call(this, ev, type);\n\n        // when done, reset the started state\n        if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {\n            this.started = false;\n        }\n\n        this.callback(this.manager, type, {\n            pointers: touches[0],\n            changedPointers: touches[1],\n            pointerType: INPUT_TYPE_TOUCH,\n            srcEvent: ev\n        });\n    }\n});\n\n/**\n * @this {TouchInput}\n * @param {Object} ev\n * @param {Number} type flag\n * @returns {undefined|Array} [all, changed]\n */\nfunction normalizeSingleTouches(ev, type) {\n    var all = toArray(ev.touches);\n    var changed = toArray(ev.changedTouches);\n\n    if (type & (INPUT_END | INPUT_CANCEL)) {\n        all = uniqueArray(all.concat(changed), 'identifier', true);\n    }\n\n    return [all, changed];\n}\n\nvar TOUCH_INPUT_MAP = {\n    touchstart: INPUT_START,\n    touchmove: INPUT_MOVE,\n    touchend: INPUT_END,\n    touchcancel: INPUT_CANCEL\n};\n\nvar TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';\n\n/**\n * Multi-user touch events input\n * @constructor\n * @extends Input\n */\nfunction TouchInput() {\n    this.evTarget = TOUCH_TARGET_EVENTS;\n    this.targetIds = {};\n\n    Input.apply(this, arguments);\n}\n\ninherit(TouchInput, Input, {\n    handler: function MTEhandler(ev) {\n        var type = TOUCH_INPUT_MAP[ev.type];\n        var touches = getTouches.call(this, ev, type);\n        if (!touches) {\n            return;\n        }\n\n        this.callback(this.manager, type, {\n            pointers: touches[0],\n            changedPointers: touches[1],\n            pointerType: INPUT_TYPE_TOUCH,\n            srcEvent: ev\n        });\n    }\n});\n\n/**\n * @this {TouchInput}\n * @param {Object} ev\n * @param {Number} type flag\n * @returns {undefined|Array} [all, changed]\n */\nfunction getTouches(ev, type) {\n    var allTouches = toArray(ev.touches);\n    var targetIds = this.targetIds;\n\n    // when there is only one touch, the process can be simplified\n    if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {\n        targetIds[allTouches[0].identifier] = true;\n        return [allTouches, allTouches];\n    }\n\n    var i,\n        targetTouches,\n        changedTouches = toArray(ev.changedTouches),\n        changedTargetTouches = [],\n        target = this.target;\n\n    // get target touches from touches\n    targetTouches = allTouches.filter(function(touch) {\n        return hasParent(touch.target, target);\n    });\n\n    // collect touches\n    if (type === INPUT_START) {\n        i = 0;\n        while (i < targetTouches.length) {\n            targetIds[targetTouches[i].identifier] = true;\n            i++;\n        }\n    }\n\n    // filter changed touches to only contain touches that exist in the collected target ids\n    i = 0;\n    while (i < changedTouches.length) {\n        if (targetIds[changedTouches[i].identifier]) {\n            changedTargetTouches.push(changedTouches[i]);\n        }\n\n        // cleanup removed touches\n        if (type & (INPUT_END | INPUT_CANCEL)) {\n            delete targetIds[changedTouches[i].identifier];\n        }\n        i++;\n    }\n\n    if (!changedTargetTouches.length) {\n        return;\n    }\n\n    return [\n        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'\n        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),\n        changedTargetTouches\n    ];\n}\n\n/**\n * Combined touch and mouse input\n *\n * Touch has a higher priority then mouse, and while touching no mouse events are allowed.\n * This because touch devices also emit mouse events while doing a touch.\n *\n * @constructor\n * @extends Input\n */\n\nvar DEDUP_TIMEOUT = 2500;\nvar DEDUP_DISTANCE = 25;\n\nfunction TouchMouseInput() {\n    Input.apply(this, arguments);\n\n    var handler = bindFn(this.handler, this);\n    this.touch = new TouchInput(this.manager, handler);\n    this.mouse = new MouseInput(this.manager, handler);\n\n    this.primaryTouch = null;\n    this.lastTouches = [];\n}\n\ninherit(TouchMouseInput, Input, {\n    /**\n     * handle mouse and touch events\n     * @param {Hammer} manager\n     * @param {String} inputEvent\n     * @param {Object} inputData\n     */\n    handler: function TMEhandler(manager, inputEvent, inputData) {\n        var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),\n            isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);\n\n        if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {\n            return;\n        }\n\n        // when we're in a touch event, record touches to  de-dupe synthetic mouse event\n        if (isTouch) {\n            recordTouches.call(this, inputEvent, inputData);\n        } else if (isMouse && isSyntheticEvent.call(this, inputData)) {\n            return;\n        }\n\n        this.callback(manager, inputEvent, inputData);\n    },\n\n    /**\n     * remove the event listeners\n     */\n    destroy: function destroy() {\n        this.touch.destroy();\n        this.mouse.destroy();\n    }\n});\n\nfunction recordTouches(eventType, eventData) {\n    if (eventType & INPUT_START) {\n        this.primaryTouch = eventData.changedPointers[0].identifier;\n        setLastTouch.call(this, eventData);\n    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n        setLastTouch.call(this, eventData);\n    }\n}\n\nfunction setLastTouch(eventData) {\n    var touch = eventData.changedPointers[0];\n\n    if (touch.identifier === this.primaryTouch) {\n        var lastTouch = {x: touch.clientX, y: touch.clientY};\n        this.lastTouches.push(lastTouch);\n        var lts = this.lastTouches;\n        var removeLastTouch = function() {\n            var i = lts.indexOf(lastTouch);\n            if (i > -1) {\n                lts.splice(i, 1);\n            }\n        };\n        setTimeout(removeLastTouch, DEDUP_TIMEOUT);\n    }\n}\n\nfunction isSyntheticEvent(eventData) {\n    var x = eventData.srcEvent.clientX, y = eventData.srcEvent.clientY;\n    for (var i = 0; i < this.lastTouches.length; i++) {\n        var t = this.lastTouches[i];\n        var dx = Math.abs(x - t.x), dy = Math.abs(y - t.y);\n        if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {\n            return true;\n        }\n    }\n    return false;\n}\n\nvar PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');\nvar NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;\n\n// magical touchAction value\nvar TOUCH_ACTION_COMPUTE = 'compute';\nvar TOUCH_ACTION_AUTO = 'auto';\nvar TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented\nvar TOUCH_ACTION_NONE = 'none';\nvar TOUCH_ACTION_PAN_X = 'pan-x';\nvar TOUCH_ACTION_PAN_Y = 'pan-y';\nvar TOUCH_ACTION_MAP = getTouchActionProps();\n\n/**\n * Touch Action\n * sets the touchAction property or uses the js alternative\n * @param {Manager} manager\n * @param {String} value\n * @constructor\n */\nfunction TouchAction(manager, value) {\n    this.manager = manager;\n    this.set(value);\n}\n\nTouchAction.prototype = {\n    /**\n     * set the touchAction value on the element or enable the polyfill\n     * @param {String} value\n     */\n    set: function(value) {\n        // find out the touch-action by the event handlers\n        if (value == TOUCH_ACTION_COMPUTE) {\n            value = this.compute();\n        }\n\n        if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {\n            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;\n        }\n        this.actions = value.toLowerCase().trim();\n    },\n\n    /**\n     * just re-set the touchAction value\n     */\n    update: function() {\n        this.set(this.manager.options.touchAction);\n    },\n\n    /**\n     * compute the value for the touchAction property based on the recognizer's settings\n     * @returns {String} value\n     */\n    compute: function() {\n        var actions = [];\n        each(this.manager.recognizers, function(recognizer) {\n            if (boolOrFn(recognizer.options.enable, [recognizer])) {\n                actions = actions.concat(recognizer.getTouchAction());\n            }\n        });\n        return cleanTouchActions(actions.join(' '));\n    },\n\n    /**\n     * this method is called on each input cycle and provides the preventing of the browser behavior\n     * @param {Object} input\n     */\n    preventDefaults: function(input) {\n        var srcEvent = input.srcEvent;\n        var direction = input.offsetDirection;\n\n        // if the touch action did prevented once this session\n        if (this.manager.session.prevented) {\n            srcEvent.preventDefault();\n            return;\n        }\n\n        var actions = this.actions;\n        var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];\n        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];\n        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];\n\n        if (hasNone) {\n            //do not prevent defaults if this is a tap gesture\n\n            var isTapPointer = input.pointers.length === 1;\n            var isTapMovement = input.distance < 2;\n            var isTapTouchTime = input.deltaTime < 250;\n\n            if (isTapPointer && isTapMovement && isTapTouchTime) {\n                return;\n            }\n        }\n\n        if (hasPanX && hasPanY) {\n            // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent\n            return;\n        }\n\n        if (hasNone ||\n            (hasPanY && direction & DIRECTION_HORIZONTAL) ||\n            (hasPanX && direction & DIRECTION_VERTICAL)) {\n            return this.preventSrc(srcEvent);\n        }\n    },\n\n    /**\n     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)\n     * @param {Object} srcEvent\n     */\n    preventSrc: function(srcEvent) {\n        this.manager.session.prevented = true;\n        srcEvent.preventDefault();\n    }\n};\n\n/**\n * when the touchActions are collected they are not a valid value, so we need to clean things up. *\n * @param {String} actions\n * @returns {*}\n */\nfunction cleanTouchActions(actions) {\n    // none\n    if (inStr(actions, TOUCH_ACTION_NONE)) {\n        return TOUCH_ACTION_NONE;\n    }\n\n    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);\n    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);\n\n    // if both pan-x and pan-y are set (different recognizers\n    // for different directions, e.g. horizontal pan but vertical swipe?)\n    // we need none (as otherwise with pan-x pan-y combined none of these\n    // recognizers will work, since the browser would handle all panning\n    if (hasPanX && hasPanY) {\n        return TOUCH_ACTION_NONE;\n    }\n\n    // pan-x OR pan-y\n    if (hasPanX || hasPanY) {\n        return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;\n    }\n\n    // manipulation\n    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {\n        return TOUCH_ACTION_MANIPULATION;\n    }\n\n    return TOUCH_ACTION_AUTO;\n}\n\nfunction getTouchActionProps() {\n    if (!NATIVE_TOUCH_ACTION) {\n        return false;\n    }\n    var touchMap = {};\n    var cssSupports = window.CSS && window.CSS.supports;\n    ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function(val) {\n\n        // If css.supports is not supported but there is native touch-action assume it supports\n        // all values. This is the case for IE 10 and 11.\n        touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;\n    });\n    return touchMap;\n}\n\n/**\n * Recognizer flow explained; *\n * All recognizers have the initial state of POSSIBLE when a input session starts.\n * The definition of a input session is from the first input until the last input, with all it's movement in it. *\n * Example session for mouse-input: mousedown -> mousemove -> mouseup\n *\n * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed\n * which determines with state it should be.\n *\n * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to\n * POSSIBLE to give it another change on the next cycle.\n *\n *               Possible\n *                  |\n *            +-----+---------------+\n *            |                     |\n *      +-----+-----+               |\n *      |           |               |\n *   Failed      Cancelled          |\n *                          +-------+------+\n *                          |              |\n *                      Recognized       Began\n *                                         |\n *                                      Changed\n *                                         |\n *                                  Ended/Recognized\n */\nvar STATE_POSSIBLE = 1;\nvar STATE_BEGAN = 2;\nvar STATE_CHANGED = 4;\nvar STATE_ENDED = 8;\nvar STATE_RECOGNIZED = STATE_ENDED;\nvar STATE_CANCELLED = 16;\nvar STATE_FAILED = 32;\n\n/**\n * Recognizer\n * Every recognizer needs to extend from this class.\n * @constructor\n * @param {Object} options\n */\nfunction Recognizer(options) {\n    this.options = assign({}, this.defaults, options || {});\n\n    this.id = uniqueId();\n\n    this.manager = null;\n\n    // default is enable true\n    this.options.enable = ifUndefined(this.options.enable, true);\n\n    this.state = STATE_POSSIBLE;\n\n    this.simultaneous = {};\n    this.requireFail = [];\n}\n\nRecognizer.prototype = {\n    /**\n     * @virtual\n     * @type {Object}\n     */\n    defaults: {},\n\n    /**\n     * set options\n     * @param {Object} options\n     * @return {Recognizer}\n     */\n    set: function(options) {\n        assign(this.options, options);\n\n        // also update the touchAction, in case something changed about the directions/enabled state\n        this.manager && this.manager.touchAction.update();\n        return this;\n    },\n\n    /**\n     * recognize simultaneous with an other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    recognizeWith: function(otherRecognizer) {\n        if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {\n            return this;\n        }\n\n        var simultaneous = this.simultaneous;\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n        if (!simultaneous[otherRecognizer.id]) {\n            simultaneous[otherRecognizer.id] = otherRecognizer;\n            otherRecognizer.recognizeWith(this);\n        }\n        return this;\n    },\n\n    /**\n     * drop the simultaneous link. it doesnt remove the link on the other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    dropRecognizeWith: function(otherRecognizer) {\n        if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {\n            return this;\n        }\n\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n        delete this.simultaneous[otherRecognizer.id];\n        return this;\n    },\n\n    /**\n     * recognizer can only run when an other is failing\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    requireFailure: function(otherRecognizer) {\n        if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {\n            return this;\n        }\n\n        var requireFail = this.requireFail;\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n        if (inArray(requireFail, otherRecognizer) === -1) {\n            requireFail.push(otherRecognizer);\n            otherRecognizer.requireFailure(this);\n        }\n        return this;\n    },\n\n    /**\n     * drop the requireFailure link. it does not remove the link on the other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    dropRequireFailure: function(otherRecognizer) {\n        if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {\n            return this;\n        }\n\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n        var index = inArray(this.requireFail, otherRecognizer);\n        if (index > -1) {\n            this.requireFail.splice(index, 1);\n        }\n        return this;\n    },\n\n    /**\n     * has require failures boolean\n     * @returns {boolean}\n     */\n    hasRequireFailures: function() {\n        return this.requireFail.length > 0;\n    },\n\n    /**\n     * if the recognizer can recognize simultaneous with an other recognizer\n     * @param {Recognizer} otherRecognizer\n     * @returns {Boolean}\n     */\n    canRecognizeWith: function(otherRecognizer) {\n        return !!this.simultaneous[otherRecognizer.id];\n    },\n\n    /**\n     * You should use `tryEmit` instead of `emit` directly to check\n     * that all the needed recognizers has failed before emitting.\n     * @param {Object} input\n     */\n    emit: function(input) {\n        var self = this;\n        var state = this.state;\n\n        function emit(event) {\n            self.manager.emit(event, input);\n        }\n\n        // 'panstart' and 'panmove'\n        if (state < STATE_ENDED) {\n            emit(self.options.event + stateStr(state));\n        }\n\n        emit(self.options.event); // simple 'eventName' events\n\n        if (input.additionalEvent) { // additional event(panleft, panright, pinchin, pinchout...)\n            emit(input.additionalEvent);\n        }\n\n        // panend and pancancel\n        if (state >= STATE_ENDED) {\n            emit(self.options.event + stateStr(state));\n        }\n    },\n\n    /**\n     * Check that all the require failure recognizers has failed,\n     * if true, it emits a gesture event,\n     * otherwise, setup the state to FAILED.\n     * @param {Object} input\n     */\n    tryEmit: function(input) {\n        if (this.canEmit()) {\n            return this.emit(input);\n        }\n        // it's failing anyway\n        this.state = STATE_FAILED;\n    },\n\n    /**\n     * can we emit?\n     * @returns {boolean}\n     */\n    canEmit: function() {\n        var i = 0;\n        while (i < this.requireFail.length) {\n            if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {\n                return false;\n            }\n            i++;\n        }\n        return true;\n    },\n\n    /**\n     * update the recognizer\n     * @param {Object} inputData\n     */\n    recognize: function(inputData) {\n        // make a new copy of the inputData\n        // so we can change the inputData without messing up the other recognizers\n        var inputDataClone = assign({}, inputData);\n\n        // is is enabled and allow recognizing?\n        if (!boolOrFn(this.options.enable, [this, inputDataClone])) {\n            this.reset();\n            this.state = STATE_FAILED;\n            return;\n        }\n\n        // reset when we've reached the end\n        if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {\n            this.state = STATE_POSSIBLE;\n        }\n\n        this.state = this.process(inputDataClone);\n\n        // the recognizer has recognized a gesture\n        // so trigger an event\n        if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {\n            this.tryEmit(inputDataClone);\n        }\n    },\n\n    /**\n     * return the state of the recognizer\n     * the actual recognizing happens in this method\n     * @virtual\n     * @param {Object} inputData\n     * @returns {Const} STATE\n     */\n    process: function(inputData) { }, // jshint ignore:line\n\n    /**\n     * return the preferred touch-action\n     * @virtual\n     * @returns {Array}\n     */\n    getTouchAction: function() { },\n\n    /**\n     * called when the gesture isn't allowed to recognize\n     * like when another is being recognized or it is disabled\n     * @virtual\n     */\n    reset: function() { }\n};\n\n/**\n * get a usable string, used as event postfix\n * @param {Const} state\n * @returns {String} state\n */\nfunction stateStr(state) {\n    if (state & STATE_CANCELLED) {\n        return 'cancel';\n    } else if (state & STATE_ENDED) {\n        return 'end';\n    } else if (state & STATE_CHANGED) {\n        return 'move';\n    } else if (state & STATE_BEGAN) {\n        return 'start';\n    }\n    return '';\n}\n\n/**\n * direction cons to string\n * @param {Const} direction\n * @returns {String}\n */\nfunction directionStr(direction) {\n    if (direction == DIRECTION_DOWN) {\n        return 'down';\n    } else if (direction == DIRECTION_UP) {\n        return 'up';\n    } else if (direction == DIRECTION_LEFT) {\n        return 'left';\n    } else if (direction == DIRECTION_RIGHT) {\n        return 'right';\n    }\n    return '';\n}\n\n/**\n * get a recognizer by name if it is bound to a manager\n * @param {Recognizer|String} otherRecognizer\n * @param {Recognizer} recognizer\n * @returns {Recognizer}\n */\nfunction getRecognizerByNameIfManager(otherRecognizer, recognizer) {\n    var manager = recognizer.manager;\n    if (manager) {\n        return manager.get(otherRecognizer);\n    }\n    return otherRecognizer;\n}\n\n/**\n * This recognizer is just used as a base for the simple attribute recognizers.\n * @constructor\n * @extends Recognizer\n */\nfunction AttrRecognizer() {\n    Recognizer.apply(this, arguments);\n}\n\ninherit(AttrRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof AttrRecognizer\n     */\n    defaults: {\n        /**\n         * @type {Number}\n         * @default 1\n         */\n        pointers: 1\n    },\n\n    /**\n     * Used to check if it the recognizer receives valid input, like input.distance > 10.\n     * @memberof AttrRecognizer\n     * @param {Object} input\n     * @returns {Boolean} recognized\n     */\n    attrTest: function(input) {\n        var optionPointers = this.options.pointers;\n        return optionPointers === 0 || input.pointers.length === optionPointers;\n    },\n\n    /**\n     * Process the input and return the state for the recognizer\n     * @memberof AttrRecognizer\n     * @param {Object} input\n     * @returns {*} State\n     */\n    process: function(input) {\n        var state = this.state;\n        var eventType = input.eventType;\n\n        var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);\n        var isValid = this.attrTest(input);\n\n        // on cancel input and we've recognized before, return STATE_CANCELLED\n        if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {\n            return state | STATE_CANCELLED;\n        } else if (isRecognized || isValid) {\n            if (eventType & INPUT_END) {\n                return state | STATE_ENDED;\n            } else if (!(state & STATE_BEGAN)) {\n                return STATE_BEGAN;\n            }\n            return state | STATE_CHANGED;\n        }\n        return STATE_FAILED;\n    }\n});\n\n/**\n * Pan\n * Recognized when the pointer is down and moved in the allowed direction.\n * @constructor\n * @extends AttrRecognizer\n */\nfunction PanRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n\n    this.pX = null;\n    this.pY = null;\n}\n\ninherit(PanRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof PanRecognizer\n     */\n    defaults: {\n        event: 'pan',\n        threshold: 10,\n        pointers: 1,\n        direction: DIRECTION_ALL\n    },\n\n    getTouchAction: function() {\n        var direction = this.options.direction;\n        var actions = [];\n        if (direction & DIRECTION_HORIZONTAL) {\n            actions.push(TOUCH_ACTION_PAN_Y);\n        }\n        if (direction & DIRECTION_VERTICAL) {\n            actions.push(TOUCH_ACTION_PAN_X);\n        }\n        return actions;\n    },\n\n    directionTest: function(input) {\n        var options = this.options;\n        var hasMoved = true;\n        var distance = input.distance;\n        var direction = input.direction;\n        var x = input.deltaX;\n        var y = input.deltaY;\n\n        // lock to axis?\n        if (!(direction & options.direction)) {\n            if (options.direction & DIRECTION_HORIZONTAL) {\n                direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;\n                hasMoved = x != this.pX;\n                distance = Math.abs(input.deltaX);\n            } else {\n                direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;\n                hasMoved = y != this.pY;\n                distance = Math.abs(input.deltaY);\n            }\n        }\n        input.direction = direction;\n        return hasMoved && distance > options.threshold && direction & options.direction;\n    },\n\n    attrTest: function(input) {\n        return AttrRecognizer.prototype.attrTest.call(this, input) &&\n            (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));\n    },\n\n    emit: function(input) {\n\n        this.pX = input.deltaX;\n        this.pY = input.deltaY;\n\n        var direction = directionStr(input.direction);\n\n        if (direction) {\n            input.additionalEvent = this.options.event + direction;\n        }\n        this._super.emit.call(this, input);\n    }\n});\n\n/**\n * Pinch\n * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).\n * @constructor\n * @extends AttrRecognizer\n */\nfunction PinchRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n}\n\ninherit(PinchRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof PinchRecognizer\n     */\n    defaults: {\n        event: 'pinch',\n        threshold: 0,\n        pointers: 2\n    },\n\n    getTouchAction: function() {\n        return [TOUCH_ACTION_NONE];\n    },\n\n    attrTest: function(input) {\n        return this._super.attrTest.call(this, input) &&\n            (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);\n    },\n\n    emit: function(input) {\n        if (input.scale !== 1) {\n            var inOut = input.scale < 1 ? 'in' : 'out';\n            input.additionalEvent = this.options.event + inOut;\n        }\n        this._super.emit.call(this, input);\n    }\n});\n\n/**\n * Press\n * Recognized when the pointer is down for x ms without any movement.\n * @constructor\n * @extends Recognizer\n */\nfunction PressRecognizer() {\n    Recognizer.apply(this, arguments);\n\n    this._timer = null;\n    this._input = null;\n}\n\ninherit(PressRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof PressRecognizer\n     */\n    defaults: {\n        event: 'press',\n        pointers: 1,\n        time: 251, // minimal time of the pointer to be pressed\n        threshold: 9 // a minimal movement is ok, but keep it low\n    },\n\n    getTouchAction: function() {\n        return [TOUCH_ACTION_AUTO];\n    },\n\n    process: function(input) {\n        var options = this.options;\n        var validPointers = input.pointers.length === options.pointers;\n        var validMovement = input.distance < options.threshold;\n        var validTime = input.deltaTime > options.time;\n\n        this._input = input;\n\n        // we only allow little movement\n        // and we've reached an end event, so a tap is possible\n        if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {\n            this.reset();\n        } else if (input.eventType & INPUT_START) {\n            this.reset();\n            this._timer = setTimeoutContext(function() {\n                this.state = STATE_RECOGNIZED;\n                this.tryEmit();\n            }, options.time, this);\n        } else if (input.eventType & INPUT_END) {\n            return STATE_RECOGNIZED;\n        }\n        return STATE_FAILED;\n    },\n\n    reset: function() {\n        clearTimeout(this._timer);\n    },\n\n    emit: function(input) {\n        if (this.state !== STATE_RECOGNIZED) {\n            return;\n        }\n\n        if (input && (input.eventType & INPUT_END)) {\n            this.manager.emit(this.options.event + 'up', input);\n        } else {\n            this._input.timeStamp = now();\n            this.manager.emit(this.options.event, this._input);\n        }\n    }\n});\n\n/**\n * Rotate\n * Recognized when two or more pointer are moving in a circular motion.\n * @constructor\n * @extends AttrRecognizer\n */\nfunction RotateRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n}\n\ninherit(RotateRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof RotateRecognizer\n     */\n    defaults: {\n        event: 'rotate',\n        threshold: 0,\n        pointers: 2\n    },\n\n    getTouchAction: function() {\n        return [TOUCH_ACTION_NONE];\n    },\n\n    attrTest: function(input) {\n        return this._super.attrTest.call(this, input) &&\n            (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);\n    }\n});\n\n/**\n * Swipe\n * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.\n * @constructor\n * @extends AttrRecognizer\n */\nfunction SwipeRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n}\n\ninherit(SwipeRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof SwipeRecognizer\n     */\n    defaults: {\n        event: 'swipe',\n        threshold: 10,\n        velocity: 0.3,\n        direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,\n        pointers: 1\n    },\n\n    getTouchAction: function() {\n        return PanRecognizer.prototype.getTouchAction.call(this);\n    },\n\n    attrTest: function(input) {\n        var direction = this.options.direction;\n        var velocity;\n\n        if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {\n            velocity = input.overallVelocity;\n        } else if (direction & DIRECTION_HORIZONTAL) {\n            velocity = input.overallVelocityX;\n        } else if (direction & DIRECTION_VERTICAL) {\n            velocity = input.overallVelocityY;\n        }\n\n        return this._super.attrTest.call(this, input) &&\n            direction & input.offsetDirection &&\n            input.distance > this.options.threshold &&\n            input.maxPointers == this.options.pointers &&\n            abs(velocity) > this.options.velocity && input.eventType & INPUT_END;\n    },\n\n    emit: function(input) {\n        var direction = directionStr(input.offsetDirection);\n        if (direction) {\n            this.manager.emit(this.options.event + direction, input);\n        }\n\n        this.manager.emit(this.options.event, input);\n    }\n});\n\n/**\n * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur\n * between the given interval and position. The delay option can be used to recognize multi-taps without firing\n * a single tap.\n *\n * The eventData from the emitted event contains the property `tapCount`, which contains the amount of\n * multi-taps being recognized.\n * @constructor\n * @extends Recognizer\n */\nfunction TapRecognizer() {\n    Recognizer.apply(this, arguments);\n\n    // previous time and center,\n    // used for tap counting\n    this.pTime = false;\n    this.pCenter = false;\n\n    this._timer = null;\n    this._input = null;\n    this.count = 0;\n}\n\ninherit(TapRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof PinchRecognizer\n     */\n    defaults: {\n        event: 'tap',\n        pointers: 1,\n        taps: 1,\n        interval: 300, // max time between the multi-tap taps\n        time: 250, // max time of the pointer to be down (like finger on the screen)\n        threshold: 9, // a minimal movement is ok, but keep it low\n        posThreshold: 10 // a multi-tap can be a bit off the initial position\n    },\n\n    getTouchAction: function() {\n        return [TOUCH_ACTION_MANIPULATION];\n    },\n\n    process: function(input) {\n        var options = this.options;\n\n        var validPointers = input.pointers.length === options.pointers;\n        var validMovement = input.distance < options.threshold;\n        var validTouchTime = input.deltaTime < options.time;\n\n        this.reset();\n\n        if ((input.eventType & INPUT_START) && (this.count === 0)) {\n            return this.failTimeout();\n        }\n\n        // we only allow little movement\n        // and we've reached an end event, so a tap is possible\n        if (validMovement && validTouchTime && validPointers) {\n            if (input.eventType != INPUT_END) {\n                return this.failTimeout();\n            }\n\n            var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;\n            var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;\n\n            this.pTime = input.timeStamp;\n            this.pCenter = input.center;\n\n            if (!validMultiTap || !validInterval) {\n                this.count = 1;\n            } else {\n                this.count += 1;\n            }\n\n            this._input = input;\n\n            // if tap count matches we have recognized it,\n            // else it has began recognizing...\n            var tapCount = this.count % options.taps;\n            if (tapCount === 0) {\n                // no failing requirements, immediately trigger the tap event\n                // or wait as long as the multitap interval to trigger\n                if (!this.hasRequireFailures()) {\n                    return STATE_RECOGNIZED;\n                } else {\n                    this._timer = setTimeoutContext(function() {\n                        this.state = STATE_RECOGNIZED;\n                        this.tryEmit();\n                    }, options.interval, this);\n                    return STATE_BEGAN;\n                }\n            }\n        }\n        return STATE_FAILED;\n    },\n\n    failTimeout: function() {\n        this._timer = setTimeoutContext(function() {\n            this.state = STATE_FAILED;\n        }, this.options.interval, this);\n        return STATE_FAILED;\n    },\n\n    reset: function() {\n        clearTimeout(this._timer);\n    },\n\n    emit: function() {\n        if (this.state == STATE_RECOGNIZED) {\n            this._input.tapCount = this.count;\n            this.manager.emit(this.options.event, this._input);\n        }\n    }\n});\n\n/**\n * Simple way to create a manager with a default set of recognizers.\n * @param {HTMLElement} element\n * @param {Object} [options]\n * @constructor\n */\nfunction Hammer(element, options) {\n    options = options || {};\n    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);\n    return new Manager(element, options);\n}\n\n/**\n * @const {string}\n */\nHammer.VERSION = '2.0.7';\n\n/**\n * default settings\n * @namespace\n */\nHammer.defaults = {\n    /**\n     * set if DOM events are being triggered.\n     * But this is slower and unused by simple implementations, so disabled by default.\n     * @type {Boolean}\n     * @default false\n     */\n    domEvents: false,\n\n    /**\n     * The value for the touchAction property/fallback.\n     * When set to `compute` it will magically set the correct value based on the added recognizers.\n     * @type {String}\n     * @default compute\n     */\n    touchAction: TOUCH_ACTION_COMPUTE,\n\n    /**\n     * @type {Boolean}\n     * @default true\n     */\n    enable: true,\n\n    /**\n     * EXPERIMENTAL FEATURE -- can be removed/changed\n     * Change the parent input target element.\n     * If Null, then it is being set the to main element.\n     * @type {Null|EventTarget}\n     * @default null\n     */\n    inputTarget: null,\n\n    /**\n     * force an input class\n     * @type {Null|Function}\n     * @default null\n     */\n    inputClass: null,\n\n    /**\n     * Default recognizer setup when calling `Hammer()`\n     * When creating a new Manager these will be skipped.\n     * @type {Array}\n     */\n    preset: [\n        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]\n        [RotateRecognizer, {enable: false}],\n        [PinchRecognizer, {enable: false}, ['rotate']],\n        [SwipeRecognizer, {direction: DIRECTION_HORIZONTAL}],\n        [PanRecognizer, {direction: DIRECTION_HORIZONTAL}, ['swipe']],\n        [TapRecognizer],\n        [TapRecognizer, {event: 'doubletap', taps: 2}, ['tap']],\n        [PressRecognizer]\n    ],\n\n    /**\n     * Some CSS properties can be used to improve the working of Hammer.\n     * Add them to this method and they will be set when creating a new Manager.\n     * @namespace\n     */\n    cssProps: {\n        /**\n         * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.\n         * @type {String}\n         * @default 'none'\n         */\n        userSelect: 'none',\n\n        /**\n         * Disable the Windows Phone grippers when pressing an element.\n         * @type {String}\n         * @default 'none'\n         */\n        touchSelect: 'none',\n\n        /**\n         * Disables the default callout shown when you touch and hold a touch target.\n         * On iOS, when you touch and hold a touch target such as a link, Safari displays\n         * a callout containing information about the link. This property allows you to disable that callout.\n         * @type {String}\n         * @default 'none'\n         */\n        touchCallout: 'none',\n\n        /**\n         * Specifies whether zooming is enabled. Used by IE10>\n         * @type {String}\n         * @default 'none'\n         */\n        contentZooming: 'none',\n\n        /**\n         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.\n         * @type {String}\n         * @default 'none'\n         */\n        userDrag: 'none',\n\n        /**\n         * Overrides the highlight color shown when the user taps a link or a JavaScript\n         * clickable element in iOS. This property obeys the alpha value, if specified.\n         * @type {String}\n         * @default 'rgba(0,0,0,0)'\n         */\n        tapHighlightColor: 'rgba(0,0,0,0)'\n    }\n};\n\nvar STOP = 1;\nvar FORCED_STOP = 2;\n\n/**\n * Manager\n * @param {HTMLElement} element\n * @param {Object} [options]\n * @constructor\n */\nfunction Manager(element, options) {\n    this.options = assign({}, Hammer.defaults, options || {});\n\n    this.options.inputTarget = this.options.inputTarget || element;\n\n    this.handlers = {};\n    this.session = {};\n    this.recognizers = [];\n    this.oldCssProps = {};\n\n    this.element = element;\n    this.input = createInputInstance(this);\n    this.touchAction = new TouchAction(this, this.options.touchAction);\n\n    toggleCssProps(this, true);\n\n    each(this.options.recognizers, function(item) {\n        var recognizer = this.add(new (item[0])(item[1]));\n        item[2] && recognizer.recognizeWith(item[2]);\n        item[3] && recognizer.requireFailure(item[3]);\n    }, this);\n}\n\nManager.prototype = {\n    /**\n     * set options\n     * @param {Object} options\n     * @returns {Manager}\n     */\n    set: function(options) {\n        assign(this.options, options);\n\n        // Options that need a little more setup\n        if (options.touchAction) {\n            this.touchAction.update();\n        }\n        if (options.inputTarget) {\n            // Clean up existing event listeners and reinitialize\n            this.input.destroy();\n            this.input.target = options.inputTarget;\n            this.input.init();\n        }\n        return this;\n    },\n\n    /**\n     * stop recognizing for this session.\n     * This session will be discarded, when a new [input]start event is fired.\n     * When forced, the recognizer cycle is stopped immediately.\n     * @param {Boolean} [force]\n     */\n    stop: function(force) {\n        this.session.stopped = force ? FORCED_STOP : STOP;\n    },\n\n    /**\n     * run the recognizers!\n     * called by the inputHandler function on every movement of the pointers (touches)\n     * it walks through all the recognizers and tries to detect the gesture that is being made\n     * @param {Object} inputData\n     */\n    recognize: function(inputData) {\n        var session = this.session;\n        if (session.stopped) {\n            return;\n        }\n\n        // run the touch-action polyfill\n        this.touchAction.preventDefaults(inputData);\n\n        var recognizer;\n        var recognizers = this.recognizers;\n\n        // this holds the recognizer that is being recognized.\n        // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED\n        // if no recognizer is detecting a thing, it is set to `null`\n        var curRecognizer = session.curRecognizer;\n\n        // reset when the last recognizer is recognized\n        // or when we're in a new session\n        if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {\n            curRecognizer = session.curRecognizer = null;\n        }\n\n        var i = 0;\n        while (i < recognizers.length) {\n            recognizer = recognizers[i];\n\n            // find out if we are allowed try to recognize the input for this one.\n            // 1.   allow if the session is NOT forced stopped (see the .stop() method)\n            // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one\n            //      that is being recognized.\n            // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.\n            //      this can be setup with the `recognizeWith()` method on the recognizer.\n            if (session.stopped !== FORCED_STOP && ( // 1\n                    !curRecognizer || recognizer == curRecognizer || // 2\n                    recognizer.canRecognizeWith(curRecognizer))) { // 3\n                recognizer.recognize(inputData);\n            } else {\n                recognizer.reset();\n            }\n\n            // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the\n            // current active recognizer. but only if we don't already have an active recognizer\n            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {\n                curRecognizer = session.curRecognizer = recognizer;\n            }\n            i++;\n        }\n    },\n\n    /**\n     * get a recognizer by its event name.\n     * @param {Recognizer|String} recognizer\n     * @returns {Recognizer|Null}\n     */\n    get: function(recognizer) {\n        if (recognizer instanceof Recognizer) {\n            return recognizer;\n        }\n\n        var recognizers = this.recognizers;\n        for (var i = 0; i < recognizers.length; i++) {\n            if (recognizers[i].options.event == recognizer) {\n                return recognizers[i];\n            }\n        }\n        return null;\n    },\n\n    /**\n     * add a recognizer to the manager\n     * existing recognizers with the same event name will be removed\n     * @param {Recognizer} recognizer\n     * @returns {Recognizer|Manager}\n     */\n    add: function(recognizer) {\n        if (invokeArrayArg(recognizer, 'add', this)) {\n            return this;\n        }\n\n        // remove existing\n        var existing = this.get(recognizer.options.event);\n        if (existing) {\n            this.remove(existing);\n        }\n\n        this.recognizers.push(recognizer);\n        recognizer.manager = this;\n\n        this.touchAction.update();\n        return recognizer;\n    },\n\n    /**\n     * remove a recognizer by name or instance\n     * @param {Recognizer|String} recognizer\n     * @returns {Manager}\n     */\n    remove: function(recognizer) {\n        if (invokeArrayArg(recognizer, 'remove', this)) {\n            return this;\n        }\n\n        recognizer = this.get(recognizer);\n\n        // let's make sure this recognizer exists\n        if (recognizer) {\n            var recognizers = this.recognizers;\n            var index = inArray(recognizers, recognizer);\n\n            if (index !== -1) {\n                recognizers.splice(index, 1);\n                this.touchAction.update();\n            }\n        }\n\n        return this;\n    },\n\n    /**\n     * bind event\n     * @param {String} events\n     * @param {Function} handler\n     * @returns {EventEmitter} this\n     */\n    on: function(events, handler) {\n        if (events === undefined) {\n            return;\n        }\n        if (handler === undefined) {\n            return;\n        }\n\n        var handlers = this.handlers;\n        each(splitStr(events), function(event) {\n            handlers[event] = handlers[event] || [];\n            handlers[event].push(handler);\n        });\n        return this;\n    },\n\n    /**\n     * unbind event, leave emit blank to remove all handlers\n     * @param {String} events\n     * @param {Function} [handler]\n     * @returns {EventEmitter} this\n     */\n    off: function(events, handler) {\n        if (events === undefined) {\n            return;\n        }\n\n        var handlers = this.handlers;\n        each(splitStr(events), function(event) {\n            if (!handler) {\n                delete handlers[event];\n            } else {\n                handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);\n            }\n        });\n        return this;\n    },\n\n    /**\n     * emit event to the listeners\n     * @param {String} event\n     * @param {Object} data\n     */\n    emit: function(event, data) {\n        // we also want to trigger dom events\n        if (this.options.domEvents) {\n            triggerDomEvent(event, data);\n        }\n\n        // no handlers, so skip it all\n        var handlers = this.handlers[event] && this.handlers[event].slice();\n        if (!handlers || !handlers.length) {\n            return;\n        }\n\n        data.type = event;\n        data.preventDefault = function() {\n            data.srcEvent.preventDefault();\n        };\n\n        var i = 0;\n        while (i < handlers.length) {\n            handlers[i](data);\n            i++;\n        }\n    },\n\n    /**\n     * destroy the manager and unbinds all events\n     * it doesn't unbind dom events, that is the user own responsibility\n     */\n    destroy: function() {\n        this.element && toggleCssProps(this, false);\n\n        this.handlers = {};\n        this.session = {};\n        this.input.destroy();\n        this.element = null;\n    }\n};\n\n/**\n * add/remove the css properties as defined in manager.options.cssProps\n * @param {Manager} manager\n * @param {Boolean} add\n */\nfunction toggleCssProps(manager, add) {\n    var element = manager.element;\n    if (!element.style) {\n        return;\n    }\n    var prop;\n    each(manager.options.cssProps, function(value, name) {\n        prop = prefixed(element.style, name);\n        if (add) {\n            manager.oldCssProps[prop] = element.style[prop];\n            element.style[prop] = value;\n        } else {\n            element.style[prop] = manager.oldCssProps[prop] || '';\n        }\n    });\n    if (!add) {\n        manager.oldCssProps = {};\n    }\n}\n\n/**\n * trigger dom event\n * @param {String} event\n * @param {Object} data\n */\nfunction triggerDomEvent(event, data) {\n    var gestureEvent = document.createEvent('Event');\n    gestureEvent.initEvent(event, true, true);\n    gestureEvent.gesture = data;\n    data.target.dispatchEvent(gestureEvent);\n}\n\nassign(Hammer, {\n    INPUT_START: INPUT_START,\n    INPUT_MOVE: INPUT_MOVE,\n    INPUT_END: INPUT_END,\n    INPUT_CANCEL: INPUT_CANCEL,\n\n    STATE_POSSIBLE: STATE_POSSIBLE,\n    STATE_BEGAN: STATE_BEGAN,\n    STATE_CHANGED: STATE_CHANGED,\n    STATE_ENDED: STATE_ENDED,\n    STATE_RECOGNIZED: STATE_RECOGNIZED,\n    STATE_CANCELLED: STATE_CANCELLED,\n    STATE_FAILED: STATE_FAILED,\n\n    DIRECTION_NONE: DIRECTION_NONE,\n    DIRECTION_LEFT: DIRECTION_LEFT,\n    DIRECTION_RIGHT: DIRECTION_RIGHT,\n    DIRECTION_UP: DIRECTION_UP,\n    DIRECTION_DOWN: DIRECTION_DOWN,\n    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,\n    DIRECTION_VERTICAL: DIRECTION_VERTICAL,\n    DIRECTION_ALL: DIRECTION_ALL,\n\n    Manager: Manager,\n    Input: Input,\n    TouchAction: TouchAction,\n\n    TouchInput: TouchInput,\n    MouseInput: MouseInput,\n    PointerEventInput: PointerEventInput,\n    TouchMouseInput: TouchMouseInput,\n    SingleTouchInput: SingleTouchInput,\n\n    Recognizer: Recognizer,\n    AttrRecognizer: AttrRecognizer,\n    Tap: TapRecognizer,\n    Pan: PanRecognizer,\n    Swipe: SwipeRecognizer,\n    Pinch: PinchRecognizer,\n    Rotate: RotateRecognizer,\n    Press: PressRecognizer,\n\n    on: addEventListeners,\n    off: removeEventListeners,\n    each: each,\n    merge: merge,\n    extend: extend,\n    assign: assign,\n    inherit: inherit,\n    bindFn: bindFn,\n    prefixed: prefixed\n});\n\n// this prevents errors when Hammer is loaded in the presence of an AMD\n//  style loader but by script tag, not by the loader.\nvar freeGlobal = (typeof window !== 'undefined' ? window : (typeof self !== 'undefined' ? self : {})); // jshint ignore:line\nfreeGlobal.Hammer = Hammer;\n\nif (typeof define === 'function' && define.amd) {\n    define(function() {\n        return Hammer;\n    });\n} else if (typeof module != 'undefined' && module.exports) {\n    module.exports = Hammer;\n} else {\n    window[exportName] = Hammer;\n}\n\n})(window, document, 'Hammer');\n","// Snap.svg 0.3.0\n// \n// Copyright (c) 2013 – 2014 Adobe Systems Incorporated. All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n// \n// http://www.apache.org/licenses/LICENSE-2.0\n// \n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n// \n// build: 2014-09-08\n\n(function (glob, factory) {\n    // AMD support\n    if (typeof define === \"function\" && define.amd) {\n        // Define as an anonymous module\n        define([\"eve\"], function( eve ) {\n            return factory(glob, eve);\n        });\n    } else if (typeof exports !== 'undefined') {\n        // Next for Node.js or CommonJS\n        var eve = require(264);\n        module.exports = factory(glob, eve);\n    } else {\n        // Browser globals (glob is window)\n        // Snap adds itself to window\n        factory(glob, glob.eve);\n    }\n}(window || this, function (window, eve) {\n\n// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n// \n// http://www.apache.org/licenses/LICENSE-2.0\n// \n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nvar mina = (function (eve) {\n    var animations = {},\n    requestAnimFrame = window.requestAnimationFrame       ||\n                       window.webkitRequestAnimationFrame ||\n                       window.mozRequestAnimationFrame    ||\n                       window.oRequestAnimationFrame      ||\n                       window.msRequestAnimationFrame     ||\n                       function (callback) {\n                           setTimeout(callback, 16);\n                       },\n    isArray = Array.isArray || function (a) {\n        return a instanceof Array ||\n            Object.prototype.toString.call(a) == \"[object Array]\";\n    },\n    idgen = 0,\n    idprefix = \"M\" + (+new Date).toString(36),\n    ID = function () {\n        return idprefix + (idgen++).toString(36);\n    },\n    diff = function (a, b, A, B) {\n        if (isArray(a)) {\n            res = [];\n            for (var i = 0, ii = a.length; i < ii; i++) {\n                res[i] = diff(a[i], b, A[i], B);\n            }\n            return res;\n        }\n        var dif = (A - a) / (B - b);\n        return function (bb) {\n            return a + dif * (bb - b);\n        };\n    },\n    timer = Date.now || function () {\n        return +new Date;\n    },\n    sta = function (val) {\n        var a = this;\n        if (val == null) {\n            return a.s;\n        }\n        var ds = a.s - val;\n        a.b += a.dur * ds;\n        a.B += a.dur * ds;\n        a.s = val;\n    },\n    speed = function (val) {\n        var a = this;\n        if (val == null) {\n            return a.spd;\n        }\n        a.spd = val;\n    },\n    duration = function (val) {\n        var a = this;\n        if (val == null) {\n            return a.dur;\n        }\n        a.s = a.s * val / a.dur;\n        a.dur = val;\n    },\n    stopit = function () {\n        var a = this;\n        delete animations[a.id];\n        a.update();\n        eve(\"mina.stop.\" + a.id, a);\n    },\n    pause = function () {\n        var a = this;\n        if (a.pdif) {\n            return;\n        }\n        delete animations[a.id];\n        a.update();\n        a.pdif = a.get() - a.b;\n    },\n    resume = function () {\n        var a = this;\n        if (!a.pdif) {\n            return;\n        }\n        a.b = a.get() - a.pdif;\n        delete a.pdif;\n        animations[a.id] = a;\n    },\n    update = function () {\n        var a = this,\n            res;\n        if (isArray(a.start)) {\n            res = [];\n            for (var j = 0, jj = a.start.length; j < jj; j++) {\n                res[j] = +a.start[j] +\n                    (a.end[j] - a.start[j]) * a.easing(a.s);\n            }\n        } else {\n            res = +a.start + (a.end - a.start) * a.easing(a.s);\n        }\n        a.set(res);\n    },\n    frame = function () {\n        var len = 0;\n        for (var i in animations) if (animations.hasOwnProperty(i)) {\n            var a = animations[i],\n                b = a.get(),\n                res;\n            len++;\n            a.s = (b - a.b) / (a.dur / a.spd);\n            if (a.s >= 1) {\n                delete animations[i];\n                a.s = 1;\n                len--;\n                (function (a) {\n                    setTimeout(function () {\n                        eve(\"mina.finish.\" + a.id, a);\n                    });\n                }(a));\n            }\n            a.update();\n        }\n        len && requestAnimFrame(frame);\n    },\n    /*/\n     * mina\n     [ method ]\n     **\n     * Generic animation of numbers\n     **\n     - a (number) start _slave_ number\n     - A (number) end _slave_ number\n     - b (number) start _master_ number (start time in general case)\n     - B (number) end _master_ number (end time in gereal case)\n     - get (function) getter of _master_ number (see @mina.time)\n     - set (function) setter of _slave_ number\n     - easing (function) #optional easing function, default is @mina.linear\n     = (object) animation descriptor\n     o {\n     o         id (string) animation id,\n     o         start (number) start _slave_ number,\n     o         end (number) end _slave_ number,\n     o         b (number) start _master_ number,\n     o         s (number) animation status (0..1),\n     o         dur (number) animation duration,\n     o         spd (number) animation speed,\n     o         get (function) getter of _master_ number (see @mina.time),\n     o         set (function) setter of _slave_ number,\n     o         easing (function) easing function, default is @mina.linear,\n     o         status (function) status getter/setter,\n     o         speed (function) speed getter/setter,\n     o         duration (function) duration getter/setter,\n     o         stop (function) animation stopper\n     o         pause (function) pauses the animation\n     o         resume (function) resumes the animation\n     o         update (function) calles setter with the right value of the animation\n     o }\n    /*/\n    mina = function (a, A, b, B, get, set, easing) {\n        var anim = {\n            id: ID(),\n            start: a,\n            end: A,\n            b: b,\n            s: 0,\n            dur: B - b,\n            spd: 1,\n            get: get,\n            set: set,\n            easing: easing || mina.linear,\n            status: sta,\n            speed: speed,\n            duration: duration,\n            stop: stopit,\n            pause: pause,\n            resume: resume,\n            update: update\n        };\n        animations[anim.id] = anim;\n        var len = 0, i;\n        for (i in animations) if (animations.hasOwnProperty(i)) {\n            len++;\n            if (len == 2) {\n                break;\n            }\n        }\n        len == 1 && requestAnimFrame(frame);\n        return anim;\n    };\n    /*/\n     * mina.time\n     [ method ]\n     **\n     * Returns the current time. Equivalent to:\n     | function () {\n     |     return (new Date).getTime();\n     | }\n    /*/\n    mina.time = timer;\n    /*/\n     * mina.getById\n     [ method ]\n     **\n     * Returns an animation by its id\n     - id (string) animation's id\n     = (object) See @mina\n    /*/\n    mina.getById = function (id) {\n        return animations[id] || null;\n    };\n\n    /*/\n     * mina.linear\n     [ method ]\n     **\n     * Default linear easing\n     - n (number) input 0..1\n     = (number) output 0..1\n    /*/\n    mina.linear = function (n) {\n        return n;\n    };\n    /*/\n     * mina.easeout\n     [ method ]\n     **\n     * Easeout easing\n     - n (number) input 0..1\n     = (number) output 0..1\n    /*/\n    mina.easeout = function (n) {\n        return Math.pow(n, 1.7);\n    };\n    /*/\n     * mina.easein\n     [ method ]\n     **\n     * Easein easing\n     - n (number) input 0..1\n     = (number) output 0..1\n    /*/\n    mina.easein = function (n) {\n        return Math.pow(n, .48);\n    };\n    /*/\n     * mina.easeinout\n     [ method ]\n     **\n     * Easeinout easing\n     - n (number) input 0..1\n     = (number) output 0..1\n    /*/\n    mina.easeinout = function (n) {\n        if (n == 1) {\n            return 1;\n        }\n        if (n == 0) {\n            return 0;\n        }\n        var q = .48 - n / 1.04,\n            Q = Math.sqrt(.1734 + q * q),\n            x = Q - q,\n            X = Math.pow(Math.abs(x), 1 / 3) * (x < 0 ? -1 : 1),\n            y = -Q - q,\n            Y = Math.pow(Math.abs(y), 1 / 3) * (y < 0 ? -1 : 1),\n            t = X + Y + .5;\n        return (1 - t) * 3 * t * t + t * t * t;\n    };\n    /*/\n     * mina.backin\n     [ method ]\n     **\n     * Backin easing\n     - n (number) input 0..1\n     = (number) output 0..1\n    /*/\n    mina.backin = function (n) {\n        if (n == 1) {\n            return 1;\n        }\n        var s = 1.70158;\n        return n * n * ((s + 1) * n - s);\n    };\n    /*/\n     * mina.backout\n     [ method ]\n     **\n     * Backout easing\n     - n (number) input 0..1\n     = (number) output 0..1\n    /*/\n    mina.backout = function (n) {\n        if (n == 0) {\n            return 0;\n        }\n        n = n - 1;\n        var s = 1.70158;\n        return n * n * ((s + 1) * n + s) + 1;\n    };\n    /*/\n     * mina.elastic\n     [ method ]\n     **\n     * Elastic easing\n     - n (number) input 0..1\n     = (number) output 0..1\n    /*/\n    mina.elastic = function (n) {\n        if (n == !!n) {\n            return n;\n        }\n        return Math.pow(2, -10 * n) * Math.sin((n - .075) *\n            (2 * Math.PI) / .3) + 1;\n    };\n    /*/\n     * mina.bounce\n     [ method ]\n     **\n     * Bounce easing\n     - n (number) input 0..1\n     = (number) output 0..1\n    /*/\n    mina.bounce = function (n) {\n        var s = 7.5625,\n            p = 2.75,\n            l;\n        if (n < (1 / p)) {\n            l = s * n * n;\n        } else {\n            if (n < (2 / p)) {\n                n -= (1.5 / p);\n                l = s * n * n + .75;\n            } else {\n                if (n < (2.5 / p)) {\n                    n -= (2.25 / p);\n                    l = s * n * n + .9375;\n                } else {\n                    n -= (2.625 / p);\n                    l = s * n * n + .984375;\n                }\n            }\n        }\n        return l;\n    };\n    window.mina = mina;\n    return mina;\n})(typeof eve == \"undefined\" ? function () {} : eve);\n// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nvar Snap = (function(root) {\nSnap.version = \"0.3.0\";\n/*/\n * Snap\n [ method ]\n **\n * Creates a drawing surface or wraps existing SVG element.\n **\n - width (number|string) width of surface\n - height (number|string) height of surface\n * or\n - DOM (SVGElement) element to be wrapped into Snap structure\n * or\n - array (array) array of elements (will return set of elements)\n * or\n - query (string) CSS query selector\n = (object) @Element\n/*/\nfunction Snap(w, h) {\n    if (w) {\n        if (w.tagName) {\n            return wrap(w);\n        }\n        if (is(w, \"array\") && Snap.set) {\n            return Snap.set.apply(Snap, w);\n        }\n        if (w instanceof Element) {\n            return w;\n        }\n        if (h == null) {\n            w = glob.doc.querySelector(w);\n            return wrap(w);\n        }\n    }\n    w = w == null ? \"100%\" : w;\n    h = h == null ? \"100%\" : h;\n    return new Paper(w, h);\n}\nSnap.toString = function () {\n    return \"Snap v\" + this.version;\n};\nSnap._ = {};\nvar glob = {\n    win: root.window,\n    doc: root.window.document\n};\nSnap._.glob = glob;\nvar has = \"hasOwnProperty\",\n    Str = String,\n    toFloat = parseFloat,\n    toInt = parseInt,\n    math = Math,\n    mmax = math.max,\n    mmin = math.min,\n    abs = math.abs,\n    pow = math.pow,\n    PI = math.PI,\n    round = math.round,\n    E = \"\",\n    S = \" \",\n    objectToString = Object.prototype.toString,\n    ISURL = /^url/(['\"]?([^/)]+?)['\"]?/)$/i,\n    colourRegExp = /^/s*((#[a-f/d]{6})|(#[a-f/d]{3})|rgba?/(/s*([/d/.]+%?/s*,/s*[/d/.]+%?/s*,/s*[/d/.]+%?(?:/s*,/s*[/d/.]+%?)?)/s*/)|hsba?/(/s*([/d/.]+(?:deg|/xb0|%)?/s*,/s*[/d/.]+%?/s*,/s*[/d/.]+(?:%?/s*,/s*[/d/.]+)?%?)/s*/)|hsla?/(/s*([/d/.]+(?:deg|/xb0|%)?/s*,/s*[/d/.]+%?/s*,/s*[/d/.]+(?:%?/s*,/s*[/d/.]+)?%?)/s*/))/s*$/i,\n    bezierrg = /^(?:cubic-)?bezier/(([^,]+),([^,]+),([^,]+),([^/)]+)/)/,\n    reURLValue = /^url/(#?([^)]+)/)$/,\n    separator = Snap._.separator = /[,/s]+/,\n    whitespace = /[/s]/g,\n    commaSpaces = /[/s]*,[/s]*/,\n    hsrg = {hs: 1, rg: 1},\n    pathCommand = /([a-z])[/s,]*((-?/d*/.?/d*(?:e[/-+]?/d+)?[/s]*,?[/s]*)+)/ig,\n    tCommand = /([rstm])[/s,]*((-?/d*/.?/d*(?:e[/-+]?/d+)?[/s]*,?[/s]*)+)/ig,\n    pathValues = /(-?/d*/.?/d*(?:e[/-+]?//d+)?)[/s]*,?[/s]*/ig,\n    idgen = 0,\n    idprefix = \"S\" + (+new Date).toString(36),\n    ID = function (el) {\n        return (el && el.type ? el.type : E) + idprefix + (idgen++).toString(36);\n    },\n    xlink = \"http://www.w3.org/1999/xlink\",\n    xmlns = \"http://www.w3.org/2000/svg\",\n    hub = {},\n    URL = Snap.url = function (url) {\n        return \"url('#\" + url + \"')\";\n    };\n\nfunction $(el, attr) {\n    if (attr) {\n        if (el == \"#text\") {\n            el = glob.doc.createTextNode(attr.text || \"\");\n        }\n        if (typeof el == \"string\") {\n            el = $(el);\n        }\n        if (typeof attr == \"string\") {\n            if (attr.substring(0, 6) == \"xlink:\") {\n                return el.getAttributeNS(xlink, attr.substring(6));\n            }\n            if (attr.substring(0, 4) == \"xml:\") {\n                return el.getAttributeNS(xmlns, attr.substring(4));\n            }\n            return el.getAttribute(attr);\n        }\n        for (var key in attr) if (attr[has](key)) {\n            var val = Str(attr[key]);\n            if (val) {\n                if (key.substring(0, 6) == \"xlink:\") {\n                    el.setAttributeNS(xlink, key.substring(6), val);\n                } else if (key.substring(0, 4) == \"xml:\") {\n                    el.setAttributeNS(xmlns, key.substring(4), val);\n                } else {\n                    el.setAttribute(key, val);\n                }\n            } else {\n                el.removeAttribute(key);\n            }\n        }\n    } else {\n        el = glob.doc.createElementNS(xmlns, el);\n    }\n    return el;\n}\nSnap._.$ = $;\nSnap._.id = ID;\nfunction getAttrs(el) {\n    var attrs = el.attributes,\n        name,\n        out = {};\n    for (var i = 0; i < attrs.length; i++) {\n        if (attrs[i].namespaceURI == xlink) {\n            name = \"xlink:\";\n        } else {\n            name = \"\";\n        }\n        name += attrs[i].name;\n        out[name] = attrs[i].textContent;\n    }\n    return out;\n}\nfunction is(o, type) {\n    type = Str.prototype.toLowerCase.call(type);\n    if (type == \"finite\") {\n        return isFinite(o);\n    }\n    if (type == \"array\" &&\n        (o instanceof Array || Array.isArray && Array.isArray(o))) {\n        return true;\n    }\n    return  (type == \"null\" && o === null) ||\n            (type == typeof o && o !== null) ||\n            (type == \"object\" && o === Object(o)) ||\n            objectToString.call(o).slice(8, -1).toLowerCase() == type;\n}\n/*/\n * Snap.format\n [ method ]\n **\n * Replaces construction of type `{<name>}` to the corresponding argument\n **\n - token (string) string to format\n - json (object) object which properties are used as a replacement\n = (string) formatted string\n > Usage\n | // this draws a rectangular shape equivalent to \"M10,20h40v50h-40z\"\n | paper.path(Snap.format(\"M{x},{y}h{dim.width}v{dim.height}h{dim['negative width']}z\", {\n |     x: 10,\n |     y: 20,\n |     dim: {\n |         width: 40,\n |         height: 50,\n |         \"negative width\": -40\n |     }\n | }));\n/*/\nSnap.format = (function () {\n    var tokenRegex = //{([^/}]+)/}/g,\n        objNotationRegex = /(?:(?:^|/.)(.+?)(?=/[|/.|$|/()|/[('|\")(.+?)/2/])(/(/))?/g, // matches .xxxxx or [\"xxxxx\"] to run over object properties\n        replacer = function (all, key, obj) {\n            var res = obj;\n            key.replace(objNotationRegex, function (all, name, quote, quotedName, isFunc) {\n                name = name || quotedName;\n                if (res) {\n                    if (name in res) {\n                        res = res[name];\n                    }\n                    typeof res == \"function\" && isFunc && (res = res());\n                }\n            });\n            res = (res == null || res == obj ? all : res) + \"\";\n            return res;\n        };\n    return function (str, obj) {\n        return Str(str).replace(tokenRegex, function (all, key) {\n            return replacer(all, key, obj);\n        });\n    };\n})();\nfunction clone(obj) {\n    if (typeof obj == \"function\" || Object(obj) !== obj) {\n        return obj;\n    }\n    var res = new obj.constructor;\n    for (var key in obj) if (obj[has](key)) {\n        res[key] = clone(obj[key]);\n    }\n    return res;\n}\nSnap._.clone = clone;\nfunction repush(array, item) {\n    for (var i = 0, ii = array.length; i < ii; i++) if (array[i] === item) {\n        return array.push(array.splice(i, 1)[0]);\n    }\n}\nfunction cacher(f, scope, postprocessor) {\n    function newf() {\n        var arg = Array.prototype.slice.call(arguments, 0),\n            args = arg.join(\"/u2400\"),\n            cache = newf.cache = newf.cache || {},\n            count = newf.count = newf.count || [];\n        if (cache[has](args)) {\n            repush(count, args);\n            return postprocessor ? postprocessor(cache[args]) : cache[args];\n        }\n        count.length >= 1e3 && delete cache[count.shift()];\n        count.push(args);\n        cache[args] = f.apply(scope, arg);\n        return postprocessor ? postprocessor(cache[args]) : cache[args];\n    }\n    return newf;\n}\nSnap._.cacher = cacher;\nfunction angle(x1, y1, x2, y2, x3, y3) {\n    if (x3 == null) {\n        var x = x1 - x2,\n            y = y1 - y2;\n        if (!x && !y) {\n            return 0;\n        }\n        return (180 + math.atan2(-y, -x) * 180 / PI + 360) % 360;\n    } else {\n        return angle(x1, y1, x3, y3) - angle(x2, y2, x3, y3);\n    }\n}\nfunction rad(deg) {\n    return deg % 360 * PI / 180;\n}\nfunction deg(rad) {\n    return rad * 180 / PI % 360;\n}\nfunction x_y() {\n    return this.x + S + this.y;\n}\nfunction x_y_w_h() {\n    return this.x + S + this.y + S + this.width + \" /xd7 \" + this.height;\n}\n\n/*/\n * Snap.rad\n [ method ]\n **\n * Transform angle to radians\n - deg (number) angle in degrees\n = (number) angle in radians\n/*/\nSnap.rad = rad;\n/*/\n * Snap.deg\n [ method ]\n **\n * Transform angle to degrees\n - rad (number) angle in radians\n = (number) angle in degrees\n/*/\nSnap.deg = deg;\n/*/\n * Snap.angle\n [ method ]\n **\n * Returns an angle between two or three points\n > Parameters\n - x1 (number) x coord of first point\n - y1 (number) y coord of first point\n - x2 (number) x coord of second point\n - y2 (number) y coord of second point\n - x3 (number) #optional x coord of third point\n - y3 (number) #optional y coord of third point\n = (number) angle in degrees\n/*/\nSnap.angle = angle;\n/*/\n * Snap.is\n [ method ]\n **\n * Handy replacement for the `typeof` operator\n - o (…) any object or primitive\n - type (string) name of the type, e.g., `string`, `function`, `number`, etc.\n = (boolean) `true` if given value is of given type\n/*/\nSnap.is = is;\n/*/\n * Snap.snapTo\n [ method ]\n **\n * Snaps given value to given grid\n - values (array|number) given array of values or step of the grid\n - value (number) value to adjust\n - tolerance (number) #optional maximum distance to the target value that would trigger the snap. Default is `10`.\n = (number) adjusted value\n/*/\nSnap.snapTo = function (values, value, tolerance) {\n    tolerance = is(tolerance, \"finite\") ? tolerance : 10;\n    if (is(values, \"array\")) {\n        var i = values.length;\n        while (i--) if (abs(values[i] - value) <= tolerance) {\n            return values[i];\n        }\n    } else {\n        values = +values;\n        var rem = value % values;\n        if (rem < tolerance) {\n            return value - rem;\n        }\n        if (rem > values - tolerance) {\n            return value - rem + values;\n        }\n    }\n    return value;\n};\n// Colour\n/*/\n * Snap.getRGB\n [ method ]\n **\n * Parses color string as RGB object\n - color (string) color string in one of the following formats:\n # <ul>\n #     <li>Color name (<code>red</code>, <code>green</code>, <code>cornflowerblue</code>, etc)</li>\n #     <li>#••• — shortened HTML color: (<code>#000</code>, <code>#fc0</code>, etc.)</li>\n #     <li>#•••••• — full length HTML color: (<code>#000000</code>, <code>#bd2300</code>)</li>\n #     <li>rgb(•••, •••, •••) — red, green and blue channels values: (<code>rgb(200,&nbsp;100,&nbsp;0)</code>)</li>\n #     <li>rgba(•••, •••, •••, •••) — also with opacity</li>\n #     <li>rgb(•••%, •••%, •••%) — same as above, but in %: (<code>rgb(100%,&nbsp;175%,&nbsp;0%)</code>)</li>\n #     <li>rgba(•••%, •••%, •••%, •••%) — also with opacity</li>\n #     <li>hsb(•••, •••, •••) — hue, saturation and brightness values: (<code>hsb(0.5,&nbsp;0.25,&nbsp;1)</code>)</li>\n #     <li>hsba(•••, •••, •••, •••) — also with opacity</li>\n #     <li>hsb(•••%, •••%, •••%) — same as above, but in %</li>\n #     <li>hsba(•••%, •••%, •••%, •••%) — also with opacity</li>\n #     <li>hsl(•••, •••, •••) — hue, saturation and luminosity values: (<code>hsb(0.5,&nbsp;0.25,&nbsp;0.5)</code>)</li>\n #     <li>hsla(•••, •••, •••, •••) — also with opacity</li>\n #     <li>hsl(•••%, •••%, •••%) — same as above, but in %</li>\n #     <li>hsla(•••%, •••%, •••%, •••%) — also with opacity</li>\n # </ul>\n * Note that `%` can be used any time: `rgb(20%, 255, 50%)`.\n = (object) RGB object in the following format:\n o {\n o     r (number) red,\n o     g (number) green,\n o     b (number) blue,\n o     hex (string) color in HTML/CSS format: #••••••,\n o     error (boolean) true if string can't be parsed\n o }\n/*/\nSnap.getRGB = cacher(function (colour) {\n    if (!colour || !!((colour = Str(colour)).indexOf(\"-\") + 1)) {\n        return {r: -1, g: -1, b: -1, hex: \"none\", error: 1, toString: rgbtoString};\n    }\n    if (colour == \"none\") {\n        return {r: -1, g: -1, b: -1, hex: \"none\", toString: rgbtoString};\n    }\n    !(hsrg[has](colour.toLowerCase().substring(0, 2)) || colour.charAt() == \"#\") && (colour = toHex(colour));\n    if (!colour) {\n        return {r: -1, g: -1, b: -1, hex: \"none\", error: 1, toString: rgbtoString};\n    }\n    var res,\n        red,\n        green,\n        blue,\n        opacity,\n        t,\n        values,\n        rgb = colour.match(colourRegExp);\n    if (rgb) {\n        if (rgb[2]) {\n            blue = toInt(rgb[2].substring(5), 16);\n            green = toInt(rgb[2].substring(3, 5), 16);\n            red = toInt(rgb[2].substring(1, 3), 16);\n        }\n        if (rgb[3]) {\n            blue = toInt((t = rgb[3].charAt(3)) + t, 16);\n            green = toInt((t = rgb[3].charAt(2)) + t, 16);\n            red = toInt((t = rgb[3].charAt(1)) + t, 16);\n        }\n        if (rgb[4]) {\n            values = rgb[4].split(commaSpaces);\n            red = toFloat(values[0]);\n            values[0].slice(-1) == \"%\" && (red *= 2.55);\n            green = toFloat(values[1]);\n            values[1].slice(-1) == \"%\" && (green *= 2.55);\n            blue = toFloat(values[2]);\n            values[2].slice(-1) == \"%\" && (blue *= 2.55);\n            rgb[1].toLowerCase().slice(0, 4) == \"rgba\" && (opacity = toFloat(values[3]));\n            values[3] && values[3].slice(-1) == \"%\" && (opacity /= 100);\n        }\n        if (rgb[5]) {\n            values = rgb[5].split(commaSpaces);\n            red = toFloat(values[0]);\n            values[0].slice(-1) == \"%\" && (red /= 100);\n            green = toFloat(values[1]);\n            values[1].slice(-1) == \"%\" && (green /= 100);\n            blue = toFloat(values[2]);\n            values[2].slice(-1) == \"%\" && (blue /= 100);\n            (values[0].slice(-3) == \"deg\" || values[0].slice(-1) == \"/xb0\") && (red /= 360);\n            rgb[1].toLowerCase().slice(0, 4) == \"hsba\" && (opacity = toFloat(values[3]));\n            values[3] && values[3].slice(-1) == \"%\" && (opacity /= 100);\n            return Snap.hsb2rgb(red, green, blue, opacity);\n        }\n        if (rgb[6]) {\n            values = rgb[6].split(commaSpaces);\n            red = toFloat(values[0]);\n            values[0].slice(-1) == \"%\" && (red /= 100);\n            green = toFloat(values[1]);\n            values[1].slice(-1) == \"%\" && (green /= 100);\n            blue = toFloat(values[2]);\n            values[2].slice(-1) == \"%\" && (blue /= 100);\n            (values[0].slice(-3) == \"deg\" || values[0].slice(-1) == \"/xb0\") && (red /= 360);\n            rgb[1].toLowerCase().slice(0, 4) == \"hsla\" && (opacity = toFloat(values[3]));\n            values[3] && values[3].slice(-1) == \"%\" && (opacity /= 100);\n            return Snap.hsl2rgb(red, green, blue, opacity);\n        }\n        red = mmin(math.round(red), 255);\n        green = mmin(math.round(green), 255);\n        blue = mmin(math.round(blue), 255);\n        opacity = mmin(mmax(opacity, 0), 1);\n        rgb = {r: red, g: green, b: blue, toString: rgbtoString};\n        rgb.hex = \"#\" + (16777216 | blue | (green << 8) | (red << 16)).toString(16).slice(1);\n        rgb.opacity = is(opacity, \"finite\") ? opacity : 1;\n        return rgb;\n    }\n    return {r: -1, g: -1, b: -1, hex: \"none\", error: 1, toString: rgbtoString};\n}, Snap);\n// SIERRA It seems odd that the following 3 conversion methods are not expressed as .this2that(), like the others.\n/*/\n * Snap.hsb\n [ method ]\n **\n * Converts HSB values to a hex representation of the color\n - h (number) hue\n - s (number) saturation\n - b (number) value or brightness\n = (string) hex representation of the color\n/*/\nSnap.hsb = cacher(function (h, s, b) {\n    return Snap.hsb2rgb(h, s, b).hex;\n});\n/*/\n * Snap.hsl\n [ method ]\n **\n * Converts HSL values to a hex representation of the color\n - h (number) hue\n - s (number) saturation\n - l (number) luminosity\n = (string) hex representation of the color\n/*/\nSnap.hsl = cacher(function (h, s, l) {\n    return Snap.hsl2rgb(h, s, l).hex;\n});\n/*/\n * Snap.rgb\n [ method ]\n **\n * Converts RGB values to a hex representation of the color\n - r (number) red\n - g (number) green\n - b (number) blue\n = (string) hex representation of the color\n/*/\nSnap.rgb = cacher(function (r, g, b, o) {\n    if (is(o, \"finite\")) {\n        var round = math.round;\n        return \"rgba(\" + [round(r), round(g), round(b), +o.toFixed(2)] + \")\";\n    }\n    return \"#\" + (16777216 | b | (g << 8) | (r << 16)).toString(16).slice(1);\n});\nvar toHex = function (color) {\n    var i = glob.doc.getElementsByTagName(\"head\")[0] || glob.doc.getElementsByTagName(\"svg\")[0],\n        red = \"rgb(255, 0, 0)\";\n    toHex = cacher(function (color) {\n        if (color.toLowerCase() == \"red\") {\n            return red;\n        }\n        i.style.color = red;\n        i.style.color = color;\n        var out = glob.doc.defaultView.getComputedStyle(i, E).getPropertyValue(\"color\");\n        return out == red ? null : out;\n    });\n    return toHex(color);\n},\nhsbtoString = function () {\n    return \"hsb(\" + [this.h, this.s, this.b] + \")\";\n},\nhsltoString = function () {\n    return \"hsl(\" + [this.h, this.s, this.l] + \")\";\n},\nrgbtoString = function () {\n    return this.opacity == 1 || this.opacity == null ?\n            this.hex :\n            \"rgba(\" + [this.r, this.g, this.b, this.opacity] + \")\";\n},\nprepareRGB = function (r, g, b) {\n    if (g == null && is(r, \"object\") && \"r\" in r && \"g\" in r && \"b\" in r) {\n        b = r.b;\n        g = r.g;\n        r = r.r;\n    }\n    if (g == null && is(r, string)) {\n        var clr = Snap.getRGB(r);\n        r = clr.r;\n        g = clr.g;\n        b = clr.b;\n    }\n    if (r > 1 || g > 1 || b > 1) {\n        r /= 255;\n        g /= 255;\n        b /= 255;\n    }\n\n    return [r, g, b];\n},\npackageRGB = function (r, g, b, o) {\n    r = math.round(r * 255);\n    g = math.round(g * 255);\n    b = math.round(b * 255);\n    var rgb = {\n        r: r,\n        g: g,\n        b: b,\n        opacity: is(o, \"finite\") ? o : 1,\n        hex: Snap.rgb(r, g, b),\n        toString: rgbtoString\n    };\n    is(o, \"finite\") && (rgb.opacity = o);\n    return rgb;\n};\n// SIERRA Clarify if Snap does not support consolidated HSLA/RGBA colors. E.g., can you specify a semi-transparent value for Snap.filter.shadow()?\n/*/\n * Snap.color\n [ method ]\n **\n * Parses the color string and returns an object featuring the color's component values\n - clr (string) color string in one of the supported formats (see @Snap.getRGB)\n = (object) Combined RGB/HSB object in the following format:\n o {\n o     r (number) red,\n o     g (number) green,\n o     b (number) blue,\n o     hex (string) color in HTML/CSS format: #••••••,\n o     error (boolean) `true` if string can't be parsed,\n o     h (number) hue,\n o     s (number) saturation,\n o     v (number) value (brightness),\n o     l (number) lightness\n o }\n/*/\nSnap.color = function (clr) {\n    var rgb;\n    if (is(clr, \"object\") && \"h\" in clr && \"s\" in clr && \"b\" in clr) {\n        rgb = Snap.hsb2rgb(clr);\n        clr.r = rgb.r;\n        clr.g = rgb.g;\n        clr.b = rgb.b;\n        clr.opacity = 1;\n        clr.hex = rgb.hex;\n    } else if (is(clr, \"object\") && \"h\" in clr && \"s\" in clr && \"l\" in clr) {\n        rgb = Snap.hsl2rgb(clr);\n        clr.r = rgb.r;\n        clr.g = rgb.g;\n        clr.b = rgb.b;\n        clr.opacity = 1;\n        clr.hex = rgb.hex;\n    } else {\n        if (is(clr, \"string\")) {\n            clr = Snap.getRGB(clr);\n        }\n        if (is(clr, \"object\") && \"r\" in clr && \"g\" in clr && \"b\" in clr && !(\"error\" in clr)) {\n            rgb = Snap.rgb2hsl(clr);\n            clr.h = rgb.h;\n            clr.s = rgb.s;\n            clr.l = rgb.l;\n            rgb = Snap.rgb2hsb(clr);\n            clr.v = rgb.b;\n        } else {\n            clr = {hex: \"none\"};\n            clr.r = clr.g = clr.b = clr.h = clr.s = clr.v = clr.l = -1;\n            clr.error = 1;\n        }\n    }\n    clr.toString = rgbtoString;\n    return clr;\n};\n/*/\n * Snap.hsb2rgb\n [ method ]\n **\n * Converts HSB values to an RGB object\n - h (number) hue\n - s (number) saturation\n - v (number) value or brightness\n = (object) RGB object in the following format:\n o {\n o     r (number) red,\n o     g (number) green,\n o     b (number) blue,\n o     hex (string) color in HTML/CSS format: #••••••\n o }\n/*/\nSnap.hsb2rgb = function (h, s, v, o) {\n    if (is(h, \"object\") && \"h\" in h && \"s\" in h && \"b\" in h) {\n        v = h.b;\n        s = h.s;\n        h = h.h;\n        o = h.o;\n    }\n    h *= 360;\n    var R, G, B, X, C;\n    h = (h % 360) / 60;\n    C = v * s;\n    X = C * (1 - abs(h % 2 - 1));\n    R = G = B = v - C;\n\n    h = ~~h;\n    R += [C, X, 0, 0, X, C][h];\n    G += [X, C, C, X, 0, 0][h];\n    B += [0, 0, X, C, C, X][h];\n    return packageRGB(R, G, B, o);\n};\n/*/\n * Snap.hsl2rgb\n [ method ]\n **\n * Converts HSL values to an RGB object\n - h (number) hue\n - s (number) saturation\n - l (number) luminosity\n = (object) RGB object in the following format:\n o {\n o     r (number) red,\n o     g (number) green,\n o     b (number) blue,\n o     hex (string) color in HTML/CSS format: #••••••\n o }\n/*/\nSnap.hsl2rgb = function (h, s, l, o) {\n    if (is(h, \"object\") && \"h\" in h && \"s\" in h && \"l\" in h) {\n        l = h.l;\n        s = h.s;\n        h = h.h;\n    }\n    if (h > 1 || s > 1 || l > 1) {\n        h /= 360;\n        s /= 100;\n        l /= 100;\n    }\n    h *= 360;\n    var R, G, B, X, C;\n    h = (h % 360) / 60;\n    C = 2 * s * (l < .5 ? l : 1 - l);\n    X = C * (1 - abs(h % 2 - 1));\n    R = G = B = l - C / 2;\n\n    h = ~~h;\n    R += [C, X, 0, 0, X, C][h];\n    G += [X, C, C, X, 0, 0][h];\n    B += [0, 0, X, C, C, X][h];\n    return packageRGB(R, G, B, o);\n};\n/*/\n * Snap.rgb2hsb\n [ method ]\n **\n * Converts RGB values to an HSB object\n - r (number) red\n - g (number) green\n - b (number) blue\n = (object) HSB object in the following format:\n o {\n o     h (number) hue,\n o     s (number) saturation,\n o     b (number) brightness\n o }\n/*/\nSnap.rgb2hsb = function (r, g, b) {\n    b = prepareRGB(r, g, b);\n    r = b[0];\n    g = b[1];\n    b = b[2];\n\n    var H, S, V, C;\n    V = mmax(r, g, b);\n    C = V - mmin(r, g, b);\n    H = (C == 0 ? null :\n         V == r ? (g - b) / C :\n         V == g ? (b - r) / C + 2 :\n                  (r - g) / C + 4\n        );\n    H = ((H + 360) % 6) * 60 / 360;\n    S = C == 0 ? 0 : C / V;\n    return {h: H, s: S, b: V, toString: hsbtoString};\n};\n/*/\n * Snap.rgb2hsl\n [ method ]\n **\n * Converts RGB values to an HSL object\n - r (number) red\n - g (number) green\n - b (number) blue\n = (object) HSL object in the following format:\n o {\n o     h (number) hue,\n o     s (number) saturation,\n o     l (number) luminosity\n o }\n/*/\nSnap.rgb2hsl = function (r, g, b) {\n    b = prepareRGB(r, g, b);\n    r = b[0];\n    g = b[1];\n    b = b[2];\n\n    var H, S, L, M, m, C;\n    M = mmax(r, g, b);\n    m = mmin(r, g, b);\n    C = M - m;\n    H = (C == 0 ? null :\n         M == r ? (g - b) / C :\n         M == g ? (b - r) / C + 2 :\n                  (r - g) / C + 4);\n    H = ((H + 360) % 6) * 60 / 360;\n    L = (M + m) / 2;\n    S = (C == 0 ? 0 :\n         L < .5 ? C / (2 * L) :\n                  C / (2 - 2 * L));\n    return {h: H, s: S, l: L, toString: hsltoString};\n};\n\n// Transformations\n// SIERRA Snap.parsePathString(): By _array of arrays,_ I assume you mean a format like this for two separate segments? [ [\"M10,10\",\"L90,90\"], [\"M90,10\",\"L10,90\"] ] Otherwise how is each command structured?\n/*/\n * Snap.parsePathString\n [ method ]\n **\n * Utility method\n **\n * Parses given path string into an array of arrays of path segments\n - pathString (string|array) path string or array of segments (in the last case it is returned straight away)\n = (array) array of segments\n/*/\nSnap.parsePathString = function (pathString) {\n    if (!pathString) {\n        return null;\n    }\n    var pth = Snap.path(pathString);\n    if (pth.arr) {\n        return Snap.path.clone(pth.arr);\n    }\n\n    var paramCounts = {a: 7, c: 6, o: 2, h: 1, l: 2, m: 2, r: 4, q: 4, s: 4, t: 2, v: 1, u: 3, z: 0},\n        data = [];\n    if (is(pathString, \"array\") && is(pathString[0], \"array\")) { // rough assumption\n        data = Snap.path.clone(pathString);\n    }\n    if (!data.length) {\n        Str(pathString).replace(pathCommand, function (a, b, c) {\n            var params = [],\n                name = b.toLowerCase();\n            c.replace(pathValues, function (a, b) {\n                b && params.push(+b);\n            });\n            if (name == \"m\" && params.length > 2) {\n                data.push([b].concat(params.splice(0, 2)));\n                name = \"l\";\n                b = b == \"m\" ? \"l\" : \"L\";\n            }\n            if (name == \"o\" && params.length == 1) {\n                data.push([b, params[0]]);\n            }\n            if (name == \"r\") {\n                data.push([b].concat(params));\n            } else while (params.length >= paramCounts[name]) {\n                data.push([b].concat(params.splice(0, paramCounts[name])));\n                if (!paramCounts[name]) {\n                    break;\n                }\n            }\n        });\n    }\n    data.toString = Snap.path.toString;\n    pth.arr = Snap.path.clone(data);\n    return data;\n};\n/*/\n * Snap.parseTransformString\n [ method ]\n **\n * Utility method\n **\n * Parses given transform string into an array of transformations\n - TString (string|array) transform string or array of transformations (in the last case it is returned straight away)\n = (array) array of transformations\n/*/\nvar parseTransformString = Snap.parseTransformString = function (TString) {\n    if (!TString) {\n        return null;\n    }\n    var paramCounts = {r: 3, s: 4, t: 2, m: 6},\n        data = [];\n    if (is(TString, \"array\") && is(TString[0], \"array\")) { // rough assumption\n        data = Snap.path.clone(TString);\n    }\n    if (!data.length) {\n        Str(TString).replace(tCommand, function (a, b, c) {\n            var params = [],\n                name = b.toLowerCase();\n            c.replace(pathValues, function (a, b) {\n                b && params.push(+b);\n            });\n            data.push([b].concat(params));\n        });\n    }\n    data.toString = Snap.path.toString;\n    return data;\n};\nfunction svgTransform2string(tstr) {\n    var res = [];\n    tstr = tstr.replace(/(?:^|/s)(/w+)/(([^)]+)/)/g, function (all, name, params) {\n        params = params.split(//s*,/s*|/s+/);\n        if (name == \"rotate\" && params.length == 1) {\n            params.push(0, 0);\n        }\n        if (name == \"scale\") {\n            if (params.length > 2) {\n                params = params.slice(0, 2);\n            } else if (params.length == 2) {\n                params.push(0, 0);\n            }\n            if (params.length == 1) {\n                params.push(params[0], 0, 0);\n            }\n        }\n        if (name == \"skewX\") {\n            res.push([\"m\", 1, 0, math.tan(rad(params[0])), 1, 0, 0]);\n        } else if (name == \"skewY\") {\n            res.push([\"m\", 1, math.tan(rad(params[0])), 0, 1, 0, 0]);\n        } else {\n            res.push([name.charAt(0)].concat(params));\n        }\n        return all;\n    });\n    return res;\n}\nSnap._.svgTransform2string = svgTransform2string;\nSnap._.rgTransform = /^[a-z][/s]*-?/.?/d/i;\nfunction transform2matrix(tstr, bbox) {\n    var tdata = parseTransformString(tstr),\n        m = new Snap.Matrix;\n    if (tdata) {\n        for (var i = 0, ii = tdata.length; i < ii; i++) {\n            var t = tdata[i],\n                tlen = t.length,\n                command = Str(t[0]).toLowerCase(),\n                absolute = t[0] != command,\n                inver = absolute ? m.invert() : 0,\n                x1,\n                y1,\n                x2,\n                y2,\n                bb;\n            if (command == \"t\" && tlen == 2){\n                m.translate(t[1], 0);\n            } else if (command == \"t\" && tlen == 3) {\n                if (absolute) {\n                    x1 = inver.x(0, 0);\n                    y1 = inver.y(0, 0);\n                    x2 = inver.x(t[1], t[2]);\n                    y2 = inver.y(t[1], t[2]);\n                    m.translate(x2 - x1, y2 - y1);\n                } else {\n                    m.translate(t[1], t[2]);\n                }\n            } else if (command == \"r\") {\n                if (tlen == 2) {\n                    bb = bb || bbox;\n                    m.rotate(t[1], bb.x + bb.width / 2, bb.y + bb.height / 2);\n                } else if (tlen == 4) {\n                    if (absolute) {\n                        x2 = inver.x(t[2], t[3]);\n                        y2 = inver.y(t[2], t[3]);\n                        m.rotate(t[1], x2, y2);\n                    } else {\n                        m.rotate(t[1], t[2], t[3]);\n                    }\n                }\n            } else if (command == \"s\") {\n                if (tlen == 2 || tlen == 3) {\n                    bb = bb || bbox;\n                    m.scale(t[1], t[tlen - 1], bb.x + bb.width / 2, bb.y + bb.height / 2);\n                } else if (tlen == 4) {\n                    if (absolute) {\n                        x2 = inver.x(t[2], t[3]);\n                        y2 = inver.y(t[2], t[3]);\n                        m.scale(t[1], t[1], x2, y2);\n                    } else {\n                        m.scale(t[1], t[1], t[2], t[3]);\n                    }\n                } else if (tlen == 5) {\n                    if (absolute) {\n                        x2 = inver.x(t[3], t[4]);\n                        y2 = inver.y(t[3], t[4]);\n                        m.scale(t[1], t[2], x2, y2);\n                    } else {\n                        m.scale(t[1], t[2], t[3], t[4]);\n                    }\n                }\n            } else if (command == \"m\" && tlen == 7) {\n                m.add(t[1], t[2], t[3], t[4], t[5], t[6]);\n            }\n        }\n    }\n    return m;\n}\nSnap._.transform2matrix = transform2matrix;\nSnap._unit2px = unit2px;\nvar contains = glob.doc.contains || glob.doc.compareDocumentPosition ?\n    function (a, b) {\n        var adown = a.nodeType == 9 ? a.documentElement : a,\n            bup = b && b.parentNode;\n            return a == bup || !!(bup && bup.nodeType == 1 && (\n                adown.contains ?\n                    adown.contains(bup) :\n                    a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16\n            ));\n    } :\n    function (a, b) {\n        if (b) {\n            while (b) {\n                b = b.parentNode;\n                if (b == a) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    };\nfunction getSomeDefs(el) {\n    var p = (el.node.ownerSVGElement && wrap(el.node.ownerSVGElement)) ||\n            (el.node.parentNode && wrap(el.node.parentNode)) ||\n            Snap.select(\"svg\") ||\n            Snap(0, 0),\n        pdefs = p.select(\"defs\"),\n        defs  = pdefs == null ? false : pdefs.node;\n    if (!defs) {\n        defs = make(\"defs\", p.node).node;\n    }\n    return defs;\n}\nfunction getSomeSVG(el) {\n    return el.node.ownerSVGElement && wrap(el.node.ownerSVGElement) || Snap.select(\"svg\");\n}\nSnap._.getSomeDefs = getSomeDefs;\nSnap._.getSomeSVG = getSomeSVG;\nfunction unit2px(el, name, value) {\n    var svg = getSomeSVG(el).node,\n        out = {},\n        mgr = svg.querySelector(\".svg---mgr\");\n    if (!mgr) {\n        mgr = $(\"rect\");\n        $(mgr, {x: -9e9, y: -9e9, width: 10, height: 10, \"class\": \"svg---mgr\", fill: \"none\"});\n        svg.appendChild(mgr);\n    }\n    function getW(val) {\n        if (val == null) {\n            return E;\n        }\n        if (val == +val) {\n            return val;\n        }\n        $(mgr, {width: val});\n        try {\n            return mgr.getBBox().width;\n        } catch (e) {\n            return 0;\n        }\n    }\n    function getH(val) {\n        if (val == null) {\n            return E;\n        }\n        if (val == +val) {\n            return val;\n        }\n        $(mgr, {height: val});\n        try {\n            return mgr.getBBox().height;\n        } catch (e) {\n            return 0;\n        }\n    }\n    function set(nam, f) {\n        if (name == null) {\n            out[nam] = f(el.attr(nam) || 0);\n        } else if (nam == name) {\n            out = f(value == null ? el.attr(nam) || 0 : value);\n        }\n    }\n    switch (el.type) {\n        case \"rect\":\n            set(\"rx\", getW);\n            set(\"ry\", getH);\n        case \"image\":\n            set(\"width\", getW);\n            set(\"height\", getH);\n        case \"text\":\n            set(\"x\", getW);\n            set(\"y\", getH);\n        break;\n        case \"circle\":\n            set(\"cx\", getW);\n            set(\"cy\", getH);\n            set(\"r\", getW);\n        break;\n        case \"ellipse\":\n            set(\"cx\", getW);\n            set(\"cy\", getH);\n            set(\"rx\", getW);\n            set(\"ry\", getH);\n        break;\n        case \"line\":\n            set(\"x1\", getW);\n            set(\"x2\", getW);\n            set(\"y1\", getH);\n            set(\"y2\", getH);\n        break;\n        case \"marker\":\n            set(\"refX\", getW);\n            set(\"markerWidth\", getW);\n            set(\"refY\", getH);\n            set(\"markerHeight\", getH);\n        break;\n        case \"radialGradient\":\n            set(\"fx\", getW);\n            set(\"fy\", getH);\n        break;\n        case \"tspan\":\n            set(\"dx\", getW);\n            set(\"dy\", getH);\n        break;\n        default:\n            set(name, getW);\n    }\n    svg.removeChild(mgr);\n    return out;\n}\n/*/\n * Snap.select\n [ method ]\n **\n * Wraps a DOM element specified by CSS selector as @Element\n - query (string) CSS selector of the element\n = (Element) the current element\n/*/\nSnap.select = function (query) {\n    query = Str(query).replace(/([^//]):/g, \"$1//:\");\n    return wrap(glob.doc.querySelector(query));\n};\n/*/\n * Snap.selectAll\n [ method ]\n **\n * Wraps DOM elements specified by CSS selector as set or array of @Element\n - query (string) CSS selector of the element\n = (Element) the current element\n/*/\nSnap.selectAll = function (query) {\n    var nodelist = glob.doc.querySelectorAll(query),\n        set = (Snap.set || Array)();\n    for (var i = 0; i < nodelist.length; i++) {\n        set.push(wrap(nodelist[i]));\n    }\n    return set;\n};\n\nfunction add2group(list) {\n    if (!is(list, \"array\")) {\n        list = Array.prototype.slice.call(arguments, 0);\n    }\n    var i = 0,\n        j = 0,\n        node = this.node;\n    while (this[i]) delete this[i++];\n    for (i = 0; i < list.length; i++) {\n        if (list[i].type == \"set\") {\n            list[i].forEach(function (el) {\n                node.appendChild(el.node);\n            });\n        } else {\n            node.appendChild(list[i].node);\n        }\n    }\n    var children = node.childNodes;\n    for (i = 0; i < children.length; i++) {\n        this[j++] = wrap(children[i]);\n    }\n    return this;\n}\n// Hub garbage collector every 10s\nsetInterval(function () {\n    for (var key in hub) if (hub[has](key)) {\n        var el = hub[key],\n            node = el.node;\n        if (el.type != \"svg\" && !node.ownerSVGElement || el.type == \"svg\" && (!node.parentNode || \"ownerSVGElement\" in node.parentNode && !node.ownerSVGElement)) {\n            delete hub[key];\n        }\n    }\n}, 1e4);\nfunction Element(el) {\n    if (el.snap in hub) {\n        return hub[el.snap];\n    }\n    var svg;\n    try {\n        svg = el.ownerSVGElement;\n    } catch(e) {}\n    /*/\n     * Element.node\n     [ property (object) ]\n     **\n     * Gives you a reference to the DOM object, so you can assign event handlers or just mess around.\n     > Usage\n     | // draw a circle at coordinate 10,10 with radius of 10\n     | var c = paper.circle(10, 10, 10);\n     | c.node.onclick = function () {\n     |     c.attr(\"fill\", \"red\");\n     | };\n    /*/\n    this.node = el;\n    if (svg) {\n        this.paper = new Paper(svg);\n    }\n    /*/\n     * Element.type\n     [ property (string) ]\n     **\n     * SVG tag name of the given element.\n    /*/\n    this.type = el.tagName;\n    var id = this.id = ID(this);\n    this.anims = {};\n    this._ = {\n        transform: []\n    };\n    el.snap = id;\n    hub[id] = this;\n    if (this.type == \"g\") {\n        this.add = add2group;\n    }\n    if (this.type in {g: 1, mask: 1, pattern: 1, symbol: 1}) {\n        for (var method in Paper.prototype) if (Paper.prototype[has](method)) {\n            this[method] = Paper.prototype[method];\n        }\n    }\n}\n   /*/\n     * Element.attr\n     [ method ]\n     **\n     * Gets or sets given attributes of the element.\n     **\n     - params (object) contains key-value pairs of attributes you want to set\n     * or\n     - param (string) name of the attribute\n     = (Element) the current element\n     * or\n     = (string) value of attribute\n     > Usage\n     | el.attr({\n     |     fill: \"#fc0\",\n     |     stroke: \"#000\",\n     |     strokeWidth: 2, // CamelCase...\n     |     \"fill-opacity\": 0.5, // or dash-separated names\n     |     width: \"*=2\" // prefixed values\n     | });\n     | console.log(el.attr(\"fill\")); // #fc0\n     * Prefixed values in format `\"+=10\"` supported. All four operations\n     * (`+`, `-`, `*` and `/`) could be used. Optionally you can use units for `+`\n     * and `-`: `\"+=2em\"`.\n    /*/\n    Element.prototype.attr = function (params, value) {\n        var el = this,\n            node = el.node;\n        if (!params) {\n            return el;\n        }\n        if (is(params, \"string\")) {\n            if (arguments.length > 1) {\n                var json = {};\n                json[params] = value;\n                params = json;\n            } else {\n                return eve(\"snap.util.getattr.\" + params, el).firstDefined();\n            }\n        }\n        for (var att in params) {\n            if (params[has](att)) {\n                eve(\"snap.util.attr.\" + att, el, params[att]);\n            }\n        }\n        return el;\n    };\n/*/\n * Snap.parse\n [ method ]\n **\n * Parses SVG fragment and converts it into a @Fragment\n **\n - svg (string) SVG string\n = (Fragment) the @Fragment\n/*/\nSnap.parse = function (svg) {\n    var f = glob.doc.createDocumentFragment(),\n        full = true,\n        div = glob.doc.createElement(\"div\");\n    svg = Str(svg);\n    if (!svg.match(/^/s*</s*svg(?:/s|>)/)) {\n        svg = \"<svg>\" + svg + \"</svg>\";\n        full = false;\n    }\n    div.innerHTML = svg;\n    svg = div.getElementsByTagName(\"svg\")[0];\n    if (svg) {\n        if (full) {\n            f = svg;\n        } else {\n            while (svg.firstChild) {\n                f.appendChild(svg.firstChild);\n            }\n            div.innerHTML = E;\n        }\n    }\n    return new Fragment(f);\n};\nfunction Fragment(frag) {\n    this.node = frag;\n}\n// SIERRA Snap.fragment() could especially use a code example\n/*/\n * Snap.fragment\n [ method ]\n **\n * Creates a DOM fragment from a given list of elements or strings\n **\n - varargs (…) SVG string\n = (Fragment) the @Fragment\n/*/\nSnap.fragment = function () {\n    var args = Array.prototype.slice.call(arguments, 0),\n        f = glob.doc.createDocumentFragment();\n    for (var i = 0, ii = args.length; i < ii; i++) {\n        var item = args[i];\n        if (item.node && item.node.nodeType) {\n            f.appendChild(item.node);\n        }\n        if (item.nodeType) {\n            f.appendChild(item);\n        }\n        if (typeof item == \"string\") {\n            f.appendChild(Snap.parse(item).node);\n        }\n    }\n    return new Fragment(f);\n};\n\nfunction make(name, parent) {\n    var res = $(name);\n    parent.appendChild(res);\n    var el = wrap(res);\n    return el;\n}\nfunction Paper(w, h) {\n    var res,\n        desc,\n        defs,\n        proto = Paper.prototype;\n    if (w && w.tagName == \"svg\") {\n        if (w.snap in hub) {\n            return hub[w.snap];\n        }\n        var doc = w.ownerDocument;\n        res = new Element(w);\n        desc = w.getElementsByTagName(\"desc\")[0];\n        defs = w.getElementsByTagName(\"defs\")[0];\n        if (!desc) {\n            desc = $(\"desc\");\n            desc.appendChild(doc.createTextNode(\"Created with Snap\"));\n            res.node.appendChild(desc);\n        }\n        if (!defs) {\n            defs = $(\"defs\");\n            res.node.appendChild(defs);\n        }\n        res.defs = defs;\n        for (var key in proto) if (proto[has](key)) {\n            res[key] = proto[key];\n        }\n        res.paper = res.root = res;\n    } else {\n        res = make(\"svg\", glob.doc.body);\n        $(res.node, {\n            height: h,\n            version: 1.1,\n            width: w,\n            xmlns: xmlns\n        });\n    }\n    return res;\n}\nfunction wrap(dom) {\n    if (!dom) {\n        return dom;\n    }\n    if (dom instanceof Element || dom instanceof Fragment) {\n        return dom;\n    }\n    if (dom.tagName && dom.tagName.toLowerCase() == \"svg\") {\n        return new Paper(dom);\n    }\n    if (dom.tagName && dom.tagName.toLowerCase() == \"object\" && dom.type == \"image/svg+xml\") {\n        return new Paper(dom.contentDocument.getElementsByTagName(\"svg\")[0]);\n    }\n    return new Element(dom);\n}\n\nSnap._.make = make;\nSnap._.wrap = wrap;\n/*/\n * Paper.el\n [ method ]\n **\n * Creates an element on paper with a given name and no attributes\n **\n - name (string) tag name\n - attr (object) attributes\n = (Element) the current element\n > Usage\n | var c = paper.circle(10, 10, 10); // is the same as...\n | var c = paper.el(\"circle\").attr({\n |     cx: 10,\n |     cy: 10,\n |     r: 10\n | });\n | // and the same as\n | var c = paper.el(\"circle\", {\n |     cx: 10,\n |     cy: 10,\n |     r: 10\n | });\n/*/\nPaper.prototype.el = function (name, attr) {\n    var el = make(name, this.node);\n    attr && el.attr(attr);\n    return el;\n};\n// default\neve.on(\"snap.util.getattr\", function () {\n    var att = eve.nt();\n    att = att.substring(att.lastIndexOf(\".\") + 1);\n    var css = att.replace(/[A-Z]/g, function (letter) {\n        return \"-\" + letter.toLowerCase();\n    });\n    if (cssAttr[has](css)) {\n        return this.node.ownerDocument.defaultView.getComputedStyle(this.node, null).getPropertyValue(css);\n    } else {\n        return $(this.node, att);\n    }\n});\nvar cssAttr = {\n    \"alignment-baseline\": 0,\n    \"baseline-shift\": 0,\n    \"clip\": 0,\n    \"clip-path\": 0,\n    \"clip-rule\": 0,\n    \"color\": 0,\n    \"color-interpolation\": 0,\n    \"color-interpolation-filters\": 0,\n    \"color-profile\": 0,\n    \"color-rendering\": 0,\n    \"cursor\": 0,\n    \"direction\": 0,\n    \"display\": 0,\n    \"dominant-baseline\": 0,\n    \"enable-background\": 0,\n    \"fill\": 0,\n    \"fill-opacity\": 0,\n    \"fill-rule\": 0,\n    \"filter\": 0,\n    \"flood-color\": 0,\n    \"flood-opacity\": 0,\n    \"font\": 0,\n    \"font-family\": 0,\n    \"font-size\": 0,\n    \"font-size-adjust\": 0,\n    \"font-stretch\": 0,\n    \"font-style\": 0,\n    \"font-variant\": 0,\n    \"font-weight\": 0,\n    \"glyph-orientation-horizontal\": 0,\n    \"glyph-orientation-vertical\": 0,\n    \"image-rendering\": 0,\n    \"kerning\": 0,\n    \"letter-spacing\": 0,\n    \"lighting-color\": 0,\n    \"marker\": 0,\n    \"marker-end\": 0,\n    \"marker-mid\": 0,\n    \"marker-start\": 0,\n    \"mask\": 0,\n    \"opacity\": 0,\n    \"overflow\": 0,\n    \"pointer-events\": 0,\n    \"shape-rendering\": 0,\n    \"stop-color\": 0,\n    \"stop-opacity\": 0,\n    \"stroke\": 0,\n    \"stroke-dasharray\": 0,\n    \"stroke-dashoffset\": 0,\n    \"stroke-linecap\": 0,\n    \"stroke-linejoin\": 0,\n    \"stroke-miterlimit\": 0,\n    \"stroke-opacity\": 0,\n    \"stroke-width\": 0,\n    \"text-anchor\": 0,\n    \"text-decoration\": 0,\n    \"text-rendering\": 0,\n    \"unicode-bidi\": 0,\n    \"visibility\": 0,\n    \"word-spacing\": 0,\n    \"writing-mode\": 0\n};\n\neve.on(\"snap.util.attr\", function (value) {\n    var att = eve.nt(),\n        attr = {};\n    att = att.substring(att.lastIndexOf(\".\") + 1);\n    attr[att] = value;\n    var style = att.replace(/-(/w)/gi, function (all, letter) {\n            return letter.toUpperCase();\n        }),\n        css = att.replace(/[A-Z]/g, function (letter) {\n            return \"-\" + letter.toLowerCase();\n        });\n    if (cssAttr[has](css)) {\n        this.node.style[style] = value == null ? E : value;\n    } else {\n        $(this.node, attr);\n    }\n});\n(function (proto) {}(Paper.prototype));\n\n// simple ajax\n/*/\n * Snap.ajax\n [ method ]\n **\n * Simple implementation of Ajax\n **\n - url (string) URL\n - postData (object|string) data for post request\n - callback (function) callback\n - scope (object) #optional scope of callback\n * or\n - url (string) URL\n - callback (function) callback\n - scope (object) #optional scope of callback\n = (XMLHttpRequest) the XMLHttpRequest object, just in case\n/*/\nSnap.ajax = function (url, postData, callback, scope){\n    var req = new XMLHttpRequest,\n        id = ID();\n    if (req) {\n        if (is(postData, \"function\")) {\n            scope = callback;\n            callback = postData;\n            postData = null;\n        } else if (is(postData, \"object\")) {\n            var pd = [];\n            for (var key in postData) if (postData.hasOwnProperty(key)) {\n                pd.push(encodeURIComponent(key) + \"=\" + encodeURIComponent(postData[key]));\n            }\n            postData = pd.join(\"&\");\n        }\n        req.open((postData ? \"POST\" : \"GET\"), url, true);\n        if (postData) {\n            req.setRequestHeader(\"X-Requested-With\", \"XMLHttpRequest\");\n            req.setRequestHeader(\"Content-type\", \"application/x-www-form-urlencoded\");\n        }\n        if (callback) {\n            eve.once(\"snap.ajax.\" + id + \".0\", callback);\n            eve.once(\"snap.ajax.\" + id + \".200\", callback);\n            eve.once(\"snap.ajax.\" + id + \".304\", callback);\n        }\n        req.onreadystatechange = function() {\n            if (req.readyState != 4) return;\n            eve(\"snap.ajax.\" + id + \".\" + req.status, scope, req);\n        };\n        if (req.readyState == 4) {\n            return req;\n        }\n        req.send(postData);\n        return req;\n    }\n};\n/*/\n * Snap.load\n [ method ]\n **\n * Loads external SVG file as a @Fragment (see @Snap.ajax for more advanced AJAX)\n **\n - url (string) URL\n - callback (function) callback\n - scope (object) #optional scope of callback\n/*/\nSnap.load = function (url, callback, scope) {\n    Snap.ajax(url, function (req) {\n        var f = Snap.parse(req.responseText);\n        scope ? callback.call(scope, f) : callback(f);\n    });\n};\nvar getOffset = function (elem) {\n    var box = elem.getBoundingClientRect(),\n        doc = elem.ownerDocument,\n        body = doc.body,\n        docElem = doc.documentElement,\n        clientTop = docElem.clientTop || body.clientTop || 0, clientLeft = docElem.clientLeft || body.clientLeft || 0,\n        top  = box.top  + (g.win.pageYOffset || docElem.scrollTop || body.scrollTop ) - clientTop,\n        left = box.left + (g.win.pageXOffset || docElem.scrollLeft || body.scrollLeft) - clientLeft;\n    return {\n        y: top,\n        x: left\n    };\n};\n/*/\n * Snap.getElementByPoint\n [ method ]\n **\n * Returns you topmost element under given point.\n **\n = (object) Snap element object\n - x (number) x coordinate from the top left corner of the window\n - y (number) y coordinate from the top left corner of the window\n > Usage\n | Snap.getElementByPoint(mouseX, mouseY).attr({stroke: \"#f00\"});\n/*/\nSnap.getElementByPoint = function (x, y) {\n    var paper = this,\n        svg = paper.canvas,\n        target = glob.doc.elementFromPoint(x, y);\n    if (glob.win.opera && target.tagName == \"svg\") {\n        var so = getOffset(target),\n            sr = target.createSVGRect();\n        sr.x = x - so.x;\n        sr.y = y - so.y;\n        sr.width = sr.height = 1;\n        var hits = target.getIntersectionList(sr, null);\n        if (hits.length) {\n            target = hits[hits.length - 1];\n        }\n    }\n    if (!target) {\n        return null;\n    }\n    return wrap(target);\n};\n/*/\n * Snap.plugin\n [ method ]\n **\n * Let you write plugins. You pass in a function with four arguments, like this:\n | Snap.plugin(function (Snap, Element, Paper, global, Fragment) {\n |     Snap.newmethod = function () {};\n |     Element.prototype.newmethod = function () {};\n |     Paper.prototype.newmethod = function () {};\n | });\n * Inside the function you have access to all main objects (and their\n * prototypes). This allow you to extend anything you want.\n **\n - f (function) your plugin body\n/*/\nSnap.plugin = function (f) {\n    f(Snap, Element, Paper, glob, Fragment);\n};\nglob.win.Snap = Snap;\nreturn Snap;\n}(window || this));\n// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nSnap.plugin(function (Snap, Element, Paper, glob, Fragment) {\n    var elproto = Element.prototype,\n        is = Snap.is,\n        Str = String,\n        unit2px = Snap._unit2px,\n        $ = Snap._.$,\n        make = Snap._.make,\n        getSomeDefs = Snap._.getSomeDefs,\n        has = \"hasOwnProperty\",\n        wrap = Snap._.wrap;\n    /*/\n     * Element.getBBox\n     [ method ]\n     **\n     * Returns the bounding box descriptor for the given element\n     **\n     = (object) bounding box descriptor:\n     o {\n     o     cx: (number) x of the center,\n     o     cy: (number) x of the center,\n     o     h: (number) height,\n     o     height: (number) height,\n     o     path: (string) path command for the box,\n     o     r0: (number) radius of a circle that fully encloses the box,\n     o     r1: (number) radius of the smallest circle that can be enclosed,\n     o     r2: (number) radius of the largest circle that can be enclosed,\n     o     vb: (string) box as a viewbox command,\n     o     w: (number) width,\n     o     width: (number) width,\n     o     x2: (number) x of the right side,\n     o     x: (number) x of the left side,\n     o     y2: (number) y of the bottom edge,\n     o     y: (number) y of the top edge\n     o }\n    /*/\n    elproto.getBBox = function (isWithoutTransform) {\n        if (!Snap.Matrix || !Snap.path) {\n            return this.node.getBBox();\n        }\n        var el = this,\n            m = new Snap.Matrix;\n        if (el.removed) {\n            return Snap._.box();\n        }\n        while (el.type == \"use\") {\n            if (!isWithoutTransform) {\n                m = m.add(el.transform().localMatrix.translate(el.attr(\"x\") || 0, el.attr(\"y\") || 0));\n            }\n            if (el.original) {\n                el = el.original;\n            } else {\n                var href = el.attr(\"xlink:href\");\n                el = el.original = el.node.ownerDocument.getElementById(href.substring(href.indexOf(\"#\") + 1));\n            }\n        }\n        var _ = el._,\n            pathfinder = Snap.path.get[el.type] || Snap.path.get.deflt;\n        try {\n            if (isWithoutTransform) {\n                _.bboxwt = pathfinder ? Snap.path.getBBox(el.realPath = pathfinder(el)) : Snap._.box(el.node.getBBox());\n                return Snap._.box(_.bboxwt);\n            } else {\n                el.realPath = pathfinder(el);\n                el.matrix = el.transform().localMatrix;\n                _.bbox = Snap.path.getBBox(Snap.path.map(el.realPath, m.add(el.matrix)));\n                return Snap._.box(_.bbox);\n            }\n        } catch (e) {\n            // Firefox doesn’t give you bbox of hidden element\n            return Snap._.box();\n        }\n    };\n    var propString = function () {\n        return this.string;\n    };\n    function extractTransform(el, tstr) {\n        if (tstr == null) {\n            var doReturn = true;\n            if (el.type == \"linearGradient\" || el.type == \"radialGradient\") {\n                tstr = el.node.getAttribute(\"gradientTransform\");\n            } else if (el.type == \"pattern\") {\n                tstr = el.node.getAttribute(\"patternTransform\");\n            } else {\n                tstr = el.node.getAttribute(\"transform\");\n            }\n            if (!tstr) {\n                return new Snap.Matrix;\n            }\n            tstr = Snap._.svgTransform2string(tstr);\n        } else {\n            if (!Snap._.rgTransform.test(tstr)) {\n                tstr = Snap._.svgTransform2string(tstr);\n            } else {\n                tstr = Str(tstr).replace(//.{3}|/u2026/g, el._.transform || E);\n            }\n            if (is(tstr, \"array\")) {\n                tstr = Snap.path ? Snap.path.toString.call(tstr) : Str(tstr);\n            }\n            el._.transform = tstr;\n        }\n        var m = Snap._.transform2matrix(tstr, el.getBBox(1));\n        if (doReturn) {\n            return m;\n        } else {\n            el.matrix = m;\n        }\n    }\n    /*/\n     * Element.transform\n     [ method ]\n     **\n     * Gets or sets transformation of the element\n     **\n     - tstr (string) transform string in Snap or SVG format\n     = (Element) the current element\n     * or\n     = (object) transformation descriptor:\n     o {\n     o     string (string) transform string,\n     o     globalMatrix (Matrix) matrix of all transformations applied to element or its parents,\n     o     localMatrix (Matrix) matrix of transformations applied only to the element,\n     o     diffMatrix (Matrix) matrix of difference between global and local transformations,\n     o     global (string) global transformation as string,\n     o     local (string) local transformation as string,\n     o     toString (function) returns `string` property\n     o }\n    /*/\n    elproto.transform = function (tstr) {\n        var _ = this._;\n        if (tstr == null) {\n            var papa = this,\n                global = new Snap.Matrix(this.node.getCTM()),\n                local = extractTransform(this),\n                ms = [local],\n                m = new Snap.Matrix,\n                i,\n                localString = local.toTransformString(),\n                string = Str(local) == Str(this.matrix) ?\n                            Str(_.transform) : localString;\n            while (papa.type != \"svg\" && (papa = papa.parent())) {\n                ms.push(extractTransform(papa));\n            }\n            i = ms.length;\n            while (i--) {\n                m.add(ms[i]);\n            }\n            return {\n                string: string,\n                globalMatrix: global,\n                totalMatrix: m,\n                localMatrix: local,\n                diffMatrix: global.clone().add(local.invert()),\n                global: global.toTransformString(),\n                total: m.toTransformString(),\n                local: localString,\n                toString: propString\n            };\n        }\n        if (tstr instanceof Snap.Matrix) {\n            this.matrix = tstr;\n            this._.transform = tstr.toTransformString();\n        } else {\n            extractTransform(this, tstr);\n        }\n\n        if (this.node) {\n            if (this.type == \"linearGradient\" || this.type == \"radialGradient\") {\n                $(this.node, {gradientTransform: this.matrix});\n            } else if (this.type == \"pattern\") {\n                $(this.node, {patternTransform: this.matrix});\n            } else {\n                $(this.node, {transform: this.matrix});\n            }\n        }\n\n        return this;\n    };\n    /*/\n     * Element.parent\n     [ method ]\n     **\n     * Returns the element's parent\n     **\n     = (Element) the parent element\n    /*/\n    elproto.parent = function () {\n        return wrap(this.node.parentNode);\n    };\n    /*/\n     * Element.append\n     [ method ]\n     **\n     * Appends the given element to current one\n     **\n     - el (Element|Set) element to append\n     = (Element) the parent element\n    /*/\n    /*/\n     * Element.add\n     [ method ]\n     **\n     * See @Element.append\n    /*/\n    elproto.append = elproto.add = function (el) {\n        if (el) {\n            if (el.type == \"set\") {\n                var it = this;\n                el.forEach(function (el) {\n                    it.add(el);\n                });\n                return this;\n            }\n            el = wrap(el);\n            this.node.appendChild(el.node);\n            el.paper = this.paper;\n        }\n        return this;\n    };\n    /*/\n     * Element.appendTo\n     [ method ]\n     **\n     * Appends the current element to the given one\n     **\n     - el (Element) parent element to append to\n     = (Element) the child element\n    /*/\n    elproto.appendTo = function (el) {\n        if (el) {\n            el = wrap(el);\n            el.append(this);\n        }\n        return this;\n    };\n    /*/\n     * Element.prepend\n     [ method ]\n     **\n     * Prepends the given element to the current one\n     **\n     - el (Element) element to prepend\n     = (Element) the parent element\n    /*/\n    elproto.prepend = function (el) {\n        if (el) {\n            if (el.type == \"set\") {\n                var it = this,\n                    first;\n                el.forEach(function (el) {\n                    if (first) {\n                        first.after(el);\n                    } else {\n                        it.prepend(el);\n                    }\n                    first = el;\n                });\n                return this;\n            }\n            el = wrap(el);\n            var parent = el.parent();\n            this.node.insertBefore(el.node, this.node.firstChild);\n            this.add && this.add();\n            el.paper = this.paper;\n            this.parent() && this.parent().add();\n            parent && parent.add();\n        }\n        return this;\n    };\n    /*/\n     * Element.prependTo\n     [ method ]\n     **\n     * Prepends the current element to the given one\n     **\n     - el (Element) parent element to prepend to\n     = (Element) the child element\n    /*/\n    elproto.prependTo = function (el) {\n        el = wrap(el);\n        el.prepend(this);\n        return this;\n    };\n    /*/\n     * Element.before\n     [ method ]\n     **\n     * Inserts given element before the current one\n     **\n     - el (Element) element to insert\n     = (Element) the parent element\n    /*/\n    elproto.before = function (el) {\n        if (el.type == \"set\") {\n            var it = this;\n            el.forEach(function (el) {\n                var parent = el.parent();\n                it.node.parentNode.insertBefore(el.node, it.node);\n                parent && parent.add();\n            });\n            this.parent().add();\n            return this;\n        }\n        el = wrap(el);\n        var parent = el.parent();\n        this.node.parentNode.insertBefore(el.node, this.node);\n        this.parent() && this.parent().add();\n        parent && parent.add();\n        el.paper = this.paper;\n        return this;\n    };\n    /*/\n     * Element.after\n     [ method ]\n     **\n     * Inserts given element after the current one\n     **\n     - el (Element) element to insert\n     = (Element) the parent element\n    /*/\n    elproto.after = function (el) {\n        el = wrap(el);\n        var parent = el.parent();\n        if (this.node.nextSibling) {\n            this.node.parentNode.insertBefore(el.node, this.node.nextSibling);\n        } else {\n            this.node.parentNode.appendChild(el.node);\n        }\n        this.parent() && this.parent().add();\n        parent && parent.add();\n        el.paper = this.paper;\n        return this;\n    };\n    /*/\n     * Element.insertBefore\n     [ method ]\n     **\n     * Inserts the element after the given one\n     **\n     - el (Element) element next to whom insert to\n     = (Element) the parent element\n    /*/\n    elproto.insertBefore = function (el) {\n        el = wrap(el);\n        var parent = this.parent();\n        el.node.parentNode.insertBefore(this.node, el.node);\n        this.paper = el.paper;\n        parent && parent.add();\n        el.parent() && el.parent().add();\n        return this;\n    };\n    /*/\n     * Element.insertAfter\n     [ method ]\n     **\n     * Inserts the element after the given one\n     **\n     - el (Element) element next to whom insert to\n     = (Element) the parent element\n    /*/\n    elproto.insertAfter = function (el) {\n        el = wrap(el);\n        var parent = this.parent();\n        el.node.parentNode.insertBefore(this.node, el.node.nextSibling);\n        this.paper = el.paper;\n        parent && parent.add();\n        el.parent() && el.parent().add();\n        return this;\n    };\n    /*/\n     * Element.remove\n     [ method ]\n     **\n     * Removes element from the DOM\n     = (Element) the detached element\n    /*/\n    elproto.remove = function () {\n        var parent = this.parent();\n        this.node.parentNode && this.node.parentNode.removeChild(this.node);\n        delete this.paper;\n        this.removed = true;\n        parent && parent.add();\n        return this;\n    };\n    /*/\n     * Element.select\n     [ method ]\n     **\n     * Gathers the nested @Element matching the given set of CSS selectors\n     **\n     - query (string) CSS selector\n     = (Element) result of query selection\n    /*/\n    elproto.select = function (query) {\n        query = Str(query).replace(/([^//]):/g, \"$1//:\");\n        return wrap(this.node.querySelector(query));\n    };\n    /*/\n     * Element.selectAll\n     [ method ]\n     **\n     * Gathers nested @Element objects matching the given set of CSS selectors\n     **\n     - query (string) CSS selector\n     = (Set|array) result of query selection\n    /*/\n    elproto.selectAll = function (query) {\n        var nodelist = this.node.querySelectorAll(query),\n            set = (Snap.set || Array)();\n        for (var i = 0; i < nodelist.length; i++) {\n            set.push(wrap(nodelist[i]));\n        }\n        return set;\n    };\n    /*/\n     * Element.asPX\n     [ method ]\n     **\n     * Returns given attribute of the element as a `px` value (not %, em, etc.)\n     **\n     - attr (string) attribute name\n     - value (string) #optional attribute value\n     = (Element) result of query selection\n    /*/\n    elproto.asPX = function (attr, value) {\n        if (value == null) {\n            value = this.attr(attr);\n        }\n        return +unit2px(this, attr, value);\n    };\n    // SIERRA Element.use(): I suggest adding a note about how to access the original element the returned <use> instantiates. It's a part of SVG with which ordinary web developers may be least familiar.\n    /*/\n     * Element.use\n     [ method ]\n     **\n     * Creates a `<use>` element linked to the current element\n     **\n     = (Element) the `<use>` element\n    /*/\n    elproto.use = function () {\n        var use,\n            id = this.node.id;\n        if (!id) {\n            id = this.id;\n            $(this.node, {\n                id: id\n            });\n        }\n        if (this.type == \"linearGradient\" || this.type == \"radialGradient\" ||\n            this.type == \"pattern\") {\n            use = make(this.type, this.node.parentNode);\n        } else {\n            use = make(\"use\", this.node.parentNode);\n        }\n        $(use.node, {\n            \"xlink:href\": \"#\" + id\n        });\n        use.original = this;\n        return use;\n    };\n    function fixids(el) {\n        var els = el.selectAll(\"*\"),\n            it,\n            url = /^/s*url/((\"|'|)(.*)/1/)/s*$/,\n            ids = [],\n            uses = {};\n        function urltest(it, name) {\n            var val = $(it.node, name);\n            val = val && val.match(url);\n            val = val && val[2];\n            if (val && val.charAt() == \"#\") {\n                val = val.substring(1);\n            } else {\n                return;\n            }\n            if (val) {\n                uses[val] = (uses[val] || []).concat(function (id) {\n                    var attr = {};\n                    attr[name] = URL(id);\n                    $(it.node, attr);\n                });\n            }\n        }\n        function linktest(it) {\n            var val = $(it.node, \"xlink:href\");\n            if (val && val.charAt() == \"#\") {\n                val = val.substring(1);\n            } else {\n                return;\n            }\n            if (val) {\n                uses[val] = (uses[val] || []).concat(function (id) {\n                    it.attr(\"xlink:href\", \"#\" + id);\n                });\n            }\n        }\n        for (var i = 0, ii = els.length; i < ii; i++) {\n            it = els[i];\n            urltest(it, \"fill\");\n            urltest(it, \"stroke\");\n            urltest(it, \"filter\");\n            urltest(it, \"mask\");\n            urltest(it, \"clip-path\");\n            linktest(it);\n            var oldid = $(it.node, \"id\");\n            if (oldid) {\n                $(it.node, {id: it.id});\n                ids.push({\n                    old: oldid,\n                    id: it.id\n                });\n            }\n        }\n        for (i = 0, ii = ids.length; i < ii; i++) {\n            var fs = uses[ids[i].old];\n            if (fs) {\n                for (var j = 0, jj = fs.length; j < jj; j++) {\n                    fs[j](ids[i].id);\n                }\n            }\n        }\n    }\n    /*/\n     * Element.clone\n     [ method ]\n     **\n     * Creates a clone of the element and inserts it after the element\n     **\n     = (Element) the clone\n    /*/\n    elproto.clone = function () {\n        var clone = wrap(this.node.cloneNode(true));\n        if ($(clone.node, \"id\")) {\n            $(clone.node, {id: clone.id});\n        }\n        fixids(clone);\n        clone.insertAfter(this);\n        return clone;\n    };\n    /*/\n     * Element.toDefs\n     [ method ]\n     **\n     * Moves element to the shared `<defs>` area\n     **\n     = (Element) the element\n    /*/\n    elproto.toDefs = function () {\n        var defs = getSomeDefs(this);\n        defs.appendChild(this.node);\n        return this;\n    };\n    /*/\n     * Element.toPattern\n     [ method ]\n     **\n     * Creates a `<pattern>` element from the current element\n     **\n     * To create a pattern you have to specify the pattern rect:\n     - x (string|number)\n     - y (string|number)\n     - width (string|number)\n     - height (string|number)\n     = (Element) the `<pattern>` element\n     * You can use pattern later on as an argument for `fill` attribute:\n     | var p = paper.path(\"M10-5-10,15M15,0,0,15M0-5-20,15\").attr({\n     |         fill: \"none\",\n     |         stroke: \"#bada55\",\n     |         strokeWidth: 5\n     |     }).pattern(0, 0, 10, 10),\n     |     c = paper.circle(200, 200, 100);\n     | c.attr({\n     |     fill: p\n     | });\n    /*/\n    elproto.pattern = elproto.toPattern = function (x, y, width, height) {\n        var p = make(\"pattern\", getSomeDefs(this));\n        if (x == null) {\n            x = this.getBBox();\n        }\n        if (is(x, \"object\") && \"x\" in x) {\n            y = x.y;\n            width = x.width;\n            height = x.height;\n            x = x.x;\n        }\n        $(p.node, {\n            x: x,\n            y: y,\n            width: width,\n            height: height,\n            patternUnits: \"userSpaceOnUse\",\n            id: p.id,\n            viewBox: [x, y, width, height].join(\" \")\n        });\n        p.node.appendChild(this.node);\n        return p;\n    };\n// SIERRA Element.marker(): clarify what a reference point is. E.g., helps you offset the object from its edge such as when centering it over a path.\n// SIERRA Element.marker(): I suggest the method should accept default reference point values.  Perhaps centered with (refX = width/2) and (refY = height/2)? Also, couldn't it assume the element's current _width_ and _height_? And please specify what _x_ and _y_ mean: offsets? If so, from where?  Couldn't they also be assigned default values?\n    /*/\n     * Element.marker\n     [ method ]\n     **\n     * Creates a `<marker>` element from the current element\n     **\n     * To create a marker you have to specify the bounding rect and reference point:\n     - x (number)\n     - y (number)\n     - width (number)\n     - height (number)\n     - refX (number)\n     - refY (number)\n     = (Element) the `<marker>` element\n     * You can specify the marker later as an argument for `marker-start`, `marker-end`, `marker-mid`, and `marker` attributes. The `marker` attribute places the marker at every point along the path, and `marker-mid` places them at every point except the start and end.\n    /*/\n    // TODO add usage for markers\n    elproto.marker = function (x, y, width, height, refX, refY) {\n        var p = make(\"marker\", getSomeDefs(this));\n        if (x == null) {\n            x = this.getBBox();\n        }\n        if (is(x, \"object\") && \"x\" in x) {\n            y = x.y;\n            width = x.width;\n            height = x.height;\n            refX = x.refX || x.cx;\n            refY = x.refY || x.cy;\n            x = x.x;\n        }\n        $(p.node, {\n            viewBox: [x, y, width, height].join(\" \"),\n            markerWidth: width,\n            markerHeight: height,\n            orient: \"auto\",\n            refX: refX || 0,\n            refY: refY || 0,\n            id: p.id\n        });\n        p.node.appendChild(this.node);\n        return p;\n    };\n    // animation\n    function slice(from, to, f) {\n        return function (arr) {\n            var res = arr.slice(from, to);\n            if (res.length == 1) {\n                res = res[0];\n            }\n            return f ? f(res) : res;\n        };\n    }\n    var Animation = function (attr, ms, easing, callback) {\n        if (typeof easing == \"function\" && !easing.length) {\n            callback = easing;\n            easing = mina.linear;\n        }\n        this.attr = attr;\n        this.dur = ms;\n        easing && (this.easing = easing);\n        callback && (this.callback = callback);\n    };\n    Snap._.Animation = Animation;\n    /*/\n     * Snap.animation\n     [ method ]\n     **\n     * Creates an animation object\n     **\n     - attr (object) attributes of final destination\n     - duration (number) duration of the animation, in milliseconds\n     - easing (function) #optional one of easing functions of @mina or custom one\n     - callback (function) #optional callback function that fires when animation ends\n     = (object) animation object\n    /*/\n    Snap.animation = function (attr, ms, easing, callback) {\n        return new Animation(attr, ms, easing, callback);\n    };\n    /*/\n     * Element.inAnim\n     [ method ]\n     **\n     * Returns a set of animations that may be able to manipulate the current element\n     **\n     = (object) in format:\n     o {\n     o     anim (object) animation object,\n     o     mina (object) @mina object,\n     o     curStatus (number) 0..1 — status of the animation: 0 — just started, 1 — just finished,\n     o     status (function) gets or sets the status of the animation,\n     o     stop (function) stops the animation\n     o }\n    /*/\n    elproto.inAnim = function () {\n        var el = this,\n            res = [];\n        for (var id in el.anims) if (el.anims[has](id)) {\n            (function (a) {\n                res.push({\n                    anim: new Animation(a._attrs, a.dur, a.easing, a._callback),\n                    mina: a,\n                    curStatus: a.status(),\n                    status: function (val) {\n                        return a.status(val);\n                    },\n                    stop: function () {\n                        a.stop();\n                    }\n                });\n            }(el.anims[id]));\n        }\n        return res;\n    };\n    /*/\n     * Snap.animate\n     [ method ]\n     **\n     * Runs generic animation of one number into another with a caring function\n     **\n     - from (number|array) number or array of numbers\n     - to (number|array) number or array of numbers\n     - setter (function) caring function that accepts one number argument\n     - duration (number) duration, in milliseconds\n     - easing (function) #optional easing function from @mina or custom\n     - callback (function) #optional callback function to execute when animation ends\n     = (object) animation object in @mina format\n     o {\n     o     id (string) animation id, consider it read-only,\n     o     duration (function) gets or sets the duration of the animation,\n     o     easing (function) easing,\n     o     speed (function) gets or sets the speed of the animation,\n     o     status (function) gets or sets the status of the animation,\n     o     stop (function) stops the animation\n     o }\n     | var rect = Snap().rect(0, 0, 10, 10);\n     | Snap.animate(0, 10, function (val) {\n     |     rect.attr({\n     |         x: val\n     |     });\n     | }, 1000);\n     | // in given context is equivalent to\n     | rect.animate({x: 10}, 1000);\n    /*/\n    Snap.animate = function (from, to, setter, ms, easing, callback) {\n        if (typeof easing == \"function\" && !easing.length) {\n            callback = easing;\n            easing = mina.linear;\n        }\n        var now = mina.time(),\n            anim = mina(from, to, now, now + ms, mina.time, setter, easing);\n        callback && eve.once(\"mina.finish.\" + anim.id, callback);\n        return anim;\n    };\n    /*/\n     * Element.stop\n     [ method ]\n     **\n     * Stops all the animations for the current element\n     **\n     = (Element) the current element\n    /*/\n    elproto.stop = function () {\n        var anims = this.inAnim();\n        for (var i = 0, ii = anims.length; i < ii; i++) {\n            anims[i].stop();\n        }\n        return this;\n    };\n    /*/\n     * Element.animate\n     [ method ]\n     **\n     * Animates the given attributes of the element\n     **\n     - attrs (object) key-value pairs of destination attributes\n     - duration (number) duration of the animation in milliseconds\n     - easing (function) #optional easing function from @mina or custom\n     - callback (function) #optional callback function that executes when the animation ends\n     = (Element) the current element\n    /*/\n    elproto.animate = function (attrs, ms, easing, callback) {\n        if (typeof easing == \"function\" && !easing.length) {\n            callback = easing;\n            easing = mina.linear;\n        }\n        if (attrs instanceof Animation) {\n            callback = attrs.callback;\n            easing = attrs.easing;\n            ms = easing.dur;\n            attrs = attrs.attr;\n        }\n        var fkeys = [], tkeys = [], keys = {}, from, to, f, eq,\n            el = this;\n        for (var key in attrs) if (attrs[has](key)) {\n            if (el.equal) {\n                eq = el.equal(key, Str(attrs[key]));\n                from = eq.from;\n                to = eq.to;\n                f = eq.f;\n            } else {\n                from = +el.attr(key);\n                to = +attrs[key];\n            }\n            var len = is(from, \"array\") ? from.length : 1;\n            keys[key] = slice(fkeys.length, fkeys.length + len, f);\n            fkeys = fkeys.concat(from);\n            tkeys = tkeys.concat(to);\n        }\n        var now = mina.time(),\n            anim = mina(fkeys, tkeys, now, now + ms, mina.time, function (val) {\n                var attr = {};\n                for (var key in keys) if (keys[has](key)) {\n                    attr[key] = keys[key](val);\n                }\n                el.attr(attr);\n            }, easing);\n        el.anims[anim.id] = anim;\n        anim._attrs = attrs;\n        anim._callback = callback;\n        eve(\"snap.animcreated.\" + el.id, anim);\n        eve.once(\"mina.finish.\" + anim.id, function () {\n            delete el.anims[anim.id];\n            callback && callback.call(el);\n        });\n        eve.once(\"mina.stop.\" + anim.id, function () {\n            delete el.anims[anim.id];\n        });\n        return el;\n    };\n    var eldata = {};\n    /*/\n     * Element.data\n     [ method ]\n     **\n     * Adds or retrieves given value associated with given key. (Don’t confuse\n     * with `data-` attributes)\n     *\n     * See also @Element.removeData\n     - key (string) key to store data\n     - value (any) #optional value to store\n     = (object) @Element\n     * or, if value is not specified:\n     = (any) value\n     > Usage\n     | for (var i = 0, i < 5, i++) {\n     |     paper.circle(10 + 15 * i, 10, 10)\n     |          .attr({fill: \"#000\"})\n     |          .data(\"i\", i)\n     |          .click(function () {\n     |             alert(this.data(\"i\"));\n     |          });\n     | }\n    /*/\n    elproto.data = function (key, value) {\n        var data = eldata[this.id] = eldata[this.id] || {};\n        if (arguments.length == 0){\n            eve(\"snap.data.get.\" + this.id, this, data, null);\n            return data;\n        }\n        if (arguments.length == 1) {\n            if (Snap.is(key, \"object\")) {\n                for (var i in key) if (key[has](i)) {\n                    this.data(i, key[i]);\n                }\n                return this;\n            }\n            eve(\"snap.data.get.\" + this.id, this, data[key], key);\n            return data[key];\n        }\n        data[key] = value;\n        eve(\"snap.data.set.\" + this.id, this, value, key);\n        return this;\n    };\n    /*/\n     * Element.removeData\n     [ method ]\n     **\n     * Removes value associated with an element by given key.\n     * If key is not provided, removes all the data of the element.\n     - key (string) #optional key\n     = (object) @Element\n    /*/\n    elproto.removeData = function (key) {\n        if (key == null) {\n            eldata[this.id] = {};\n        } else {\n            eldata[this.id] && delete eldata[this.id][key];\n        }\n        return this;\n    };\n    /*/\n     * Element.outerSVG\n     [ method ]\n     **\n     * Returns SVG code for the element, equivalent to HTML's `outerHTML`.\n     *\n     * See also @Element.innerSVG\n     = (string) SVG code for the element\n    /*/\n    /*/\n     * Element.toString\n     [ method ]\n     **\n     * See @Element.outerSVG\n    /*/\n    elproto.outerSVG = elproto.toString = toString(1);\n    /*/\n     * Element.innerSVG\n     [ method ]\n     **\n     * Returns SVG code for the element's contents, equivalent to HTML's `innerHTML`\n     = (string) SVG code for the element\n    /*/\n    elproto.innerSVG = toString();\n    function toString(type) {\n        return function () {\n            var res = type ? \"<\" + this.type : \"\",\n                attr = this.node.attributes,\n                chld = this.node.childNodes;\n            if (type) {\n                for (var i = 0, ii = attr.length; i < ii; i++) {\n                    res += \" \" + attr[i].name + '=\"' +\n                            attr[i].value.replace(/\"/g, '//\"') + '\"';\n                }\n            }\n            if (chld.length) {\n                type && (res += \">\");\n                for (i = 0, ii = chld.length; i < ii; i++) {\n                    if (chld[i].nodeType == 3) {\n                        res += chld[i].nodeValue;\n                    } else if (chld[i].nodeType == 1) {\n                        res += wrap(chld[i]).toString();\n                    }\n                }\n                type && (res += \"</\" + this.type + \">\");\n            } else {\n                type && (res += \"/>\");\n            }\n            return res;\n        };\n    }\n    elproto.toDataURL = function () {\n        if (window && window.btoa) {\n            var bb = this.getBBox(),\n                svg = Snap.format('<svg version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"{width}\" height=\"{height}\" viewBox=\"{x} {y} {width} {height}\">{contents}</svg>', {\n                x: +bb.x.toFixed(3),\n                y: +bb.y.toFixed(3),\n                width: +bb.width.toFixed(3),\n                height: +bb.height.toFixed(3),\n                contents: this.outerSVG()\n            });\n            return \"data:image/svg+xml;base64,\" + btoa(unescape(encodeURIComponent(svg)));\n        }\n    };\n    /*/\n     * Fragment.select\n     [ method ]\n     **\n     * See @Element.select\n    /*/\n    Fragment.prototype.select = elproto.select;\n    /*/\n     * Fragment.selectAll\n     [ method ]\n     **\n     * See @Element.selectAll\n    /*/\n    Fragment.prototype.selectAll = elproto.selectAll;\n});\n\n// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n// \n// http://www.apache.org/licenses/LICENSE-2.0\n// \n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nSnap.plugin(function (Snap, Element, Paper, glob, Fragment) {\n    var objectToString = Object.prototype.toString,\n        Str = String,\n        math = Math,\n        E = \"\";\n    function Matrix(a, b, c, d, e, f) {\n        if (b == null && objectToString.call(a) == \"[object SVGMatrix]\") {\n            this.a = a.a;\n            this.b = a.b;\n            this.c = a.c;\n            this.d = a.d;\n            this.e = a.e;\n            this.f = a.f;\n            return;\n        }\n        if (a != null) {\n            this.a = +a;\n            this.b = +b;\n            this.c = +c;\n            this.d = +d;\n            this.e = +e;\n            this.f = +f;\n        } else {\n            this.a = 1;\n            this.b = 0;\n            this.c = 0;\n            this.d = 1;\n            this.e = 0;\n            this.f = 0;\n        }\n    }\n    (function (matrixproto) {\n        /*/\n         * Matrix.add\n         [ method ]\n         **\n         * Adds the given matrix to existing one\n         - a (number)\n         - b (number)\n         - c (number)\n         - d (number)\n         - e (number)\n         - f (number)\n         * or\n         - matrix (object) @Matrix\n        /*/\n        matrixproto.add = function (a, b, c, d, e, f) {\n            var out = [[], [], []],\n                m = [[this.a, this.c, this.e], [this.b, this.d, this.f], [0, 0, 1]],\n                matrix = [[a, c, e], [b, d, f], [0, 0, 1]],\n                x, y, z, res;\n\n            if (a && a instanceof Matrix) {\n                matrix = [[a.a, a.c, a.e], [a.b, a.d, a.f], [0, 0, 1]];\n            }\n\n            for (x = 0; x < 3; x++) {\n                for (y = 0; y < 3; y++) {\n                    res = 0;\n                    for (z = 0; z < 3; z++) {\n                        res += m[x][z] * matrix[z][y];\n                    }\n                    out[x][y] = res;\n                }\n            }\n            this.a = out[0][0];\n            this.b = out[1][0];\n            this.c = out[0][1];\n            this.d = out[1][1];\n            this.e = out[0][2];\n            this.f = out[1][2];\n            return this;\n        };\n        /*/\n         * Matrix.invert\n         [ method ]\n         **\n         * Returns an inverted version of the matrix\n         = (object) @Matrix\n        /*/\n        matrixproto.invert = function () {\n            var me = this,\n                x = me.a * me.d - me.b * me.c;\n            return new Matrix(me.d / x, -me.b / x, -me.c / x, me.a / x, (me.c * me.f - me.d * me.e) / x, (me.b * me.e - me.a * me.f) / x);\n        };\n        /*/\n         * Matrix.clone\n         [ method ]\n         **\n         * Returns a copy of the matrix\n         = (object) @Matrix\n        /*/\n        matrixproto.clone = function () {\n            return new Matrix(this.a, this.b, this.c, this.d, this.e, this.f);\n        };\n        /*/\n         * Matrix.translate\n         [ method ]\n         **\n         * Translate the matrix\n         - x (number) horizontal offset distance\n         - y (number) vertical offset distance\n        /*/\n        matrixproto.translate = function (x, y) {\n            return this.add(1, 0, 0, 1, x, y);\n        };\n        /*/\n         * Matrix.scale\n         [ method ]\n         **\n         * Scales the matrix\n         - x (number) amount to be scaled, with `1` resulting in no change\n         - y (number) #optional amount to scale along the vertical axis. (Otherwise `x` applies to both axes.)\n         - cx (number) #optional horizontal origin point from which to scale\n         - cy (number) #optional vertical origin point from which to scale\n         * Default cx, cy is the middle point of the element.\n        /*/\n        matrixproto.scale = function (x, y, cx, cy) {\n            y == null && (y = x);\n            (cx || cy) && this.add(1, 0, 0, 1, cx, cy);\n            this.add(x, 0, 0, y, 0, 0);\n            (cx || cy) && this.add(1, 0, 0, 1, -cx, -cy);\n            return this;\n        };\n        /*/\n         * Matrix.rotate\n         [ method ]\n         **\n         * Rotates the matrix\n         - a (number) angle of rotation, in degrees\n         - x (number) horizontal origin point from which to rotate\n         - y (number) vertical origin point from which to rotate\n        /*/\n        matrixproto.rotate = function (a, x, y) {\n            a = Snap.rad(a);\n            x = x || 0;\n            y = y || 0;\n            var cos = +math.cos(a).toFixed(9),\n                sin = +math.sin(a).toFixed(9);\n            this.add(cos, sin, -sin, cos, x, y);\n            return this.add(1, 0, 0, 1, -x, -y);\n        };\n        /*/\n         * Matrix.x\n         [ method ]\n         **\n         * Returns x coordinate for given point after transformation described by the matrix. See also @Matrix.y\n         - x (number)\n         - y (number)\n         = (number) x\n        /*/\n        matrixproto.x = function (x, y) {\n            return x * this.a + y * this.c + this.e;\n        };\n        /*/\n         * Matrix.y\n         [ method ]\n         **\n         * Returns y coordinate for given point after transformation described by the matrix. See also @Matrix.x\n         - x (number)\n         - y (number)\n         = (number) y\n        /*/\n        matrixproto.y = function (x, y) {\n            return x * this.b + y * this.d + this.f;\n        };\n        matrixproto.get = function (i) {\n            return +this[Str.fromCharCode(97 + i)].toFixed(4);\n        };\n        matrixproto.toString = function () {\n            return \"matrix(\" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)].join() + \")\";\n        };\n        matrixproto.offset = function () {\n            return [this.e.toFixed(4), this.f.toFixed(4)];\n        };\n        function norm(a) {\n            return a[0] * a[0] + a[1] * a[1];\n        }\n        function normalize(a) {\n            var mag = math.sqrt(norm(a));\n            a[0] && (a[0] /= mag);\n            a[1] && (a[1] /= mag);\n        }\n        /*/\n         * Matrix.determinant\n         [ method ]\n         **\n         * Finds determinant of the given matrix.\n         = (number) determinant\n        /*/\n        matrixproto.determinant = function () {\n            return this.a * this.d - this.b * this.c;\n        };\n        /*/\n         * Matrix.split\n         [ method ]\n         **\n         * Splits matrix into primitive transformations\n         = (object) in format:\n         o dx (number) translation by x\n         o dy (number) translation by y\n         o scalex (number) scale by x\n         o scaley (number) scale by y\n         o shear (number) shear\n         o rotate (number) rotation in deg\n         o isSimple (boolean) could it be represented via simple transformations\n        /*/\n        matrixproto.split = function () {\n            var out = {};\n            // translation\n            out.dx = this.e;\n            out.dy = this.f;\n\n            // scale and shear\n            var row = [[this.a, this.c], [this.b, this.d]];\n            out.scalex = math.sqrt(norm(row[0]));\n            normalize(row[0]);\n\n            out.shear = row[0][0] * row[1][0] + row[0][1] * row[1][1];\n            row[1] = [row[1][0] - row[0][0] * out.shear, row[1][1] - row[0][1] * out.shear];\n\n            out.scaley = math.sqrt(norm(row[1]));\n            normalize(row[1]);\n            out.shear /= out.scaley;\n\n            if (this.determinant() < 0) {\n                out.scalex = -out.scalex;\n            }\n\n            // rotation\n            var sin = -row[0][1],\n                cos = row[1][1];\n            if (cos < 0) {\n                out.rotate = Snap.deg(math.acos(cos));\n                if (sin < 0) {\n                    out.rotate = 360 - out.rotate;\n                }\n            } else {\n                out.rotate = Snap.deg(math.asin(sin));\n            }\n\n            out.isSimple = !+out.shear.toFixed(9) && (out.scalex.toFixed(9) == out.scaley.toFixed(9) || !out.rotate);\n            out.isSuperSimple = !+out.shear.toFixed(9) && out.scalex.toFixed(9) == out.scaley.toFixed(9) && !out.rotate;\n            out.noRotation = !+out.shear.toFixed(9) && !out.rotate;\n            return out;\n        };\n        /*/\n         * Matrix.toTransformString\n         [ method ]\n         **\n         * Returns transform string that represents given matrix\n         = (string) transform string\n        /*/\n        matrixproto.toTransformString = function (shorter) {\n            var s = shorter || this.split();\n            if (!+s.shear.toFixed(9)) {\n                s.scalex = +s.scalex.toFixed(4);\n                s.scaley = +s.scaley.toFixed(4);\n                s.rotate = +s.rotate.toFixed(4);\n                return  (s.dx || s.dy ? \"t\" + [+s.dx.toFixed(4), +s.dy.toFixed(4)] : E) + \n                        (s.scalex != 1 || s.scaley != 1 ? \"s\" + [s.scalex, s.scaley, 0, 0] : E) +\n                        (s.rotate ? \"r\" + [+s.rotate.toFixed(4), 0, 0] : E);\n            } else {\n                return \"m\" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)];\n            }\n        };\n    })(Matrix.prototype);\n    /*/\n     * Snap.Matrix\n     [ method ]\n     **\n     * Matrix constructor, extend on your own risk.\n     * To create matrices use @Snap.matrix.\n    /*/\n    Snap.Matrix = Matrix;\n    /*/\n     * Snap.matrix\n     [ method ]\n     **\n     * Utility method\n     **\n     * Returns a matrix based on the given parameters\n     - a (number)\n     - b (number)\n     - c (number)\n     - d (number)\n     - e (number)\n     - f (number)\n     * or\n     - svgMatrix (SVGMatrix)\n     = (object) @Matrix\n    /*/\n    Snap.matrix = function (a, b, c, d, e, f) {\n        return new Matrix(a, b, c, d, e, f);\n    };\n});\n// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n// \n// http://www.apache.org/licenses/LICENSE-2.0\n// \n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nSnap.plugin(function (Snap, Element, Paper, glob, Fragment) {\n    var has = \"hasOwnProperty\",\n        make = Snap._.make,\n        wrap = Snap._.wrap,\n        is = Snap.is,\n        getSomeDefs = Snap._.getSomeDefs,\n        reURLValue = /^url/(#?([^)]+)/)$/,\n        $ = Snap._.$,\n        URL = Snap.url,\n        Str = String,\n        separator = Snap._.separator,\n        E = \"\";\n    // Attributes event handlers\n    eve.on(\"snap.util.attr.mask\", function (value) {\n        if (value instanceof Element || value instanceof Fragment) {\n            eve.stop();\n            if (value instanceof Fragment && value.node.childNodes.length == 1) {\n                value = value.node.firstChild;\n                getSomeDefs(this).appendChild(value);\n                value = wrap(value);\n            }\n            if (value.type == \"mask\") {\n                var mask = value;\n            } else {\n                mask = make(\"mask\", getSomeDefs(this));\n                mask.node.appendChild(value.node);\n            }\n            !mask.node.id && $(mask.node, {\n                id: mask.id\n            });\n            $(this.node, {\n                mask: URL(mask.id)\n            });\n        }\n    });\n    (function (clipIt) {\n        eve.on(\"snap.util.attr.clip\", clipIt);\n        eve.on(\"snap.util.attr.clip-path\", clipIt);\n        eve.on(\"snap.util.attr.clipPath\", clipIt);\n    }(function (value) {\n        if (value instanceof Element || value instanceof Fragment) {\n            eve.stop();\n            if (value.type == \"clipPath\") {\n                var clip = value;\n            } else {\n                clip = make(\"clipPath\", getSomeDefs(this));\n                clip.node.appendChild(value.node);\n                !clip.node.id && $(clip.node, {\n                    id: clip.id\n                });\n            }\n            $(this.node, {\n                \"clip-path\": URL(clip.node.id || clip.id)\n            });\n        }\n    }));\n    function fillStroke(name) {\n        return function (value) {\n            eve.stop();\n            if (value instanceof Fragment && value.node.childNodes.length == 1 &&\n                (value.node.firstChild.tagName == \"radialGradient\" ||\n                value.node.firstChild.tagName == \"linearGradient\" ||\n                value.node.firstChild.tagName == \"pattern\")) {\n                value = value.node.firstChild;\n                getSomeDefs(this).appendChild(value);\n                value = wrap(value);\n            }\n            if (value instanceof Element) {\n                if (value.type == \"radialGradient\" || value.type == \"linearGradient\"\n                   || value.type == \"pattern\") {\n                    if (!value.node.id) {\n                        $(value.node, {\n                            id: value.id\n                        });\n                    }\n                    var fill = URL(value.node.id);\n                } else {\n                    fill = value.attr(name);\n                }\n            } else {\n                fill = Snap.color(value);\n                if (fill.error) {\n                    var grad = Snap(getSomeDefs(this).ownerSVGElement).gradient(value);\n                    if (grad) {\n                        if (!grad.node.id) {\n                            $(grad.node, {\n                                id: grad.id\n                            });\n                        }\n                        fill = URL(grad.node.id);\n                    } else {\n                        fill = value;\n                    }\n                } else {\n                    fill = Str(fill);\n                }\n            }\n            var attrs = {};\n            attrs[name] = fill;\n            $(this.node, attrs);\n            this.node.style[name] = E;\n        };\n    }\n    eve.on(\"snap.util.attr.fill\", fillStroke(\"fill\"));\n    eve.on(\"snap.util.attr.stroke\", fillStroke(\"stroke\"));\n    var gradrg = /^([lr])(?:/(([^)]*)/))?(.*)$/i;\n    eve.on(\"snap.util.grad.parse\", function parseGrad(string) {\n        string = Str(string);\n        var tokens = string.match(gradrg);\n        if (!tokens) {\n            return null;\n        }\n        var type = tokens[1],\n            params = tokens[2],\n            stops = tokens[3];\n        params = params.split(//s*,/s*/).map(function (el) {\n            return +el == el ? +el : el;\n        });\n        if (params.length == 1 && params[0] == 0) {\n            params = [];\n        }\n        stops = stops.split(\"-\");\n        stops = stops.map(function (el) {\n            el = el.split(\":\");\n            var out = {\n                color: el[0]\n            };\n            if (el[1]) {\n                out.offset = parseFloat(el[1]);\n            }\n            return out;\n        });\n        return {\n            type: type,\n            params: params,\n            stops: stops\n        };\n    });\n\n    eve.on(\"snap.util.attr.d\", function (value) {\n        eve.stop();\n        if (is(value, \"array\") && is(value[0], \"array\")) {\n            value = Snap.path.toString.call(value);\n        }\n        value = Str(value);\n        if (value.match(/[ruo]/i)) {\n            value = Snap.path.toAbsolute(value);\n        }\n        $(this.node, {d: value});\n    })(-1);\n    eve.on(\"snap.util.attr.#text\", function (value) {\n        eve.stop();\n        value = Str(value);\n        var txt = glob.doc.createTextNode(value);\n        while (this.node.firstChild) {\n            this.node.removeChild(this.node.firstChild);\n        }\n        this.node.appendChild(txt);\n    })(-1);\n    eve.on(\"snap.util.attr.path\", function (value) {\n        eve.stop();\n        this.attr({d: value});\n    })(-1);\n    eve.on(\"snap.util.attr.class\", function (value) {\n        eve.stop();\n        this.node.className.baseVal = value;\n    })(-1);\n    eve.on(\"snap.util.attr.viewBox\", function (value) {\n        var vb;\n        if (is(value, \"object\") && \"x\" in value) {\n            vb = [value.x, value.y, value.width, value.height].join(\" \");\n        } else if (is(value, \"array\")) {\n            vb = value.join(\" \");\n        } else {\n            vb = value;\n        }\n        $(this.node, {\n            viewBox: vb\n        });\n        eve.stop();\n    })(-1);\n    eve.on(\"snap.util.attr.transform\", function (value) {\n        this.transform(value);\n        eve.stop();\n    })(-1);\n    eve.on(\"snap.util.attr.r\", function (value) {\n        if (this.type == \"rect\") {\n            eve.stop();\n            $(this.node, {\n                rx: value,\n                ry: value\n            });\n        }\n    })(-1);\n    eve.on(\"snap.util.attr.textpath\", function (value) {\n        eve.stop();\n        if (this.type == \"text\") {\n            var id, tp, node;\n            if (!value && this.textPath) {\n                tp = this.textPath;\n                while (tp.node.firstChild) {\n                    this.node.appendChild(tp.node.firstChild);\n                }\n                tp.remove();\n                delete this.textPath;\n                return;\n            }\n            if (is(value, \"string\")) {\n                var defs = getSomeDefs(this),\n                    path = wrap(defs.parentNode).path(value);\n                defs.appendChild(path.node);\n                id = path.id;\n                path.attr({id: id});\n            } else {\n                value = wrap(value);\n                if (value instanceof Element) {\n                    id = value.attr(\"id\");\n                    if (!id) {\n                        id = value.id;\n                        value.attr({id: id});\n                    }\n                }\n            }\n            if (id) {\n                tp = this.textPath;\n                node = this.node;\n                if (tp) {\n                    tp.attr({\"xlink:href\": \"#\" + id});\n                } else {\n                    tp = $(\"textPath\", {\n                        \"xlink:href\": \"#\" + id\n                    });\n                    while (node.firstChild) {\n                        tp.appendChild(node.firstChild);\n                    }\n                    node.appendChild(tp);\n                    this.textPath = wrap(tp);\n                }\n            }\n        }\n    })(-1);\n    eve.on(\"snap.util.attr.text\", function (value) {\n        if (this.type == \"text\") {\n            var i = 0,\n                node = this.node,\n                tuner = function (chunk) {\n                    var out = $(\"tspan\");\n                    if (is(chunk, \"array\")) {\n                        for (var i = 0; i < chunk.length; i++) {\n                            out.appendChild(tuner(chunk[i]));\n                        }\n                    } else {\n                        out.appendChild(glob.doc.createTextNode(chunk));\n                    }\n                    out.normalize && out.normalize();\n                    return out;\n                };\n            while (node.firstChild) {\n                node.removeChild(node.firstChild);\n            }\n            var tuned = tuner(value);\n            while (tuned.firstChild) {\n                node.appendChild(tuned.firstChild);\n            }\n        }\n        eve.stop();\n    })(-1);\n    function setFontSize(value) {\n        eve.stop();\n        if (value == +value) {\n            value += \"px\";\n        }\n        this.node.style.fontSize = value;\n    }\n    eve.on(\"snap.util.attr.fontSize\", setFontSize)(-1);\n    eve.on(\"snap.util.attr.font-size\", setFontSize)(-1);\n\n\n    eve.on(\"snap.util.getattr.transform\", function () {\n        eve.stop();\n        return this.transform();\n    })(-1);\n    eve.on(\"snap.util.getattr.textpath\", function () {\n        eve.stop();\n        return this.textPath;\n    })(-1);\n    // Markers\n    (function () {\n        function getter(end) {\n            return function () {\n                eve.stop();\n                var style = glob.doc.defaultView.getComputedStyle(this.node, null).getPropertyValue(\"marker-\" + end);\n                if (style == \"none\") {\n                    return style;\n                } else {\n                    return Snap(glob.doc.getElementById(style.match(reURLValue)[1]));\n                }\n            };\n        }\n        function setter(end) {\n            return function (value) {\n                eve.stop();\n                var name = \"marker\" + end.charAt(0).toUpperCase() + end.substring(1);\n                if (value == \"\" || !value) {\n                    this.node.style[name] = \"none\";\n                    return;\n                }\n                if (value.type == \"marker\") {\n                    var id = value.node.id;\n                    if (!id) {\n                        $(value.node, {id: value.id});\n                    }\n                    this.node.style[name] = URL(id);\n                    return;\n                }\n            };\n        }\n        eve.on(\"snap.util.getattr.marker-end\", getter(\"end\"))(-1);\n        eve.on(\"snap.util.getattr.markerEnd\", getter(\"end\"))(-1);\n        eve.on(\"snap.util.getattr.marker-start\", getter(\"start\"))(-1);\n        eve.on(\"snap.util.getattr.markerStart\", getter(\"start\"))(-1);\n        eve.on(\"snap.util.getattr.marker-mid\", getter(\"mid\"))(-1);\n        eve.on(\"snap.util.getattr.markerMid\", getter(\"mid\"))(-1);\n        eve.on(\"snap.util.attr.marker-end\", setter(\"end\"))(-1);\n        eve.on(\"snap.util.attr.markerEnd\", setter(\"end\"))(-1);\n        eve.on(\"snap.util.attr.marker-start\", setter(\"start\"))(-1);\n        eve.on(\"snap.util.attr.markerStart\", setter(\"start\"))(-1);\n        eve.on(\"snap.util.attr.marker-mid\", setter(\"mid\"))(-1);\n        eve.on(\"snap.util.attr.markerMid\", setter(\"mid\"))(-1);\n    }());\n    eve.on(\"snap.util.getattr.r\", function () {\n        if (this.type == \"rect\" && $(this.node, \"rx\") == $(this.node, \"ry\")) {\n            eve.stop();\n            return $(this.node, \"rx\");\n        }\n    })(-1);\n    function textExtract(node) {\n        var out = [];\n        var children = node.childNodes;\n        for (var i = 0, ii = children.length; i < ii; i++) {\n            var chi = children[i];\n            if (chi.nodeType == 3) {\n                out.push(chi.nodeValue);\n            }\n            if (chi.tagName == \"tspan\") {\n                if (chi.childNodes.length == 1 && chi.firstChild.nodeType == 3) {\n                    out.push(chi.firstChild.nodeValue);\n                } else {\n                    out.push(textExtract(chi));\n                }\n            }\n        }\n        return out;\n    }\n    eve.on(\"snap.util.getattr.text\", function () {\n        if (this.type == \"text\" || this.type == \"tspan\") {\n            eve.stop();\n            var out = textExtract(this.node);\n            return out.length == 1 ? out[0] : out;\n        }\n    })(-1);\n    eve.on(\"snap.util.getattr.#text\", function () {\n        return this.node.textContent;\n    })(-1);\n    eve.on(\"snap.util.getattr.viewBox\", function () {\n        eve.stop();\n        var vb = $(this.node, \"viewBox\");\n        if (vb) {\n            vb = vb.split(separator);\n            return Snap._.box(+vb[0], +vb[1], +vb[2], +vb[3]);\n        } else {\n            return;\n        }\n    })(-1);\n    eve.on(\"snap.util.getattr.points\", function () {\n        var p = $(this.node, \"points\");\n        eve.stop();\n        if (p) {\n            return p.split(separator);\n        } else {\n            return;\n        }\n    })(-1);\n    eve.on(\"snap.util.getattr.path\", function () {\n        var p = $(this.node, \"d\");\n        eve.stop();\n        return p;\n    })(-1);\n    eve.on(\"snap.util.getattr.class\", function () {\n        return this.node.className.baseVal;\n    })(-1);\n    function getFontSize() {\n        eve.stop();\n        return this.node.style.fontSize;\n    }\n    eve.on(\"snap.util.getattr.fontSize\", getFontSize)(-1);\n    eve.on(\"snap.util.getattr.font-size\", getFontSize)(-1);\n});\n\n// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n// \n// http://www.apache.org/licenses/LICENSE-2.0\n// \n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nSnap.plugin(function (Snap, Element, Paper, glob, Fragment) {\n    var proto = Paper.prototype,\n        is = Snap.is;\n    /*/\n     * Paper.rect\n     [ method ]\n     *\n     * Draws a rectangle\n     **\n     - x (number) x coordinate of the top left corner\n     - y (number) y coordinate of the top left corner\n     - width (number) width\n     - height (number) height\n     - rx (number) #optional horizontal radius for rounded corners, default is 0\n     - ry (number) #optional vertical radius for rounded corners, default is rx or 0\n     = (object) the `rect` element\n     **\n     > Usage\n     | // regular rectangle\n     | var c = paper.rect(10, 10, 50, 50);\n     | // rectangle with rounded corners\n     | var c = paper.rect(40, 40, 50, 50, 10);\n    /*/\n    proto.rect = function (x, y, w, h, rx, ry) {\n        var attr;\n        if (ry == null) {\n            ry = rx;\n        }\n        if (is(x, \"object\") && x == \"[object Object]\") {\n            attr = x;\n        } else if (x != null) {\n            attr = {\n                x: x,\n                y: y,\n                width: w,\n                height: h\n            };\n            if (rx != null) {\n                attr.rx = rx;\n                attr.ry = ry;\n            }\n        }\n        return this.el(\"rect\", attr);\n    };\n    /*/\n     * Paper.circle\n     [ method ]\n     **\n     * Draws a circle\n     **\n     - x (number) x coordinate of the centre\n     - y (number) y coordinate of the centre\n     - r (number) radius\n     = (object) the `circle` element\n     **\n     > Usage\n     | var c = paper.circle(50, 50, 40);\n    /*/\n    proto.circle = function (cx, cy, r) {\n        var attr;\n        if (is(cx, \"object\") && cx == \"[object Object]\") {\n            attr = cx;\n        } else if (cx != null) {\n            attr = {\n                cx: cx,\n                cy: cy,\n                r: r\n            };\n        }\n        return this.el(\"circle\", attr);\n    };\n\n    var preload = (function () {\n        function onerror() {\n            this.parentNode.removeChild(this);\n        }\n        return function (src, f) {\n            var img = glob.doc.createElement(\"img\"),\n                body = glob.doc.body;\n            img.style.cssText = \"position:absolute;left:-9999em;top:-9999em\";\n            img.onload = function () {\n                f.call(img);\n                img.onload = img.onerror = null;\n                body.removeChild(img);\n            };\n            img.onerror = onerror;\n            body.appendChild(img);\n            img.src = src;\n        };\n    }());\n\n    /*/\n     * Paper.image\n     [ method ]\n     **\n     * Places an image on the surface\n     **\n     - src (string) URI of the source image\n     - x (number) x offset position\n     - y (number) y offset position\n     - width (number) width of the image\n     - height (number) height of the image\n     = (object) the `image` element\n     * or\n     = (object) Snap element object with type `image`\n     **\n     > Usage\n     | var c = paper.image(\"apple.png\", 10, 10, 80, 80);\n    /*/\n    proto.image = function (src, x, y, width, height) {\n        var el = this.el(\"image\");\n        if (is(src, \"object\") && \"src\" in src) {\n            el.attr(src);\n        } else if (src != null) {\n            var set = {\n                \"xlink:href\": src,\n                preserveAspectRatio: \"none\"\n            };\n            if (x != null && y != null) {\n                set.x = x;\n                set.y = y;\n            }\n            if (width != null && height != null) {\n                set.width = width;\n                set.height = height;\n            } else {\n                preload(src, function () {\n                    Snap._.$(el.node, {\n                        width: this.offsetWidth,\n                        height: this.offsetHeight\n                    });\n                });\n            }\n            Snap._.$(el.node, set);\n        }\n        return el;\n    };\n    /*/\n     * Paper.ellipse\n     [ method ]\n     **\n     * Draws an ellipse\n     **\n     - x (number) x coordinate of the centre\n     - y (number) y coordinate of the centre\n     - rx (number) horizontal radius\n     - ry (number) vertical radius\n     = (object) the `ellipse` element\n     **\n     > Usage\n     | var c = paper.ellipse(50, 50, 40, 20);\n    /*/\n    proto.ellipse = function (cx, cy, rx, ry) {\n        var attr;\n        if (is(cx, \"object\") && cx == \"[object Object]\") {\n            attr = cx;\n        } else if (cx != null) {\n            attr ={\n                cx: cx,\n                cy: cy,\n                rx: rx,\n                ry: ry\n            };\n        }\n        return this.el(\"ellipse\", attr);\n    };\n    // SIERRA Paper.path(): Unclear from the link what a Catmull-Rom curveto is, and why it would make life any easier.\n    /*/\n     * Paper.path\n     [ method ]\n     **\n     * Creates a `<path>` element using the given string as the path's definition\n     - pathString (string) #optional path string in SVG format\n     * Path string consists of one-letter commands, followed by comma seprarated arguments in numerical form. Example:\n     | \"M10,20L30,40\"\n     * This example features two commands: `M`, with arguments `(10, 20)` and `L` with arguments `(30, 40)`. Uppercase letter commands express coordinates in absolute terms, while lowercase commands express them in relative terms from the most recently declared coordinates.\n     *\n     # <p>Here is short list of commands available, for more details see <a href=\"http://www.w3.org/TR/SVG/paths.html#PathData\" title=\"Details of a path's data attribute's format are described in the SVG specification.\">SVG path string format</a> or <a href=\"https://developer.mozilla.org/en/SVG/Tutorial/Paths\">article about path strings at MDN</a>.</p>\n     # <table><thead><tr><th>Command</th><th>Name</th><th>Parameters</th></tr></thead><tbody>\n     # <tr><td>M</td><td>moveto</td><td>(x y)+</td></tr>\n     # <tr><td>Z</td><td>closepath</td><td>(none)</td></tr>\n     # <tr><td>L</td><td>lineto</td><td>(x y)+</td></tr>\n     # <tr><td>H</td><td>horizontal lineto</td><td>x+</td></tr>\n     # <tr><td>V</td><td>vertical lineto</td><td>y+</td></tr>\n     # <tr><td>C</td><td>curveto</td><td>(x1 y1 x2 y2 x y)+</td></tr>\n     # <tr><td>S</td><td>smooth curveto</td><td>(x2 y2 x y)+</td></tr>\n     # <tr><td>Q</td><td>quadratic Bézier curveto</td><td>(x1 y1 x y)+</td></tr>\n     # <tr><td>T</td><td>smooth quadratic Bézier curveto</td><td>(x y)+</td></tr>\n     # <tr><td>A</td><td>elliptical arc</td><td>(rx ry x-axis-rotation large-arc-flag sweep-flag x y)+</td></tr>\n     # <tr><td>R</td><td><a href=\"http://en.wikipedia.org/wiki/Catmull–Rom_spline#Catmull.E2.80.93Rom_spline\">Catmull-Rom curveto</a>*</td><td>x1 y1 (x y)+</td></tr></tbody></table>\n     * * _Catmull-Rom curveto_ is a not standard SVG command and added to make life easier.\n     * Note: there is a special case when a path consists of only three commands: `M10,10R…z`. In this case the path connects back to its starting point.\n     > Usage\n     | var c = paper.path(\"M10 10L90 90\");\n     | // draw a diagonal line:\n     | // move to 10,10, line to 90,90\n    /*/\n    proto.path = function (d) {\n        var attr;\n        if (is(d, \"object\") && !is(d, \"array\")) {\n            attr = d;\n        } else if (d) {\n            attr = {d: d};\n        }\n        return this.el(\"path\", attr);\n    };\n    /*/\n     * Paper.g\n     [ method ]\n     **\n     * Creates a group element\n     **\n     - varargs (…) #optional elements to nest within the group\n     = (object) the `g` element\n     **\n     > Usage\n     | var c1 = paper.circle(),\n     |     c2 = paper.rect(),\n     |     g = paper.g(c2, c1); // note that the order of elements is different\n     * or\n     | var c1 = paper.circle(),\n     |     c2 = paper.rect(),\n     |     g = paper.g();\n     | g.add(c2, c1);\n    /*/\n    /*/\n     * Paper.group\n     [ method ]\n     **\n     * See @Paper.g\n    /*/\n    proto.group = proto.g = function (first) {\n        var attr,\n            el = this.el(\"g\");\n        if (arguments.length == 1 && first && !first.type) {\n            el.attr(first);\n        } else if (arguments.length) {\n            el.add(Array.prototype.slice.call(arguments, 0));\n        }\n        return el;\n    };\n    /*/\n     * Paper.svg\n     [ method ]\n     **\n     * Creates a nested SVG element.\n     - x (number) @optional X of the element\n     - y (number) @optional Y of the element\n     - width (number) @optional width of the element\n     - height (number) @optional height of the element\n     - vbx (number) @optional viewbox X\n     - vby (number) @optional viewbox Y\n     - vbw (number) @optional viewbox width\n     - vbh (number) @optional viewbox height\n     **\n     = (object) the `svg` element\n     **\n    /*/\n    proto.svg = function (x, y, width, height, vbx, vby, vbw, vbh) {\n        var attrs = {};\n        if (is(x, \"object\") && y == null) {\n            attrs = x;\n        } else {\n            if (x != null) {\n                attrs.x = x;\n            }\n            if (y != null) {\n                attrs.y = y;\n            }\n            if (width != null) {\n                attrs.width = width;\n            }\n            if (height != null) {\n                attrs.height = height;\n            }\n            if (vbx != null && vby != null && vbw != null && vbh != null) {\n                attrs.viewBox = [vbx, vby, vbw, vbh];\n            }\n        }\n        return this.el(\"svg\", attrs);\n    };\n    /*/\n     * Paper.mask\n     [ method ]\n     **\n     * Equivalent in behaviour to @Paper.g, except it’s a mask.\n     **\n     = (object) the `mask` element\n     **\n    /*/\n    proto.mask = function (first) {\n        var attr,\n            el = this.el(\"mask\");\n        if (arguments.length == 1 && first && !first.type) {\n            el.attr(first);\n        } else if (arguments.length) {\n            el.add(Array.prototype.slice.call(arguments, 0));\n        }\n        return el;\n    };\n    /*/\n     * Paper.ptrn\n     [ method ]\n     **\n     * Equivalent in behaviour to @Paper.g, except it’s a pattern.\n     - x (number) @optional X of the element\n     - y (number) @optional Y of the element\n     - width (number) @optional width of the element\n     - height (number) @optional height of the element\n     - vbx (number) @optional viewbox X\n     - vby (number) @optional viewbox Y\n     - vbw (number) @optional viewbox width\n     - vbh (number) @optional viewbox height\n     **\n     = (object) the `pattern` element\n     **\n    /*/\n    proto.ptrn = function (x, y, width, height, vx, vy, vw, vh) {\n        if (is(x, \"object\")) {\n            var attr = x;\n        } else {\n            attr = {patternUnits: \"userSpaceOnUse\"};\n            if (x) {\n                attr.x = x;\n            }\n            if (y) {\n                attr.y = y;\n            }\n            if (width != null) {\n                attr.width = width;\n            }\n            if (height != null) {\n                attr.height = height;\n            }\n            if (vx != null && vy != null && vw != null && vh != null) {\n                attr.viewBox = [vx, vy, vw, vh];\n            }\n        }\n        return this.el(\"pattern\", attr);\n    };\n    /*/\n     * Paper.use\n     [ method ]\n     **\n     * Creates a <use> element.\n     - id (string) @optional id of element to link\n     * or\n     - id (Element) @optional element to link\n     **\n     = (object) the `use` element\n     **\n    /*/\n    proto.use = function (id) {\n        if (id != null) {\n            if (id instanceof Element) {\n                if (!id.attr(\"id\")) {\n                    id.attr({id: Snap._.id(id)});\n                }\n                id = id.attr(\"id\");\n            }\n            if (String(id).charAt() == \"#\") {\n                id = id.substring(1);\n            }\n            return this.el(\"use\", {\"xlink:href\": \"#\" + id});\n        } else {\n            return Element.prototype.use.call(this);\n        }\n    };\n    /*/\n     * Paper.symbol\n     [ method ]\n     **\n     * Creates a <symbol> element.\n     - vbx (number) @optional viewbox X\n     - vby (number) @optional viewbox Y\n     - vbw (number) @optional viewbox width\n     - vbh (number) @optional viewbox height\n     = (object) the `symbol` element\n     **\n    /*/\n    proto.symbol = function (vx, vy, vw, vh) {\n        var attr = {};\n        if (vx != null && vy != null && vw != null && vh != null) {\n            attr.viewBox = [vx, vy, vw, vh];\n        }\n\n        return this.el(\"symbol\", attr);\n    };\n    /*/\n     * Paper.text\n     [ method ]\n     **\n     * Draws a text string\n     **\n     - x (number) x coordinate position\n     - y (number) y coordinate position\n     - text (string|array) The text string to draw or array of strings to nest within separate `<tspan>` elements\n     = (object) the `text` element\n     **\n     > Usage\n     | var t1 = paper.text(50, 50, \"Snap\");\n     | var t2 = paper.text(50, 50, [\"S\",\"n\",\"a\",\"p\"]);\n     | // Text path usage\n     | t1.attr({textpath: \"M10,10L100,100\"});\n     | // or\n     | var pth = paper.path(\"M10,10L100,100\");\n     | t1.attr({textpath: pth});\n    /*/\n    proto.text = function (x, y, text) {\n        var attr = {};\n        if (is(x, \"object\")) {\n            attr = x;\n        } else if (x != null) {\n            attr = {\n                x: x,\n                y: y,\n                text: text || \"\"\n            };\n        }\n        return this.el(\"text\", attr);\n    };\n    /*/\n     * Paper.line\n     [ method ]\n     **\n     * Draws a line\n     **\n     - x1 (number) x coordinate position of the start\n     - y1 (number) y coordinate position of the start\n     - x2 (number) x coordinate position of the end\n     - y2 (number) y coordinate position of the end\n     = (object) the `line` element\n     **\n     > Usage\n     | var t1 = paper.line(50, 50, 100, 100);\n    /*/\n    proto.line = function (x1, y1, x2, y2) {\n        var attr = {};\n        if (is(x1, \"object\")) {\n            attr = x1;\n        } else if (x1 != null) {\n            attr = {\n                x1: x1,\n                x2: x2,\n                y1: y1,\n                y2: y2\n            };\n        }\n        return this.el(\"line\", attr);\n    };\n    /*/\n     * Paper.polyline\n     [ method ]\n     **\n     * Draws a polyline\n     **\n     - points (array) array of points\n     * or\n     - varargs (…) points\n     = (object) the `polyline` element\n     **\n     > Usage\n     | var p1 = paper.polyline([10, 10, 100, 100]);\n     | var p2 = paper.polyline(10, 10, 100, 100);\n    /*/\n    proto.polyline = function (points) {\n        if (arguments.length > 1) {\n            points = Array.prototype.slice.call(arguments, 0);\n        }\n        var attr = {};\n        if (is(points, \"object\") && !is(points, \"array\")) {\n            attr = points;\n        } else if (points != null) {\n            attr = {points: points};\n        }\n        return this.el(\"polyline\", attr);\n    };\n    /*/\n     * Paper.polygon\n     [ method ]\n     **\n     * Draws a polygon. See @Paper.polyline\n    /*/\n    proto.polygon = function (points) {\n        if (arguments.length > 1) {\n            points = Array.prototype.slice.call(arguments, 0);\n        }\n        var attr = {};\n        if (is(points, \"object\") && !is(points, \"array\")) {\n            attr = points;\n        } else if (points != null) {\n            attr = {points: points};\n        }\n        return this.el(\"polygon\", attr);\n    };\n    // gradients\n    (function () {\n        var $ = Snap._.$;\n        // gradients' helpers\n        function Gstops() {\n            return this.selectAll(\"stop\");\n        }\n        function GaddStop(color, offset) {\n            var stop = $(\"stop\"),\n                attr = {\n                    offset: +offset + \"%\"\n                };\n            color = Snap.color(color);\n            attr[\"stop-color\"] = color.hex;\n            if (color.opacity < 1) {\n                attr[\"stop-opacity\"] = color.opacity;\n            }\n            $(stop, attr);\n            this.node.appendChild(stop);\n            return this;\n        }\n        function GgetBBox() {\n            if (this.type == \"linearGradient\") {\n                var x1 = $(this.node, \"x1\") || 0,\n                    x2 = $(this.node, \"x2\") || 1,\n                    y1 = $(this.node, \"y1\") || 0,\n                    y2 = $(this.node, \"y2\") || 0;\n                return Snap._.box(x1, y1, math.abs(x2 - x1), math.abs(y2 - y1));\n            } else {\n                var cx = this.node.cx || .5,\n                    cy = this.node.cy || .5,\n                    r = this.node.r || 0;\n                return Snap._.box(cx - r, cy - r, r * 2, r * 2);\n            }\n        }\n        function gradient(defs, str) {\n            var grad = eve(\"snap.util.grad.parse\", null, str).firstDefined(),\n                el;\n            if (!grad) {\n                return null;\n            }\n            grad.params.unshift(defs);\n            if (grad.type.toLowerCase() == \"l\") {\n                el = gradientLinear.apply(0, grad.params);\n            } else {\n                el = gradientRadial.apply(0, grad.params);\n            }\n            if (grad.type != grad.type.toLowerCase()) {\n                $(el.node, {\n                    gradientUnits: \"userSpaceOnUse\"\n                });\n            }\n            var stops = grad.stops,\n                len = stops.length,\n                start = 0,\n                j = 0;\n            function seed(i, end) {\n                var step = (end - start) / (i - j);\n                for (var k = j; k < i; k++) {\n                    stops[k].offset = +(+start + step * (k - j)).toFixed(2);\n                }\n                j = i;\n                start = end;\n            }\n            len--;\n            for (var i = 0; i < len; i++) if (\"offset\" in stops[i]) {\n                seed(i, stops[i].offset);\n            }\n            stops[len].offset = stops[len].offset || 100;\n            seed(len, stops[len].offset);\n            for (i = 0; i <= len; i++) {\n                var stop = stops[i];\n                el.addStop(stop.color, stop.offset);\n            }\n            return el;\n        }\n        function gradientLinear(defs, x1, y1, x2, y2) {\n            var el = Snap._.make(\"linearGradient\", defs);\n            el.stops = Gstops;\n            el.addStop = GaddStop;\n            el.getBBox = GgetBBox;\n            if (x1 != null) {\n                $(el.node, {\n                    x1: x1,\n                    y1: y1,\n                    x2: x2,\n                    y2: y2\n                });\n            }\n            return el;\n        }\n        function gradientRadial(defs, cx, cy, r, fx, fy) {\n            var el = Snap._.make(\"radialGradient\", defs);\n            el.stops = Gstops;\n            el.addStop = GaddStop;\n            el.getBBox = GgetBBox;\n            if (cx != null) {\n                $(el.node, {\n                    cx: cx,\n                    cy: cy,\n                    r: r\n                });\n            }\n            if (fx != null && fy != null) {\n                $(el.node, {\n                    fx: fx,\n                    fy: fy\n                });\n            }\n            return el;\n        }\n        /*/\n         * Paper.gradient\n         [ method ]\n         **\n         * Creates a gradient element\n         **\n         - gradient (string) gradient descriptor\n         > Gradient Descriptor\n         * The gradient descriptor is an expression formatted as\n         * follows: `<type>(<coords>)<colors>`.  The `<type>` can be\n         * either linear or radial.  The uppercase `L` or `R` letters\n         * indicate absolute coordinates offset from the SVG surface.\n         * Lowercase `l` or `r` letters indicate coordinates\n         * calculated relative to the element to which the gradient is\n         * applied.  Coordinates specify a linear gradient vector as\n         * `x1`, `y1`, `x2`, `y2`, or a radial gradient as `cx`, `cy`,\n         * `r` and optional `fx`, `fy` specifying a focal point away\n         * from the center of the circle. Specify `<colors>` as a list\n         * of dash-separated CSS color values.  Each color may be\n         * followed by a custom offset value, separated with a colon\n         * character.\n         > Examples\n         * Linear gradient, relative from top-left corner to bottom-right\n         * corner, from black through red to white:\n         | var g = paper.gradient(\"l(0, 0, 1, 1)#000-#f00-#fff\");\n         * Linear gradient, absolute from (0, 0) to (100, 100), from black\n         * through red at 25% to white:\n         | var g = paper.gradient(\"L(0, 0, 100, 100)#000-#f00:25-#fff\");\n         * Radial gradient, relative from the center of the element with radius\n         * half the width, from black to white:\n         | var g = paper.gradient(\"r(0.5, 0.5, 0.5)#000-#fff\");\n         * To apply the gradient:\n         | paper.circle(50, 50, 40).attr({\n         |     fill: g\n         | });\n         = (object) the `gradient` element\n        /*/\n        proto.gradient = function (str) {\n            return gradient(this.defs, str);\n        };\n        proto.gradientLinear = function (x1, y1, x2, y2) {\n            return gradientLinear(this.defs, x1, y1, x2, y2);\n        };\n        proto.gradientRadial = function (cx, cy, r, fx, fy) {\n            return gradientRadial(this.defs, cx, cy, r, fx, fy);\n        };\n        /*/\n         * Paper.toString\n         [ method ]\n         **\n         * Returns SVG code for the @Paper\n         = (string) SVG code for the @Paper\n        /*/\n        proto.toString = function () {\n            var doc = this.node.ownerDocument,\n                f = doc.createDocumentFragment(),\n                d = doc.createElement(\"div\"),\n                svg = this.node.cloneNode(true),\n                res;\n            f.appendChild(d);\n            d.appendChild(svg);\n            Snap._.$(svg, {xmlns: \"http://www.w3.org/2000/svg\"});\n            res = d.innerHTML;\n            f.removeChild(f.firstChild);\n            return res;\n        };\n        /*/\n         * Paper.toDataURL\n         [ method ]\n         **\n         * Returns SVG code for the @Paper as Data URI string.\n         = (string) Data URI string\n        /*/\n        proto.toDataURL = function () {\n            if (window && window.btoa) {\n                return \"data:image/svg+xml;base64,\" + btoa(unescape(encodeURIComponent(this)));\n            }\n        };\n        /*/\n         * Paper.clear\n         [ method ]\n         **\n         * Removes all child nodes of the paper, except <defs>.\n        /*/\n        proto.clear = function () {\n            var node = this.node.firstChild,\n                next;\n            while (node) {\n                next = node.nextSibling;\n                if (node.tagName != \"defs\") {\n                    node.parentNode.removeChild(node);\n                } else {\n                    proto.clear.call({node: node});\n                }\n                node = next;\n            }\n        };\n    }());\n});\n\n// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n// \n// http://www.apache.org/licenses/LICENSE-2.0\n// \n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nSnap.plugin(function (Snap, Element, Paper, glob) {\n    var elproto = Element.prototype,\n        is = Snap.is,\n        clone = Snap._.clone,\n        has = \"hasOwnProperty\",\n        p2s = /,?([a-z]),?/gi,\n        toFloat = parseFloat,\n        math = Math,\n        PI = math.PI,\n        mmin = math.min,\n        mmax = math.max,\n        pow = math.pow,\n        abs = math.abs;\n    function paths(ps) {\n        var p = paths.ps = paths.ps || {};\n        if (p[ps]) {\n            p[ps].sleep = 100;\n        } else {\n            p[ps] = {\n                sleep: 100\n            };\n        }\n        setTimeout(function () {\n            for (var key in p) if (p[has](key) && key != ps) {\n                p[key].sleep--;\n                !p[key].sleep && delete p[key];\n            }\n        });\n        return p[ps];\n    }\n    function box(x, y, width, height) {\n        if (x == null) {\n            x = y = width = height = 0;\n        }\n        if (y == null) {\n            y = x.y;\n            width = x.width;\n            height = x.height;\n            x = x.x;\n        }\n        return {\n            x: x,\n            y: y,\n            width: width,\n            w: width,\n            height: height,\n            h: height,\n            x2: x + width,\n            y2: y + height,\n            cx: x + width / 2,\n            cy: y + height / 2,\n            r1: math.min(width, height) / 2,\n            r2: math.max(width, height) / 2,\n            r0: math.sqrt(width * width + height * height) / 2,\n            path: rectPath(x, y, width, height),\n            vb: [x, y, width, height].join(\" \")\n        };\n    }\n    function toString() {\n        return this.join(\",\").replace(p2s, \"$1\");\n    }\n    function pathClone(pathArray) {\n        var res = clone(pathArray);\n        res.toString = toString;\n        return res;\n    }\n    function getPointAtSegmentLength(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length) {\n        if (length == null) {\n            return bezlen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y);\n        } else {\n            return findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y,\n                getTotLen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length));\n        }\n    }\n    function getLengthFactory(istotal, subpath) {\n        function O(val) {\n            return +(+val).toFixed(3);\n        }\n        return Snap._.cacher(function (path, length, onlystart) {\n            if (path instanceof Element) {\n                path = path.attr(\"d\");\n            }\n            path = path2curve(path);\n            var x, y, p, l, sp = \"\", subpaths = {}, point,\n                len = 0;\n            for (var i = 0, ii = path.length; i < ii; i++) {\n                p = path[i];\n                if (p[0] == \"M\") {\n                    x = +p[1];\n                    y = +p[2];\n                } else {\n                    l = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);\n                    if (len + l > length) {\n                        if (subpath && !subpaths.start) {\n                            point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);\n                            sp += [\n                                \"C\" + O(point.start.x),\n                                O(point.start.y),\n                                O(point.m.x),\n                                O(point.m.y),\n                                O(point.x),\n                                O(point.y)\n                            ];\n                            if (onlystart) {return sp;}\n                            subpaths.start = sp;\n                            sp = [\n                                \"M\" + O(point.x),\n                                O(point.y) + \"C\" + O(point.n.x),\n                                O(point.n.y),\n                                O(point.end.x),\n                                O(point.end.y),\n                                O(p[5]),\n                                O(p[6])\n                            ].join();\n                            len += l;\n                            x = +p[5];\n                            y = +p[6];\n                            continue;\n                        }\n                        if (!istotal && !subpath) {\n                            point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);\n                            return point;\n                        }\n                    }\n                    len += l;\n                    x = +p[5];\n                    y = +p[6];\n                }\n                sp += p.shift() + p;\n            }\n            subpaths.end = sp;\n            point = istotal ? len : subpath ? subpaths : findDotsAtSegment(x, y, p[0], p[1], p[2], p[3], p[4], p[5], 1);\n            return point;\n        }, null, Snap._.clone);\n    }\n    var getTotalLength = getLengthFactory(1),\n        getPointAtLength = getLengthFactory(),\n        getSubpathsAtLength = getLengthFactory(0, 1);\n    function findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {\n        var t1 = 1 - t,\n            t13 = pow(t1, 3),\n            t12 = pow(t1, 2),\n            t2 = t * t,\n            t3 = t2 * t,\n            x = t13 * p1x + t12 * 3 * t * c1x + t1 * 3 * t * t * c2x + t3 * p2x,\n            y = t13 * p1y + t12 * 3 * t * c1y + t1 * 3 * t * t * c2y + t3 * p2y,\n            mx = p1x + 2 * t * (c1x - p1x) + t2 * (c2x - 2 * c1x + p1x),\n            my = p1y + 2 * t * (c1y - p1y) + t2 * (c2y - 2 * c1y + p1y),\n            nx = c1x + 2 * t * (c2x - c1x) + t2 * (p2x - 2 * c2x + c1x),\n            ny = c1y + 2 * t * (c2y - c1y) + t2 * (p2y - 2 * c2y + c1y),\n            ax = t1 * p1x + t * c1x,\n            ay = t1 * p1y + t * c1y,\n            cx = t1 * c2x + t * p2x,\n            cy = t1 * c2y + t * p2y,\n            alpha = (90 - math.atan2(mx - nx, my - ny) * 180 / PI);\n        // (mx > nx || my < ny) && (alpha += 180);\n        return {\n            x: x,\n            y: y,\n            m: {x: mx, y: my},\n            n: {x: nx, y: ny},\n            start: {x: ax, y: ay},\n            end: {x: cx, y: cy},\n            alpha: alpha\n        };\n    }\n    function bezierBBox(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {\n        if (!Snap.is(p1x, \"array\")) {\n            p1x = [p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y];\n        }\n        var bbox = curveDim.apply(null, p1x);\n        return box(\n            bbox.min.x,\n            bbox.min.y,\n            bbox.max.x - bbox.min.x,\n            bbox.max.y - bbox.min.y\n        );\n    }\n    function isPointInsideBBox(bbox, x, y) {\n        return  x >= bbox.x &&\n                x <= bbox.x + bbox.width &&\n                y >= bbox.y &&\n                y <= bbox.y + bbox.height;\n    }\n    function isBBoxIntersect(bbox1, bbox2) {\n        bbox1 = box(bbox1);\n        bbox2 = box(bbox2);\n        return isPointInsideBBox(bbox2, bbox1.x, bbox1.y)\n            || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y)\n            || isPointInsideBBox(bbox2, bbox1.x, bbox1.y2)\n            || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y2)\n            || isPointInsideBBox(bbox1, bbox2.x, bbox2.y)\n            || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y)\n            || isPointInsideBBox(bbox1, bbox2.x, bbox2.y2)\n            || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y2)\n            || (bbox1.x < bbox2.x2 && bbox1.x > bbox2.x\n                || bbox2.x < bbox1.x2 && bbox2.x > bbox1.x)\n            && (bbox1.y < bbox2.y2 && bbox1.y > bbox2.y\n                || bbox2.y < bbox1.y2 && bbox2.y > bbox1.y);\n    }\n    function base3(t, p1, p2, p3, p4) {\n        var t1 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4,\n            t2 = t * t1 + 6 * p1 - 12 * p2 + 6 * p3;\n        return t * t2 - 3 * p1 + 3 * p2;\n    }\n    function bezlen(x1, y1, x2, y2, x3, y3, x4, y4, z) {\n        if (z == null) {\n            z = 1;\n        }\n        z = z > 1 ? 1 : z < 0 ? 0 : z;\n        var z2 = z / 2,\n            n = 12,\n            Tvalues = [-.1252,.1252,-.3678,.3678,-.5873,.5873,-.7699,.7699,-.9041,.9041,-.9816,.9816],\n            Cvalues = [0.2491,0.2491,0.2335,0.2335,0.2032,0.2032,0.1601,0.1601,0.1069,0.1069,0.0472,0.0472],\n            sum = 0;\n        for (var i = 0; i < n; i++) {\n            var ct = z2 * Tvalues[i] + z2,\n                xbase = base3(ct, x1, x2, x3, x4),\n                ybase = base3(ct, y1, y2, y3, y4),\n                comb = xbase * xbase + ybase * ybase;\n            sum += Cvalues[i] * math.sqrt(comb);\n        }\n        return z2 * sum;\n    }\n    function getTotLen(x1, y1, x2, y2, x3, y3, x4, y4, ll) {\n        if (ll < 0 || bezlen(x1, y1, x2, y2, x3, y3, x4, y4) < ll) {\n            return;\n        }\n        var t = 1,\n            step = t / 2,\n            t2 = t - step,\n            l,\n            e = .01;\n        l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);\n        while (abs(l - ll) > e) {\n            step /= 2;\n            t2 += (l < ll ? 1 : -1) * step;\n            l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);\n        }\n        return t2;\n    }\n    function intersect(x1, y1, x2, y2, x3, y3, x4, y4) {\n        if (\n            mmax(x1, x2) < mmin(x3, x4) ||\n            mmin(x1, x2) > mmax(x3, x4) ||\n            mmax(y1, y2) < mmin(y3, y4) ||\n            mmin(y1, y2) > mmax(y3, y4)\n        ) {\n            return;\n        }\n        var nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4),\n            ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4),\n            denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n\n        if (!denominator) {\n            return;\n        }\n        var px = nx / denominator,\n            py = ny / denominator,\n            px2 = +px.toFixed(2),\n            py2 = +py.toFixed(2);\n        if (\n            px2 < +mmin(x1, x2).toFixed(2) ||\n            px2 > +mmax(x1, x2).toFixed(2) ||\n            px2 < +mmin(x3, x4).toFixed(2) ||\n            px2 > +mmax(x3, x4).toFixed(2) ||\n            py2 < +mmin(y1, y2).toFixed(2) ||\n            py2 > +mmax(y1, y2).toFixed(2) ||\n            py2 < +mmin(y3, y4).toFixed(2) ||\n            py2 > +mmax(y3, y4).toFixed(2)\n        ) {\n            return;\n        }\n        return {x: px, y: py};\n    }\n    function inter(bez1, bez2) {\n        return interHelper(bez1, bez2);\n    }\n    function interCount(bez1, bez2) {\n        return interHelper(bez1, bez2, 1);\n    }\n    function interHelper(bez1, bez2, justCount) {\n        var bbox1 = bezierBBox(bez1),\n            bbox2 = bezierBBox(bez2);\n        if (!isBBoxIntersect(bbox1, bbox2)) {\n            return justCount ? 0 : [];\n        }\n        var l1 = bezlen.apply(0, bez1),\n            l2 = bezlen.apply(0, bez2),\n            n1 = ~~(l1 / 8),\n            n2 = ~~(l2 / 8),\n            dots1 = [],\n            dots2 = [],\n            xy = {},\n            res = justCount ? 0 : [];\n        for (var i = 0; i < n1 + 1; i++) {\n            var p = findDotsAtSegment.apply(0, bez1.concat(i / n1));\n            dots1.push({x: p.x, y: p.y, t: i / n1});\n        }\n        for (i = 0; i < n2 + 1; i++) {\n            p = findDotsAtSegment.apply(0, bez2.concat(i / n2));\n            dots2.push({x: p.x, y: p.y, t: i / n2});\n        }\n        for (i = 0; i < n1; i++) {\n            for (var j = 0; j < n2; j++) {\n                var di = dots1[i],\n                    di1 = dots1[i + 1],\n                    dj = dots2[j],\n                    dj1 = dots2[j + 1],\n                    ci = abs(di1.x - di.x) < .001 ? \"y\" : \"x\",\n                    cj = abs(dj1.x - dj.x) < .001 ? \"y\" : \"x\",\n                    is = intersect(di.x, di.y, di1.x, di1.y, dj.x, dj.y, dj1.x, dj1.y);\n                if (is) {\n                    if (xy[is.x.toFixed(4)] == is.y.toFixed(4)) {\n                        continue;\n                    }\n                    xy[is.x.toFixed(4)] = is.y.toFixed(4);\n                    var t1 = di.t + abs((is[ci] - di[ci]) / (di1[ci] - di[ci])) * (di1.t - di.t),\n                        t2 = dj.t + abs((is[cj] - dj[cj]) / (dj1[cj] - dj[cj])) * (dj1.t - dj.t);\n                    if (t1 >= 0 && t1 <= 1 && t2 >= 0 && t2 <= 1) {\n                        if (justCount) {\n                            res++;\n                        } else {\n                            res.push({\n                                x: is.x,\n                                y: is.y,\n                                t1: t1,\n                                t2: t2\n                            });\n                        }\n                    }\n                }\n            }\n        }\n        return res;\n    }\n    function pathIntersection(path1, path2) {\n        return interPathHelper(path1, path2);\n    }\n    function pathIntersectionNumber(path1, path2) {\n        return interPathHelper(path1, path2, 1);\n    }\n    function interPathHelper(path1, path2, justCount) {\n        path1 = path2curve(path1);\n        path2 = path2curve(path2);\n        var x1, y1, x2, y2, x1m, y1m, x2m, y2m, bez1, bez2,\n            res = justCount ? 0 : [];\n        for (var i = 0, ii = path1.length; i < ii; i++) {\n            var pi = path1[i];\n            if (pi[0] == \"M\") {\n                x1 = x1m = pi[1];\n                y1 = y1m = pi[2];\n            } else {\n                if (pi[0] == \"C\") {\n                    bez1 = [x1, y1].concat(pi.slice(1));\n                    x1 = bez1[6];\n                    y1 = bez1[7];\n                } else {\n                    bez1 = [x1, y1, x1, y1, x1m, y1m, x1m, y1m];\n                    x1 = x1m;\n                    y1 = y1m;\n                }\n                for (var j = 0, jj = path2.length; j < jj; j++) {\n                    var pj = path2[j];\n                    if (pj[0] == \"M\") {\n                        x2 = x2m = pj[1];\n                        y2 = y2m = pj[2];\n                    } else {\n                        if (pj[0] == \"C\") {\n                            bez2 = [x2, y2].concat(pj.slice(1));\n                            x2 = bez2[6];\n                            y2 = bez2[7];\n                        } else {\n                            bez2 = [x2, y2, x2, y2, x2m, y2m, x2m, y2m];\n                            x2 = x2m;\n                            y2 = y2m;\n                        }\n                        var intr = interHelper(bez1, bez2, justCount);\n                        if (justCount) {\n                            res += intr;\n                        } else {\n                            for (var k = 0, kk = intr.length; k < kk; k++) {\n                                intr[k].segment1 = i;\n                                intr[k].segment2 = j;\n                                intr[k].bez1 = bez1;\n                                intr[k].bez2 = bez2;\n                            }\n                            res = res.concat(intr);\n                        }\n                    }\n                }\n            }\n        }\n        return res;\n    }\n    function isPointInsidePath(path, x, y) {\n        var bbox = pathBBox(path);\n        return isPointInsideBBox(bbox, x, y) &&\n               interPathHelper(path, [[\"M\", x, y], [\"H\", bbox.x2 + 10]], 1) % 2 == 1;\n    }\n    function pathBBox(path) {\n        var pth = paths(path);\n        if (pth.bbox) {\n            return clone(pth.bbox);\n        }\n        if (!path) {\n            return box();\n        }\n        path = path2curve(path);\n        var x = 0, \n            y = 0,\n            X = [],\n            Y = [],\n            p;\n        for (var i = 0, ii = path.length; i < ii; i++) {\n            p = path[i];\n            if (p[0] == \"M\") {\n                x = p[1];\n                y = p[2];\n                X.push(x);\n                Y.push(y);\n            } else {\n                var dim = curveDim(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);\n                X = X.concat(dim.min.x, dim.max.x);\n                Y = Y.concat(dim.min.y, dim.max.y);\n                x = p[5];\n                y = p[6];\n            }\n        }\n        var xmin = mmin.apply(0, X),\n            ymin = mmin.apply(0, Y),\n            xmax = mmax.apply(0, X),\n            ymax = mmax.apply(0, Y),\n            bb = box(xmin, ymin, xmax - xmin, ymax - ymin);\n        pth.bbox = clone(bb);\n        return bb;\n    }\n    function rectPath(x, y, w, h, r) {\n        if (r) {\n            return [\n                [\"M\", +x + (+r), y],\n                [\"l\", w - r * 2, 0],\n                [\"a\", r, r, 0, 0, 1, r, r],\n                [\"l\", 0, h - r * 2],\n                [\"a\", r, r, 0, 0, 1, -r, r],\n                [\"l\", r * 2 - w, 0],\n                [\"a\", r, r, 0, 0, 1, -r, -r],\n                [\"l\", 0, r * 2 - h],\n                [\"a\", r, r, 0, 0, 1, r, -r],\n                [\"z\"]\n            ];\n        }\n        var res = [[\"M\", x, y], [\"l\", w, 0], [\"l\", 0, h], [\"l\", -w, 0], [\"z\"]];\n        res.toString = toString;\n        return res;\n    }\n    function ellipsePath(x, y, rx, ry, a) {\n        if (a == null && ry == null) {\n            ry = rx;\n        }\n        x = +x;\n        y = +y;\n        rx = +rx;\n        ry = +ry;\n        if (a != null) {\n            var rad = Math.PI / 180,\n                x1 = x + rx * Math.cos(-ry * rad),\n                x2 = x + rx * Math.cos(-a * rad),\n                y1 = y + rx * Math.sin(-ry * rad),\n                y2 = y + rx * Math.sin(-a * rad),\n                res = [[\"M\", x1, y1], [\"A\", rx, rx, 0, +(a - ry > 180), 0, x2, y2]];\n        } else {\n            res = [\n                [\"M\", x, y],\n                [\"m\", 0, -ry],\n                [\"a\", rx, ry, 0, 1, 1, 0, 2 * ry],\n                [\"a\", rx, ry, 0, 1, 1, 0, -2 * ry],\n                [\"z\"]\n            ];\n        }\n        res.toString = toString;\n        return res;\n    }\n    var unit2px = Snap._unit2px,\n        getPath = {\n        path: function (el) {\n            return el.attr(\"path\");\n        },\n        circle: function (el) {\n            var attr = unit2px(el);\n            return ellipsePath(attr.cx, attr.cy, attr.r);\n        },\n        ellipse: function (el) {\n            var attr = unit2px(el);\n            return ellipsePath(attr.cx || 0, attr.cy || 0, attr.rx, attr.ry);\n        },\n        rect: function (el) {\n            var attr = unit2px(el);\n            return rectPath(attr.x || 0, attr.y || 0, attr.width, attr.height, attr.rx, attr.ry);\n        },\n        image: function (el) {\n            var attr = unit2px(el);\n            return rectPath(attr.x || 0, attr.y || 0, attr.width, attr.height);\n        },\n        line: function (el) {\n            return \"M\" + [el.attr(\"x1\") || 0, el.attr(\"y1\") || 0, el.attr(\"x2\"), el.attr(\"y2\")];\n        },\n        polyline: function (el) {\n            return \"M\" + el.attr(\"points\");\n        },\n        polygon: function (el) {\n            return \"M\" + el.attr(\"points\") + \"z\";\n        },\n        deflt: function (el) {\n            var bbox = el.node.getBBox();\n            return rectPath(bbox.x, bbox.y, bbox.width, bbox.height);\n        }\n    };\n    function pathToRelative(pathArray) {\n        var pth = paths(pathArray),\n            lowerCase = String.prototype.toLowerCase;\n        if (pth.rel) {\n            return pathClone(pth.rel);\n        }\n        if (!Snap.is(pathArray, \"array\") || !Snap.is(pathArray && pathArray[0], \"array\")) {\n            pathArray = Snap.parsePathString(pathArray);\n        }\n        var res = [],\n            x = 0,\n            y = 0,\n            mx = 0,\n            my = 0,\n            start = 0;\n        if (pathArray[0][0] == \"M\") {\n            x = pathArray[0][1];\n            y = pathArray[0][2];\n            mx = x;\n            my = y;\n            start++;\n            res.push([\"M\", x, y]);\n        }\n        for (var i = start, ii = pathArray.length; i < ii; i++) {\n            var r = res[i] = [],\n                pa = pathArray[i];\n            if (pa[0] != lowerCase.call(pa[0])) {\n                r[0] = lowerCase.call(pa[0]);\n                switch (r[0]) {\n                    case \"a\":\n                        r[1] = pa[1];\n                        r[2] = pa[2];\n                        r[3] = pa[3];\n                        r[4] = pa[4];\n                        r[5] = pa[5];\n                        r[6] = +(pa[6] - x).toFixed(3);\n                        r[7] = +(pa[7] - y).toFixed(3);\n                        break;\n                    case \"v\":\n                        r[1] = +(pa[1] - y).toFixed(3);\n                        break;\n                    case \"m\":\n                        mx = pa[1];\n                        my = pa[2];\n                    default:\n                        for (var j = 1, jj = pa.length; j < jj; j++) {\n                            r[j] = +(pa[j] - ((j % 2) ? x : y)).toFixed(3);\n                        }\n                }\n            } else {\n                r = res[i] = [];\n                if (pa[0] == \"m\") {\n                    mx = pa[1] + x;\n                    my = pa[2] + y;\n                }\n                for (var k = 0, kk = pa.length; k < kk; k++) {\n                    res[i][k] = pa[k];\n                }\n            }\n            var len = res[i].length;\n            switch (res[i][0]) {\n                case \"z\":\n                    x = mx;\n                    y = my;\n                    break;\n                case \"h\":\n                    x += +res[i][len - 1];\n                    break;\n                case \"v\":\n                    y += +res[i][len - 1];\n                    break;\n                default:\n                    x += +res[i][len - 2];\n                    y += +res[i][len - 1];\n            }\n        }\n        res.toString = toString;\n        pth.rel = pathClone(res);\n        return res;\n    }\n    function pathToAbsolute(pathArray) {\n        var pth = paths(pathArray);\n        if (pth.abs) {\n            return pathClone(pth.abs);\n        }\n        if (!is(pathArray, \"array\") || !is(pathArray && pathArray[0], \"array\")) { // rough assumption\n            pathArray = Snap.parsePathString(pathArray);\n        }\n        if (!pathArray || !pathArray.length) {\n            return [[\"M\", 0, 0]];\n        }\n        var res = [],\n            x = 0,\n            y = 0,\n            mx = 0,\n            my = 0,\n            start = 0,\n            pa0;\n        if (pathArray[0][0] == \"M\") {\n            x = +pathArray[0][1];\n            y = +pathArray[0][2];\n            mx = x;\n            my = y;\n            start++;\n            res[0] = [\"M\", x, y];\n        }\n        var crz = pathArray.length == 3 &&\n            pathArray[0][0] == \"M\" &&\n            pathArray[1][0].toUpperCase() == \"R\" &&\n            pathArray[2][0].toUpperCase() == \"Z\";\n        for (var r, pa, i = start, ii = pathArray.length; i < ii; i++) {\n            res.push(r = []);\n            pa = pathArray[i];\n            pa0 = pa[0];\n            if (pa0 != pa0.toUpperCase()) {\n                r[0] = pa0.toUpperCase();\n                switch (r[0]) {\n                    case \"A\":\n                        r[1] = pa[1];\n                        r[2] = pa[2];\n                        r[3] = pa[3];\n                        r[4] = pa[4];\n                        r[5] = pa[5];\n                        r[6] = +pa[6] + x;\n                        r[7] = +pa[7] + y;\n                        break;\n                    case \"V\":\n                        r[1] = +pa[1] + y;\n                        break;\n                    case \"H\":\n                        r[1] = +pa[1] + x;\n                        break;\n                    case \"R\":\n                        var dots = [x, y].concat(pa.slice(1));\n                        for (var j = 2, jj = dots.length; j < jj; j++) {\n                            dots[j] = +dots[j] + x;\n                            dots[++j] = +dots[j] + y;\n                        }\n                        res.pop();\n                        res = res.concat(catmullRom2bezier(dots, crz));\n                        break;\n                    case \"O\":\n                        res.pop();\n                        dots = ellipsePath(x, y, pa[1], pa[2]);\n                        dots.push(dots[0]);\n                        res = res.concat(dots);\n                        break;\n                    case \"U\":\n                        res.pop();\n                        res = res.concat(ellipsePath(x, y, pa[1], pa[2], pa[3]));\n                        r = [\"U\"].concat(res[res.length - 1].slice(-2));\n                        break;\n                    case \"M\":\n                        mx = +pa[1] + x;\n                        my = +pa[2] + y;\n                    default:\n                        for (j = 1, jj = pa.length; j < jj; j++) {\n                            r[j] = +pa[j] + ((j % 2) ? x : y);\n                        }\n                }\n            } else if (pa0 == \"R\") {\n                dots = [x, y].concat(pa.slice(1));\n                res.pop();\n                res = res.concat(catmullRom2bezier(dots, crz));\n                r = [\"R\"].concat(pa.slice(-2));\n            } else if (pa0 == \"O\") {\n                res.pop();\n                dots = ellipsePath(x, y, pa[1], pa[2]);\n                dots.push(dots[0]);\n                res = res.concat(dots);\n            } else if (pa0 == \"U\") {\n                res.pop();\n                res = res.concat(ellipsePath(x, y, pa[1], pa[2], pa[3]));\n                r = [\"U\"].concat(res[res.length - 1].slice(-2));\n            } else {\n                for (var k = 0, kk = pa.length; k < kk; k++) {\n                    r[k] = pa[k];\n                }\n            }\n            pa0 = pa0.toUpperCase();\n            if (pa0 != \"O\") {\n                switch (r[0]) {\n                    case \"Z\":\n                        x = +mx;\n                        y = +my;\n                        break;\n                    case \"H\":\n                        x = r[1];\n                        break;\n                    case \"V\":\n                        y = r[1];\n                        break;\n                    case \"M\":\n                        mx = r[r.length - 2];\n                        my = r[r.length - 1];\n                    default:\n                        x = r[r.length - 2];\n                        y = r[r.length - 1];\n                }\n            }\n        }\n        res.toString = toString;\n        pth.abs = pathClone(res);\n        return res;\n    }\n    function l2c(x1, y1, x2, y2) {\n        return [x1, y1, x2, y2, x2, y2];\n    }\n    function q2c(x1, y1, ax, ay, x2, y2) {\n        var _13 = 1 / 3,\n            _23 = 2 / 3;\n        return [\n                _13 * x1 + _23 * ax,\n                _13 * y1 + _23 * ay,\n                _13 * x2 + _23 * ax,\n                _13 * y2 + _23 * ay,\n                x2,\n                y2\n            ];\n    }\n    function a2c(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {\n        // for more information of where this math came from visit:\n        // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n        var _120 = PI * 120 / 180,\n            rad = PI / 180 * (+angle || 0),\n            res = [],\n            xy,\n            rotate = Snap._.cacher(function (x, y, rad) {\n                var X = x * math.cos(rad) - y * math.sin(rad),\n                    Y = x * math.sin(rad) + y * math.cos(rad);\n                return {x: X, y: Y};\n            });\n        if (!recursive) {\n            xy = rotate(x1, y1, -rad);\n            x1 = xy.x;\n            y1 = xy.y;\n            xy = rotate(x2, y2, -rad);\n            x2 = xy.x;\n            y2 = xy.y;\n            var cos = math.cos(PI / 180 * angle),\n                sin = math.sin(PI / 180 * angle),\n                x = (x1 - x2) / 2,\n                y = (y1 - y2) / 2;\n            var h = (x * x) / (rx * rx) + (y * y) / (ry * ry);\n            if (h > 1) {\n                h = math.sqrt(h);\n                rx = h * rx;\n                ry = h * ry;\n            }\n            var rx2 = rx * rx,\n                ry2 = ry * ry,\n                k = (large_arc_flag == sweep_flag ? -1 : 1) *\n                    math.sqrt(abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x))),\n                cx = k * rx * y / ry + (x1 + x2) / 2,\n                cy = k * -ry * x / rx + (y1 + y2) / 2,\n                f1 = math.asin(((y1 - cy) / ry).toFixed(9)),\n                f2 = math.asin(((y2 - cy) / ry).toFixed(9));\n\n            f1 = x1 < cx ? PI - f1 : f1;\n            f2 = x2 < cx ? PI - f2 : f2;\n            f1 < 0 && (f1 = PI * 2 + f1);\n            f2 < 0 && (f2 = PI * 2 + f2);\n            if (sweep_flag && f1 > f2) {\n                f1 = f1 - PI * 2;\n            }\n            if (!sweep_flag && f2 > f1) {\n                f2 = f2 - PI * 2;\n            }\n        } else {\n            f1 = recursive[0];\n            f2 = recursive[1];\n            cx = recursive[2];\n            cy = recursive[3];\n        }\n        var df = f2 - f1;\n        if (abs(df) > _120) {\n            var f2old = f2,\n                x2old = x2,\n                y2old = y2;\n            f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);\n            x2 = cx + rx * math.cos(f2);\n            y2 = cy + ry * math.sin(f2);\n            res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);\n        }\n        df = f2 - f1;\n        var c1 = math.cos(f1),\n            s1 = math.sin(f1),\n            c2 = math.cos(f2),\n            s2 = math.sin(f2),\n            t = math.tan(df / 4),\n            hx = 4 / 3 * rx * t,\n            hy = 4 / 3 * ry * t,\n            m1 = [x1, y1],\n            m2 = [x1 + hx * s1, y1 - hy * c1],\n            m3 = [x2 + hx * s2, y2 - hy * c2],\n            m4 = [x2, y2];\n        m2[0] = 2 * m1[0] - m2[0];\n        m2[1] = 2 * m1[1] - m2[1];\n        if (recursive) {\n            return [m2, m3, m4].concat(res);\n        } else {\n            res = [m2, m3, m4].concat(res).join().split(\",\");\n            var newres = [];\n            for (var i = 0, ii = res.length; i < ii; i++) {\n                newres[i] = i % 2 ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;\n            }\n            return newres;\n        }\n    }\n    function findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {\n        var t1 = 1 - t;\n        return {\n            x: pow(t1, 3) * p1x + pow(t1, 2) * 3 * t * c1x + t1 * 3 * t * t * c2x + pow(t, 3) * p2x,\n            y: pow(t1, 3) * p1y + pow(t1, 2) * 3 * t * c1y + t1 * 3 * t * t * c2y + pow(t, 3) * p2y\n        };\n    }\n    \n    // Returns bounding box of cubic bezier curve.\n    // Source: http://blog.hackers-cafe.net/2009/06/how-to-calculate-bezier-curves-bounding.html\n    // Original version: NISHIO Hirokazu\n    // Modifications: https://github.com/timo22345\n    function curveDim(x0, y0, x1, y1, x2, y2, x3, y3) {\n        var tvalues = [],\n            bounds = [[], []],\n            a, b, c, t, t1, t2, b2ac, sqrtb2ac;\n        for (var i = 0; i < 2; ++i) {\n            if (i == 0) {\n                b = 6 * x0 - 12 * x1 + 6 * x2;\n                a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;\n                c = 3 * x1 - 3 * x0;\n            } else {\n                b = 6 * y0 - 12 * y1 + 6 * y2;\n                a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;\n                c = 3 * y1 - 3 * y0;\n            }\n            if (abs(a) < 1e-12) {\n                if (abs(b) < 1e-12) {\n                    continue;\n                }\n                t = -c / b;\n                if (0 < t && t < 1) {\n                    tvalues.push(t);\n                }\n                continue;\n            }\n            b2ac = b * b - 4 * c * a;\n            sqrtb2ac = math.sqrt(b2ac);\n            if (b2ac < 0) {\n                continue;\n            }\n            t1 = (-b + sqrtb2ac) / (2 * a);\n            if (0 < t1 && t1 < 1) {\n                tvalues.push(t1);\n            }\n            t2 = (-b - sqrtb2ac) / (2 * a);\n            if (0 < t2 && t2 < 1) {\n                tvalues.push(t2);\n            }\n        }\n\n        var x, y, j = tvalues.length,\n            jlen = j,\n            mt;\n        while (j--) {\n            t = tvalues[j];\n            mt = 1 - t;\n            bounds[0][j] = (mt * mt * mt * x0) + (3 * mt * mt * t * x1) + (3 * mt * t * t * x2) + (t * t * t * x3);\n            bounds[1][j] = (mt * mt * mt * y0) + (3 * mt * mt * t * y1) + (3 * mt * t * t * y2) + (t * t * t * y3);\n        }\n\n        bounds[0][jlen] = x0;\n        bounds[1][jlen] = y0;\n        bounds[0][jlen + 1] = x3;\n        bounds[1][jlen + 1] = y3;\n        bounds[0].length = bounds[1].length = jlen + 2;\n\n\n        return {\n          min: {x: mmin.apply(0, bounds[0]), y: mmin.apply(0, bounds[1])},\n          max: {x: mmax.apply(0, bounds[0]), y: mmax.apply(0, bounds[1])}\n        };\n    }\n\n    function path2curve(path, path2) {\n        var pth = !path2 && paths(path);\n        if (!path2 && pth.curve) {\n            return pathClone(pth.curve);\n        }\n        var p = pathToAbsolute(path),\n            p2 = path2 && pathToAbsolute(path2),\n            attrs = {x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null},\n            attrs2 = {x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null},\n            processPath = function (path, d, pcom) {\n                var nx, ny;\n                if (!path) {\n                    return [\"C\", d.x, d.y, d.x, d.y, d.x, d.y];\n                }\n                !(path[0] in {T: 1, Q: 1}) && (d.qx = d.qy = null);\n                switch (path[0]) {\n                    case \"M\":\n                        d.X = path[1];\n                        d.Y = path[2];\n                        break;\n                    case \"A\":\n                        path = [\"C\"].concat(a2c.apply(0, [d.x, d.y].concat(path.slice(1))));\n                        break;\n                    case \"S\":\n                        if (pcom == \"C\" || pcom == \"S\") { // In \"S\" case we have to take into account, if the previous command is C/S.\n                            nx = d.x * 2 - d.bx;          // And reflect the previous\n                            ny = d.y * 2 - d.by;          // command's control point relative to the current point.\n                        }\n                        else {                            // or some else or nothing\n                            nx = d.x;\n                            ny = d.y;\n                        }\n                        path = [\"C\", nx, ny].concat(path.slice(1));\n                        break;\n                    case \"T\":\n                        if (pcom == \"Q\" || pcom == \"T\") { // In \"T\" case we have to take into account, if the previous command is Q/T.\n                            d.qx = d.x * 2 - d.qx;        // And make a reflection similar\n                            d.qy = d.y * 2 - d.qy;        // to case \"S\".\n                        }\n                        else {                            // or something else or nothing\n                            d.qx = d.x;\n                            d.qy = d.y;\n                        }\n                        path = [\"C\"].concat(q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));\n                        break;\n                    case \"Q\":\n                        d.qx = path[1];\n                        d.qy = path[2];\n                        path = [\"C\"].concat(q2c(d.x, d.y, path[1], path[2], path[3], path[4]));\n                        break;\n                    case \"L\":\n                        path = [\"C\"].concat(l2c(d.x, d.y, path[1], path[2]));\n                        break;\n                    case \"H\":\n                        path = [\"C\"].concat(l2c(d.x, d.y, path[1], d.y));\n                        break;\n                    case \"V\":\n                        path = [\"C\"].concat(l2c(d.x, d.y, d.x, path[1]));\n                        break;\n                    case \"Z\":\n                        path = [\"C\"].concat(l2c(d.x, d.y, d.X, d.Y));\n                        break;\n                }\n                return path;\n            },\n            fixArc = function (pp, i) {\n                if (pp[i].length > 7) {\n                    pp[i].shift();\n                    var pi = pp[i];\n                    while (pi.length) {\n                        pcoms1[i] = \"A\"; // if created multiple C:s, their original seg is saved\n                        p2 && (pcoms2[i] = \"A\"); // the same as above\n                        pp.splice(i++, 0, [\"C\"].concat(pi.splice(0, 6)));\n                    }\n                    pp.splice(i, 1);\n                    ii = mmax(p.length, p2 && p2.length || 0);\n                }\n            },\n            fixM = function (path1, path2, a1, a2, i) {\n                if (path1 && path2 && path1[i][0] == \"M\" && path2[i][0] != \"M\") {\n                    path2.splice(i, 0, [\"M\", a2.x, a2.y]);\n                    a1.bx = 0;\n                    a1.by = 0;\n                    a1.x = path1[i][1];\n                    a1.y = path1[i][2];\n                    ii = mmax(p.length, p2 && p2.length || 0);\n                }\n            },\n            pcoms1 = [], // path commands of original path p\n            pcoms2 = [], // path commands of original path p2\n            pfirst = \"\", // temporary holder for original path command\n            pcom = \"\"; // holder for previous path command of original path\n        for (var i = 0, ii = mmax(p.length, p2 && p2.length || 0); i < ii; i++) {\n            p[i] && (pfirst = p[i][0]); // save current path command\n\n            if (pfirst != \"C\") // C is not saved yet, because it may be result of conversion\n            {\n                pcoms1[i] = pfirst; // Save current path command\n                i && ( pcom = pcoms1[i - 1]); // Get previous path command pcom\n            }\n            p[i] = processPath(p[i], attrs, pcom); // Previous path command is inputted to processPath\n\n            if (pcoms1[i] != \"A\" && pfirst == \"C\") pcoms1[i] = \"C\"; // A is the only command\n            // which may produce multiple C:s\n            // so we have to make sure that C is also C in original path\n\n            fixArc(p, i); // fixArc adds also the right amount of A:s to pcoms1\n\n            if (p2) { // the same procedures is done to p2\n                p2[i] && (pfirst = p2[i][0]);\n                if (pfirst != \"C\") {\n                    pcoms2[i] = pfirst;\n                    i && (pcom = pcoms2[i - 1]);\n                }\n                p2[i] = processPath(p2[i], attrs2, pcom);\n\n                if (pcoms2[i] != \"A\" && pfirst == \"C\") {\n                    pcoms2[i] = \"C\";\n                }\n\n                fixArc(p2, i);\n            }\n            fixM(p, p2, attrs, attrs2, i);\n            fixM(p2, p, attrs2, attrs, i);\n            var seg = p[i],\n                seg2 = p2 && p2[i],\n                seglen = seg.length,\n                seg2len = p2 && seg2.length;\n            attrs.x = seg[seglen - 2];\n            attrs.y = seg[seglen - 1];\n            attrs.bx = toFloat(seg[seglen - 4]) || attrs.x;\n            attrs.by = toFloat(seg[seglen - 3]) || attrs.y;\n            attrs2.bx = p2 && (toFloat(seg2[seg2len - 4]) || attrs2.x);\n            attrs2.by = p2 && (toFloat(seg2[seg2len - 3]) || attrs2.y);\n            attrs2.x = p2 && seg2[seg2len - 2];\n            attrs2.y = p2 && seg2[seg2len - 1];\n        }\n        if (!p2) {\n            pth.curve = pathClone(p);\n        }\n        return p2 ? [p, p2] : p;\n    }\n    function mapPath(path, matrix) {\n        if (!matrix) {\n            return path;\n        }\n        var x, y, i, j, ii, jj, pathi;\n        path = path2curve(path);\n        for (i = 0, ii = path.length; i < ii; i++) {\n            pathi = path[i];\n            for (j = 1, jj = pathi.length; j < jj; j += 2) {\n                x = matrix.x(pathi[j], pathi[j + 1]);\n                y = matrix.y(pathi[j], pathi[j + 1]);\n                pathi[j] = x;\n                pathi[j + 1] = y;\n            }\n        }\n        return path;\n    }\n\n    // http://schepers.cc/getting-to-the-point\n    function catmullRom2bezier(crp, z) {\n        var d = [];\n        for (var i = 0, iLen = crp.length; iLen - 2 * !z > i; i += 2) {\n            var p = [\n                        {x: +crp[i - 2], y: +crp[i - 1]},\n                        {x: +crp[i],     y: +crp[i + 1]},\n                        {x: +crp[i + 2], y: +crp[i + 3]},\n                        {x: +crp[i + 4], y: +crp[i + 5]}\n                    ];\n            if (z) {\n                if (!i) {\n                    p[0] = {x: +crp[iLen - 2], y: +crp[iLen - 1]};\n                } else if (iLen - 4 == i) {\n                    p[3] = {x: +crp[0], y: +crp[1]};\n                } else if (iLen - 2 == i) {\n                    p[2] = {x: +crp[0], y: +crp[1]};\n                    p[3] = {x: +crp[2], y: +crp[3]};\n                }\n            } else {\n                if (iLen - 4 == i) {\n                    p[3] = p[2];\n                } else if (!i) {\n                    p[0] = {x: +crp[i], y: +crp[i + 1]};\n                }\n            }\n            d.push([\"C\",\n                  (-p[0].x + 6 * p[1].x + p[2].x) / 6,\n                  (-p[0].y + 6 * p[1].y + p[2].y) / 6,\n                  (p[1].x + 6 * p[2].x - p[3].x) / 6,\n                  (p[1].y + 6*p[2].y - p[3].y) / 6,\n                  p[2].x,\n                  p[2].y\n            ]);\n        }\n\n        return d;\n    }\n\n    // export\n    Snap.path = paths;\n\n    /*/\n     * Snap.path.getTotalLength\n     [ method ]\n     **\n     * Returns the length of the given path in pixels\n     **\n     - path (string) SVG path string\n     **\n     = (number) length\n    /*/\n    Snap.path.getTotalLength = getTotalLength;\n    /*/\n     * Snap.path.getPointAtLength\n     [ method ]\n     **\n     * Returns the coordinates of the point located at the given length along the given path\n     **\n     - path (string) SVG path string\n     - length (number) length, in pixels, from the start of the path, excluding non-rendering jumps\n     **\n     = (object) representation of the point:\n     o {\n     o     x: (number) x coordinate,\n     o     y: (number) y coordinate,\n     o     alpha: (number) angle of derivative\n     o }\n    /*/\n    Snap.path.getPointAtLength = getPointAtLength;\n    /*/\n     * Snap.path.getSubpath\n     [ method ]\n     **\n     * Returns the subpath of a given path between given start and end lengths\n     **\n     - path (string) SVG path string\n     - from (number) length, in pixels, from the start of the path to the start of the segment\n     - to (number) length, in pixels, from the start of the path to the end of the segment\n     **\n     = (string) path string definition for the segment\n    /*/\n    Snap.path.getSubpath = function (path, from, to) {\n        if (this.getTotalLength(path) - to < 1e-6) {\n            return getSubpathsAtLength(path, from).end;\n        }\n        var a = getSubpathsAtLength(path, to, 1);\n        return from ? getSubpathsAtLength(a, from).end : a;\n    };\n    /*/\n     * Element.getTotalLength\n     [ method ]\n     **\n     * Returns the length of the path in pixels (only works for `path` elements)\n     = (number) length\n    /*/\n    elproto.getTotalLength = function () {\n        if (this.node.getTotalLength) {\n            return this.node.getTotalLength();\n        }\n    };\n    // SIERRA Element.getPointAtLength()/Element.getTotalLength(): If a <path> is broken into different segments, is the jump distance to the new coordinates set by the _M_ or _m_ commands calculated as part of the path's total length?\n    /*/\n     * Element.getPointAtLength\n     [ method ]\n     **\n     * Returns coordinates of the point located at the given length on the given path (only works for `path` elements)\n     **\n     - length (number) length, in pixels, from the start of the path, excluding non-rendering jumps\n     **\n     = (object) representation of the point:\n     o {\n     o     x: (number) x coordinate,\n     o     y: (number) y coordinate,\n     o     alpha: (number) angle of derivative\n     o }\n    /*/\n    elproto.getPointAtLength = function (length) {\n        return getPointAtLength(this.attr(\"d\"), length);\n    };\n    // SIERRA Element.getSubpath(): Similar to the problem for Element.getPointAtLength(). Unclear how this would work for a segmented path. Overall, the concept of _subpath_ and what I'm calling a _segment_ (series of non-_M_ or _Z_ commands) is unclear.\n    /*/\n     * Element.getSubpath\n     [ method ]\n     **\n     * Returns subpath of a given element from given start and end lengths (only works for `path` elements)\n     **\n     - from (number) length, in pixels, from the start of the path to the start of the segment\n     - to (number) length, in pixels, from the start of the path to the end of the segment\n     **\n     = (string) path string definition for the segment\n    /*/\n    elproto.getSubpath = function (from, to) {\n        return Snap.path.getSubpath(this.attr(\"d\"), from, to);\n    };\n    Snap._.box = box;\n    /*/\n     * Snap.path.findDotsAtSegment\n     [ method ]\n     **\n     * Utility method\n     **\n     * Finds dot coordinates on the given cubic beziér curve at the given t\n     - p1x (number) x of the first point of the curve\n     - p1y (number) y of the first point of the curve\n     - c1x (number) x of the first anchor of the curve\n     - c1y (number) y of the first anchor of the curve\n     - c2x (number) x of the second anchor of the curve\n     - c2y (number) y of the second anchor of the curve\n     - p2x (number) x of the second point of the curve\n     - p2y (number) y of the second point of the curve\n     - t (number) position on the curve (0..1)\n     = (object) point information in format:\n     o {\n     o     x: (number) x coordinate of the point,\n     o     y: (number) y coordinate of the point,\n     o     m: {\n     o         x: (number) x coordinate of the left anchor,\n     o         y: (number) y coordinate of the left anchor\n     o     },\n     o     n: {\n     o         x: (number) x coordinate of the right anchor,\n     o         y: (number) y coordinate of the right anchor\n     o     },\n     o     start: {\n     o         x: (number) x coordinate of the start of the curve,\n     o         y: (number) y coordinate of the start of the curve\n     o     },\n     o     end: {\n     o         x: (number) x coordinate of the end of the curve,\n     o         y: (number) y coordinate of the end of the curve\n     o     },\n     o     alpha: (number) angle of the curve derivative at the point\n     o }\n    /*/\n    Snap.path.findDotsAtSegment = findDotsAtSegment;\n    /*/\n     * Snap.path.bezierBBox\n     [ method ]\n     **\n     * Utility method\n     **\n     * Returns the bounding box of a given cubic beziér curve\n     - p1x (number) x of the first point of the curve\n     - p1y (number) y of the first point of the curve\n     - c1x (number) x of the first anchor of the curve\n     - c1y (number) y of the first anchor of the curve\n     - c2x (number) x of the second anchor of the curve\n     - c2y (number) y of the second anchor of the curve\n     - p2x (number) x of the second point of the curve\n     - p2y (number) y of the second point of the curve\n     * or\n     - bez (array) array of six points for beziér curve\n     = (object) bounding box\n     o {\n     o     x: (number) x coordinate of the left top point of the box,\n     o     y: (number) y coordinate of the left top point of the box,\n     o     x2: (number) x coordinate of the right bottom point of the box,\n     o     y2: (number) y coordinate of the right bottom point of the box,\n     o     width: (number) width of the box,\n     o     height: (number) height of the box\n     o }\n    /*/\n    Snap.path.bezierBBox = bezierBBox;\n    /*/\n     * Snap.path.isPointInsideBBox\n     [ method ]\n     **\n     * Utility method\n     **\n     * Returns `true` if given point is inside bounding box\n     - bbox (string) bounding box\n     - x (string) x coordinate of the point\n     - y (string) y coordinate of the point\n     = (boolean) `true` if point is inside\n    /*/\n    Snap.path.isPointInsideBBox = isPointInsideBBox;\n    /*/\n     * Snap.path.isBBoxIntersect\n     [ method ]\n     **\n     * Utility method\n     **\n     * Returns `true` if two bounding boxes intersect\n     - bbox1 (string) first bounding box\n     - bbox2 (string) second bounding box\n     = (boolean) `true` if bounding boxes intersect\n    /*/\n    Snap.path.isBBoxIntersect = isBBoxIntersect;\n    /*/\n     * Snap.path.intersection\n     [ method ]\n     **\n     * Utility method\n     **\n     * Finds intersections of two paths\n     - path1 (string) path string\n     - path2 (string) path string\n     = (array) dots of intersection\n     o [\n     o     {\n     o         x: (number) x coordinate of the point,\n     o         y: (number) y coordinate of the point,\n     o         t1: (number) t value for segment of path1,\n     o         t2: (number) t value for segment of path2,\n     o         segment1: (number) order number for segment of path1,\n     o         segment2: (number) order number for segment of path2,\n     o         bez1: (array) eight coordinates representing beziér curve for the segment of path1,\n     o         bez2: (array) eight coordinates representing beziér curve for the segment of path2\n     o     }\n     o ]\n    /*/\n    Snap.path.intersection = pathIntersection;\n    Snap.path.intersectionNumber = pathIntersectionNumber;\n    /*/\n     * Snap.path.isPointInside\n     [ method ]\n     **\n     * Utility method\n     **\n     * Returns `true` if given point is inside a given closed path.\n     *\n     * Note: fill mode doesn’t affect the result of this method.\n     - path (string) path string\n     - x (number) x of the point\n     - y (number) y of the point\n     = (boolean) `true` if point is inside the path\n    /*/\n    Snap.path.isPointInside = isPointInsidePath;\n    /*/\n     * Snap.path.getBBox\n     [ method ]\n     **\n     * Utility method\n     **\n     * Returns the bounding box of a given path\n     - path (string) path string\n     = (object) bounding box\n     o {\n     o     x: (number) x coordinate of the left top point of the box,\n     o     y: (number) y coordinate of the left top point of the box,\n     o     x2: (number) x coordinate of the right bottom point of the box,\n     o     y2: (number) y coordinate of the right bottom point of the box,\n     o     width: (number) width of the box,\n     o     height: (number) height of the box\n     o }\n    /*/\n    Snap.path.getBBox = pathBBox;\n    Snap.path.get = getPath;\n    /*/\n     * Snap.path.toRelative\n     [ method ]\n     **\n     * Utility method\n     **\n     * Converts path coordinates into relative values\n     - path (string) path string\n     = (array) path string\n    /*/\n    Snap.path.toRelative = pathToRelative;\n    /*/\n     * Snap.path.toAbsolute\n     [ method ]\n     **\n     * Utility method\n     **\n     * Converts path coordinates into absolute values\n     - path (string) path string\n     = (array) path string\n    /*/\n    Snap.path.toAbsolute = pathToAbsolute;\n    /*/\n     * Snap.path.toCubic\n     [ method ]\n     **\n     * Utility method\n     **\n     * Converts path to a new path where all segments are cubic beziér curves\n     - pathString (string|array) path string or array of segments\n     = (array) array of segments\n    /*/\n    Snap.path.toCubic = path2curve;\n    /*/\n     * Snap.path.map\n     [ method ]\n     **\n     * Transform the path string with the given matrix\n     - path (string) path string\n     - matrix (object) see @Matrix\n     = (string) transformed path string\n    /*/\n    Snap.path.map = mapPath;\n    Snap.path.toString = toString;\n    Snap.path.clone = pathClone;\n});\n// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n// \n// http://www.apache.org/licenses/LICENSE-2.0\n// \n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nSnap.plugin(function (Snap, Element, Paper, glob) {\n    var elproto = Element.prototype,\n    has = \"hasOwnProperty\",\n    supportsTouch = \"createTouch\" in glob.doc,\n    events = [\n        \"click\", \"dblclick\", \"mousedown\", \"mousemove\", \"mouseout\",\n        \"mouseover\", \"mouseup\", \"touchstart\", \"touchmove\", \"touchend\",\n        \"touchcancel\"\n    ],\n    touchMap = {\n        mousedown: \"touchstart\",\n        mousemove: \"touchmove\",\n        mouseup: \"touchend\"\n    },\n    getScroll = function (xy, el) {\n        var name = xy == \"y\" ? \"scrollTop\" : \"scrollLeft\",\n            doc = el && el.node ? el.node.ownerDocument : glob.doc;\n        return doc[name in doc.documentElement ? \"documentElement\" : \"body\"][name];\n    },\n    preventDefault = function () {\n        this.returnValue = false;\n    },\n    preventTouch = function () {\n        return this.originalEvent.preventDefault();\n    },\n    stopPropagation = function () {\n        this.cancelBubble = true;\n    },\n    stopTouch = function () {\n        return this.originalEvent.stopPropagation();\n    },\n    addEvent = (function () {\n        if (glob.doc.addEventListener) {\n            return function (obj, type, fn, element) {\n                var realName = supportsTouch && touchMap[type] ? touchMap[type] : type,\n                    f = function (e) {\n                        var scrollY = getScroll(\"y\", element),\n                            scrollX = getScroll(\"x\", element);\n                        if (supportsTouch && touchMap[has](type)) {\n                            for (var i = 0, ii = e.targetTouches && e.targetTouches.length; i < ii; i++) {\n                                if (e.targetTouches[i].target == obj || obj.contains(e.targetTouches[i].target)) {\n                                    var olde = e;\n                                    e = e.targetTouches[i];\n                                    e.originalEvent = olde;\n                                    e.preventDefault = preventTouch;\n                                    e.stopPropagation = stopTouch;\n                                    break;\n                                }\n                            }\n                        }\n                        var x = e.clientX + scrollX,\n                            y = e.clientY + scrollY;\n                        return fn.call(element, e, x, y);\n                    };\n\n                if (type !== realName) {\n                    obj.addEventListener(type, f, false);\n                }\n\n                obj.addEventListener(realName, f, false);\n\n                return function () {\n                    if (type !== realName) {\n                        obj.removeEventListener(type, f, false);\n                    }\n\n                    obj.removeEventListener(realName, f, false);\n                    return true;\n                };\n            };\n        } else if (glob.doc.attachEvent) {\n            return function (obj, type, fn, element) {\n                var f = function (e) {\n                    e = e || element.node.ownerDocument.window.event;\n                    var scrollY = getScroll(\"y\", element),\n                        scrollX = getScroll(\"x\", element),\n                        x = e.clientX + scrollX,\n                        y = e.clientY + scrollY;\n                    e.preventDefault = e.preventDefault || preventDefault;\n                    e.stopPropagation = e.stopPropagation || stopPropagation;\n                    return fn.call(element, e, x, y);\n                };\n                obj.attachEvent(\"on\" + type, f);\n                var detacher = function () {\n                    obj.detachEvent(\"on\" + type, f);\n                    return true;\n                };\n                return detacher;\n            };\n        }\n    })(),\n    drag = [],\n    dragMove = function (e) {\n        var x = e.clientX,\n            y = e.clientY,\n            scrollY = getScroll(\"y\"),\n            scrollX = getScroll(\"x\"),\n            dragi,\n            j = drag.length;\n        while (j--) {\n            dragi = drag[j];\n            if (supportsTouch) {\n                var i = e.touches && e.touches.length,\n                    touch;\n                while (i--) {\n                    touch = e.touches[i];\n                    if (touch.identifier == dragi.el._drag.id || dragi.el.node.contains(touch.target)) {\n                        x = touch.clientX;\n                        y = touch.clientY;\n                        (e.originalEvent ? e.originalEvent : e).preventDefault();\n                        break;\n                    }\n                }\n            } else {\n                e.preventDefault();\n            }\n            var node = dragi.el.node,\n                o,\n                next = node.nextSibling,\n                parent = node.parentNode,\n                display = node.style.display;\n            // glob.win.opera && parent.removeChild(node);\n            // node.style.display = \"none\";\n            // o = dragi.el.paper.getElementByPoint(x, y);\n            // node.style.display = display;\n            // glob.win.opera && (next ? parent.insertBefore(node, next) : parent.appendChild(node));\n            // o && eve(\"snap.drag.over.\" + dragi.el.id, dragi.el, o);\n            x += scrollX;\n            y += scrollY;\n            eve(\"snap.drag.move.\" + dragi.el.id, dragi.move_scope || dragi.el, x - dragi.el._drag.x, y - dragi.el._drag.y, x, y, e);\n        }\n    },\n    dragUp = function (e) {\n        Snap.unmousemove(dragMove).unmouseup(dragUp);\n        var i = drag.length,\n            dragi;\n        while (i--) {\n            dragi = drag[i];\n            dragi.el._drag = {};\n            eve(\"snap.drag.end.\" + dragi.el.id, dragi.end_scope || dragi.start_scope || dragi.move_scope || dragi.el, e);\n        }\n        drag = [];\n    };\n    /*/\n     * Element.click\n     [ method ]\n     **\n     * Adds a click event handler to the element\n     - handler (function) handler for the event\n     = (object) @Element\n    /*/\n    /*/\n     * Element.unclick\n     [ method ]\n     **\n     * Removes a click event handler from the element\n     - handler (function) handler for the event\n     = (object) @Element\n    /*/\n    \n    /*/\n     * Element.dblclick\n     [ method ]\n     **\n     * Adds a double click event handler to the element\n     - handler (function) handler for the event\n     = (object) @Element\n    /*/\n    /*/\n     * Element.undblclick\n     [ method ]\n     **\n     * Removes a double click event handler from the element\n     - handler (function) handler for the event\n     = (object) @Element\n    /*/\n    \n    /*/\n     * Element.mousedown\n     [ method ]\n     **\n     * Adds a mousedown event handler to the element\n     - handler (function) handler for the event\n     = (object) @Element\n    /*/\n    /*/\n     * Element.unmousedown\n     [ method ]\n     **\n     * Removes a mousedown event handler from the element\n     - handler (function) handler for the event\n     = (object) @Element\n    /*/\n    \n    /*/\n     * Element.mousemove\n     [ method ]\n     **\n     * Adds a mousemove event handler to the element\n     - handler (function) handler for the event\n     = (object) @Element\n    /*/\n    /*/\n     * Element.unmousemove\n     [ method ]\n     **\n     * Removes a mousemove event handler from the element\n     - handler (function) handler for the event\n     = (object) @Element\n    /*/\n    \n    /*/\n     * Element.mouseout\n     [ method ]\n     **\n     * Adds a mouseout event handler to the element\n     - handler (function) handler for the event\n     = (object) @Element\n    /*/\n    /*/\n     * Element.unmouseout\n     [ method ]\n     **\n     * Removes a mouseout event handler from the element\n     - handler (function) handler for the event\n     = (object) @Element\n    /*/\n    \n    /*/\n     * Element.mouseover\n     [ method ]\n     **\n     * Adds a mouseover event handler to the element\n     - handler (function) handler for the event\n     = (object) @Element\n    /*/\n    /*/\n     * Element.unmouseover\n     [ method ]\n     **\n     * Removes a mouseover event handler from the element\n     - handler (function) handler for the event\n     = (object) @Element\n    /*/\n    \n    /*/\n     * Element.mouseup\n     [ method ]\n     **\n     * Adds a mouseup event handler to the element\n     - handler (function) handler for the event\n     = (object) @Element\n    /*/\n    /*/\n     * Element.unmouseup\n     [ method ]\n     **\n     * Removes a mouseup event handler from the element\n     - handler (function) handler for the event\n     = (object) @Element\n    /*/\n    \n    /*/\n     * Element.touchstart\n     [ method ]\n     **\n     * Adds a touchstart event handler to the element\n     - handler (function) handler for the event\n     = (object) @Element\n    /*/\n    /*/\n     * Element.untouchstart\n     [ method ]\n     **\n     * Removes a touchstart event handler from the element\n     - handler (function) handler for the event\n     = (object) @Element\n    /*/\n    \n    /*/\n     * Element.touchmove\n     [ method ]\n     **\n     * Adds a touchmove event handler to the element\n     - handler (function) handler for the event\n     = (object) @Element\n    /*/\n    /*/\n     * Element.untouchmove\n     [ method ]\n     **\n     * Removes a touchmove event handler from the element\n     - handler (function) handler for the event\n     = (object) @Element\n    /*/\n    \n    /*/\n     * Element.touchend\n     [ method ]\n     **\n     * Adds a touchend event handler to the element\n     - handler (function) handler for the event\n     = (object) @Element\n    /*/\n    /*/\n     * Element.untouchend\n     [ method ]\n     **\n     * Removes a touchend event handler from the element\n     - handler (function) handler for the event\n     = (object) @Element\n    /*/\n    \n    /*/\n     * Element.touchcancel\n     [ method ]\n     **\n     * Adds a touchcancel event handler to the element\n     - handler (function) handler for the event\n     = (object) @Element\n    /*/\n    /*/\n     * Element.untouchcancel\n     [ method ]\n     **\n     * Removes a touchcancel event handler from the element\n     - handler (function) handler for the event\n     = (object) @Element\n    /*/\n    for (var i = events.length; i--;) {\n        (function (eventName) {\n            Snap[eventName] = elproto[eventName] = function (fn, scope) {\n                if (Snap.is(fn, \"function\")) {\n                    this.events = this.events || [];\n                    this.events.push({\n                        name: eventName,\n                        f: fn,\n                        unbind: addEvent(this.node || document, eventName, fn, scope || this)\n                    });\n                }\n                return this;\n            };\n            Snap[\"un\" + eventName] =\n            elproto[\"un\" + eventName] = function (fn) {\n                var events = this.events || [],\n                    l = events.length;\n                while (l--) if (events[l].name == eventName &&\n                               (events[l].f == fn || !fn)) {\n                    events[l].unbind();\n                    events.splice(l, 1);\n                    !events.length && delete this.events;\n                    return this;\n                }\n                return this;\n            };\n        })(events[i]);\n    }\n    /*/\n     * Element.hover\n     [ method ]\n     **\n     * Adds hover event handlers to the element\n     - f_in (function) handler for hover in\n     - f_out (function) handler for hover out\n     - icontext (object) #optional context for hover in handler\n     - ocontext (object) #optional context for hover out handler\n     = (object) @Element\n    /*/\n    elproto.hover = function (f_in, f_out, scope_in, scope_out) {\n        return this.mouseover(f_in, scope_in).mouseout(f_out, scope_out || scope_in);\n    };\n    /*/\n     * Element.unhover\n     [ method ]\n     **\n     * Removes hover event handlers from the element\n     - f_in (function) handler for hover in\n     - f_out (function) handler for hover out\n     = (object) @Element\n    /*/\n    elproto.unhover = function (f_in, f_out) {\n        return this.unmouseover(f_in).unmouseout(f_out);\n    };\n    var draggable = [];\n    // SIERRA unclear what _context_ refers to for starting, ending, moving the drag gesture.\n    // SIERRA Element.drag(): _x position of the mouse_: Where are the x/y values offset from?\n    // SIERRA Element.drag(): much of this member's doc appears to be duplicated for some reason.\n    // SIERRA Unclear about this sentence: _Additionally following drag events will be triggered: drag.start.<id> on start, drag.end.<id> on end and drag.move.<id> on every move._ Is there a global _drag_ object to which you can assign handlers keyed by an element's ID?\n    /*/\n     * Element.drag\n     [ method ]\n     **\n     * Adds event handlers for an element's drag gesture\n     **\n     - onmove (function) handler for moving\n     - onstart (function) handler for drag start\n     - onend (function) handler for drag end\n     - mcontext (object) #optional context for moving handler\n     - scontext (object) #optional context for drag start handler\n     - econtext (object) #optional context for drag end handler\n     * Additionaly following `drag` events are triggered: `drag.start.<id>` on start, \n     * `drag.end.<id>` on end and `drag.move.<id>` on every move. When element is dragged over another element \n     * `drag.over.<id>` fires as well.\n     *\n     * Start event and start handler are called in specified context or in context of the element with following parameters:\n     o x (number) x position of the mouse\n     o y (number) y position of the mouse\n     o event (object) DOM event object\n     * Move event and move handler are called in specified context or in context of the element with following parameters:\n     o dx (number) shift by x from the start point\n     o dy (number) shift by y from the start point\n     o x (number) x position of the mouse\n     o y (number) y position of the mouse\n     o event (object) DOM event object\n     * End event and end handler are called in specified context or in context of the element with following parameters:\n     o event (object) DOM event object\n     = (object) @Element\n    /*/\n    elproto.drag = function (onmove, onstart, onend, move_scope, start_scope, end_scope) {\n        if (!arguments.length) {\n            var origTransform;\n            return this.drag(function (dx, dy) {\n                this.attr({\n                    transform: origTransform + (origTransform ? \"T\" : \"t\") + [dx, dy]\n                });\n            }, function () {\n                origTransform = this.transform().local;\n            });\n        }\n        function start(e, x, y) {\n            (e.originalEvent || e).preventDefault();\n            this._drag.x = x;\n            this._drag.y = y;\n            this._drag.id = e.identifier;\n            !drag.length && Snap.mousemove(dragMove).mouseup(dragUp);\n            drag.push({el: this, move_scope: move_scope, start_scope: start_scope, end_scope: end_scope});\n            onstart && eve.on(\"snap.drag.start.\" + this.id, onstart);\n            onmove && eve.on(\"snap.drag.move.\" + this.id, onmove);\n            onend && eve.on(\"snap.drag.end.\" + this.id, onend);\n            eve(\"snap.drag.start.\" + this.id, start_scope || move_scope || this, x, y, e);\n        }\n        this._drag = {};\n        draggable.push({el: this, start: start});\n        this.mousedown(start);\n        return this;\n    };\n    /*\n     * Element.onDragOver\n     [ method ]\n     **\n     * Shortcut to assign event handler for `drag.over.<id>` event, where `id` is the element's `id` (see @Element.id)\n     - f (function) handler for event, first argument would be the element you are dragging over\n    /*/\n    // elproto.onDragOver = function (f) {\n    //     f ? eve.on(\"snap.drag.over.\" + this.id, f) : eve.unbind(\"snap.drag.over.\" + this.id);\n    // };\n    /*/\n     * Element.undrag\n     [ method ]\n     **\n     * Removes all drag event handlers from the given element\n    /*/\n    elproto.undrag = function () {\n        var i = draggable.length;\n        while (i--) if (draggable[i].el == this) {\n            this.unmousedown(draggable[i].start);\n            draggable.splice(i, 1);\n            eve.unbind(\"snap.drag.*.\" + this.id);\n        }\n        !draggable.length && Snap.unmousemove(dragMove).unmouseup(dragUp);\n        return this;\n    };\n});\n// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n// \n// http://www.apache.org/licenses/LICENSE-2.0\n// \n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nSnap.plugin(function (Snap, Element, Paper, glob) {\n    var elproto = Element.prototype,\n        pproto = Paper.prototype,\n        rgurl = /^/s*url/((.+)/)/,\n        Str = String,\n        $ = Snap._.$;\n    Snap.filter = {};\n    /*/\n     * Paper.filter\n     [ method ]\n     **\n     * Creates a `<filter>` element\n     **\n     - filstr (string) SVG fragment of filter provided as a string\n     = (object) @Element\n     * Note: It is recommended to use filters embedded into the page inside an empty SVG element.\n     > Usage\n     | var f = paper.filter('<feGaussianBlur stdDeviation=\"2\"/>'),\n     |     c = paper.circle(10, 10, 10).attr({\n     |         filter: f\n     |     });\n    /*/\n    pproto.filter = function (filstr) {\n        var paper = this;\n        if (paper.type != \"svg\") {\n            paper = paper.paper;\n        }\n        var f = Snap.parse(Str(filstr)),\n            id = Snap._.id(),\n            width = paper.node.offsetWidth,\n            height = paper.node.offsetHeight,\n            filter = $(\"filter\");\n        $(filter, {\n            id: id,\n            filterUnits: \"userSpaceOnUse\"\n        });\n        filter.appendChild(f.node);\n        paper.defs.appendChild(filter);\n        return new Element(filter);\n    };\n    \n    eve.on(\"snap.util.getattr.filter\", function () {\n        eve.stop();\n        var p = $(this.node, \"filter\");\n        if (p) {\n            var match = Str(p).match(rgurl);\n            return match && Snap.select(match[1]);\n        }\n    });\n    eve.on(\"snap.util.attr.filter\", function (value) {\n        if (value instanceof Element && value.type == \"filter\") {\n            eve.stop();\n            var id = value.node.id;\n            if (!id) {\n                $(value.node, {id: value.id});\n                id = value.id;\n            }\n            $(this.node, {\n                filter: Snap.url(id)\n            });\n        }\n        if (!value || value == \"none\") {\n            eve.stop();\n            this.node.removeAttribute(\"filter\");\n        }\n    });\n    /*/\n     * Snap.filter.blur\n     [ method ]\n     **\n     * Returns an SVG markup string for the blur filter\n     **\n     - x (number) amount of horizontal blur, in pixels\n     - y (number) #optional amount of vertical blur, in pixels\n     = (string) filter representation\n     > Usage\n     | var f = paper.filter(Snap.filter.blur(5, 10)),\n     |     c = paper.circle(10, 10, 10).attr({\n     |         filter: f\n     |     });\n    /*/\n    Snap.filter.blur = function (x, y) {\n        if (x == null) {\n            x = 2;\n        }\n        var def = y == null ? x : [x, y];\n        return Snap.format('/<feGaussianBlur stdDeviation=\"{def}\"/>', {\n            def: def\n        });\n    };\n    Snap.filter.blur.toString = function () {\n        return this();\n    };\n    /*/\n     * Snap.filter.shadow\n     [ method ]\n     **\n     * Returns an SVG markup string for the shadow filter\n     **\n     - dx (number) #optional horizontal shift of the shadow, in pixels\n     - dy (number) #optional vertical shift of the shadow, in pixels\n     - blur (number) #optional amount of blur\n     - color (string) #optional color of the shadow\n     - opacity (number) #optional `0..1` opacity of the shadow\n     * or\n     - dx (number) #optional horizontal shift of the shadow, in pixels\n     - dy (number) #optional vertical shift of the shadow, in pixels\n     - color (string) #optional color of the shadow\n     - opacity (number) #optional `0..1` opacity of the shadow\n     * which makes blur default to `4`. Or\n     - dx (number) #optional horizontal shift of the shadow, in pixels\n     - dy (number) #optional vertical shift of the shadow, in pixels\n     - opacity (number) #optional `0..1` opacity of the shadow\n     = (string) filter representation\n     > Usage\n     | var f = paper.filter(Snap.filter.shadow(0, 2, 3)),\n     |     c = paper.circle(10, 10, 10).attr({\n     |         filter: f\n     |     });\n    /*/\n    Snap.filter.shadow = function (dx, dy, blur, color, opacity) {\n        if (typeof blur == \"string\") {\n            color = blur;\n            opacity = color;\n            blur = 4;\n        }\n        if (typeof color != \"string\") {\n            opacity = color;\n            color = \"#000\";\n        }\n        color = color || \"#000\";\n        if (blur == null) {\n            blur = 4;\n        }\n        if (opacity == null) {\n            opacity = 1;\n        }\n        if (dx == null) {\n            dx = 0;\n            dy = 2;\n        }\n        if (dy == null) {\n            dy = dx;\n        }\n        color = Snap.color(color);\n        return Snap.format('<feGaussianBlur in=\"SourceAlpha\" stdDeviation=\"{blur}\"/><feOffset dx=\"{dx}\" dy=\"{dy}\" result=\"offsetblur\"/><feFlood flood-color=\"{color}\"/><feComposite in2=\"offsetblur\" operator=\"in\"/><feComponentTransfer><feFuncA type=\"linear\" slope=\"{opacity}\"/></feComponentTransfer><feMerge><feMergeNode/><feMergeNode in=\"SourceGraphic\"/></feMerge>', {\n            color: color,\n            dx: dx,\n            dy: dy,\n            blur: blur,\n            opacity: opacity\n        });\n    };\n    Snap.filter.shadow.toString = function () {\n        return this();\n    };\n    /*/\n     * Snap.filter.grayscale\n     [ method ]\n     **\n     * Returns an SVG markup string for the grayscale filter\n     **\n     - amount (number) amount of filter (`0..1`)\n     = (string) filter representation\n    /*/\n    Snap.filter.grayscale = function (amount) {\n        if (amount == null) {\n            amount = 1;\n        }\n        return Snap.format('<feColorMatrix type=\"matrix\" values=\"{a} {b} {c} 0 0 {d} {e} {f} 0 0 {g} {b} {h} 0 0 0 0 0 1 0\"/>', {\n            a: 0.2126 + 0.7874 * (1 - amount),\n            b: 0.7152 - 0.7152 * (1 - amount),\n            c: 0.0722 - 0.0722 * (1 - amount),\n            d: 0.2126 - 0.2126 * (1 - amount),\n            e: 0.7152 + 0.2848 * (1 - amount),\n            f: 0.0722 - 0.0722 * (1 - amount),\n            g: 0.2126 - 0.2126 * (1 - amount),\n            h: 0.0722 + 0.9278 * (1 - amount)\n        });\n    };\n    Snap.filter.grayscale.toString = function () {\n        return this();\n    };\n    /*/\n     * Snap.filter.sepia\n     [ method ]\n     **\n     * Returns an SVG markup string for the sepia filter\n     **\n     - amount (number) amount of filter (`0..1`)\n     = (string) filter representation\n    /*/\n    Snap.filter.sepia = function (amount) {\n        if (amount == null) {\n            amount = 1;\n        }\n        return Snap.format('<feColorMatrix type=\"matrix\" values=\"{a} {b} {c} 0 0 {d} {e} {f} 0 0 {g} {h} {i} 0 0 0 0 0 1 0\"/>', {\n            a: 0.393 + 0.607 * (1 - amount),\n            b: 0.769 - 0.769 * (1 - amount),\n            c: 0.189 - 0.189 * (1 - amount),\n            d: 0.349 - 0.349 * (1 - amount),\n            e: 0.686 + 0.314 * (1 - amount),\n            f: 0.168 - 0.168 * (1 - amount),\n            g: 0.272 - 0.272 * (1 - amount),\n            h: 0.534 - 0.534 * (1 - amount),\n            i: 0.131 + 0.869 * (1 - amount)\n        });\n    };\n    Snap.filter.sepia.toString = function () {\n        return this();\n    };\n    /*/\n     * Snap.filter.saturate\n     [ method ]\n     **\n     * Returns an SVG markup string for the saturate filter\n     **\n     - amount (number) amount of filter (`0..1`)\n     = (string) filter representation\n    /*/\n    Snap.filter.saturate = function (amount) {\n        if (amount == null) {\n            amount = 1;\n        }\n        return Snap.format('<feColorMatrix type=\"saturate\" values=\"{amount}\"/>', {\n            amount: 1 - amount\n        });\n    };\n    Snap.filter.saturate.toString = function () {\n        return this();\n    };\n    /*/\n     * Snap.filter.hueRotate\n     [ method ]\n     **\n     * Returns an SVG markup string for the hue-rotate filter\n     **\n     - angle (number) angle of rotation\n     = (string) filter representation\n    /*/\n    Snap.filter.hueRotate = function (angle) {\n        angle = angle || 0;\n        return Snap.format('<feColorMatrix type=\"hueRotate\" values=\"{angle}\"/>', {\n            angle: angle\n        });\n    };\n    Snap.filter.hueRotate.toString = function () {\n        return this();\n    };\n    /*/\n     * Snap.filter.invert\n     [ method ]\n     **\n     * Returns an SVG markup string for the invert filter\n     **\n     - amount (number) amount of filter (`0..1`)\n     = (string) filter representation\n    /*/\n    Snap.filter.invert = function (amount) {\n        if (amount == null) {\n            amount = 1;\n        }\n        return Snap.format('<feComponentTransfer><feFuncR type=\"table\" tableValues=\"{amount} {amount2}\"/><feFuncG type=\"table\" tableValues=\"{amount} {amount2}\"/><feFuncB type=\"table\" tableValues=\"{amount} {amount2}\"/></feComponentTransfer>', {\n            amount: amount,\n            amount2: 1 - amount\n        });\n    };\n    Snap.filter.invert.toString = function () {\n        return this();\n    };\n    /*/\n     * Snap.filter.brightness\n     [ method ]\n     **\n     * Returns an SVG markup string for the brightness filter\n     **\n     - amount (number) amount of filter (`0..1`)\n     = (string) filter representation\n    /*/\n    Snap.filter.brightness = function (amount) {\n        if (amount == null) {\n            amount = 1;\n        }\n        return Snap.format('<feComponentTransfer><feFuncR type=\"linear\" slope=\"{amount}\"/><feFuncG type=\"linear\" slope=\"{amount}\"/><feFuncB type=\"linear\" slope=\"{amount}\"/></feComponentTransfer>', {\n            amount: amount\n        });\n    };\n    Snap.filter.brightness.toString = function () {\n        return this();\n    };\n    /*/\n     * Snap.filter.contrast\n     [ method ]\n     **\n     * Returns an SVG markup string for the contrast filter\n     **\n     - amount (number) amount of filter (`0..1`)\n     = (string) filter representation\n    /*/\n    Snap.filter.contrast = function (amount) {\n        if (amount == null) {\n            amount = 1;\n        }\n        return Snap.format('<feComponentTransfer><feFuncR type=\"linear\" slope=\"{amount}\" intercept=\"{amount2}\"/><feFuncG type=\"linear\" slope=\"{amount}\" intercept=\"{amount2}\"/><feFuncB type=\"linear\" slope=\"{amount}\" intercept=\"{amount2}\"/></feComponentTransfer>', {\n            amount: amount,\n            amount2: .5 - amount / 2\n        });\n    };\n    Snap.filter.contrast.toString = function () {\n        return this();\n    };\n});\n\nreturn Snap;\n}));","'use strict';\n\nvar snapsvg = module.exports = require(266);\n\nsnapsvg.plugin(function(Snap, Element) {\n\n  /*/\n   * Element.children\n   [ method ]\n   **\n   * Returns array of all the children of the element.\n   = (array) array of Elements\n  /*/\n  Element.prototype.children = function () {\n      var out = [],\n          ch = this.node.childNodes;\n      for (var i = 0, ii = ch.length; i < ii; i++) {\n          out[i] = new Snap(ch[i]);\n      }\n      return out;\n  };\n});\n\n\n/**\n * @class ClassPlugin\n *\n * Extends snapsvg with methods to add and remove classes\n */\nsnapsvg.plugin(function (Snap, Element, Paper, global) {\n\n  function split(str) {\n    return str.split(//s+/);\n  }\n\n  function join(array) {\n    return array.join(' ');\n  }\n\n  function getClasses(e) {\n    return split(e.attr('class') || '');\n  }\n\n  function setClasses(e, classes) {\n    e.attr('class', join(classes));\n  }\n\n  /**\n   * @method snapsvg.Element#addClass\n   *\n   * @example\n   *\n   * e.attr('class', 'selector');\n   *\n   * e.addClass('foo bar'); // adds classes foo and bar\n   * e.attr('class'); // -> 'selector foo bar'\n   *\n   * e.addClass('fooBar');\n   * e.attr('class'); // -> 'selector foo bar fooBar'\n   *\n   * @param {String} cls classes to be added to the element\n   *\n   * @return {snapsvg.Element} the element (this)\n   */\n  Element.prototype.addClass = function(cls) {\n    var current = getClasses(this),\n        add = split(cls),\n        i, e;\n\n    for (i = 0, e; !!(e = add[i]); i++) {\n      if (current.indexOf(e) === -1) {\n        current.push(e);\n      }\n    }\n\n    setClasses(this, current);\n\n    return this;\n  };\n\n  /**\n   * @method snapsvg.Element#hasClass\n   *\n   * @param  {String}  cls the class to query for\n   * @return {Boolean} returns true if the element has the given class\n   */\n  Element.prototype.hasClass = function(cls) {\n    if (!cls) {\n      throw new Error('[snapsvg] syntax: hasClass(clsStr)');\n    }\n\n    return getClasses(this).indexOf(cls) !== -1;\n  };\n\n  /**\n   * @method snapsvg.Element#removeClass\n   *\n   * @example\n   *\n   * e.attr('class', 'foo bar');\n   *\n   * e.removeClass('foo');\n   * e.attr('class'); // -> 'bar'\n   *\n   * e.removeClass('foo bar'); // removes classes foo and bar\n   * e.attr('class'); // -> ''\n   *\n   * @param {String} cls classes to be removed from element\n   *\n   * @return {snapsvg.Element} the element (this)\n   */\n  Element.prototype.removeClass = function(cls) {\n    var current = getClasses(this),\n        remove = split(cls),\n        i, e, idx;\n\n    for (i = 0, e; !!(e = remove[i]); i++) {\n      idx = current.indexOf(e);\n\n      if (idx !== -1) {\n        // remove element from array\n        current.splice(idx, 1);\n      }\n    }\n\n    setClasses(this, current);\n\n    return this;\n  };\n\n});\n\n/**\n * @class TranslatePlugin\n *\n * Extends snapsvg with methods to translate elements\n */\nsnapsvg.plugin(function (Snap, Element, Paper, global) {\n\n  /*\n   * @method snapsvg.Element#translate\n   *\n   * @example\n   *\n   * e.translate(10, 20);\n   *\n   * // sets transform matrix to translate(10, 20)\n   *\n   * @param {Number} x translation\n   * @param {Number} y translation\n   *\n   * @return {snapsvg.Element} the element (this)\n   */\n  Element.prototype.translate = function(x, y) {\n    var matrix = new Snap.Matrix();\n    matrix.translate(x, y);\n    return this.transform(matrix);\n  };\n});\n\n\n/**\n * @class CreatePlugin\n *\n * Create an svg element without attaching it to the dom\n */\nsnapsvg.plugin(function(Snap) {\n\n  Snap.create = function(name, attrs) {\n    return Snap._.wrap(Snap._.$(name, attrs));\n  };\n});\n\n\n/**\n * @class CreatSnapAtPlugin\n *\n * Extends snap.svg with a method to create a SVG element\n * at a specific position in the DOM.\n */\nsnapsvg.plugin(function(Snap, Element, Paper, global) {\n\n  /*\n   * @method snapsvg.createSnapAt\n   *\n   * @example\n   *\n   * snapsvg.createSnapAt(parentNode, 200, 200);\n   *\n   * @param {Number} width of svg\n   * @param {Number} height of svg\n   * @param {Object} parentNode svg Element will be child of this\n   *\n   * @return {snapsvg.Element} the newly created wrapped SVG element instance\n   */\n  Snap.createSnapAt = function(width, height, parentNode) {\n\n    var svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n    svg.setAttribute('width', width);\n    svg.setAttribute('height', height);\n    if (!parentNode) {\n      parentNode = document.body;\n    }\n    parentNode.appendChild(svg);\n\n    return new Snap(svg);\n  };\n});","'use strict';\n\nvar hat = require(269);\n\n\n/**\n * Create a new id generator / cache instance.\n *\n * You may optionally provide a seed that is used internally.\n *\n * @param {Seed} seed\n */\nfunction Ids(seed) {\n\n  if (!(this instanceof Ids)) {\n    return new Ids(seed);\n  }\n\n  seed = seed || [ 128, 36, 1 ];\n  this._seed = seed.length ? hat.rack(seed[0], seed[1], seed[2]) : seed;\n}\n\nmodule.exports = Ids;\n\n/**\n * Generate a next id.\n *\n * @param {Object} [element] element to bind the id to\n *\n * @return {String} id\n */\nIds.prototype.next = function(element) {\n  return this._seed(element || true);\n};\n\n/**\n * Generate a next id with a given prefix.\n *\n * @param {Object} [element] element to bind the id to\n *\n * @return {String} id\n */\nIds.prototype.nextPrefixed = function(prefix, element) {\n  var id;\n\n  do {\n    id = prefix + this.next(true);\n  } while (this.assigned(id));\n\n  // claim {prefix}{random}\n  this.claim(id, element);\n\n  // return\n  return id;\n};\n\n/**\n * Manually claim an existing id.\n *\n * @param {String} id\n * @param {String} [element] element the id is claimed by\n */\nIds.prototype.claim = function(id, element) {\n  this._seed.set(id, element || true);\n};\n\n/**\n * Returns true if the given id has already been assigned.\n *\n * @param  {String} id\n * @return {Boolean}\n */\nIds.prototype.assigned = function(id) {\n  return this._seed.get(id) || false;\n};\n\n/**\n * Unclaim an id.\n *\n * @param  {String} id the id to unclaim\n */\nIds.prototype.unclaim = function(id) {\n  delete this._seed.hats[id];\n};\n\n\n/**\n * Clear all claimed ids.\n */\nIds.prototype.clear = function() {\n\n  var hats = this._seed.hats,\n      id;\n\n  for (id in hats) {\n    this.unclaim(id);\n  }\n};","var hat = module.exports = function (bits, base) {\n    if (!base) base = 16;\n    if (bits === undefined) bits = 128;\n    if (bits <= 0) return '0';\n    \n    var digits = Math.log(Math.pow(2, bits)) / Math.log(base);\n    for (var i = 2; digits === Infinity; i *= 2) {\n        digits = Math.log(Math.pow(2, bits / i)) / Math.log(base) * i;\n    }\n    \n    var rem = digits - Math.floor(digits);\n    \n    var res = '';\n    \n    for (var i = 0; i < Math.floor(digits); i++) {\n        var x = Math.floor(Math.random() * base).toString(base);\n        res = x + res;\n    }\n    \n    if (rem) {\n        var b = Math.pow(base, rem);\n        var x = Math.floor(Math.random() * b).toString(base);\n        res = x + res;\n    }\n    \n    var parsed = parseInt(res, base);\n    if (parsed !== Infinity && parsed >= Math.pow(2, bits)) {\n        return hat(bits, base)\n    }\n    else return res;\n};\n\nhat.rack = function (bits, base, expandBy) {\n    var fn = function (data) {\n        var iters = 0;\n        do {\n            if (iters ++ > 10) {\n                if (expandBy) bits += expandBy;\n                else throw new Error('too many ID collisions, use more bits')\n            }\n            \n            var id = hat(bits, base);\n        } while (Object.hasOwnProperty.call(hats, id));\n        \n        hats[id] = data;\n        return id;\n    };\n    var hats = fn.hats = {};\n    \n    fn.get = function (id) {\n        return fn.hats[id];\n    };\n    \n    fn.set = function (id, value) {\n        fn.hats[id] = value;\n        return fn;\n    };\n    \n    fn.bits = bits || 128;\n    fn.base = base || 16;\n    return fn;\n};\n","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n","var createFindIndex = require(360);\n\n/**\n * This method is like `_.find` except that it returns the index of the first\n * element `predicate` returns truthy for instead of the element itself.\n *\n * If a property name is provided for `predicate` the created `_.property`\n * style callback returns the property value of the given element.\n *\n * If a value is also provided for `thisArg` the created `_.matchesProperty`\n * style callback returns `true` for elements that have a matching property\n * value, else `false`.\n *\n * If an object is provided for `predicate` the created `_.matches` style\n * callback returns `true` for elements that have the properties of the given\n * object, else `false`.\n *\n * @static\n * @memberOf _\n * @category Array\n * @param {Array} array The array to search.\n * @param {Function|Object|string} [predicate=_.identity] The function invoked\n *  per iteration.\n * @param {*} [thisArg] The `this` binding of `predicate`.\n * @returns {number} Returns the index of the found element, else `-1`.\n * @example\n *\n * var users = [\n *   { 'user': 'barney',  'active': false },\n *   { 'user': 'fred',    'active': false },\n *   { 'user': 'pebbles', 'active': true }\n * ];\n *\n * _.findIndex(users, function(chr) {\n *   return chr.user == 'barney';\n * });\n * // => 0\n *\n * // using the `_.matches` callback shorthand\n * _.findIndex(users, { 'user': 'fred', 'active': false });\n * // => 1\n *\n * // using the `_.matchesProperty` callback shorthand\n * _.findIndex(users, 'active', false);\n * // => 0\n *\n * // using the `_.property` callback shorthand\n * _.findIndex(users, 'active');\n * // => 2\n */\nvar findIndex = createFindIndex();\n\nmodule.exports = findIndex;\n","var baseFlatten = require(320),\n    isIterateeCall = require(380);\n\n/**\n * Flattens a nested array. If `isDeep` is `true` the array is recursively\n * flattened, otherwise it's only flattened a single level.\n *\n * @static\n * @memberOf _\n * @category Array\n * @param {Array} array The array to flatten.\n * @param {boolean} [isDeep] Specify a deep flatten.\n * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n * @returns {Array} Returns the new flattened array.\n * @example\n *\n * _.flatten([1, [2, 3, [4]]]);\n * // => [1, 2, 3, [4]]\n *\n * // using `isDeep`\n * _.flatten([1, [2, 3, [4]]], true);\n * // => [1, 2, 3, 4]\n */\nfunction flatten(array, isDeep, guard) {\n  var length = array ? array.length : 0;\n  if (guard && isIterateeCall(array, isDeep, guard)) {\n    isDeep = false;\n  }\n  return length ? baseFlatten(array, isDeep) : [];\n}\n\nmodule.exports = flatten;\n","/**\n * Gets the last element of `array`.\n *\n * @static\n * @memberOf _\n * @category Array\n * @param {Array} array The array to query.\n * @returns {*} Returns the last element of `array`.\n * @example\n *\n * _.last([1, 2, 3]);\n * // => 3\n */\nfunction last(array) {\n  var length = array ? array.length : 0;\n  return length ? array[length - 1] : undefined;\n}\n\nmodule.exports = last;\n","var baseFlatten = require(320),\n    baseUniq = require(343),\n    restParam = require(295);\n\n/**\n * Creates an array of unique values, in order, from all of the provided arrays\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\n * for equality comparisons.\n *\n * @static\n * @memberOf _\n * @category Array\n * @param {...Array} [arrays] The arrays to inspect.\n * @returns {Array} Returns the new array of combined values.\n * @example\n *\n * _.union([1, 2], [4, 2], [2, 1]);\n * // => [1, 2, 4]\n */\nvar union = restParam(function(arrays) {\n  return baseUniq(baseFlatten(arrays, false, true));\n});\n\nmodule.exports = union;\n","var baseCallback = require(309),\n    baseUniq = require(343),\n    isIterateeCall = require(380),\n    sortedUniq = require(395);\n\n/**\n * Creates a duplicate-free version of an array, using\n * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\n * for equality comparisons, in which only the first occurence of each element\n * is kept. Providing `true` for `isSorted` performs a faster search algorithm\n * for sorted arrays. If an iteratee function is provided it's invoked for\n * each element in the array to generate the criterion by which uniqueness\n * is computed. The `iteratee` is bound to `thisArg` and invoked with three\n * arguments: (value, index, array).\n *\n * If a property name is provided for `iteratee` the created `_.property`\n * style callback returns the property value of the given element.\n *\n * If a value is also provided for `thisArg` the created `_.matchesProperty`\n * style callback returns `true` for elements that have a matching property\n * value, else `false`.\n *\n * If an object is provided for `iteratee` the created `_.matches` style\n * callback returns `true` for elements that have the properties of the given\n * object, else `false`.\n *\n * @static\n * @memberOf _\n * @alias unique\n * @category Array\n * @param {Array} array The array to inspect.\n * @param {boolean} [isSorted] Specify the array is sorted.\n * @param {Function|Object|string} [iteratee] The function invoked per iteration.\n * @param {*} [thisArg] The `this` binding of `iteratee`.\n * @returns {Array} Returns the new duplicate-value-free array.\n * @example\n *\n * _.uniq([2, 1, 2]);\n * // => [2, 1]\n *\n * // using `isSorted`\n * _.uniq([1, 1, 2], true);\n * // => [1, 2]\n *\n * // using an iteratee function\n * _.uniq([1, 2.5, 1.5, 2], function(n) {\n *   return this.floor(n);\n * }, Math);\n * // => [1, 2.5]\n *\n * // using the `_.property` callback shorthand\n * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');\n * // => [{ 'x': 1 }, { 'x': 2 }]\n */\nfunction uniq(array, isSorted, iteratee, thisArg) {\n  var length = array ? array.length : 0;\n  if (!length) {\n    return [];\n  }\n  if (isSorted != null && typeof isSorted != 'boolean') {\n    thisArg = iteratee;\n    iteratee = isIterateeCall(array, isSorted, thisArg) ? undefined : isSorted;\n    isSorted = false;\n  }\n  iteratee = iteratee == null ? iteratee : baseCallback(iteratee, thisArg, 3);\n  return (isSorted)\n    ? sortedUniq(array, iteratee)\n    : baseUniq(array, iteratee);\n}\n\nmodule.exports = uniq;\n","module.exports = require(275);\n","var baseDifference = require(314),\n    isArrayLike = require(378),\n    restParam = require(295);\n\n/**\n * Creates an array excluding all provided values using\n * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\n * for equality comparisons.\n *\n * @static\n * @memberOf _\n * @category Array\n * @param {Array} array The array to filter.\n * @param {...*} [values] The values to exclude.\n * @returns {Array} Returns the new array of filtered values.\n * @example\n *\n * _.without([1, 2, 1, 3], 1, 2);\n * // => [3]\n */\nvar without = restParam(function(array, values) {\n  return isArrayLike(array)\n    ? baseDifference(array, values)\n    : [];\n});\n\nmodule.exports = without;\n","var LazyWrapper = require(296),\n    LodashWrapper = require(297),\n    baseLodash = require(329),\n    isArray = require(401),\n    isObjectLike = require(384),\n    wrapperClone = require(398);\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Creates a `lodash` object which wraps `value` to enable implicit chaining.\n * Methods that operate on and return arrays, collections, and functions can\n * be chained together. Methods that retrieve a single value or may return a\n * primitive value will automatically end the chain returning the unwrapped\n * value. Explicit chaining may be enabled using `_.chain`. The execution of\n * chained methods is lazy, that is, execution is deferred until `_#value`\n * is implicitly or explicitly called.\n *\n * Lazy evaluation allows several methods to support shortcut fusion. Shortcut\n * fusion is an optimization strategy which merge iteratee calls; this can help\n * to avoid the creation of intermediate data structures and greatly reduce the\n * number of iteratee executions.\n *\n * Chaining is supported in custom builds as long as the `_#value` method is\n * directly or indirectly included in the build.\n *\n * In addition to lodash methods, wrappers have `Array` and `String` methods.\n *\n * The wrapper `Array` methods are:\n * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`,\n * `splice`, and `unshift`\n *\n * The wrapper `String` methods are:\n * `replace` and `split`\n *\n * The wrapper methods that support shortcut fusion are:\n * `compact`, `drop`, `dropRight`, `dropRightWhile`, `dropWhile`, `filter`,\n * `first`, `initial`, `last`, `map`, `pluck`, `reject`, `rest`, `reverse`,\n * `slice`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, `toArray`,\n * and `where`\n *\n * The chainable wrapper methods are:\n * `after`, `ary`, `assign`, `at`, `before`, `bind`, `bindAll`, `bindKey`,\n * `callback`, `chain`, `chunk`, `commit`, `compact`, `concat`, `constant`,\n * `countBy`, `create`, `curry`, `debounce`, `defaults`, `defaultsDeep`,\n * `defer`, `delay`, `difference`, `drop`, `dropRight`, `dropRightWhile`,\n * `dropWhile`, `fill`, `filter`, `flatten`, `flattenDeep`, `flow`, `flowRight`,\n * `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`,\n * `functions`, `groupBy`, `indexBy`, `initial`, `intersection`, `invert`,\n * `invoke`, `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`,\n * `matchesProperty`, `memoize`, `merge`, `method`, `methodOf`, `mixin`,\n * `modArgs`, `negate`, `omit`, `once`, `pairs`, `partial`, `partialRight`,\n * `partition`, `pick`, `plant`, `pluck`, `property`, `propertyOf`, `pull`,\n * `pullAt`, `push`, `range`, `rearg`, `reject`, `remove`, `rest`, `restParam`,\n * `reverse`, `set`, `shuffle`, `slice`, `sort`, `sortBy`, `sortByAll`,\n * `sortByOrder`, `splice`, `spread`, `take`, `takeRight`, `takeRightWhile`,\n * `takeWhile`, `tap`, `throttle`, `thru`, `times`, `toArray`, `toPlainObject`,\n * `transform`, `union`, `uniq`, `unshift`, `unzip`, `unzipWith`, `values`,\n * `valuesIn`, `where`, `without`, `wrap`, `xor`, `zip`, `zipObject`, `zipWith`\n *\n * The wrapper methods that are **not** chainable by default are:\n * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clone`, `cloneDeep`,\n * `deburr`, `endsWith`, `escape`, `escapeRegExp`, `every`, `find`, `findIndex`,\n * `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `findWhere`, `first`,\n * `floor`, `get`, `gt`, `gte`, `has`, `identity`, `includes`, `indexOf`,\n * `inRange`, `isArguments`, `isArray`, `isBoolean`, `isDate`, `isElement`,\n * `isEmpty`, `isEqual`, `isError`, `isFinite` `isFunction`, `isMatch`,\n * `isNative`, `isNaN`, `isNull`, `isNumber`, `isObject`, `isPlainObject`,\n * `isRegExp`, `isString`, `isUndefined`, `isTypedArray`, `join`, `kebabCase`,\n * `last`, `lastIndexOf`, `lt`, `lte`, `max`, `min`, `noConflict`, `noop`,\n * `now`, `pad`, `padLeft`, `padRight`, `parseInt`, `pop`, `random`, `reduce`,\n * `reduceRight`, `repeat`, `result`, `round`, `runInContext`, `shift`, `size`,\n * `snakeCase`, `some`, `sortedIndex`, `sortedLastIndex`, `startCase`,\n * `startsWith`, `sum`, `template`, `trim`, `trimLeft`, `trimRight`, `trunc`,\n * `unescape`, `uniqueId`, `value`, and `words`\n *\n * The wrapper method `sample` will return a wrapped value when `n` is provided,\n * otherwise an unwrapped value is returned.\n *\n * @name _\n * @constructor\n * @category Chain\n * @param {*} value The value to wrap in a `lodash` instance.\n * @returns {Object} Returns the new `lodash` wrapper instance.\n * @example\n *\n * var wrapped = _([1, 2, 3]);\n *\n * // returns an unwrapped value\n * wrapped.reduce(function(total, n) {\n *   return total + n;\n * });\n * // => 6\n *\n * // returns a wrapped value\n * var squares = wrapped.map(function(n) {\n *   return n * n;\n * });\n *\n * _.isArray(squares);\n * // => false\n *\n * _.isArray(squares.value());\n * // => true\n */\nfunction lodash(value) {\n  if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {\n    if (value instanceof LodashWrapper) {\n      return value;\n    }\n    if (hasOwnProperty.call(value, '__chain__') && hasOwnProperty.call(value, '__wrapped__')) {\n      return wrapperClone(value);\n    }\n  }\n  return new LodashWrapper(value);\n}\n\n// Ensure wrappers are instances of `baseLodash`.\nlodash.prototype = baseLodash.prototype;\n\nmodule.exports = lodash;\n","module.exports = require(290);\n","var arrayEvery = require(301),\n    baseCallback = require(309),\n    baseEvery = require(316),\n    isArray = require(401),\n    isIterateeCall = require(380);\n\n/**\n * Checks if `predicate` returns truthy for **all** elements of `collection`.\n * The predicate is bound to `thisArg` and invoked with three arguments:\n * (value, index|key, collection).\n *\n * If a property name is provided for `predicate` the created `_.property`\n * style callback returns the property value of the given element.\n *\n * If a value is also provided for `thisArg` the created `_.matchesProperty`\n * style callback returns `true` for elements that have a matching property\n * value, else `false`.\n *\n * If an object is provided for `predicate` the created `_.matches` style\n * callback returns `true` for elements that have the properties of the given\n * object, else `false`.\n *\n * @static\n * @memberOf _\n * @alias all\n * @category Collection\n * @param {Array|Object|string} collection The collection to iterate over.\n * @param {Function|Object|string} [predicate=_.identity] The function invoked\n *  per iteration.\n * @param {*} [thisArg] The `this` binding of `predicate`.\n * @returns {boolean} Returns `true` if all elements pass the predicate check,\n *  else `false`.\n * @example\n *\n * _.every([true, 1, null, 'yes'], Boolean);\n * // => false\n *\n * var users = [\n *   { 'user': 'barney', 'active': false },\n *   { 'user': 'fred',   'active': false }\n * ];\n *\n * // using the `_.matches` callback shorthand\n * _.every(users, { 'user': 'barney', 'active': false });\n * // => false\n *\n * // using the `_.matchesProperty` callback shorthand\n * _.every(users, 'active', false);\n * // => true\n *\n * // using the `_.property` callback shorthand\n * _.every(users, 'active');\n * // => false\n */\nfunction every(collection, predicate, thisArg) {\n  var func = isArray(collection) ? arrayEvery : baseEvery;\n  if (thisArg && isIterateeCall(collection, predicate, thisArg)) {\n    predicate = undefined;\n  }\n  if (typeof predicate != 'function' || thisArg !== undefined) {\n    predicate = baseCallback(predicate, thisArg, 3);\n  }\n  return func(collection, predicate);\n}\n\nmodule.exports = every;\n","var arrayFilter = require(302),\n    baseCallback = require(309),\n    baseFilter = require(317),\n    isArray = require(401);\n\n/**\n * Iterates over elements of `collection`, returning an array of all elements\n * `predicate` returns truthy for. The predicate is bound to `thisArg` and\n * invoked with three arguments: (value, index|key, collection).\n *\n * If a property name is provided for `predicate` the created `_.property`\n * style callback returns the property value of the given element.\n *\n * If a value is also provided for `thisArg` the created `_.matchesProperty`\n * style callback returns `true` for elements that have a matching property\n * value, else `false`.\n *\n * If an object is provided for `predicate` the created `_.matches` style\n * callback returns `true` for elements that have the properties of the given\n * object, else `false`.\n *\n * @static\n * @memberOf _\n * @alias select\n * @category Collection\n * @param {Array|Object|string} collection The collection to iterate over.\n * @param {Function|Object|string} [predicate=_.identity] The function invoked\n *  per iteration.\n * @param {*} [thisArg] The `this` binding of `predicate`.\n * @returns {Array} Returns the new filtered array.\n * @example\n *\n * _.filter([4, 5, 6], function(n) {\n *   return n % 2 == 0;\n * });\n * // => [4, 6]\n *\n * var users = [\n *   { 'user': 'barney', 'age': 36, 'active': true },\n *   { 'user': 'fred',   'age': 40, 'active': false }\n * ];\n *\n * // using the `_.matches` callback shorthand\n * _.pluck(_.filter(users, { 'age': 36, 'active': true }), 'user');\n * // => ['barney']\n *\n * // using the `_.matchesProperty` callback shorthand\n * _.pluck(_.filter(users, 'active', false), 'user');\n * // => ['fred']\n *\n * // using the `_.property` callback shorthand\n * _.pluck(_.filter(users, 'active'), 'user');\n * // => ['barney']\n */\nfunction filter(collection, predicate, thisArg) {\n  var func = isArray(collection) ? arrayFilter : baseFilter;\n  predicate = baseCallback(predicate, thisArg, 3);\n  return func(collection, predicate);\n}\n\nmodule.exports = filter;\n","var baseEach = require(315),\n    createFind = require(359);\n\n/**\n * Iterates over elements of `collection`, returning the first element\n * `predicate` returns truthy for. The predicate is bound to `thisArg` and\n * invoked with three arguments: (value, index|key, collection).\n *\n * If a property name is provided for `predicate` the created `_.property`\n * style callback returns the property value of the given element.\n *\n * If a value is also provided for `thisArg` the created `_.matchesProperty`\n * style callback returns `true` for elements that have a matching property\n * value, else `false`.\n *\n * If an object is provided for `predicate` the created `_.matches` style\n * callback returns `true` for elements that have the properties of the given\n * object, else `false`.\n *\n * @static\n * @memberOf _\n * @alias detect\n * @category Collection\n * @param {Array|Object|string} collection The collection to search.\n * @param {Function|Object|string} [predicate=_.identity] The function invoked\n *  per iteration.\n * @param {*} [thisArg] The `this` binding of `predicate`.\n * @returns {*} Returns the matched element, else `undefined`.\n * @example\n *\n * var users = [\n *   { 'user': 'barney',  'age': 36, 'active': true },\n *   { 'user': 'fred',    'age': 40, 'active': false },\n *   { 'user': 'pebbles', 'age': 1,  'active': true }\n * ];\n *\n * _.result(_.find(users, function(chr) {\n *   return chr.age < 40;\n * }), 'user');\n * // => 'barney'\n *\n * // using the `_.matches` callback shorthand\n * _.result(_.find(users, { 'age': 1, 'active': true }), 'user');\n * // => 'pebbles'\n *\n * // using the `_.matchesProperty` callback shorthand\n * _.result(_.find(users, 'active', false), 'user');\n * // => 'fred'\n *\n * // using the `_.property` callback shorthand\n * _.result(_.find(users, 'active'), 'user');\n * // => 'barney'\n */\nvar find = createFind(baseEach);\n\nmodule.exports = find;\n","var arrayEach = require(300),\n    baseEach = require(315),\n    createForEach = require(361);\n\n/**\n * Iterates over elements of `collection` invoking `iteratee` for each element.\n * The `iteratee` is bound to `thisArg` and invoked with three arguments:\n * (value, index|key, collection). Iteratee functions may exit iteration early\n * by explicitly returning `false`.\n *\n * **Note:** As with other \"Collections\" methods, objects with a \"length\" property\n * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`\n * may be used for object iteration.\n *\n * @static\n * @memberOf _\n * @alias each\n * @category Collection\n * @param {Array|Object|string} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @param {*} [thisArg] The `this` binding of `iteratee`.\n * @returns {Array|Object|string} Returns `collection`.\n * @example\n *\n * _([1, 2]).forEach(function(n) {\n *   console.log(n);\n * }).value();\n * // => logs each value from left to right and returns the array\n *\n * _.forEach({ 'a': 1, 'b': 2 }, function(n, key) {\n *   console.log(n, key);\n * });\n * // => logs each value-key pair and returns the object (iteration order is not guaranteed)\n */\nvar forEach = createForEach(arrayEach, baseEach);\n\nmodule.exports = forEach;\n","var createAggregator = require(352);\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Creates an object composed of keys generated from the results of running\n * each element of `collection` through `iteratee`. The corresponding value\n * of each key is an array of the elements responsible for generating the key.\n * The `iteratee` is bound to `thisArg` and invoked with three arguments:\n * (value, index|key, collection).\n *\n * If a property name is provided for `iteratee` the created `_.property`\n * style callback returns the property value of the given element.\n *\n * If a value is also provided for `thisArg` the created `_.matchesProperty`\n * style callback returns `true` for elements that have a matching property\n * value, else `false`.\n *\n * If an object is provided for `iteratee` the created `_.matches` style\n * callback returns `true` for elements that have the properties of the given\n * object, else `false`.\n *\n * @static\n * @memberOf _\n * @category Collection\n * @param {Array|Object|string} collection The collection to iterate over.\n * @param {Function|Object|string} [iteratee=_.identity] The function invoked\n *  per iteration.\n * @param {*} [thisArg] The `this` binding of `iteratee`.\n * @returns {Object} Returns the composed aggregate object.\n * @example\n *\n * _.groupBy([4.2, 6.1, 6.4], function(n) {\n *   return Math.floor(n);\n * });\n * // => { '4': [4.2], '6': [6.1, 6.4] }\n *\n * _.groupBy([4.2, 6.1, 6.4], function(n) {\n *   return this.floor(n);\n * }, Math);\n * // => { '4': [4.2], '6': [6.1, 6.4] }\n *\n * // using the `_.property` callback shorthand\n * _.groupBy(['one', 'two', 'three'], 'length');\n * // => { '3': ['one', 'two'], '5': ['three'] }\n */\nvar groupBy = createAggregator(function(result, value, key) {\n  if (hasOwnProperty.call(result, key)) {\n    result[key].push(value);\n  } else {\n    result[key] = [value];\n  }\n});\n\nmodule.exports = groupBy;\n","var baseIndexOf = require(325),\n    getLength = require(371),\n    isArray = require(401),\n    isIterateeCall = require(380),\n    isLength = require(383),\n    isString = require(407),\n    values = require(419);\n\n/* Native method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max;\n\n/**\n * Checks if `target` is in `collection` using\n * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\n * for equality comparisons. If `fromIndex` is negative, it's used as the offset\n * from the end of `collection`.\n *\n * @static\n * @memberOf _\n * @alias contains, include\n * @category Collection\n * @param {Array|Object|string} collection The collection to search.\n * @param {*} target The value to search for.\n * @param {number} [fromIndex=0] The index to search from.\n * @param- {Object} [guard] Enables use as a callback for functions like `_.reduce`.\n * @returns {boolean} Returns `true` if a matching element is found, else `false`.\n * @example\n *\n * _.includes([1, 2, 3], 1);\n * // => true\n *\n * _.includes([1, 2, 3], 1, 2);\n * // => false\n *\n * _.includes({ 'user': 'fred', 'age': 40 }, 'fred');\n * // => true\n *\n * _.includes('pebbles', 'eb');\n * // => true\n */\nfunction includes(collection, target, fromIndex, guard) {\n  var length = collection ? getLength(collection) : 0;\n  if (!isLength(length)) {\n    collection = values(collection);\n    length = collection.length;\n  }\n  if (typeof fromIndex != 'number' || (guard && isIterateeCall(target, fromIndex, guard))) {\n    fromIndex = 0;\n  } else {\n    fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : (fromIndex || 0);\n  }\n  return (typeof collection == 'string' || !isArray(collection) && isString(collection))\n    ? (fromIndex <= length && collection.indexOf(target, fromIndex) > -1)\n    : (!!length && baseIndexOf(collection, target, fromIndex) > -1);\n}\n\nmodule.exports = includes;\n","var arrayMap = require(303),\n    baseCallback = require(309),\n    baseMap = require(330),\n    isArray = require(401);\n\n/**\n * Creates an array of values by running each element in `collection` through\n * `iteratee`. The `iteratee` is bound to `thisArg` and invoked with three\n * arguments: (value, index|key, collection).\n *\n * If a property name is provided for `iteratee` the created `_.property`\n * style callback returns the property value of the given element.\n *\n * If a value is also provided for `thisArg` the created `_.matchesProperty`\n * style callback returns `true` for elements that have a matching property\n * value, else `false`.\n *\n * If an object is provided for `iteratee` the created `_.matches` style\n * callback returns `true` for elements that have the properties of the given\n * object, else `false`.\n *\n * Many lodash methods are guarded to work as iteratees for methods like\n * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.\n *\n * The guarded methods are:\n * `ary`, `callback`, `chunk`, `clone`, `create`, `curry`, `curryRight`,\n * `drop`, `dropRight`, `every`, `fill`, `flatten`, `invert`, `max`, `min`,\n * `parseInt`, `slice`, `sortBy`, `take`, `takeRight`, `template`, `trim`,\n * `trimLeft`, `trimRight`, `trunc`, `random`, `range`, `sample`, `some`,\n * `sum`, `uniq`, and `words`\n *\n * @static\n * @memberOf _\n * @alias collect\n * @category Collection\n * @param {Array|Object|string} collection The collection to iterate over.\n * @param {Function|Object|string} [iteratee=_.identity] The function invoked\n *  per iteration.\n * @param {*} [thisArg] The `this` binding of `iteratee`.\n * @returns {Array} Returns the new mapped array.\n * @example\n *\n * function timesThree(n) {\n *   return n * 3;\n * }\n *\n * _.map([1, 2], timesThree);\n * // => [3, 6]\n *\n * _.map({ 'a': 1, 'b': 2 }, timesThree);\n * // => [3, 6] (iteration order is not guaranteed)\n *\n * var users = [\n *   { 'user': 'barney' },\n *   { 'user': 'fred' }\n * ];\n *\n * // using the `_.property` callback shorthand\n * _.map(users, 'user');\n * // => ['barney', 'fred']\n */\nfunction map(collection, iteratee, thisArg) {\n  var func = isArray(collection) ? arrayMap : baseMap;\n  iteratee = baseCallback(iteratee, thisArg, 3);\n  return func(collection, iteratee);\n}\n\nmodule.exports = map;\n","var arrayReduce = require(305),\n    baseEach = require(315),\n    createReduce = require(364);\n\n/**\n * Reduces `collection` to a value which is the accumulated result of running\n * each element in `collection` through `iteratee`, where each successive\n * invocation is supplied the return value of the previous. If `accumulator`\n * is not provided the first element of `collection` is used as the initial\n * value. The `iteratee` is bound to `thisArg` and invoked with four arguments:\n * (accumulator, value, index|key, collection).\n *\n * Many lodash methods are guarded to work as iteratees for methods like\n * `_.reduce`, `_.reduceRight`, and `_.transform`.\n *\n * The guarded methods are:\n * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `sortByAll`,\n * and `sortByOrder`\n *\n * @static\n * @memberOf _\n * @alias foldl, inject\n * @category Collection\n * @param {Array|Object|string} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @param {*} [accumulator] The initial value.\n * @param {*} [thisArg] The `this` binding of `iteratee`.\n * @returns {*} Returns the accumulated value.\n * @example\n *\n * _.reduce([1, 2], function(total, n) {\n *   return total + n;\n * });\n * // => 3\n *\n * _.reduce({ 'a': 1, 'b': 2 }, function(result, n, key) {\n *   result[key] = n * 3;\n *   return result;\n * }, {});\n * // => { 'a': 3, 'b': 6 } (iteration order is not guaranteed)\n */\nvar reduce = createReduce(arrayReduce, baseEach);\n\nmodule.exports = reduce;\n","var arrayFilter = require(302),\n    baseCallback = require(309),\n    baseFilter = require(317),\n    isArray = require(401);\n\n/**\n * The opposite of `_.filter`; this method returns the elements of `collection`\n * that `predicate` does **not** return truthy for.\n *\n * @static\n * @memberOf _\n * @category Collection\n * @param {Array|Object|string} collection The collection to iterate over.\n * @param {Function|Object|string} [predicate=_.identity] The function invoked\n *  per iteration.\n * @param {*} [thisArg] The `this` binding of `predicate`.\n * @returns {Array} Returns the new filtered array.\n * @example\n *\n * _.reject([1, 2, 3, 4], function(n) {\n *   return n % 2 == 0;\n * });\n * // => [1, 3]\n *\n * var users = [\n *   { 'user': 'barney', 'age': 36, 'active': false },\n *   { 'user': 'fred',   'age': 40, 'active': true }\n * ];\n *\n * // using the `_.matches` callback shorthand\n * _.pluck(_.reject(users, { 'age': 40, 'active': true }), 'user');\n * // => ['barney']\n *\n * // using the `_.matchesProperty` callback shorthand\n * _.pluck(_.reject(users, 'active', false), 'user');\n * // => ['fred']\n *\n * // using the `_.property` callback shorthand\n * _.pluck(_.reject(users, 'active'), 'user');\n * // => ['barney']\n */\nfunction reject(collection, predicate, thisArg) {\n  var func = isArray(collection) ? arrayFilter : baseFilter;\n  predicate = baseCallback(predicate, thisArg, 3);\n  return func(collection, function(value, index, collection) {\n    return !predicate(value, index, collection);\n  });\n}\n\nmodule.exports = reject;\n","var getLength = require(371),\n    isLength = require(383),\n    keys = require(412);\n\n/**\n * Gets the size of `collection` by returning its length for array-like\n * values or the number of own enumerable properties for objects.\n *\n * @static\n * @memberOf _\n * @category Collection\n * @param {Array|Object|string} collection The collection to inspect.\n * @returns {number} Returns the size of `collection`.\n * @example\n *\n * _.size([1, 2, 3]);\n * // => 3\n *\n * _.size({ 'a': 1, 'b': 2 });\n * // => 2\n *\n * _.size('pebbles');\n * // => 7\n */\nfunction size(collection) {\n  var length = collection ? getLength(collection) : 0;\n  return isLength(length) ? length : keys(collection).length;\n}\n\nmodule.exports = size;\n","var arraySome = require(306),\n    baseCallback = require(309),\n    baseSome = require(340),\n    isArray = require(401),\n    isIterateeCall = require(380);\n\n/**\n * Checks if `predicate` returns truthy for **any** element of `collection`.\n * The function returns as soon as it finds a passing value and does not iterate\n * over the entire collection. The predicate is bound to `thisArg` and invoked\n * with three arguments: (value, index|key, collection).\n *\n * If a property name is provided for `predicate` the created `_.property`\n * style callback returns the property value of the given element.\n *\n * If a value is also provided for `thisArg` the created `_.matchesProperty`\n * style callback returns `true` for elements that have a matching property\n * value, else `false`.\n *\n * If an object is provided for `predicate` the created `_.matches` style\n * callback returns `true` for elements that have the properties of the given\n * object, else `false`.\n *\n * @static\n * @memberOf _\n * @alias any\n * @category Collection\n * @param {Array|Object|string} collection The collection to iterate over.\n * @param {Function|Object|string} [predicate=_.identity] The function invoked\n *  per iteration.\n * @param {*} [thisArg] The `this` binding of `predicate`.\n * @returns {boolean} Returns `true` if any element passes the predicate check,\n *  else `false`.\n * @example\n *\n * _.some([null, 0, 'yes', false], Boolean);\n * // => true\n *\n * var users = [\n *   { 'user': 'barney', 'active': true },\n *   { 'user': 'fred',   'active': false }\n * ];\n *\n * // using the `_.matches` callback shorthand\n * _.some(users, { 'user': 'barney', 'active': false });\n * // => false\n *\n * // using the `_.matchesProperty` callback shorthand\n * _.some(users, 'active', false);\n * // => true\n *\n * // using the `_.property` callback shorthand\n * _.some(users, 'active');\n * // => true\n */\nfunction some(collection, predicate, thisArg) {\n  var func = isArray(collection) ? arraySome : baseSome;\n  if (thisArg && isIterateeCall(collection, predicate, thisArg)) {\n    predicate = undefined;\n  }\n  if (typeof predicate != 'function' || thisArg !== undefined) {\n    predicate = baseCallback(predicate, thisArg, 3);\n  }\n  return func(collection, predicate);\n}\n\nmodule.exports = some;\n","var baseCallback = require(309),\n    baseMap = require(330),\n    baseSortBy = require(341),\n    compareAscending = require(349),\n    isIterateeCall = require(380);\n\n/**\n * Creates an array of elements, sorted in ascending order by the results of\n * running each element in a collection through `iteratee`. This method performs\n * a stable sort, that is, it preserves the original sort order of equal elements.\n * The `iteratee` is bound to `thisArg` and invoked with three arguments:\n * (value, index|key, collection).\n *\n * If a property name is provided for `iteratee` the created `_.property`\n * style callback returns the property value of the given element.\n *\n * If a value is also provided for `thisArg` the created `_.matchesProperty`\n * style callback returns `true` for elements that have a matching property\n * value, else `false`.\n *\n * If an object is provided for `iteratee` the created `_.matches` style\n * callback returns `true` for elements that have the properties of the given\n * object, else `false`.\n *\n * @static\n * @memberOf _\n * @category Collection\n * @param {Array|Object|string} collection The collection to iterate over.\n * @param {Function|Object|string} [iteratee=_.identity] The function invoked\n *  per iteration.\n * @param {*} [thisArg] The `this` binding of `iteratee`.\n * @returns {Array} Returns the new sorted array.\n * @example\n *\n * _.sortBy([1, 2, 3], function(n) {\n *   return Math.sin(n);\n * });\n * // => [3, 1, 2]\n *\n * _.sortBy([1, 2, 3], function(n) {\n *   return this.sin(n);\n * }, Math);\n * // => [3, 1, 2]\n *\n * var users = [\n *   { 'user': 'fred' },\n *   { 'user': 'pebbles' },\n *   { 'user': 'barney' }\n * ];\n *\n * // using the `_.property` callback shorthand\n * _.pluck(_.sortBy(users, 'user'), 'user');\n * // => ['barney', 'fred', 'pebbles']\n */\nfunction sortBy(collection, iteratee, thisArg) {\n  if (collection == null) {\n    return [];\n  }\n  if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {\n    iteratee = undefined;\n  }\n  var index = -1;\n  iteratee = baseCallback(iteratee, thisArg, 3);\n\n  var result = baseMap(collection, function(value, key, collection) {\n    return { 'criteria': iteratee(value, key, collection), 'index': ++index, 'value': value };\n  });\n  return baseSortBy(result, compareAscending);\n}\n\nmodule.exports = sortBy;\n","var getNative = require(373);\n\n/* Native method references for those with the same name as other `lodash` methods. */\nvar nativeNow = getNative(Date, 'now');\n\n/**\n * Gets the number of milliseconds that have elapsed since the Unix epoch\n * (1 January 1970 00:00:00 UTC).\n *\n * @static\n * @memberOf _\n * @category Date\n * @example\n *\n * _.defer(function(stamp) {\n *   console.log(_.now() - stamp);\n * }, _.now());\n * // => logs the number of milliseconds it took for the deferred function to be invoked\n */\nvar now = nativeNow || function() {\n  return new Date().getTime();\n};\n\nmodule.exports = now;\n","var createWrapper = require(365),\n    replaceHolders = require(392),\n    restParam = require(295);\n\n/** Used to compose bitmasks for wrapper metadata. */\nvar BIND_FLAG = 1,\n    PARTIAL_FLAG = 32;\n\n/**\n * Creates a function that invokes `func` with the `this` binding of `thisArg`\n * and prepends any additional `_.bind` arguments to those provided to the\n * bound function.\n *\n * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,\n * may be used as a placeholder for partially applied arguments.\n *\n * **Note:** Unlike native `Function#bind` this method does not set the \"length\"\n * property of bound functions.\n *\n * @static\n * @memberOf _\n * @category Function\n * @param {Function} func The function to bind.\n * @param {*} thisArg The `this` binding of `func`.\n * @param {...*} [partials] The arguments to be partially applied.\n * @returns {Function} Returns the new bound function.\n * @example\n *\n * var greet = function(greeting, punctuation) {\n *   return greeting + ' ' + this.user + punctuation;\n * };\n *\n * var object = { 'user': 'fred' };\n *\n * var bound = _.bind(greet, object, 'hi');\n * bound('!');\n * // => 'hi fred!'\n *\n * // using placeholders\n * var bound = _.bind(greet, object, _, '!');\n * bound('hi');\n * // => 'hi fred!'\n */\nvar bind = restParam(function(func, thisArg, partials) {\n  var bitmask = BIND_FLAG;\n  if (partials.length) {\n    var holders = replaceHolders(partials, bind.placeholder);\n    bitmask |= PARTIAL_FLAG;\n  }\n  return createWrapper(func, bitmask, thisArg, partials, holders);\n});\n\n// Assign default placeholders.\nbind.placeholder = {};\n\nmodule.exports = bind;\n","var isObject = require(405),\n    now = require(292);\n\n/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/* Native method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max;\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked. The debounced function comes with a `cancel` method to cancel\n * delayed invocations. Provide an options object to indicate that `func`\n * should be invoked on the leading and/or trailing edge of the `wait` timeout.\n * Subsequent calls to the debounced function return the result of the last\n * `func` invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked\n * on the trailing edge of the timeout only if the the debounced function is\n * invoked more than once during the `wait` timeout.\n *\n * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)\n * for details over the differences between `_.debounce` and `_.throttle`.\n *\n * @static\n * @memberOf _\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0] The number of milliseconds to delay.\n * @param {Object} [options] The options object.\n * @param {boolean} [options.leading=false] Specify invoking on the leading\n *  edge of the timeout.\n * @param {number} [options.maxWait] The maximum time `func` is allowed to be\n *  delayed before it's invoked.\n * @param {boolean} [options.trailing=true] Specify invoking on the trailing\n *  edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // avoid costly calculations while the window size is in flux\n * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n *\n * // invoke `sendMail` when the click event is fired, debouncing subsequent calls\n * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }));\n *\n * // ensure `batchLog` is invoked once after 1 second of debounced calls\n * var source = new EventSource('/stream');\n * jQuery(source).on('message', _.debounce(batchLog, 250, {\n *   'maxWait': 1000\n * }));\n *\n * // cancel a debounced call\n * var todoChanges = _.debounce(batchLog, 1000);\n * Object.observe(models.todo, todoChanges);\n *\n * Object.observe(models, function(changes) {\n *   if (_.find(changes, { 'user': 'todo', 'type': 'delete'})) {\n *     todoChanges.cancel();\n *   }\n * }, ['delete']);\n *\n * // ...at some point `models.todo` is changed\n * models.todo.completed = true;\n *\n * // ...before 1 second has passed `models.todo` is deleted\n * // which cancels the debounced `todoChanges` call\n * delete models.todo;\n */\nfunction debounce(func, wait, options) {\n  var args,\n      maxTimeoutId,\n      result,\n      stamp,\n      thisArg,\n      timeoutId,\n      trailingCall,\n      lastCalled = 0,\n      maxWait = false,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  wait = wait < 0 ? 0 : (+wait || 0);\n  if (options === true) {\n    var leading = true;\n    trailing = false;\n  } else if (isObject(options)) {\n    leading = !!options.leading;\n    maxWait = 'maxWait' in options && nativeMax(+options.maxWait || 0, wait);\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  function cancel() {\n    if (timeoutId) {\n      clearTimeout(timeoutId);\n    }\n    if (maxTimeoutId) {\n      clearTimeout(maxTimeoutId);\n    }\n    lastCalled = 0;\n    maxTimeoutId = timeoutId = trailingCall = undefined;\n  }\n\n  function complete(isCalled, id) {\n    if (id) {\n      clearTimeout(id);\n    }\n    maxTimeoutId = timeoutId = trailingCall = undefined;\n    if (isCalled) {\n      lastCalled = now();\n      result = func.apply(thisArg, args);\n      if (!timeoutId && !maxTimeoutId) {\n        args = thisArg = undefined;\n      }\n    }\n  }\n\n  function delayed() {\n    var remaining = wait - (now() - stamp);\n    if (remaining <= 0 || remaining > wait) {\n      complete(trailingCall, maxTimeoutId);\n    } else {\n      timeoutId = setTimeout(delayed, remaining);\n    }\n  }\n\n  function maxDelayed() {\n    complete(trailing, timeoutId);\n  }\n\n  function debounced() {\n    args = arguments;\n    stamp = now();\n    thisArg = this;\n    trailingCall = trailing && (timeoutId || !leading);\n\n    if (maxWait === false) {\n      var leadingCall = leading && !timeoutId;\n    } else {\n      if (!maxTimeoutId && !leading) {\n        lastCalled = stamp;\n      }\n      var remaining = maxWait - (stamp - lastCalled),\n          isCalled = remaining <= 0 || remaining > maxWait;\n\n      if (isCalled) {\n        if (maxTimeoutId) {\n          maxTimeoutId = clearTimeout(maxTimeoutId);\n        }\n        lastCalled = stamp;\n        result = func.apply(thisArg, args);\n      }\n      else if (!maxTimeoutId) {\n        maxTimeoutId = setTimeout(maxDelayed, remaining);\n      }\n    }\n    if (isCalled && timeoutId) {\n      timeoutId = clearTimeout(timeoutId);\n    }\n    else if (!timeoutId && wait !== maxWait) {\n      timeoutId = setTimeout(delayed, wait);\n    }\n    if (leadingCall) {\n      isCalled = true;\n      result = func.apply(thisArg, args);\n    }\n    if (isCalled && !timeoutId && !maxTimeoutId) {\n      args = thisArg = undefined;\n    }\n    return result;\n  }\n  debounced.cancel = cancel;\n  return debounced;\n}\n\nmodule.exports = debounce;\n","/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/* Native method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max;\n\n/**\n * Creates a function that invokes `func` with the `this` binding of the\n * created function and arguments from `start` and beyond provided as an array.\n *\n * **Note:** This method is based on the [rest parameter](https://developer.mozilla.org/Web/JavaScript/Reference/Functions/rest_parameters).\n *\n * @static\n * @memberOf _\n * @category Function\n * @param {Function} func The function to apply a rest parameter to.\n * @param {number} [start=func.length-1] The start position of the rest parameter.\n * @returns {Function} Returns the new function.\n * @example\n *\n * var say = _.restParam(function(what, names) {\n *   return what + ' ' + _.initial(names).join(', ') +\n *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);\n * });\n *\n * say('hello', 'fred', 'barney', 'pebbles');\n * // => 'hello fred, barney, & pebbles'\n */\nfunction restParam(func, start) {\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  start = nativeMax(start === undefined ? (func.length - 1) : (+start || 0), 0);\n  return function() {\n    var args = arguments,\n        index = -1,\n        length = nativeMax(args.length - start, 0),\n        rest = Array(length);\n\n    while (++index < length) {\n      rest[index] = args[start + index];\n    }\n    switch (start) {\n      case 0: return func.call(this, rest);\n      case 1: return func.call(this, args[0], rest);\n      case 2: return func.call(this, args[0], args[1], rest);\n    }\n    var otherArgs = Array(start + 1);\n    index = -1;\n    while (++index < start) {\n      otherArgs[index] = args[index];\n    }\n    otherArgs[start] = rest;\n    return func.apply(this, otherArgs);\n  };\n}\n\nmodule.exports = restParam;\n","var baseCreate = require(313),\n    baseLodash = require(329);\n\n/** Used as references for `-Infinity` and `Infinity`. */\nvar POSITIVE_INFINITY = Number.POSITIVE_INFINITY;\n\n/**\n * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.\n *\n * @private\n * @param {*} value The value to wrap.\n */\nfunction LazyWrapper(value) {\n  this.__wrapped__ = value;\n  this.__actions__ = [];\n  this.__dir__ = 1;\n  this.__filtered__ = false;\n  this.__iteratees__ = [];\n  this.__takeCount__ = POSITIVE_INFINITY;\n  this.__views__ = [];\n}\n\nLazyWrapper.prototype = baseCreate(baseLodash.prototype);\nLazyWrapper.prototype.constructor = LazyWrapper;\n\nmodule.exports = LazyWrapper;\n","var baseCreate = require(313),\n    baseLodash = require(329);\n\n/**\n * The base constructor for creating `lodash` wrapper objects.\n *\n * @private\n * @param {*} value The value to wrap.\n * @param {boolean} [chainAll] Enable chaining for all wrapper methods.\n * @param {Array} [actions=[]] Actions to peform to resolve the unwrapped value.\n */\nfunction LodashWrapper(value, chainAll, actions) {\n  this.__wrapped__ = value;\n  this.__actions__ = actions || [];\n  this.__chain__ = !!chainAll;\n}\n\nLodashWrapper.prototype = baseCreate(baseLodash.prototype);\nLodashWrapper.prototype.constructor = LodashWrapper;\n\nmodule.exports = LodashWrapper;\n","var cachePush = require('./cachePush'),\n    getNative = require('./getNative');\n\n/** Native method references. */\nvar Set = getNative(global, 'Set');\n\n/* Native method references for those with the same name as other `lodash` methods. */\nvar nativeCreate = getNative(Object, 'create');\n\n/**\n *\n * Creates a cache object to store unique values.\n *\n * @private\n * @param {Array} [values] The values to cache.\n */\nfunction SetCache(values) {\n  var length = values ? values.length : 0;\n\n  this.data = { 'hash': nativeCreate(null), 'set': new Set };\n  while (length--) {\n    this.push(values[length]);\n  }\n}\n\n// Add functions to the `Set` cache.\nSetCache.prototype.push = cachePush;\n\nmodule.exports = SetCache;\n","/**\n * Copies the values of `source` to `array`.\n *\n * @private\n * @param {Array} source The array to copy values from.\n * @param {Array} [array=[]] The array to copy values to.\n * @returns {Array} Returns `array`.\n */\nfunction arrayCopy(source, array) {\n  var index = -1,\n      length = source.length;\n\n  array || (array = Array(length));\n  while (++index < length) {\n    array[index] = source[index];\n  }\n  return array;\n}\n\nmodule.exports = arrayCopy;\n","/**\n * A specialized version of `_.forEach` for arrays without support for callback\n * shorthands and `this` binding.\n *\n * @private\n * @param {Array} array The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns `array`.\n */\nfunction arrayEach(array, iteratee) {\n  var index = -1,\n      length = array.length;\n\n  while (++index < length) {\n    if (iteratee(array[index], index, array) === false) {\n      break;\n    }\n  }\n  return array;\n}\n\nmodule.exports = arrayEach;\n","/**\n * A specialized version of `_.every` for arrays without support for callback\n * shorthands and `this` binding.\n *\n * @private\n * @param {Array} array The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if all elements pass the predicate check,\n *  else `false`.\n */\nfunction arrayEvery(array, predicate) {\n  var index = -1,\n      length = array.length;\n\n  while (++index < length) {\n    if (!predicate(array[index], index, array)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nmodule.exports = arrayEvery;\n","/**\n * A specialized version of `_.filter` for arrays without support for callback\n * shorthands and `this` binding.\n *\n * @private\n * @param {Array} array The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n */\nfunction arrayFilter(array, predicate) {\n  var index = -1,\n      length = array.length,\n      resIndex = -1,\n      result = [];\n\n  while (++index < length) {\n    var value = array[index];\n    if (predicate(value, index, array)) {\n      result[++resIndex] = value;\n    }\n  }\n  return result;\n}\n\nmodule.exports = arrayFilter;\n","/**\n * A specialized version of `_.map` for arrays without support for callback\n * shorthands and `this` binding.\n *\n * @private\n * @param {Array} array The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction arrayMap(array, iteratee) {\n  var index = -1,\n      length = array.length,\n      result = Array(length);\n\n  while (++index < length) {\n    result[index] = iteratee(array[index], index, array);\n  }\n  return result;\n}\n\nmodule.exports = arrayMap;\n","/**\n * Appends the elements of `values` to `array`.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to append.\n * @returns {Array} Returns `array`.\n */\nfunction arrayPush(array, values) {\n  var index = -1,\n      length = values.length,\n      offset = array.length;\n\n  while (++index < length) {\n    array[offset + index] = values[index];\n  }\n  return array;\n}\n\nmodule.exports = arrayPush;\n","/**\n * A specialized version of `_.reduce` for arrays without support for callback\n * shorthands and `this` binding.\n *\n * @private\n * @param {Array} array The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {*} [accumulator] The initial value.\n * @param {boolean} [initFromArray] Specify using the first element of `array`\n *  as the initial value.\n * @returns {*} Returns the accumulated value.\n */\nfunction arrayReduce(array, iteratee, accumulator, initFromArray) {\n  var index = -1,\n      length = array.length;\n\n  if (initFromArray && length) {\n    accumulator = array[++index];\n  }\n  while (++index < length) {\n    accumulator = iteratee(accumulator, array[index], index, array);\n  }\n  return accumulator;\n}\n\nmodule.exports = arrayReduce;\n","/**\n * A specialized version of `_.some` for arrays without support for callback\n * shorthands and `this` binding.\n *\n * @private\n * @param {Array} array The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if any element passes the predicate check,\n *  else `false`.\n */\nfunction arraySome(array, predicate) {\n  var index = -1,\n      length = array.length;\n\n  while (++index < length) {\n    if (predicate(array[index], index, array)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nmodule.exports = arraySome;\n","var keys = require(412);\n\n/**\n * A specialized version of `_.assign` for customizing assigned values without\n * support for argument juggling, multiple sources, and `this` binding `customizer`\n * functions.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @param {Function} customizer The function to customize assigned values.\n * @returns {Object} Returns `object`.\n */\nfunction assignWith(object, source, customizer) {\n  var index = -1,\n      props = keys(source),\n      length = props.length;\n\n  while (++index < length) {\n    var key = props[index],\n        value = object[key],\n        result = customizer(value, source[key], key, object, source);\n\n    if ((result === result ? (result !== value) : (value === value)) ||\n        (value === undefined && !(key in object))) {\n      object[key] = result;\n    }\n  }\n  return object;\n}\n\nmodule.exports = assignWith;\n","var baseCopy = require(312),\n    keys = require(412);\n\n/**\n * The base implementation of `_.assign` without support for argument juggling,\n * multiple sources, and `customizer` functions.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @returns {Object} Returns `object`.\n */\nfunction baseAssign(object, source) {\n  return source == null\n    ? object\n    : baseCopy(source, keys(source), object);\n}\n\nmodule.exports = baseAssign;\n","var baseMatches = require(331),\n    baseMatchesProperty = require(332),\n    bindCallback = require(345),\n    identity = require(420),\n    property = require(422);\n\n/**\n * The base implementation of `_.callback` which supports specifying the\n * number of arguments to provide to `func`.\n *\n * @private\n * @param {*} [func=_.identity] The value to convert to a callback.\n * @param {*} [thisArg] The `this` binding of `func`.\n * @param {number} [argCount] The number of arguments to provide to `func`.\n * @returns {Function} Returns the callback.\n */\nfunction baseCallback(func, thisArg, argCount) {\n  var type = typeof func;\n  if (type == 'function') {\n    return thisArg === undefined\n      ? func\n      : bindCallback(func, thisArg, argCount);\n  }\n  if (func == null) {\n    return identity;\n  }\n  if (type == 'object') {\n    return baseMatches(func);\n  }\n  return thisArg === undefined\n    ? property(func)\n    : baseMatchesProperty(func, thisArg);\n}\n\nmodule.exports = baseCallback;\n","var arrayCopy = require(299),\n    arrayEach = require(300),\n    baseAssign = require(308),\n    baseForOwn = require(323),\n    initCloneArray = require(375),\n    initCloneByTag = require(376),\n    initCloneObject = require(377),\n    isArray = require(401),\n    isObject = require(405);\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/** Used to identify `toStringTag` values supported by `_.clone`. */\nvar cloneableTags = {};\ncloneableTags[argsTag] = cloneableTags[arrayTag] =\ncloneableTags[arrayBufferTag] = cloneableTags[boolTag] =\ncloneableTags[dateTag] = cloneableTags[float32Tag] =\ncloneableTags[float64Tag] = cloneableTags[int8Tag] =\ncloneableTags[int16Tag] = cloneableTags[int32Tag] =\ncloneableTags[numberTag] = cloneableTags[objectTag] =\ncloneableTags[regexpTag] = cloneableTags[stringTag] =\ncloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =\ncloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;\ncloneableTags[errorTag] = cloneableTags[funcTag] =\ncloneableTags[mapTag] = cloneableTags[setTag] =\ncloneableTags[weakMapTag] = false;\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objToString = objectProto.toString;\n\n/**\n * The base implementation of `_.clone` without support for argument juggling\n * and `this` binding `customizer` functions.\n *\n * @private\n * @param {*} value The value to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @param {Function} [customizer] The function to customize cloning values.\n * @param {string} [key] The key of `value`.\n * @param {Object} [object] The object `value` belongs to.\n * @param {Array} [stackA=[]] Tracks traversed source objects.\n * @param {Array} [stackB=[]] Associates clones with source counterparts.\n * @returns {*} Returns the cloned value.\n */\nfunction baseClone(value, isDeep, customizer, key, object, stackA, stackB) {\n  var result;\n  if (customizer) {\n    result = object ? customizer(value, key, object) : customizer(value);\n  }\n  if (result !== undefined) {\n    return result;\n  }\n  if (!isObject(value)) {\n    return value;\n  }\n  var isArr = isArray(value);\n  if (isArr) {\n    result = initCloneArray(value);\n    if (!isDeep) {\n      return arrayCopy(value, result);\n    }\n  } else {\n    var tag = objToString.call(value),\n        isFunc = tag == funcTag;\n\n    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {\n      result = initCloneObject(isFunc ? {} : value);\n      if (!isDeep) {\n        return baseAssign(result, value);\n      }\n    } else {\n      return cloneableTags[tag]\n        ? initCloneByTag(value, tag, isDeep)\n        : (object ? value : {});\n    }\n  }\n  // Check for circular references and return its corresponding clone.\n  stackA || (stackA = []);\n  stackB || (stackB = []);\n\n  var length = stackA.length;\n  while (length--) {\n    if (stackA[length] == value) {\n      return stackB[length];\n    }\n  }\n  // Add the source value to the stack of traversed objects and associate it with its clone.\n  stackA.push(value);\n  stackB.push(result);\n\n  // Recursively populate clone (susceptible to call stack limits).\n  (isArr ? arrayEach : baseForOwn)(value, function(subValue, key) {\n    result[key] = baseClone(subValue, isDeep, customizer, key, value, stackA, stackB);\n  });\n  return result;\n}\n\nmodule.exports = baseClone;\n","/**\n * The base implementation of `compareAscending` which compares values and\n * sorts them in ascending order without guaranteeing a stable sort.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {number} Returns the sort order indicator for `value`.\n */\nfunction baseCompareAscending(value, other) {\n  if (value !== other) {\n    var valIsNull = value === null,\n        valIsUndef = value === undefined,\n        valIsReflexive = value === value;\n\n    var othIsNull = other === null,\n        othIsUndef = other === undefined,\n        othIsReflexive = other === other;\n\n    if ((value > other && !othIsNull) || !valIsReflexive ||\n        (valIsNull && !othIsUndef && othIsReflexive) ||\n        (valIsUndef && othIsReflexive)) {\n      return 1;\n    }\n    if ((value < other && !valIsNull) || !othIsReflexive ||\n        (othIsNull && !valIsUndef && valIsReflexive) ||\n        (othIsUndef && valIsReflexive)) {\n      return -1;\n    }\n  }\n  return 0;\n}\n\nmodule.exports = baseCompareAscending;\n","/**\n * Copies properties of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy properties from.\n * @param {Array} props The property names to copy.\n * @param {Object} [object={}] The object to copy properties to.\n * @returns {Object} Returns `object`.\n */\nfunction baseCopy(source, props, object) {\n  object || (object = {});\n\n  var index = -1,\n      length = props.length;\n\n  while (++index < length) {\n    var key = props[index];\n    object[key] = source[key];\n  }\n  return object;\n}\n\nmodule.exports = baseCopy;\n","var isObject = require(405);\n\n/**\n * The base implementation of `_.create` without support for assigning\n * properties to the created object.\n *\n * @private\n * @param {Object} prototype The object to inherit from.\n * @returns {Object} Returns the new object.\n */\nvar baseCreate = (function() {\n  function object() {}\n  return function(prototype) {\n    if (isObject(prototype)) {\n      object.prototype = prototype;\n      var result = new object;\n      object.prototype = undefined;\n    }\n    return result || {};\n  };\n}());\n\nmodule.exports = baseCreate;\n","var baseIndexOf = require(325),\n    cacheIndexOf = require(347),\n    createCache = require(357);\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/**\n * The base implementation of `_.difference` which accepts a single array\n * of values to exclude.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {Array} values The values to exclude.\n * @returns {Array} Returns the new array of filtered values.\n */\nfunction baseDifference(array, values) {\n  var length = array ? array.length : 0,\n      result = [];\n\n  if (!length) {\n    return result;\n  }\n  var index = -1,\n      indexOf = baseIndexOf,\n      isCommon = true,\n      cache = (isCommon && values.length >= LARGE_ARRAY_SIZE) ? createCache(values) : null,\n      valuesLength = values.length;\n\n  if (cache) {\n    indexOf = cacheIndexOf;\n    isCommon = false;\n    values = cache;\n  }\n  outer:\n  while (++index < length) {\n    var value = array[index];\n\n    if (isCommon && value === value) {\n      var valuesIndex = valuesLength;\n      while (valuesIndex--) {\n        if (values[valuesIndex] === value) {\n          continue outer;\n        }\n      }\n      result.push(value);\n    }\n    else if (indexOf(values, value, 0) < 0) {\n      result.push(value);\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseDifference;\n","var baseForOwn = require(323),\n    createBaseEach = require(354);\n\n/**\n * The base implementation of `_.forEach` without support for callback\n * shorthands and `this` binding.\n *\n * @private\n * @param {Array|Object|string} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array|Object|string} Returns `collection`.\n */\nvar baseEach = createBaseEach(baseForOwn);\n\nmodule.exports = baseEach;\n","var baseEach = require(315);\n\n/**\n * The base implementation of `_.every` without support for callback\n * shorthands and `this` binding.\n *\n * @private\n * @param {Array|Object|string} collection The collection to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if all elements pass the predicate check,\n *  else `false`\n */\nfunction baseEvery(collection, predicate) {\n  var result = true;\n  baseEach(collection, function(value, index, collection) {\n    result = !!predicate(value, index, collection);\n    return result;\n  });\n  return result;\n}\n\nmodule.exports = baseEvery;\n","var baseEach = require(315);\n\n/**\n * The base implementation of `_.filter` without support for callback\n * shorthands and `this` binding.\n *\n * @private\n * @param {Array|Object|string} collection The collection to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n */\nfunction baseFilter(collection, predicate) {\n  var result = [];\n  baseEach(collection, function(value, index, collection) {\n    if (predicate(value, index, collection)) {\n      result.push(value);\n    }\n  });\n  return result;\n}\n\nmodule.exports = baseFilter;\n","/**\n * The base implementation of `_.find`, `_.findLast`, `_.findKey`, and `_.findLastKey`,\n * without support for callback shorthands and `this` binding, which iterates\n * over `collection` using the provided `eachFunc`.\n *\n * @private\n * @param {Array|Object|string} collection The collection to search.\n * @param {Function} predicate The function invoked per iteration.\n * @param {Function} eachFunc The function to iterate over `collection`.\n * @param {boolean} [retKey] Specify returning the key of the found element\n *  instead of the element itself.\n * @returns {*} Returns the found element or its key, else `undefined`.\n */\nfunction baseFind(collection, predicate, eachFunc, retKey) {\n  var result;\n  eachFunc(collection, function(value, key, collection) {\n    if (predicate(value, key, collection)) {\n      result = retKey ? key : value;\n      return false;\n    }\n  });\n  return result;\n}\n\nmodule.exports = baseFind;\n","/**\n * The base implementation of `_.findIndex` and `_.findLastIndex` without\n * support for callback shorthands and `this` binding.\n *\n * @private\n * @param {Array} array The array to search.\n * @param {Function} predicate The function invoked per iteration.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction baseFindIndex(array, predicate, fromRight) {\n  var length = array.length,\n      index = fromRight ? length : -1;\n\n  while ((fromRight ? index-- : ++index < length)) {\n    if (predicate(array[index], index, array)) {\n      return index;\n    }\n  }\n  return -1;\n}\n\nmodule.exports = baseFindIndex;\n","var arrayPush = require(304),\n    isArguments = require(400),\n    isArray = require(401),\n    isArrayLike = require(378),\n    isObjectLike = require(384);\n\n/**\n * The base implementation of `_.flatten` with added support for restricting\n * flattening and specifying the start index.\n *\n * @private\n * @param {Array} array The array to flatten.\n * @param {boolean} [isDeep] Specify a deep flatten.\n * @param {boolean} [isStrict] Restrict flattening to arrays-like objects.\n * @param {Array} [result=[]] The initial result value.\n * @returns {Array} Returns the new flattened array.\n */\nfunction baseFlatten(array, isDeep, isStrict, result) {\n  result || (result = []);\n\n  var index = -1,\n      length = array.length;\n\n  while (++index < length) {\n    var value = array[index];\n    if (isObjectLike(value) && isArrayLike(value) &&\n        (isStrict || isArray(value) || isArguments(value))) {\n      if (isDeep) {\n        // Recursively flatten arrays (susceptible to call stack limits).\n        baseFlatten(value, isDeep, isStrict, result);\n      } else {\n        arrayPush(result, value);\n      }\n    } else if (!isStrict) {\n      result[result.length] = value;\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseFlatten;\n","var createBaseFor = require(355);\n\n/**\n * The base implementation of `baseForIn` and `baseForOwn` which iterates\n * over `object` properties returned by `keysFunc` invoking `iteratee` for\n * each property. Iteratee functions may exit iteration early by explicitly\n * returning `false`.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @returns {Object} Returns `object`.\n */\nvar baseFor = createBaseFor();\n\nmodule.exports = baseFor;\n","var baseFor = require(321),\n    keysIn = require(413);\n\n/**\n * The base implementation of `_.forIn` without support for callback\n * shorthands and `this` binding.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Object} Returns `object`.\n */\nfunction baseForIn(object, iteratee) {\n  return baseFor(object, iteratee, keysIn);\n}\n\nmodule.exports = baseForIn;\n","var baseFor = require(321),\n    keys = require(412);\n\n/**\n * The base implementation of `_.forOwn` without support for callback\n * shorthands and `this` binding.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Object} Returns `object`.\n */\nfunction baseForOwn(object, iteratee) {\n  return baseFor(object, iteratee, keys);\n}\n\nmodule.exports = baseForOwn;\n","var toObject = require(396);\n\n/**\n * The base implementation of `get` without support for string paths\n * and default values.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array} path The path of the property to get.\n * @param {string} [pathKey] The key representation of path.\n * @returns {*} Returns the resolved value.\n */\nfunction baseGet(object, path, pathKey) {\n  if (object == null) {\n    return;\n  }\n  if (pathKey !== undefined && pathKey in toObject(object)) {\n    path = [pathKey];\n  }\n  var index = 0,\n      length = path.length;\n\n  while (object != null && index < length) {\n    object = object[path[index++]];\n  }\n  return (index && index == length) ? object : undefined;\n}\n\nmodule.exports = baseGet;\n","var indexOfNaN = require(374);\n\n/**\n * The base implementation of `_.indexOf` without support for binary searches.\n *\n * @private\n * @param {Array} array The array to search.\n * @param {*} value The value to search for.\n * @param {number} fromIndex The index to search from.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction baseIndexOf(array, value, fromIndex) {\n  if (value !== value) {\n    return indexOfNaN(array, fromIndex);\n  }\n  var index = fromIndex - 1,\n      length = array.length;\n\n  while (++index < length) {\n    if (array[index] === value) {\n      return index;\n    }\n  }\n  return -1;\n}\n\nmodule.exports = baseIndexOf;\n","var baseIsEqualDeep = require(327),\n    isObject = require(405),\n    isObjectLike = require(384);\n\n/**\n * The base implementation of `_.isEqual` without support for `this` binding\n * `customizer` functions.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @param {Function} [customizer] The function to customize comparing values.\n * @param {boolean} [isLoose] Specify performing partial comparisons.\n * @param {Array} [stackA] Tracks traversed `value` objects.\n * @param {Array} [stackB] Tracks traversed `other` objects.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n */\nfunction baseIsEqual(value, other, customizer, isLoose, stackA, stackB) {\n  if (value === other) {\n    return true;\n  }\n  if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {\n    return value !== value && other !== other;\n  }\n  return baseIsEqualDeep(value, other, baseIsEqual, customizer, isLoose, stackA, stackB);\n}\n\nmodule.exports = baseIsEqual;\n","var equalArrays = require(366),\n    equalByTag = require(367),\n    equalObjects = require(368),\n    isArray = require(401),\n    isTypedArray = require(408);\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    objectTag = '[object Object]';\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objToString = objectProto.toString;\n\n/**\n * A specialized version of `baseIsEqual` for arrays and objects which performs\n * deep comparisons and tracks traversed objects enabling objects with circular\n * references to be compared.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Function} [customizer] The function to customize comparing objects.\n * @param {boolean} [isLoose] Specify performing partial comparisons.\n * @param {Array} [stackA=[]] Tracks traversed `value` objects.\n * @param {Array} [stackB=[]] Tracks traversed `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction baseIsEqualDeep(object, other, equalFunc, customizer, isLoose, stackA, stackB) {\n  var objIsArr = isArray(object),\n      othIsArr = isArray(other),\n      objTag = arrayTag,\n      othTag = arrayTag;\n\n  if (!objIsArr) {\n    objTag = objToString.call(object);\n    if (objTag == argsTag) {\n      objTag = objectTag;\n    } else if (objTag != objectTag) {\n      objIsArr = isTypedArray(object);\n    }\n  }\n  if (!othIsArr) {\n    othTag = objToString.call(other);\n    if (othTag == argsTag) {\n      othTag = objectTag;\n    } else if (othTag != objectTag) {\n      othIsArr = isTypedArray(other);\n    }\n  }\n  var objIsObj = objTag == objectTag,\n      othIsObj = othTag == objectTag,\n      isSameTag = objTag == othTag;\n\n  if (isSameTag && !(objIsArr || objIsObj)) {\n    return equalByTag(object, other, objTag);\n  }\n  if (!isLoose) {\n    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n    if (objIsWrapped || othIsWrapped) {\n      return equalFunc(objIsWrapped ? object.value() : object, othIsWrapped ? other.value() : other, customizer, isLoose, stackA, stackB);\n    }\n  }\n  if (!isSameTag) {\n    return false;\n  }\n  // Assume cyclic values are equal.\n  // For more information on detecting circular references see https://es5.github.io/#JO.\n  stackA || (stackA = []);\n  stackB || (stackB = []);\n\n  var length = stackA.length;\n  while (length--) {\n    if (stackA[length] == object) {\n      return stackB[length] == other;\n    }\n  }\n  // Add `object` and `other` to the stack of traversed objects.\n  stackA.push(object);\n  stackB.push(other);\n\n  var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, customizer, isLoose, stackA, stackB);\n\n  stackA.pop();\n  stackB.pop();\n\n  return result;\n}\n\nmodule.exports = baseIsEqualDeep;\n","var baseIsEqual = require(326),\n    toObject = require(396);\n\n/**\n * The base implementation of `_.isMatch` without support for callback\n * shorthands and `this` binding.\n *\n * @private\n * @param {Object} object The object to inspect.\n * @param {Array} matchData The propery names, values, and compare flags to match.\n * @param {Function} [customizer] The function to customize comparing objects.\n * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n */\nfunction baseIsMatch(object, matchData, customizer) {\n  var index = matchData.length,\n      length = index,\n      noCustomizer = !customizer;\n\n  if (object == null) {\n    return !length;\n  }\n  object = toObject(object);\n  while (index--) {\n    var data = matchData[index];\n    if ((noCustomizer && data[2])\n          ? data[1] !== object[data[0]]\n          : !(data[0] in object)\n        ) {\n      return false;\n    }\n  }\n  while (++index < length) {\n    data = matchData[index];\n    var key = data[0],\n        objValue = object[key],\n        srcValue = data[1];\n\n    if (noCustomizer && data[2]) {\n      if (objValue === undefined && !(key in object)) {\n        return false;\n      }\n    } else {\n      var result = customizer ? customizer(objValue, srcValue, key) : undefined;\n      if (!(result === undefined ? baseIsEqual(srcValue, objValue, customizer, true) : result)) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nmodule.exports = baseIsMatch;\n","/**\n * The function whose prototype all chaining wrappers inherit from.\n *\n * @private\n */\nfunction baseLodash() {\n  // No operation performed.\n}\n\nmodule.exports = baseLodash;\n","var baseEach = require(315),\n    isArrayLike = require(378);\n\n/**\n * The base implementation of `_.map` without support for callback shorthands\n * and `this` binding.\n *\n * @private\n * @param {Array|Object|string} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction baseMap(collection, iteratee) {\n  var index = -1,\n      result = isArrayLike(collection) ? Array(collection.length) : [];\n\n  baseEach(collection, function(value, key, collection) {\n    result[++index] = iteratee(value, key, collection);\n  });\n  return result;\n}\n\nmodule.exports = baseMap;\n","var baseIsMatch = require(328),\n    getMatchData = require(372),\n    toObject = require(396);\n\n/**\n * The base implementation of `_.matches` which does not clone `source`.\n *\n * @private\n * @param {Object} source The object of property values to match.\n * @returns {Function} Returns the new function.\n */\nfunction baseMatches(source) {\n  var matchData = getMatchData(source);\n  if (matchData.length == 1 && matchData[0][2]) {\n    var key = matchData[0][0],\n        value = matchData[0][1];\n\n    return function(object) {\n      if (object == null) {\n        return false;\n      }\n      return object[key] === value && (value !== undefined || (key in toObject(object)));\n    };\n  }\n  return function(object) {\n    return baseIsMatch(object, matchData);\n  };\n}\n\nmodule.exports = baseMatches;\n","var baseGet = require(324),\n    baseIsEqual = require(326),\n    baseSlice = require(339),\n    isArray = require(401),\n    isKey = require(381),\n    isStrictComparable = require(385),\n    last = require(273),\n    toObject = require(396),\n    toPath = require(397);\n\n/**\n * The base implementation of `_.matchesProperty` which does not clone `srcValue`.\n *\n * @private\n * @param {string} path The path of the property to get.\n * @param {*} srcValue The value to compare.\n * @returns {Function} Returns the new function.\n */\nfunction baseMatchesProperty(path, srcValue) {\n  var isArr = isArray(path),\n      isCommon = isKey(path) && isStrictComparable(srcValue),\n      pathKey = (path + '');\n\n  path = toPath(path);\n  return function(object) {\n    if (object == null) {\n      return false;\n    }\n    var key = pathKey;\n    object = toObject(object);\n    if ((isArr || !isCommon) && !(key in object)) {\n      object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));\n      if (object == null) {\n        return false;\n      }\n      key = last(path);\n      object = toObject(object);\n    }\n    return object[key] === srcValue\n      ? (srcValue !== undefined || (key in object))\n      : baseIsEqual(srcValue, object[key], undefined, true);\n  };\n}\n\nmodule.exports = baseMatchesProperty;\n","var arrayEach = require(300),\n    baseMergeDeep = require(334),\n    isArray = require(401),\n    isArrayLike = require(378),\n    isObject = require(405),\n    isObjectLike = require(384),\n    isTypedArray = require(408),\n    keys = require(412);\n\n/**\n * The base implementation of `_.merge` without support for argument juggling,\n * multiple sources, and `this` binding `customizer` functions.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @param {Function} [customizer] The function to customize merged values.\n * @param {Array} [stackA=[]] Tracks traversed source objects.\n * @param {Array} [stackB=[]] Associates values with source counterparts.\n * @returns {Object} Returns `object`.\n */\nfunction baseMerge(object, source, customizer, stackA, stackB) {\n  if (!isObject(object)) {\n    return object;\n  }\n  var isSrcArr = isArrayLike(source) && (isArray(source) || isTypedArray(source)),\n      props = isSrcArr ? undefined : keys(source);\n\n  arrayEach(props || source, function(srcValue, key) {\n    if (props) {\n      key = srcValue;\n      srcValue = source[key];\n    }\n    if (isObjectLike(srcValue)) {\n      stackA || (stackA = []);\n      stackB || (stackB = []);\n      baseMergeDeep(object, source, key, baseMerge, customizer, stackA, stackB);\n    }\n    else {\n      var value = object[key],\n          result = customizer ? customizer(value, srcValue, key, object, source) : undefined,\n          isCommon = result === undefined;\n\n      if (isCommon) {\n        result = srcValue;\n      }\n      if ((result !== undefined || (isSrcArr && !(key in object))) &&\n          (isCommon || (result === result ? (result !== value) : (value === value)))) {\n        object[key] = result;\n      }\n    }\n  });\n  return object;\n}\n\nmodule.exports = baseMerge;\n","var arrayCopy = require(299),\n    isArguments = require(400),\n    isArray = require(401),\n    isArrayLike = require(378),\n    isPlainObject = require(406),\n    isTypedArray = require(408),\n    toPlainObject = require(409);\n\n/**\n * A specialized version of `baseMerge` for arrays and objects which performs\n * deep merges and tracks traversed objects enabling objects with circular\n * references to be merged.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @param {string} key The key of the value to merge.\n * @param {Function} mergeFunc The function to merge values.\n * @param {Function} [customizer] The function to customize merged values.\n * @param {Array} [stackA=[]] Tracks traversed source objects.\n * @param {Array} [stackB=[]] Associates values with source counterparts.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction baseMergeDeep(object, source, key, mergeFunc, customizer, stackA, stackB) {\n  var length = stackA.length,\n      srcValue = source[key];\n\n  while (length--) {\n    if (stackA[length] == srcValue) {\n      object[key] = stackB[length];\n      return;\n    }\n  }\n  var value = object[key],\n      result = customizer ? customizer(value, srcValue, key, object, source) : undefined,\n      isCommon = result === undefined;\n\n  if (isCommon) {\n    result = srcValue;\n    if (isArrayLike(srcValue) && (isArray(srcValue) || isTypedArray(srcValue))) {\n      result = isArray(value)\n        ? value\n        : (isArrayLike(value) ? arrayCopy(value) : []);\n    }\n    else if (isPlainObject(srcValue) || isArguments(srcValue)) {\n      result = isArguments(value)\n        ? toPlainObject(value)\n        : (isPlainObject(value) ? value : {});\n    }\n    else {\n      isCommon = false;\n    }\n  }\n  // Add the source value to the stack of traversed objects and associate\n  // it with its merged value.\n  stackA.push(srcValue);\n  stackB.push(result);\n\n  if (isCommon) {\n    // Recursively merge objects and arrays (susceptible to call stack limits).\n    object[key] = mergeFunc(result, srcValue, customizer, stackA, stackB);\n  } else if (result === result ? (result !== value) : (value === value)) {\n    object[key] = result;\n  }\n}\n\nmodule.exports = baseMergeDeep;\n","/**\n * The base implementation of `_.property` without support for deep paths.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @returns {Function} Returns the new function.\n */\nfunction baseProperty(key) {\n  return function(object) {\n    return object == null ? undefined : object[key];\n  };\n}\n\nmodule.exports = baseProperty;\n","var baseGet = require(324),\n    toPath = require(397);\n\n/**\n * A specialized version of `baseProperty` which supports deep paths.\n *\n * @private\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new function.\n */\nfunction basePropertyDeep(path) {\n  var pathKey = (path + '');\n  path = toPath(path);\n  return function(object) {\n    return baseGet(object, path, pathKey);\n  };\n}\n\nmodule.exports = basePropertyDeep;\n","/**\n * The base implementation of `_.reduce` and `_.reduceRight` without support\n * for callback shorthands and `this` binding, which iterates over `collection`\n * using the provided `eachFunc`.\n *\n * @private\n * @param {Array|Object|string} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {*} accumulator The initial value.\n * @param {boolean} initFromCollection Specify using the first or last element\n *  of `collection` as the initial value.\n * @param {Function} eachFunc The function to iterate over `collection`.\n * @returns {*} Returns the accumulated value.\n */\nfunction baseReduce(collection, iteratee, accumulator, initFromCollection, eachFunc) {\n  eachFunc(collection, function(value, index, collection) {\n    accumulator = initFromCollection\n      ? (initFromCollection = false, value)\n      : iteratee(accumulator, value, index, collection);\n  });\n  return accumulator;\n}\n\nmodule.exports = baseReduce;\n","var identity = require(420),\n    metaMap = require(387);\n\n/**\n * The base implementation of `setData` without support for hot loop detection.\n *\n * @private\n * @param {Function} func The function to associate metadata with.\n * @param {*} data The metadata.\n * @returns {Function} Returns `func`.\n */\nvar baseSetData = !metaMap ? identity : function(func, data) {\n  metaMap.set(func, data);\n  return func;\n};\n\nmodule.exports = baseSetData;\n","/**\n * The base implementation of `_.slice` without an iteratee call guard.\n *\n * @private\n * @param {Array} array The array to slice.\n * @param {number} [start=0] The start position.\n * @param {number} [end=array.length] The end position.\n * @returns {Array} Returns the slice of `array`.\n */\nfunction baseSlice(array, start, end) {\n  var index = -1,\n      length = array.length;\n\n  start = start == null ? 0 : (+start || 0);\n  if (start < 0) {\n    start = -start > length ? 0 : (length + start);\n  }\n  end = (end === undefined || end > length) ? length : (+end || 0);\n  if (end < 0) {\n    end += length;\n  }\n  length = start > end ? 0 : ((end - start) >>> 0);\n  start >>>= 0;\n\n  var result = Array(length);\n  while (++index < length) {\n    result[index] = array[index + start];\n  }\n  return result;\n}\n\nmodule.exports = baseSlice;\n","var baseEach = require(315);\n\n/**\n * The base implementation of `_.some` without support for callback shorthands\n * and `this` binding.\n *\n * @private\n * @param {Array|Object|string} collection The collection to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if any element passes the predicate check,\n *  else `false`.\n */\nfunction baseSome(collection, predicate) {\n  var result;\n\n  baseEach(collection, function(value, index, collection) {\n    result = predicate(value, index, collection);\n    return !result;\n  });\n  return !!result;\n}\n\nmodule.exports = baseSome;\n","/**\n * The base implementation of `_.sortBy` which uses `comparer` to define\n * the sort order of `array` and replaces criteria objects with their\n * corresponding values.\n *\n * @private\n * @param {Array} array The array to sort.\n * @param {Function} comparer The function to define sort order.\n * @returns {Array} Returns `array`.\n */\nfunction baseSortBy(array, comparer) {\n  var length = array.length;\n\n  array.sort(comparer);\n  while (length--) {\n    array[length] = array[length].value;\n  }\n  return array;\n}\n\nmodule.exports = baseSortBy;\n","/**\n * Converts `value` to a string if it's not one. An empty string is returned\n * for `null` or `undefined` values.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  return value == null ? '' : (value + '');\n}\n\nmodule.exports = baseToString;\n","var baseIndexOf = require(325),\n    cacheIndexOf = require(347),\n    createCache = require(357);\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/**\n * The base implementation of `_.uniq` without support for callback shorthands\n * and `this` binding.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {Function} [iteratee] The function invoked per iteration.\n * @returns {Array} Returns the new duplicate free array.\n */\nfunction baseUniq(array, iteratee) {\n  var index = -1,\n      indexOf = baseIndexOf,\n      length = array.length,\n      isCommon = true,\n      isLarge = isCommon && length >= LARGE_ARRAY_SIZE,\n      seen = isLarge ? createCache() : null,\n      result = [];\n\n  if (seen) {\n    indexOf = cacheIndexOf;\n    isCommon = false;\n  } else {\n    isLarge = false;\n    seen = iteratee ? [] : result;\n  }\n  outer:\n  while (++index < length) {\n    var value = array[index],\n        computed = iteratee ? iteratee(value, index, array) : value;\n\n    if (isCommon && value === value) {\n      var seenIndex = seen.length;\n      while (seenIndex--) {\n        if (seen[seenIndex] === computed) {\n          continue outer;\n        }\n      }\n      if (iteratee) {\n        seen.push(computed);\n      }\n      result.push(value);\n    }\n    else if (indexOf(seen, computed, 0) < 0) {\n      if (iteratee || isLarge) {\n        seen.push(computed);\n      }\n      result.push(value);\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseUniq;\n","/**\n * The base implementation of `_.values` and `_.valuesIn` which creates an\n * array of `object` property values corresponding to the property names\n * of `props`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array} props The property names to get values for.\n * @returns {Object} Returns the array of property values.\n */\nfunction baseValues(object, props) {\n  var index = -1,\n      length = props.length,\n      result = Array(length);\n\n  while (++index < length) {\n    result[index] = object[props[index]];\n  }\n  return result;\n}\n\nmodule.exports = baseValues;\n","var identity = require(420);\n\n/**\n * A specialized version of `baseCallback` which only supports `this` binding\n * and specifying the number of arguments to provide to `func`.\n *\n * @private\n * @param {Function} func The function to bind.\n * @param {*} thisArg The `this` binding of `func`.\n * @param {number} [argCount] The number of arguments to provide to `func`.\n * @returns {Function} Returns the callback.\n */\nfunction bindCallback(func, thisArg, argCount) {\n  if (typeof func != 'function') {\n    return identity;\n  }\n  if (thisArg === undefined) {\n    return func;\n  }\n  switch (argCount) {\n    case 1: return function(value) {\n      return func.call(thisArg, value);\n    };\n    case 3: return function(value, index, collection) {\n      return func.call(thisArg, value, index, collection);\n    };\n    case 4: return function(accumulator, value, index, collection) {\n      return func.call(thisArg, accumulator, value, index, collection);\n    };\n    case 5: return function(value, other, key, object, source) {\n      return func.call(thisArg, value, other, key, object, source);\n    };\n  }\n  return function() {\n    return func.apply(thisArg, arguments);\n  };\n}\n\nmodule.exports = bindCallback;\n","/** Native method references. */\nvar ArrayBuffer = global.ArrayBuffer,\n    Uint8Array = global.Uint8Array;\n\n/**\n * Creates a clone of the given array buffer.\n *\n * @private\n * @param {ArrayBuffer} buffer The array buffer to clone.\n * @returns {ArrayBuffer} Returns the cloned array buffer.\n */\nfunction bufferClone(buffer) {\n  var result = new ArrayBuffer(buffer.byteLength),\n      view = new Uint8Array(result);\n\n  view.set(new Uint8Array(buffer));\n  return result;\n}\n\nmodule.exports = bufferClone;\n","var isObject = require(405);\n\n/**\n * Checks if `value` is in `cache` mimicking the return signature of\n * `_.indexOf` by returning `0` if the value is found, else `-1`.\n *\n * @private\n * @param {Object} cache The cache to search.\n * @param {*} value The value to search for.\n * @returns {number} Returns `0` if `value` is found, else `-1`.\n */\nfunction cacheIndexOf(cache, value) {\n  var data = cache.data,\n      result = (typeof value == 'string' || isObject(value)) ? data.set.has(value) : data.hash[value];\n\n  return result ? 0 : -1;\n}\n\nmodule.exports = cacheIndexOf;\n","var isObject = require(405);\n\n/**\n * Adds `value` to the cache.\n *\n * @private\n * @name push\n * @memberOf SetCache\n * @param {*} value The value to cache.\n */\nfunction cachePush(value) {\n  var data = this.data;\n  if (typeof value == 'string' || isObject(value)) {\n    data.set.add(value);\n  } else {\n    data.hash[value] = true;\n  }\n}\n\nmodule.exports = cachePush;\n","var baseCompareAscending = require(311);\n\n/**\n * Used by `_.sortBy` to compare transformed elements of a collection and stable\n * sort them in ascending order.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @returns {number} Returns the sort order indicator for `object`.\n */\nfunction compareAscending(object, other) {\n  return baseCompareAscending(object.criteria, other.criteria) || (object.index - other.index);\n}\n\nmodule.exports = compareAscending;\n","/* Native method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max;\n\n/**\n * Creates an array that is the composition of partially applied arguments,\n * placeholders, and provided arguments into a single array of arguments.\n *\n * @private\n * @param {Array|Object} args The provided arguments.\n * @param {Array} partials The arguments to prepend to those provided.\n * @param {Array} holders The `partials` placeholder indexes.\n * @returns {Array} Returns the new array of composed arguments.\n */\nfunction composeArgs(args, partials, holders) {\n  var holdersLength = holders.length,\n      argsIndex = -1,\n      argsLength = nativeMax(args.length - holdersLength, 0),\n      leftIndex = -1,\n      leftLength = partials.length,\n      result = Array(leftLength + argsLength);\n\n  while (++leftIndex < leftLength) {\n    result[leftIndex] = partials[leftIndex];\n  }\n  while (++argsIndex < holdersLength) {\n    result[holders[argsIndex]] = args[argsIndex];\n  }\n  while (argsLength--) {\n    result[leftIndex++] = args[argsIndex++];\n  }\n  return result;\n}\n\nmodule.exports = composeArgs;\n","/* Native method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max;\n\n/**\n * This function is like `composeArgs` except that the arguments composition\n * is tailored for `_.partialRight`.\n *\n * @private\n * @param {Array|Object} args The provided arguments.\n * @param {Array} partials The arguments to append to those provided.\n * @param {Array} holders The `partials` placeholder indexes.\n * @returns {Array} Returns the new array of composed arguments.\n */\nfunction composeArgsRight(args, partials, holders) {\n  var holdersIndex = -1,\n      holdersLength = holders.length,\n      argsIndex = -1,\n      argsLength = nativeMax(args.length - holdersLength, 0),\n      rightIndex = -1,\n      rightLength = partials.length,\n      result = Array(argsLength + rightLength);\n\n  while (++argsIndex < argsLength) {\n    result[argsIndex] = args[argsIndex];\n  }\n  var offset = argsIndex;\n  while (++rightIndex < rightLength) {\n    result[offset + rightIndex] = partials[rightIndex];\n  }\n  while (++holdersIndex < holdersLength) {\n    result[offset + holders[holdersIndex]] = args[argsIndex++];\n  }\n  return result;\n}\n\nmodule.exports = composeArgsRight;\n","var baseCallback = require(309),\n    baseEach = require(315),\n    isArray = require(401);\n\n/**\n * Creates a `_.countBy`, `_.groupBy`, `_.indexBy`, or `_.partition` function.\n *\n * @private\n * @param {Function} setter The function to set keys and values of the accumulator object.\n * @param {Function} [initializer] The function to initialize the accumulator object.\n * @returns {Function} Returns the new aggregator function.\n */\nfunction createAggregator(setter, initializer) {\n  return function(collection, iteratee, thisArg) {\n    var result = initializer ? initializer() : {};\n    iteratee = baseCallback(iteratee, thisArg, 3);\n\n    if (isArray(collection)) {\n      var index = -1,\n          length = collection.length;\n\n      while (++index < length) {\n        var value = collection[index];\n        setter(result, value, iteratee(value, index, collection), collection);\n      }\n    } else {\n      baseEach(collection, function(value, key, collection) {\n        setter(result, value, iteratee(value, key, collection), collection);\n      });\n    }\n    return result;\n  };\n}\n\nmodule.exports = createAggregator;\n","var bindCallback = require(345),\n    isIterateeCall = require(380),\n    restParam = require(295);\n\n/**\n * Creates a `_.assign`, `_.defaults`, or `_.merge` function.\n *\n * @private\n * @param {Function} assigner The function to assign values.\n * @returns {Function} Returns the new assigner function.\n */\nfunction createAssigner(assigner) {\n  return restParam(function(object, sources) {\n    var index = -1,\n        length = object == null ? 0 : sources.length,\n        customizer = length > 2 ? sources[length - 2] : undefined,\n        guard = length > 2 ? sources[2] : undefined,\n        thisArg = length > 1 ? sources[length - 1] : undefined;\n\n    if (typeof customizer == 'function') {\n      customizer = bindCallback(customizer, thisArg, 5);\n      length -= 2;\n    } else {\n      customizer = typeof thisArg == 'function' ? thisArg : undefined;\n      length -= (customizer ? 1 : 0);\n    }\n    if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n      customizer = length < 3 ? undefined : customizer;\n      length = 1;\n    }\n    while (++index < length) {\n      var source = sources[index];\n      if (source) {\n        assigner(object, source, customizer);\n      }\n    }\n    return object;\n  });\n}\n\nmodule.exports = createAssigner;\n","var getLength = require(371),\n    isLength = require(383),\n    toObject = require(396);\n\n/**\n * Creates a `baseEach` or `baseEachRight` function.\n *\n * @private\n * @param {Function} eachFunc The function to iterate over a collection.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseEach(eachFunc, fromRight) {\n  return function(collection, iteratee) {\n    var length = collection ? getLength(collection) : 0;\n    if (!isLength(length)) {\n      return eachFunc(collection, iteratee);\n    }\n    var index = fromRight ? length : -1,\n        iterable = toObject(collection);\n\n    while ((fromRight ? index-- : ++index < length)) {\n      if (iteratee(iterable[index], index, iterable) === false) {\n        break;\n      }\n    }\n    return collection;\n  };\n}\n\nmodule.exports = createBaseEach;\n","var toObject = require(396);\n\n/**\n * Creates a base function for `_.forIn` or `_.forInRight`.\n *\n * @private\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseFor(fromRight) {\n  return function(object, iteratee, keysFunc) {\n    var iterable = toObject(object),\n        props = keysFunc(object),\n        length = props.length,\n        index = fromRight ? length : -1;\n\n    while ((fromRight ? index-- : ++index < length)) {\n      var key = props[index];\n      if (iteratee(iterable[key], key, iterable) === false) {\n        break;\n      }\n    }\n    return object;\n  };\n}\n\nmodule.exports = createBaseFor;\n","var createCtorWrapper = require('./createCtorWrapper');\n\n/**\n * Creates a function that wraps `func` and invokes it with the `this`\n * binding of `thisArg`.\n *\n * @private\n * @param {Function} func The function to bind.\n * @param {*} [thisArg] The `this` binding of `func`.\n * @returns {Function} Returns the new bound function.\n */\nfunction createBindWrapper(func, thisArg) {\n  var Ctor = createCtorWrapper(func);\n\n  function wrapper() {\n    var fn = (this && this !== global && this instanceof wrapper) ? Ctor : func;\n    return fn.apply(thisArg, arguments);\n  }\n  return wrapper;\n}\n\nmodule.exports = createBindWrapper;\n","var SetCache = require('./SetCache'),\n    getNative = require('./getNative');\n\n/** Native method references. */\nvar Set = getNative(global, 'Set');\n\n/* Native method references for those with the same name as other `lodash` methods. */\nvar nativeCreate = getNative(Object, 'create');\n\n/**\n * Creates a `Set` cache object to optimize linear searches of large arrays.\n *\n * @private\n * @param {Array} [values] The values to cache.\n * @returns {null|Object} Returns the new cache object if `Set` is supported, else `null`.\n */\nfunction createCache(values) {\n  return (nativeCreate && Set) ? new SetCache(values) : null;\n}\n\nmodule.exports = createCache;\n","var baseCreate = require(313),\n    isObject = require(405);\n\n/**\n * Creates a function that produces an instance of `Ctor` regardless of\n * whether it was invoked as part of a `new` expression or by `call` or `apply`.\n *\n * @private\n * @param {Function} Ctor The constructor to wrap.\n * @returns {Function} Returns the new wrapped function.\n */\nfunction createCtorWrapper(Ctor) {\n  return function() {\n    // Use a `switch` statement to work with class constructors.\n    // See http://ecma-international.org/ecma-262/6.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist\n    // for more details.\n    var args = arguments;\n    switch (args.length) {\n      case 0: return new Ctor;\n      case 1: return new Ctor(args[0]);\n      case 2: return new Ctor(args[0], args[1]);\n      case 3: return new Ctor(args[0], args[1], args[2]);\n      case 4: return new Ctor(args[0], args[1], args[2], args[3]);\n      case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);\n      case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);\n      case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);\n    }\n    var thisBinding = baseCreate(Ctor.prototype),\n        result = Ctor.apply(thisBinding, args);\n\n    // Mimic the constructor's `return` behavior.\n    // See https://es5.github.io/#x13.2.2 for more details.\n    return isObject(result) ? result : thisBinding;\n  };\n}\n\nmodule.exports = createCtorWrapper;\n","var baseCallback = require(309),\n    baseFind = require(318),\n    baseFindIndex = require(319),\n    isArray = require(401);\n\n/**\n * Creates a `_.find` or `_.findLast` function.\n *\n * @private\n * @param {Function} eachFunc The function to iterate over a collection.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new find function.\n */\nfunction createFind(eachFunc, fromRight) {\n  return function(collection, predicate, thisArg) {\n    predicate = baseCallback(predicate, thisArg, 3);\n    if (isArray(collection)) {\n      var index = baseFindIndex(collection, predicate, fromRight);\n      return index > -1 ? collection[index] : undefined;\n    }\n    return baseFind(collection, predicate, eachFunc);\n  };\n}\n\nmodule.exports = createFind;\n","var baseCallback = require(309),\n    baseFindIndex = require(319);\n\n/**\n * Creates a `_.findIndex` or `_.findLastIndex` function.\n *\n * @private\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new find function.\n */\nfunction createFindIndex(fromRight) {\n  return function(array, predicate, thisArg) {\n    if (!(array && array.length)) {\n      return -1;\n    }\n    predicate = baseCallback(predicate, thisArg, 3);\n    return baseFindIndex(array, predicate, fromRight);\n  };\n}\n\nmodule.exports = createFindIndex;\n","var bindCallback = require(345),\n    isArray = require(401);\n\n/**\n * Creates a function for `_.forEach` or `_.forEachRight`.\n *\n * @private\n * @param {Function} arrayFunc The function to iterate over an array.\n * @param {Function} eachFunc The function to iterate over a collection.\n * @returns {Function} Returns the new each function.\n */\nfunction createForEach(arrayFunc, eachFunc) {\n  return function(collection, iteratee, thisArg) {\n    return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection))\n      ? arrayFunc(collection, iteratee)\n      : eachFunc(collection, bindCallback(iteratee, thisArg, 3));\n  };\n}\n\nmodule.exports = createForEach;\n","var arrayCopy = require('./arrayCopy'),\n    composeArgs = require('./composeArgs'),\n    composeArgsRight = require('./composeArgsRight'),\n    createCtorWrapper = require('./createCtorWrapper'),\n    isLaziable = require('./isLaziable'),\n    reorder = require('./reorder'),\n    replaceHolders = require('./replaceHolders'),\n    setData = require('./setData');\n\n/** Used to compose bitmasks for wrapper metadata. */\nvar BIND_FLAG = 1,\n    BIND_KEY_FLAG = 2,\n    CURRY_BOUND_FLAG = 4,\n    CURRY_FLAG = 8,\n    CURRY_RIGHT_FLAG = 16,\n    PARTIAL_FLAG = 32,\n    PARTIAL_RIGHT_FLAG = 64,\n    ARY_FLAG = 128;\n\n/* Native method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max;\n\n/**\n * Creates a function that wraps `func` and invokes it with optional `this`\n * binding of, partial application, and currying.\n *\n * @private\n * @param {Function|string} func The function or method name to reference.\n * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.\n * @param {*} [thisArg] The `this` binding of `func`.\n * @param {Array} [partials] The arguments to prepend to those provided to the new function.\n * @param {Array} [holders] The `partials` placeholder indexes.\n * @param {Array} [partialsRight] The arguments to append to those provided to the new function.\n * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.\n * @param {Array} [argPos] The argument positions of the new function.\n * @param {number} [ary] The arity cap of `func`.\n * @param {number} [arity] The arity of `func`.\n * @returns {Function} Returns the new wrapped function.\n */\nfunction createHybridWrapper(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {\n  var isAry = bitmask & ARY_FLAG,\n      isBind = bitmask & BIND_FLAG,\n      isBindKey = bitmask & BIND_KEY_FLAG,\n      isCurry = bitmask & CURRY_FLAG,\n      isCurryBound = bitmask & CURRY_BOUND_FLAG,\n      isCurryRight = bitmask & CURRY_RIGHT_FLAG,\n      Ctor = isBindKey ? undefined : createCtorWrapper(func);\n\n  function wrapper() {\n    // Avoid `arguments` object use disqualifying optimizations by\n    // converting it to an array before providing it to other functions.\n    var length = arguments.length,\n        index = length,\n        args = Array(length);\n\n    while (index--) {\n      args[index] = arguments[index];\n    }\n    if (partials) {\n      args = composeArgs(args, partials, holders);\n    }\n    if (partialsRight) {\n      args = composeArgsRight(args, partialsRight, holdersRight);\n    }\n    if (isCurry || isCurryRight) {\n      var placeholder = wrapper.placeholder,\n          argsHolders = replaceHolders(args, placeholder);\n\n      length -= argsHolders.length;\n      if (length < arity) {\n        var newArgPos = argPos ? arrayCopy(argPos) : undefined,\n            newArity = nativeMax(arity - length, 0),\n            newsHolders = isCurry ? argsHolders : undefined,\n            newHoldersRight = isCurry ? undefined : argsHolders,\n            newPartials = isCurry ? args : undefined,\n            newPartialsRight = isCurry ? undefined : args;\n\n        bitmask |= (isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG);\n        bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);\n\n        if (!isCurryBound) {\n          bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);\n        }\n        var newData = [func, bitmask, thisArg, newPartials, newsHolders, newPartialsRight, newHoldersRight, newArgPos, ary, newArity],\n            result = createHybridWrapper.apply(undefined, newData);\n\n        if (isLaziable(func)) {\n          setData(result, newData);\n        }\n        result.placeholder = placeholder;\n        return result;\n      }\n    }\n    var thisBinding = isBind ? thisArg : this,\n        fn = isBindKey ? thisBinding[func] : func;\n\n    if (argPos) {\n      args = reorder(args, argPos);\n    }\n    if (isAry && ary < args.length) {\n      args.length = ary;\n    }\n    if (this && this !== global && this instanceof wrapper) {\n      fn = Ctor || createCtorWrapper(func);\n    }\n    return fn.apply(thisBinding, args);\n  }\n  return wrapper;\n}\n\nmodule.exports = createHybridWrapper;\n","var createCtorWrapper = require('./createCtorWrapper');\n\n/** Used to compose bitmasks for wrapper metadata. */\nvar BIND_FLAG = 1;\n\n/**\n * Creates a function that wraps `func` and invokes it with the optional `this`\n * binding of `thisArg` and the `partials` prepended to those provided to\n * the wrapper.\n *\n * @private\n * @param {Function} func The function to partially apply arguments to.\n * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.\n * @param {*} thisArg The `this` binding of `func`.\n * @param {Array} partials The arguments to prepend to those provided to the new function.\n * @returns {Function} Returns the new bound function.\n */\nfunction createPartialWrapper(func, bitmask, thisArg, partials) {\n  var isBind = bitmask & BIND_FLAG,\n      Ctor = createCtorWrapper(func);\n\n  function wrapper() {\n    // Avoid `arguments` object use disqualifying optimizations by\n    // converting it to an array before providing it `func`.\n    var argsIndex = -1,\n        argsLength = arguments.length,\n        leftIndex = -1,\n        leftLength = partials.length,\n        args = Array(leftLength + argsLength);\n\n    while (++leftIndex < leftLength) {\n      args[leftIndex] = partials[leftIndex];\n    }\n    while (argsLength--) {\n      args[leftIndex++] = arguments[++argsIndex];\n    }\n    var fn = (this && this !== global && this instanceof wrapper) ? Ctor : func;\n    return fn.apply(isBind ? thisArg : this, args);\n  }\n  return wrapper;\n}\n\nmodule.exports = createPartialWrapper;\n","var baseCallback = require(309),\n    baseReduce = require(337),\n    isArray = require(401);\n\n/**\n * Creates a function for `_.reduce` or `_.reduceRight`.\n *\n * @private\n * @param {Function} arrayFunc The function to iterate over an array.\n * @param {Function} eachFunc The function to iterate over a collection.\n * @returns {Function} Returns the new each function.\n */\nfunction createReduce(arrayFunc, eachFunc) {\n  return function(collection, iteratee, accumulator, thisArg) {\n    var initFromArray = arguments.length < 3;\n    return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection))\n      ? arrayFunc(collection, iteratee, accumulator, initFromArray)\n      : baseReduce(collection, baseCallback(iteratee, thisArg, 4), accumulator, initFromArray, eachFunc);\n  };\n}\n\nmodule.exports = createReduce;\n","var baseSetData = require(338),\n    createBindWrapper = require(356),\n    createHybridWrapper = require(362),\n    createPartialWrapper = require(363),\n    getData = require(369),\n    mergeData = require(386),\n    setData = require(393);\n\n/** Used to compose bitmasks for wrapper metadata. */\nvar BIND_FLAG = 1,\n    BIND_KEY_FLAG = 2,\n    PARTIAL_FLAG = 32,\n    PARTIAL_RIGHT_FLAG = 64;\n\n/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/* Native method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max;\n\n/**\n * Creates a function that either curries or invokes `func` with optional\n * `this` binding and partially applied arguments.\n *\n * @private\n * @param {Function|string} func The function or method name to reference.\n * @param {number} bitmask The bitmask of flags.\n *  The bitmask may be composed of the following flags:\n *     1 - `_.bind`\n *     2 - `_.bindKey`\n *     4 - `_.curry` or `_.curryRight` of a bound function\n *     8 - `_.curry`\n *    16 - `_.curryRight`\n *    32 - `_.partial`\n *    64 - `_.partialRight`\n *   128 - `_.rearg`\n *   256 - `_.ary`\n * @param {*} [thisArg] The `this` binding of `func`.\n * @param {Array} [partials] The arguments to be partially applied.\n * @param {Array} [holders] The `partials` placeholder indexes.\n * @param {Array} [argPos] The argument positions of the new function.\n * @param {number} [ary] The arity cap of `func`.\n * @param {number} [arity] The arity of `func`.\n * @returns {Function} Returns the new wrapped function.\n */\nfunction createWrapper(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {\n  var isBindKey = bitmask & BIND_KEY_FLAG;\n  if (!isBindKey && typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var length = partials ? partials.length : 0;\n  if (!length) {\n    bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);\n    partials = holders = undefined;\n  }\n  length -= (holders ? holders.length : 0);\n  if (bitmask & PARTIAL_RIGHT_FLAG) {\n    var partialsRight = partials,\n        holdersRight = holders;\n\n    partials = holders = undefined;\n  }\n  var data = isBindKey ? undefined : getData(func),\n      newData = [func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity];\n\n  if (data) {\n    mergeData(newData, data);\n    bitmask = newData[1];\n    arity = newData[9];\n  }\n  newData[9] = arity == null\n    ? (isBindKey ? 0 : func.length)\n    : (nativeMax(arity - length, 0) || 0);\n\n  if (bitmask == BIND_FLAG) {\n    var result = createBindWrapper(newData[0], newData[2]);\n  } else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !newData[4].length) {\n    result = createPartialWrapper.apply(undefined, newData);\n  } else {\n    result = createHybridWrapper.apply(undefined, newData);\n  }\n  var setter = data ? baseSetData : setData;\n  return setter(result, newData);\n}\n\nmodule.exports = createWrapper;\n","var arraySome = require(306);\n\n/**\n * A specialized version of `baseIsEqualDeep` for arrays with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Array} array The array to compare.\n * @param {Array} other The other array to compare.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Function} [customizer] The function to customize comparing arrays.\n * @param {boolean} [isLoose] Specify performing partial comparisons.\n * @param {Array} [stackA] Tracks traversed `value` objects.\n * @param {Array} [stackB] Tracks traversed `other` objects.\n * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n */\nfunction equalArrays(array, other, equalFunc, customizer, isLoose, stackA, stackB) {\n  var index = -1,\n      arrLength = array.length,\n      othLength = other.length;\n\n  if (arrLength != othLength && !(isLoose && othLength > arrLength)) {\n    return false;\n  }\n  // Ignore non-index properties.\n  while (++index < arrLength) {\n    var arrValue = array[index],\n        othValue = other[index],\n        result = customizer ? customizer(isLoose ? othValue : arrValue, isLoose ? arrValue : othValue, index) : undefined;\n\n    if (result !== undefined) {\n      if (result) {\n        continue;\n      }\n      return false;\n    }\n    // Recursively compare arrays (susceptible to call stack limits).\n    if (isLoose) {\n      if (!arraySome(other, function(othValue) {\n            return arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB);\n          })) {\n        return false;\n      }\n    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB))) {\n      return false;\n    }\n  }\n  return true;\n}\n\nmodule.exports = equalArrays;\n","/** `Object#toString` result references. */\nvar boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    numberTag = '[object Number]',\n    regexpTag = '[object RegExp]',\n    stringTag = '[object String]';\n\n/**\n * A specialized version of `baseIsEqualDeep` for comparing objects of\n * the same `toStringTag`.\n *\n * **Note:** This function only supports comparing values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {string} tag The `toStringTag` of the objects to compare.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalByTag(object, other, tag) {\n  switch (tag) {\n    case boolTag:\n    case dateTag:\n      // Coerce dates and booleans to numbers, dates to milliseconds and booleans\n      // to `1` or `0` treating invalid dates coerced to `NaN` as not equal.\n      return +object == +other;\n\n    case errorTag:\n      return object.name == other.name && object.message == other.message;\n\n    case numberTag:\n      // Treat `NaN` vs. `NaN` as equal.\n      return (object != +object)\n        ? other != +other\n        : object == +other;\n\n    case regexpTag:\n    case stringTag:\n      // Coerce regexes to strings and treat strings primitives and string\n      // objects as equal. See https://es5.github.io/#x15.10.6.4 for more details.\n      return object == (other + '');\n  }\n  return false;\n}\n\nmodule.exports = equalByTag;\n","var keys = require(412);\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * A specialized version of `baseIsEqualDeep` for objects with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Function} [customizer] The function to customize comparing values.\n * @param {boolean} [isLoose] Specify performing partial comparisons.\n * @param {Array} [stackA] Tracks traversed `value` objects.\n * @param {Array} [stackB] Tracks traversed `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalObjects(object, other, equalFunc, customizer, isLoose, stackA, stackB) {\n  var objProps = keys(object),\n      objLength = objProps.length,\n      othProps = keys(other),\n      othLength = othProps.length;\n\n  if (objLength != othLength && !isLoose) {\n    return false;\n  }\n  var index = objLength;\n  while (index--) {\n    var key = objProps[index];\n    if (!(isLoose ? key in other : hasOwnProperty.call(other, key))) {\n      return false;\n    }\n  }\n  var skipCtor = isLoose;\n  while (++index < objLength) {\n    key = objProps[index];\n    var objValue = object[key],\n        othValue = other[key],\n        result = customizer ? customizer(isLoose ? othValue : objValue, isLoose? objValue : othValue, key) : undefined;\n\n    // Recursively compare objects (susceptible to call stack limits).\n    if (!(result === undefined ? equalFunc(objValue, othValue, customizer, isLoose, stackA, stackB) : result)) {\n      return false;\n    }\n    skipCtor || (skipCtor = key == 'constructor');\n  }\n  if (!skipCtor) {\n    var objCtor = object.constructor,\n        othCtor = other.constructor;\n\n    // Non `Object` object instances with different constructors are not equal.\n    if (objCtor != othCtor &&\n        ('constructor' in object && 'constructor' in other) &&\n        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n          typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nmodule.exports = equalObjects;\n","var metaMap = require(387),\n    noop = require(421);\n\n/**\n * Gets metadata for `func`.\n *\n * @private\n * @param {Function} func The function to query.\n * @returns {*} Returns the metadata for `func`.\n */\nvar getData = !metaMap ? noop : function(func) {\n  return metaMap.get(func);\n};\n\nmodule.exports = getData;\n","var realNames = require(390);\n\n/**\n * Gets the name of `func`.\n *\n * @private\n * @param {Function} func The function to query.\n * @returns {string} Returns the function name.\n */\nfunction getFuncName(func) {\n  var result = (func.name + ''),\n      array = realNames[result],\n      length = array ? array.length : 0;\n\n  while (length--) {\n    var data = array[length],\n        otherFunc = data.func;\n    if (otherFunc == null || otherFunc == func) {\n      return data.name;\n    }\n  }\n  return result;\n}\n\nmodule.exports = getFuncName;\n","var baseProperty = require(335);\n\n/**\n * Gets the \"length\" property value of `object`.\n *\n * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)\n * that affects Safari on at least iOS 8.1-8.3 ARM64.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {*} Returns the \"length\" value.\n */\nvar getLength = baseProperty('length');\n\nmodule.exports = getLength;\n","var isStrictComparable = require(385),\n    pairs = require(416);\n\n/**\n * Gets the propery names, values, and compare flags of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the match data of `object`.\n */\nfunction getMatchData(object) {\n  var result = pairs(object),\n      length = result.length;\n\n  while (length--) {\n    result[length][2] = isStrictComparable(result[length][1]);\n  }\n  return result;\n}\n\nmodule.exports = getMatchData;\n","var isNative = require(403);\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = object == null ? undefined : object[key];\n  return isNative(value) ? value : undefined;\n}\n\nmodule.exports = getNative;\n","/**\n * Gets the index at which the first occurrence of `NaN` is found in `array`.\n *\n * @private\n * @param {Array} array The array to search.\n * @param {number} fromIndex The index to search from.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {number} Returns the index of the matched `NaN`, else `-1`.\n */\nfunction indexOfNaN(array, fromIndex, fromRight) {\n  var length = array.length,\n      index = fromIndex + (fromRight ? 0 : -1);\n\n  while ((fromRight ? index-- : ++index < length)) {\n    var other = array[index];\n    if (other !== other) {\n      return index;\n    }\n  }\n  return -1;\n}\n\nmodule.exports = indexOfNaN;\n","/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Initializes an array clone.\n *\n * @private\n * @param {Array} array The array to clone.\n * @returns {Array} Returns the initialized clone.\n */\nfunction initCloneArray(array) {\n  var length = array.length,\n      result = new array.constructor(length);\n\n  // Add array properties assigned by `RegExp#exec`.\n  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {\n    result.index = array.index;\n    result.input = array.input;\n  }\n  return result;\n}\n\nmodule.exports = initCloneArray;\n","var bufferClone = require(346);\n\n/** `Object#toString` result references. */\nvar boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    numberTag = '[object Number]',\n    regexpTag = '[object RegExp]',\n    stringTag = '[object String]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/** Used to match `RegExp` flags from their coerced string values. */\nvar reFlags = //w*$/;\n\n/**\n * Initializes an object clone based on its `toStringTag`.\n *\n * **Note:** This function only supports cloning values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to clone.\n * @param {string} tag The `toStringTag` of the object to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneByTag(object, tag, isDeep) {\n  var Ctor = object.constructor;\n  switch (tag) {\n    case arrayBufferTag:\n      return bufferClone(object);\n\n    case boolTag:\n    case dateTag:\n      return new Ctor(+object);\n\n    case float32Tag: case float64Tag:\n    case int8Tag: case int16Tag: case int32Tag:\n    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:\n      var buffer = object.buffer;\n      return new Ctor(isDeep ? bufferClone(buffer) : buffer, object.byteOffset, object.length);\n\n    case numberTag:\n    case stringTag:\n      return new Ctor(object);\n\n    case regexpTag:\n      var result = new Ctor(object.source, reFlags.exec(object));\n      result.lastIndex = object.lastIndex;\n  }\n  return result;\n}\n\nmodule.exports = initCloneByTag;\n","/**\n * Initializes an object clone.\n *\n * @private\n * @param {Object} object The object to clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneObject(object) {\n  var Ctor = object.constructor;\n  if (!(typeof Ctor == 'function' && Ctor instanceof Ctor)) {\n    Ctor = Object;\n  }\n  return new Ctor;\n}\n\nmodule.exports = initCloneObject;\n","var getLength = require(371),\n    isLength = require(383);\n\n/**\n * Checks if `value` is array-like.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(getLength(value));\n}\n\nmodule.exports = isArrayLike;\n","/** Used to detect unsigned integer values. */\nvar reIsUint = /^/d+$/;\n\n/**\n * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)\n * of an array-like value.\n */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;\n  length = length == null ? MAX_SAFE_INTEGER : length;\n  return value > -1 && value % 1 == 0 && value < length;\n}\n\nmodule.exports = isIndex;\n","var isArrayLike = require(378),\n    isIndex = require(379),\n    isObject = require(405);\n\n/**\n * Checks if the provided arguments are from an iteratee call.\n *\n * @private\n * @param {*} value The potential iteratee value argument.\n * @param {*} index The potential iteratee index or key argument.\n * @param {*} object The potential iteratee object argument.\n * @returns {boolean} Returns `true` if the arguments are from an iteratee call, else `false`.\n */\nfunction isIterateeCall(value, index, object) {\n  if (!isObject(object)) {\n    return false;\n  }\n  var type = typeof index;\n  if (type == 'number'\n      ? (isArrayLike(object) && isIndex(index, object.length))\n      : (type == 'string' && index in object)) {\n    var other = object[index];\n    return value === value ? (value === other) : (other !== other);\n  }\n  return false;\n}\n\nmodule.exports = isIterateeCall;\n","var isArray = require(401),\n    toObject = require(396);\n\n/** Used to match property names within property paths. */\nvar reIsDeepProp = //.|/[(?:[^[/]]*|([\"'])(?:(?!/1)[^/n//]|//.)*?/1)/]/,\n    reIsPlainProp = /^/w*$/;\n\n/**\n * Checks if `value` is a property name and not a property path.\n *\n * @private\n * @param {*} value The value to check.\n * @param {Object} [object] The object to query keys on.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n */\nfunction isKey(value, object) {\n  var type = typeof value;\n  if ((type == 'string' && reIsPlainProp.test(value)) || type == 'number') {\n    return true;\n  }\n  if (isArray(value)) {\n    return false;\n  }\n  var result = !reIsDeepProp.test(value);\n  return result || (object != null && value in toObject(object));\n}\n\nmodule.exports = isKey;\n","var LazyWrapper = require(296),\n    getData = require(369),\n    getFuncName = require(370),\n    lodash = require(278);\n\n/**\n * Checks if `func` has a lazy counterpart.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` has a lazy counterpart, else `false`.\n */\nfunction isLaziable(func) {\n  var funcName = getFuncName(func),\n      other = lodash[funcName];\n\n  if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {\n    return false;\n  }\n  if (func === other) {\n    return true;\n  }\n  var data = getData(other);\n  return !!data && func === data[0];\n}\n\nmodule.exports = isLaziable;\n","/**\n * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)\n * of an array-like value.\n */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n */\nfunction isLength(value) {\n  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\nmodule.exports = isLength;\n","/**\n * Checks if `value` is object-like.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\nmodule.exports = isObjectLike;\n","var isObject = require(405);\n\n/**\n * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` if suitable for strict\n *  equality comparisons, else `false`.\n */\nfunction isStrictComparable(value) {\n  return value === value && !isObject(value);\n}\n\nmodule.exports = isStrictComparable;\n","var arrayCopy = require(299),\n    composeArgs = require(350),\n    composeArgsRight = require(351),\n    replaceHolders = require(392);\n\n/** Used to compose bitmasks for wrapper metadata. */\nvar BIND_FLAG = 1,\n    CURRY_BOUND_FLAG = 4,\n    CURRY_FLAG = 8,\n    ARY_FLAG = 128,\n    REARG_FLAG = 256;\n\n/** Used as the internal argument placeholder. */\nvar PLACEHOLDER = '__lodash_placeholder__';\n\n/* Native method references for those with the same name as other `lodash` methods. */\nvar nativeMin = Math.min;\n\n/**\n * Merges the function metadata of `source` into `data`.\n *\n * Merging metadata reduces the number of wrappers required to invoke a function.\n * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`\n * may be applied regardless of execution order. Methods like `_.ary` and `_.rearg`\n * augment function arguments, making the order in which they are executed important,\n * preventing the merging of metadata. However, we make an exception for a safe\n * common case where curried functions have `_.ary` and or `_.rearg` applied.\n *\n * @private\n * @param {Array} data The destination metadata.\n * @param {Array} source The source metadata.\n * @returns {Array} Returns `data`.\n */\nfunction mergeData(data, source) {\n  var bitmask = data[1],\n      srcBitmask = source[1],\n      newBitmask = bitmask | srcBitmask,\n      isCommon = newBitmask < ARY_FLAG;\n\n  var isCombo =\n    (srcBitmask == ARY_FLAG && bitmask == CURRY_FLAG) ||\n    (srcBitmask == ARY_FLAG && bitmask == REARG_FLAG && data[7].length <= source[8]) ||\n    (srcBitmask == (ARY_FLAG | REARG_FLAG) && bitmask == CURRY_FLAG);\n\n  // Exit early if metadata can't be merged.\n  if (!(isCommon || isCombo)) {\n    return data;\n  }\n  // Use source `thisArg` if available.\n  if (srcBitmask & BIND_FLAG) {\n    data[2] = source[2];\n    // Set when currying a bound function.\n    newBitmask |= (bitmask & BIND_FLAG) ? 0 : CURRY_BOUND_FLAG;\n  }\n  // Compose partial arguments.\n  var value = source[3];\n  if (value) {\n    var partials = data[3];\n    data[3] = partials ? composeArgs(partials, value, source[4]) : arrayCopy(value);\n    data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : arrayCopy(source[4]);\n  }\n  // Compose partial right arguments.\n  value = source[5];\n  if (value) {\n    partials = data[5];\n    data[5] = partials ? composeArgsRight(partials, value, source[6]) : arrayCopy(value);\n    data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : arrayCopy(source[6]);\n  }\n  // Use source `argPos` if available.\n  value = source[7];\n  if (value) {\n    data[7] = arrayCopy(value);\n  }\n  // Use source `ary` if it's smaller.\n  if (srcBitmask & ARY_FLAG) {\n    data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);\n  }\n  // Use source `arity` if one is not provided.\n  if (data[9] == null) {\n    data[9] = source[9];\n  }\n  // Use source `func` and merge bitmasks.\n  data[0] = source[0];\n  data[1] = newBitmask;\n\n  return data;\n}\n\nmodule.exports = mergeData;\n","var getNative = require('./getNative');\n\n/** Native method references. */\nvar WeakMap = getNative(global, 'WeakMap');\n\n/** Used to store function metadata. */\nvar metaMap = WeakMap && new WeakMap;\n\nmodule.exports = metaMap;\n","var toObject = require(396);\n\n/**\n * A specialized version of `_.pick` which picks `object` properties specified\n * by `props`.\n *\n * @private\n * @param {Object} object The source object.\n * @param {string[]} props The property names to pick.\n * @returns {Object} Returns the new object.\n */\nfunction pickByArray(object, props) {\n  object = toObject(object);\n\n  var index = -1,\n      length = props.length,\n      result = {};\n\n  while (++index < length) {\n    var key = props[index];\n    if (key in object) {\n      result[key] = object[key];\n    }\n  }\n  return result;\n}\n\nmodule.exports = pickByArray;\n","var baseForIn = require(322);\n\n/**\n * A specialized version of `_.pick` which picks `object` properties `predicate`\n * returns truthy for.\n *\n * @private\n * @param {Object} object The source object.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {Object} Returns the new object.\n */\nfunction pickByCallback(object, predicate) {\n  var result = {};\n  baseForIn(object, function(value, key, object) {\n    if (predicate(value, key, object)) {\n      result[key] = value;\n    }\n  });\n  return result;\n}\n\nmodule.exports = pickByCallback;\n","/** Used to lookup unminified function names. */\nvar realNames = {};\n\nmodule.exports = realNames;\n","var arrayCopy = require(299),\n    isIndex = require(379);\n\n/* Native method references for those with the same name as other `lodash` methods. */\nvar nativeMin = Math.min;\n\n/**\n * Reorder `array` according to the specified indexes where the element at\n * the first index is assigned as the first element, the element at\n * the second index is assigned as the second element, and so on.\n *\n * @private\n * @param {Array} array The array to reorder.\n * @param {Array} indexes The arranged array indexes.\n * @returns {Array} Returns `array`.\n */\nfunction reorder(array, indexes) {\n  var arrLength = array.length,\n      length = nativeMin(indexes.length, arrLength),\n      oldArray = arrayCopy(array);\n\n  while (length--) {\n    var index = indexes[length];\n    array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;\n  }\n  return array;\n}\n\nmodule.exports = reorder;\n","/** Used as the internal argument placeholder. */\nvar PLACEHOLDER = '__lodash_placeholder__';\n\n/**\n * Replaces all `placeholder` elements in `array` with an internal placeholder\n * and returns an array of their indexes.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {*} placeholder The placeholder to replace.\n * @returns {Array} Returns the new array of placeholder indexes.\n */\nfunction replaceHolders(array, placeholder) {\n  var index = -1,\n      length = array.length,\n      resIndex = -1,\n      result = [];\n\n  while (++index < length) {\n    if (array[index] === placeholder) {\n      array[index] = PLACEHOLDER;\n      result[++resIndex] = index;\n    }\n  }\n  return result;\n}\n\nmodule.exports = replaceHolders;\n","var baseSetData = require(338),\n    now = require(292);\n\n/** Used to detect when a function becomes hot. */\nvar HOT_COUNT = 150,\n    HOT_SPAN = 16;\n\n/**\n * Sets metadata for `func`.\n *\n * **Note:** If this function becomes hot, i.e. is invoked a lot in a short\n * period of time, it will trip its breaker and transition to an identity function\n * to avoid garbage collection pauses in V8. See [V8 issue 2070](https://code.google.com/p/v8/issues/detail?id=2070)\n * for more details.\n *\n * @private\n * @param {Function} func The function to associate metadata with.\n * @param {*} data The metadata.\n * @returns {Function} Returns `func`.\n */\nvar setData = (function() {\n  var count = 0,\n      lastCalled = 0;\n\n  return function(key, value) {\n    var stamp = now(),\n        remaining = HOT_SPAN - (stamp - lastCalled);\n\n    lastCalled = stamp;\n    if (remaining > 0) {\n      if (++count >= HOT_COUNT) {\n        return key;\n      }\n    } else {\n      count = 0;\n    }\n    return baseSetData(key, value);\n  };\n}());\n\nmodule.exports = setData;\n","var isArguments = require(400),\n    isArray = require(401),\n    isIndex = require(379),\n    isLength = require(383),\n    keysIn = require(413);\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * A fallback implementation of `Object.keys` which creates an array of the\n * own enumerable property names of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction shimKeys(object) {\n  var props = keysIn(object),\n      propsLength = props.length,\n      length = propsLength && object.length;\n\n  var allowIndexes = !!length && isLength(length) &&\n    (isArray(object) || isArguments(object));\n\n  var index = -1,\n      result = [];\n\n  while (++index < propsLength) {\n    var key = props[index];\n    if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = shimKeys;\n","/**\n * An implementation of `_.uniq` optimized for sorted arrays without support\n * for callback shorthands and `this` binding.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {Function} [iteratee] The function invoked per iteration.\n * @returns {Array} Returns the new duplicate free array.\n */\nfunction sortedUniq(array, iteratee) {\n  var seen,\n      index = -1,\n      length = array.length,\n      resIndex = -1,\n      result = [];\n\n  while (++index < length) {\n    var value = array[index],\n        computed = iteratee ? iteratee(value, index, array) : value;\n\n    if (!index || seen !== computed) {\n      seen = computed;\n      result[++resIndex] = value;\n    }\n  }\n  return result;\n}\n\nmodule.exports = sortedUniq;\n","var isObject = require(405);\n\n/**\n * Converts `value` to an object if it's not one.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {Object} Returns the object.\n */\nfunction toObject(value) {\n  return isObject(value) ? value : Object(value);\n}\n\nmodule.exports = toObject;\n","var baseToString = require(342),\n    isArray = require(401);\n\n/** Used to match property names within property paths. */\nvar rePropName = /[^.[/]]+|/[(?:(-?/d+(?:/./d+)?)|([\"'])((?:(?!/2)[^/n//]|//.)*?)/2)/]/g;\n\n/** Used to match backslashes in property paths. */\nvar reEscapeChar = ///(//)?/g;\n\n/**\n * Converts `value` to property path array if it's not one.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {Array} Returns the property path array.\n */\nfunction toPath(value) {\n  if (isArray(value)) {\n    return value;\n  }\n  var result = [];\n  baseToString(value).replace(rePropName, function(match, number, quote, string) {\n    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));\n  });\n  return result;\n}\n\nmodule.exports = toPath;\n","var LazyWrapper = require(296),\n    LodashWrapper = require(297),\n    arrayCopy = require(299);\n\n/**\n * Creates a clone of `wrapper`.\n *\n * @private\n * @param {Object} wrapper The wrapper to clone.\n * @returns {Object} Returns the cloned wrapper.\n */\nfunction wrapperClone(wrapper) {\n  return wrapper instanceof LazyWrapper\n    ? wrapper.clone()\n    : new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__, arrayCopy(wrapper.__actions__));\n}\n\nmodule.exports = wrapperClone;\n","var baseClone = require(310),\n    bindCallback = require(345),\n    isIterateeCall = require(380);\n\n/**\n * Creates a clone of `value`. If `isDeep` is `true` nested objects are cloned,\n * otherwise they are assigned by reference. If `customizer` is provided it's\n * invoked to produce the cloned values. If `customizer` returns `undefined`\n * cloning is handled by the method instead. The `customizer` is bound to\n * `thisArg` and invoked with up to three argument; (value [, index|key, object]).\n *\n * **Note:** This method is loosely based on the\n * [structured clone algorithm](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm).\n * The enumerable properties of `arguments` objects and objects created by\n * constructors other than `Object` are cloned to plain `Object` objects. An\n * empty object is returned for uncloneable values such as functions, DOM nodes,\n * Maps, Sets, and WeakMaps.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @param {Function} [customizer] The function to customize cloning values.\n * @param {*} [thisArg] The `this` binding of `customizer`.\n * @returns {*} Returns the cloned value.\n * @example\n *\n * var users = [\n *   { 'user': 'barney' },\n *   { 'user': 'fred' }\n * ];\n *\n * var shallow = _.clone(users);\n * shallow[0] === users[0];\n * // => true\n *\n * var deep = _.clone(users, true);\n * deep[0] === users[0];\n * // => false\n *\n * // using a customizer callback\n * var el = _.clone(document.body, function(value) {\n *   if (_.isElement(value)) {\n *     return value.cloneNode(false);\n *   }\n * });\n *\n * el === document.body\n * // => false\n * el.nodeName\n * // => BODY\n * el.childNodes.length;\n * // => 0\n */\nfunction clone(value, isDeep, customizer, thisArg) {\n  if (isDeep && typeof isDeep != 'boolean' && isIterateeCall(value, isDeep, customizer)) {\n    isDeep = false;\n  }\n  else if (typeof isDeep == 'function') {\n    thisArg = customizer;\n    customizer = isDeep;\n    isDeep = false;\n  }\n  return typeof customizer == 'function'\n    ? baseClone(value, isDeep, bindCallback(customizer, thisArg, 3))\n    : baseClone(value, isDeep);\n}\n\nmodule.exports = clone;\n","var isArrayLike = require(378),\n    isObjectLike = require(384);\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Native method references. */\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\n\n/**\n * Checks if `value` is classified as an `arguments` object.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nfunction isArguments(value) {\n  return isObjectLike(value) && isArrayLike(value) &&\n    hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');\n}\n\nmodule.exports = isArguments;\n","var getNative = require(373),\n    isLength = require(383),\n    isObjectLike = require(384);\n\n/** `Object#toString` result references. */\nvar arrayTag = '[object Array]';\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objToString = objectProto.toString;\n\n/* Native method references for those with the same name as other `lodash` methods. */\nvar nativeIsArray = getNative(Array, 'isArray');\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(function() { return arguments; }());\n * // => false\n */\nvar isArray = nativeIsArray || function(value) {\n  return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;\n};\n\nmodule.exports = isArray;\n","var isObject = require(405);\n\n/** `Object#toString` result references. */\nvar funcTag = '[object Function]';\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objToString = objectProto.toString;\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in older versions of Chrome and Safari which return 'function' for regexes\n  // and Safari 8 which returns 'object' for typed array constructors.\n  return isObject(value) && objToString.call(value) == funcTag;\n}\n\nmodule.exports = isFunction;\n","var isFunction = require(402),\n    isObjectLike = require(384);\n\n/** Used to detect host constructors (Safari > 5). */\nvar reIsHostCtor = /^/[object .+?Constructor/]$/;\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar fnToString = Function.prototype.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  fnToString.call(hasOwnProperty).replace(/[//^$.*+?()[/]{}|]/g, '//$&')\n  .replace(/hasOwnProperty|(function).*?(?=///()| for .+?(?=///])/g, '$1.*?') + '$'\n);\n\n/**\n * Checks if `value` is a native function.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function, else `false`.\n * @example\n *\n * _.isNative(Array.prototype.push);\n * // => true\n *\n * _.isNative(_);\n * // => false\n */\nfunction isNative(value) {\n  if (value == null) {\n    return false;\n  }\n  if (isFunction(value)) {\n    return reIsNative.test(fnToString.call(value));\n  }\n  return isObjectLike(value) && reIsHostCtor.test(value);\n}\n\nmodule.exports = isNative;\n","var isObjectLike = require(384);\n\n/** `Object#toString` result references. */\nvar numberTag = '[object Number]';\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objToString = objectProto.toString;\n\n/**\n * Checks if `value` is classified as a `Number` primitive or object.\n *\n * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are classified\n * as numbers, use the `_.isFinite` method.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n * @example\n *\n * _.isNumber(8.4);\n * // => true\n *\n * _.isNumber(NaN);\n * // => true\n *\n * _.isNumber('8.4');\n * // => false\n */\nfunction isNumber(value) {\n  return typeof value == 'number' || (isObjectLike(value) && objToString.call(value) == numberTag);\n}\n\nmodule.exports = isNumber;\n","/**\n * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.\n * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(1);\n * // => false\n */\nfunction isObject(value) {\n  // Avoid a V8 JIT bug in Chrome 19-20.\n  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\nmodule.exports = isObject;\n","var baseForIn = require(322),\n    isArguments = require(400),\n    isObjectLike = require(384);\n\n/** `Object#toString` result references. */\nvar objectTag = '[object Object]';\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objToString = objectProto.toString;\n\n/**\n * Checks if `value` is a plain object, that is, an object created by the\n * `Object` constructor or one with a `[[Prototype]]` of `null`.\n *\n * **Note:** This method assumes objects created by the `Object` constructor\n * have no inherited enumerable properties.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n * }\n *\n * _.isPlainObject(new Foo);\n * // => false\n *\n * _.isPlainObject([1, 2, 3]);\n * // => false\n *\n * _.isPlainObject({ 'x': 0, 'y': 0 });\n * // => true\n *\n * _.isPlainObject(Object.create(null));\n * // => true\n */\nfunction isPlainObject(value) {\n  var Ctor;\n\n  // Exit early for non `Object` objects.\n  if (!(isObjectLike(value) && objToString.call(value) == objectTag && !isArguments(value)) ||\n      (!hasOwnProperty.call(value, 'constructor') && (Ctor = value.constructor, typeof Ctor == 'function' && !(Ctor instanceof Ctor)))) {\n    return false;\n  }\n  // IE < 9 iterates inherited properties before own properties. If the first\n  // iterated property is an object's own property then there are no inherited\n  // enumerable properties.\n  var result;\n  // In most environments an object's own properties are iterated before\n  // its inherited properties. If the last iterated property is an object's\n  // own property then there are no inherited enumerable properties.\n  baseForIn(value, function(subValue, key) {\n    result = key;\n  });\n  return result === undefined || hasOwnProperty.call(value, result);\n}\n\nmodule.exports = isPlainObject;\n","var isObjectLike = require(384);\n\n/** `Object#toString` result references. */\nvar stringTag = '[object String]';\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objToString = objectProto.toString;\n\n/**\n * Checks if `value` is classified as a `String` primitive or object.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n * @example\n *\n * _.isString('abc');\n * // => true\n *\n * _.isString(1);\n * // => false\n */\nfunction isString(value) {\n  return typeof value == 'string' || (isObjectLike(value) && objToString.call(value) == stringTag);\n}\n\nmodule.exports = isString;\n","var isLength = require(383),\n    isObjectLike = require(384);\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dateTag] = typedArrayTags[errorTag] =\ntypedArrayTags[funcTag] = typedArrayTags[mapTag] =\ntypedArrayTags[numberTag] = typedArrayTags[objectTag] =\ntypedArrayTags[regexpTag] = typedArrayTags[setTag] =\ntypedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objToString = objectProto.toString;\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nfunction isTypedArray(value) {\n  return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objToString.call(value)];\n}\n\nmodule.exports = isTypedArray;\n","var baseCopy = require(312),\n    keysIn = require(413);\n\n/**\n * Converts `value` to a plain object flattening inherited enumerable\n * properties of `value` to own properties of the plain object.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {Object} Returns the converted plain object.\n * @example\n *\n * function Foo() {\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.assign({ 'a': 1 }, new Foo);\n * // => { 'a': 1, 'b': 2 }\n *\n * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));\n * // => { 'a': 1, 'b': 2, 'c': 3 }\n */\nfunction toPlainObject(value) {\n  return baseCopy(value, keysIn(value));\n}\n\nmodule.exports = toPlainObject;\n","var assignWith = require(307),\n    baseAssign = require(308),\n    createAssigner = require(353);\n\n/**\n * Assigns own enumerable properties of source object(s) to the destination\n * object. Subsequent sources overwrite property assignments of previous sources.\n * If `customizer` is provided it's invoked to produce the assigned values.\n * The `customizer` is bound to `thisArg` and invoked with five arguments:\n * (objectValue, sourceValue, key, object, source).\n *\n * **Note:** This method mutates `object` and is based on\n * [`Object.assign`](http://ecma-international.org/ecma-262/6.0/#sec-object.assign).\n *\n * @static\n * @memberOf _\n * @alias extend\n * @category Object\n * @param {Object} object The destination object.\n * @param {...Object} [sources] The source objects.\n * @param {Function} [customizer] The function to customize assigned values.\n * @param {*} [thisArg] The `this` binding of `customizer`.\n * @returns {Object} Returns `object`.\n * @example\n *\n * _.assign({ 'user': 'barney' }, { 'age': 40 }, { 'user': 'fred' });\n * // => { 'user': 'fred', 'age': 40 }\n *\n * // using a customizer callback\n * var defaults = _.partialRight(_.assign, function(value, other) {\n *   return _.isUndefined(value) ? other : value;\n * });\n *\n * defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });\n * // => { 'user': 'barney', 'age': 36 }\n */\nvar assign = createAssigner(function(object, source, customizer) {\n  return customizer\n    ? assignWith(object, source, customizer)\n    : baseAssign(object, source);\n});\n\nmodule.exports = assign;\n","var baseGet = require(324),\n    baseSlice = require(339),\n    isArguments = require(400),\n    isArray = require(401),\n    isIndex = require(379),\n    isKey = require(381),\n    isLength = require(383),\n    last = require(273),\n    toPath = require(397);\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Checks if `path` is a direct property.\n *\n * @static\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @returns {boolean} Returns `true` if `path` is a direct property, else `false`.\n * @example\n *\n * var object = { 'a': { 'b': { 'c': 3 } } };\n *\n * _.has(object, 'a');\n * // => true\n *\n * _.has(object, 'a.b.c');\n * // => true\n *\n * _.has(object, ['a', 'b', 'c']);\n * // => true\n */\nfunction has(object, path) {\n  if (object == null) {\n    return false;\n  }\n  var result = hasOwnProperty.call(object, path);\n  if (!result && !isKey(path)) {\n    path = toPath(path);\n    object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));\n    if (object == null) {\n      return false;\n    }\n    path = last(path);\n    result = hasOwnProperty.call(object, path);\n  }\n  return result || (isLength(object.length) && isIndex(path, object.length) &&\n    (isArray(object) || isArguments(object)));\n}\n\nmodule.exports = has;\n","var getNative = require(373),\n    isArrayLike = require(378),\n    isObject = require(405),\n    shimKeys = require(394);\n\n/* Native method references for those with the same name as other `lodash` methods. */\nvar nativeKeys = getNative(Object, 'keys');\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nvar keys = !nativeKeys ? shimKeys : function(object) {\n  var Ctor = object == null ? undefined : object.constructor;\n  if ((typeof Ctor == 'function' && Ctor.prototype === object) ||\n      (typeof object != 'function' && isArrayLike(object))) {\n    return shimKeys(object);\n  }\n  return isObject(object) ? nativeKeys(object) : [];\n};\n\nmodule.exports = keys;\n","var isArguments = require(400),\n    isArray = require(401),\n    isIndex = require(379),\n    isLength = require(383),\n    isObject = require(405);\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Creates an array of the own and inherited enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects.\n *\n * @static\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keysIn(new Foo);\n * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n */\nfunction keysIn(object) {\n  if (object == null) {\n    return [];\n  }\n  if (!isObject(object)) {\n    object = Object(object);\n  }\n  var length = object.length;\n  length = (length && isLength(length) &&\n    (isArray(object) || isArguments(object)) && length) || 0;\n\n  var Ctor = object.constructor,\n      index = -1,\n      isProto = typeof Ctor == 'function' && Ctor.prototype === object,\n      result = Array(length),\n      skipIndexes = length > 0;\n\n  while (++index < length) {\n    result[index] = (index + '');\n  }\n  for (var key in object) {\n    if (!(skipIndexes && isIndex(key, length)) &&\n        !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = keysIn;\n","var baseMerge = require(333),\n    createAssigner = require(353);\n\n/**\n * Recursively merges own enumerable properties of the source object(s), that\n * don't resolve to `undefined` into the destination object. Subsequent sources\n * overwrite property assignments of previous sources. If `customizer` is\n * provided it's invoked to produce the merged values of the destination and\n * source properties. If `customizer` returns `undefined` merging is handled\n * by the method instead. The `customizer` is bound to `thisArg` and invoked\n * with five arguments: (objectValue, sourceValue, key, object, source).\n *\n * @static\n * @memberOf _\n * @category Object\n * @param {Object} object The destination object.\n * @param {...Object} [sources] The source objects.\n * @param {Function} [customizer] The function to customize assigned values.\n * @param {*} [thisArg] The `this` binding of `customizer`.\n * @returns {Object} Returns `object`.\n * @example\n *\n * var users = {\n *   'data': [{ 'user': 'barney' }, { 'user': 'fred' }]\n * };\n *\n * var ages = {\n *   'data': [{ 'age': 36 }, { 'age': 40 }]\n * };\n *\n * _.merge(users, ages);\n * // => { 'data': [{ 'user': 'barney', 'age': 36 }, { 'user': 'fred', 'age': 40 }] }\n *\n * // using a customizer callback\n * var object = {\n *   'fruits': ['apple'],\n *   'vegetables': ['beet']\n * };\n *\n * var other = {\n *   'fruits': ['banana'],\n *   'vegetables': ['carrot']\n * };\n *\n * _.merge(object, other, function(a, b) {\n *   if (_.isArray(a)) {\n *     return a.concat(b);\n *   }\n * });\n * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot'] }\n */\nvar merge = createAssigner(baseMerge);\n\nmodule.exports = merge;\n","var arrayMap = require(303),\n    baseDifference = require(314),\n    baseFlatten = require(320),\n    bindCallback = require(345),\n    keysIn = require(413),\n    pickByArray = require(388),\n    pickByCallback = require(389),\n    restParam = require(295);\n\n/**\n * The opposite of `_.pick`; this method creates an object composed of the\n * own and inherited enumerable properties of `object` that are not omitted.\n *\n * @static\n * @memberOf _\n * @category Object\n * @param {Object} object The source object.\n * @param {Function|...(string|string[])} [predicate] The function invoked per\n *  iteration or property names to omit, specified as individual property\n *  names or arrays of property names.\n * @param {*} [thisArg] The `this` binding of `predicate`.\n * @returns {Object} Returns the new object.\n * @example\n *\n * var object = { 'user': 'fred', 'age': 40 };\n *\n * _.omit(object, 'age');\n * // => { 'user': 'fred' }\n *\n * _.omit(object, _.isNumber);\n * // => { 'user': 'fred' }\n */\nvar omit = restParam(function(object, props) {\n  if (object == null) {\n    return {};\n  }\n  if (typeof props[0] != 'function') {\n    var props = arrayMap(baseFlatten(props), String);\n    return pickByArray(object, baseDifference(keysIn(object), props));\n  }\n  var predicate = bindCallback(props[0], props[1], 3);\n  return pickByCallback(object, function(value, key, object) {\n    return !predicate(value, key, object);\n  });\n});\n\nmodule.exports = omit;\n","var keys = require(412),\n    toObject = require(396);\n\n/**\n * Creates a two dimensional array of the key-value pairs for `object`,\n * e.g. `[[key1, value1], [key2, value2]]`.\n *\n * @static\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the new array of key-value pairs.\n * @example\n *\n * _.pairs({ 'barney': 36, 'fred': 40 });\n * // => [['barney', 36], ['fred', 40]] (iteration order is not guaranteed)\n */\nfunction pairs(object) {\n  object = toObject(object);\n\n  var index = -1,\n      props = keys(object),\n      length = props.length,\n      result = Array(length);\n\n  while (++index < length) {\n    var key = props[index];\n    result[index] = [key, object[key]];\n  }\n  return result;\n}\n\nmodule.exports = pairs;\n","var baseFlatten = require(320),\n    bindCallback = require(345),\n    pickByArray = require(388),\n    pickByCallback = require(389),\n    restParam = require(295);\n\n/**\n * Creates an object composed of the picked `object` properties. Property\n * names may be specified as individual arguments or as arrays of property\n * names. If `predicate` is provided it's invoked for each property of `object`\n * picking the properties `predicate` returns truthy for. The predicate is\n * bound to `thisArg` and invoked with three arguments: (value, key, object).\n *\n * @static\n * @memberOf _\n * @category Object\n * @param {Object} object The source object.\n * @param {Function|...(string|string[])} [predicate] The function invoked per\n *  iteration or property names to pick, specified as individual property\n *  names or arrays of property names.\n * @param {*} [thisArg] The `this` binding of `predicate`.\n * @returns {Object} Returns the new object.\n * @example\n *\n * var object = { 'user': 'fred', 'age': 40 };\n *\n * _.pick(object, 'user');\n * // => { 'user': 'fred' }\n *\n * _.pick(object, _.isString);\n * // => { 'user': 'fred' }\n */\nvar pick = restParam(function(object, props) {\n  if (object == null) {\n    return {};\n  }\n  return typeof props[0] == 'function'\n    ? pickByCallback(object, bindCallback(props[0], props[1], 3))\n    : pickByArray(object, baseFlatten(props));\n});\n\nmodule.exports = pick;\n","var arrayEach = require(300),\n    baseCallback = require(309),\n    baseCreate = require(313),\n    baseForOwn = require(323),\n    isArray = require(401),\n    isFunction = require(402),\n    isObject = require(405),\n    isTypedArray = require(408);\n\n/**\n * An alternative to `_.reduce`; this method transforms `object` to a new\n * `accumulator` object which is the result of running each of its own enumerable\n * properties through `iteratee`, with each invocation potentially mutating\n * the `accumulator` object. The `iteratee` is bound to `thisArg` and invoked\n * with four arguments: (accumulator, value, key, object). Iteratee functions\n * may exit iteration early by explicitly returning `false`.\n *\n * @static\n * @memberOf _\n * @category Object\n * @param {Array|Object} object The object to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @param {*} [accumulator] The custom accumulator value.\n * @param {*} [thisArg] The `this` binding of `iteratee`.\n * @returns {*} Returns the accumulated value.\n * @example\n *\n * _.transform([2, 3, 4], function(result, n) {\n *   result.push(n *= n);\n *   return n % 2 == 0;\n * });\n * // => [4, 9]\n *\n * _.transform({ 'a': 1, 'b': 2 }, function(result, n, key) {\n *   result[key] = n * 3;\n * });\n * // => { 'a': 3, 'b': 6 }\n */\nfunction transform(object, iteratee, accumulator, thisArg) {\n  var isArr = isArray(object) || isTypedArray(object);\n  iteratee = baseCallback(iteratee, thisArg, 4);\n\n  if (accumulator == null) {\n    if (isArr || isObject(object)) {\n      var Ctor = object.constructor;\n      if (isArr) {\n        accumulator = isArray(object) ? new Ctor : [];\n      } else {\n        accumulator = baseCreate(isFunction(Ctor) ? Ctor.prototype : undefined);\n      }\n    } else {\n      accumulator = {};\n    }\n  }\n  (isArr ? arrayEach : baseForOwn)(object, function(value, index, object) {\n    return iteratee(accumulator, value, index, object);\n  });\n  return accumulator;\n}\n\nmodule.exports = transform;\n","var baseValues = require(344),\n    keys = require(412);\n\n/**\n * Creates an array of the own enumerable property values of `object`.\n *\n * **Note:** Non-object values are coerced to objects.\n *\n * @static\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property values.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.values(new Foo);\n * // => [1, 2] (iteration order is not guaranteed)\n *\n * _.values('hi');\n * // => ['h', 'i']\n */\nfunction values(object) {\n  return baseValues(object, keys(object));\n}\n\nmodule.exports = values;\n","/**\n * This method returns the first argument provided to it.\n *\n * @static\n * @memberOf _\n * @category Utility\n * @param {*} value Any value.\n * @returns {*} Returns `value`.\n * @example\n *\n * var object = { 'user': 'fred' };\n *\n * _.identity(object) === object;\n * // => true\n */\nfunction identity(value) {\n  return value;\n}\n\nmodule.exports = identity;\n","/**\n * A no-operation function that returns `undefined` regardless of the\n * arguments it receives.\n *\n * @static\n * @memberOf _\n * @category Utility\n * @example\n *\n * var object = { 'user': 'fred' };\n *\n * _.noop(object) === undefined;\n * // => true\n */\nfunction noop() {\n  // No operation performed.\n}\n\nmodule.exports = noop;\n","var baseProperty = require(335),\n    basePropertyDeep = require(336),\n    isKey = require(381);\n\n/**\n * Creates a function that returns the property value at `path` on a\n * given object.\n *\n * @static\n * @memberOf _\n * @category Utility\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new function.\n * @example\n *\n * var objects = [\n *   { 'a': { 'b': { 'c': 2 } } },\n *   { 'a': { 'b': { 'c': 1 } } }\n * ];\n *\n * _.map(objects, _.property('a.b.c'));\n * // => [2, 1]\n *\n * _.pluck(_.sortBy(objects, _.property(['a', 'b', 'c'])), 'a.b.c');\n * // => [1, 2]\n */\nfunction property(path) {\n  return isKey(path) ? baseProperty(path) : basePropertyDeep(path);\n}\n\nmodule.exports = property;\n","/**\n * Set attribute `name` to `val`, or get attr `name`.\n *\n * @param {Element} el\n * @param {String} name\n * @param {String} [val]\n * @api public\n */\n\nmodule.exports = function(el, name, val) {\n  // get\n  if (arguments.length == 2) {\n    return el.getAttribute(name);\n  }\n\n  // remove\n  if (val === null) {\n    return el.removeAttribute(name);\n  }\n\n  // set\n  el.setAttribute(name, val);\n\n  return el;\n};","module.exports = require(433);","module.exports = function(el) {\n\n  var c;\n\n  while (el.childNodes.length) {\n    c = el.childNodes[0];\n    el.removeChild(c);\n  }\n\n  return el;\n};","module.exports = require(435);","module.exports = require(436);","module.exports = require(440);","module.exports = require(437);","module.exports = require(438);","module.exports = require(439);","module.exports = function(el) {\n  el.parentNode && el.parentNode.removeChild(el);\n};","/**\n * Module dependencies.\n */\n\ntry {\n  var index = require(434);\n} catch (err) {\n  var index = require(434);\n}\n\n/**\n * Whitespace regexp.\n */\n\nvar re = //s+/;\n\n/**\n * toString reference.\n */\n\nvar toString = Object.prototype.toString;\n\n/**\n * Wrap `el` in a `ClassList`.\n *\n * @param {Element} el\n * @return {ClassList}\n * @api public\n */\n\nmodule.exports = function(el){\n  return new ClassList(el);\n};\n\n/**\n * Initialize a new ClassList for `el`.\n *\n * @param {Element} el\n * @api private\n */\n\nfunction ClassList(el) {\n  if (!el || !el.nodeType) {\n    throw new Error('A DOM element reference is required');\n  }\n  this.el = el;\n  this.list = el.classList;\n}\n\n/**\n * Add class `name` if not already present.\n *\n * @param {String} name\n * @return {ClassList}\n * @api public\n */\n\nClassList.prototype.add = function(name){\n  // classList\n  if (this.list) {\n    this.list.add(name);\n    return this;\n  }\n\n  // fallback\n  var arr = this.array();\n  var i = index(arr, name);\n  if (!~i) arr.push(name);\n  this.el.className = arr.join(' ');\n  return this;\n};\n\n/**\n * Remove class `name` when present, or\n * pass a regular expression to remove\n * any which match.\n *\n * @param {String|RegExp} name\n * @return {ClassList}\n * @api public\n */\n\nClassList.prototype.remove = function(name){\n  if ('[object RegExp]' == toString.call(name)) {\n    return this.removeMatching(name);\n  }\n\n  // classList\n  if (this.list) {\n    this.list.remove(name);\n    return this;\n  }\n\n  // fallback\n  var arr = this.array();\n  var i = index(arr, name);\n  if (~i) arr.splice(i, 1);\n  this.el.className = arr.join(' ');\n  return this;\n};\n\n/**\n * Remove all classes matching `re`.\n *\n * @param {RegExp} re\n * @return {ClassList}\n * @api private\n */\n\nClassList.prototype.removeMatching = function(re){\n  var arr = this.array();\n  for (var i = 0; i < arr.length; i++) {\n    if (re.test(arr[i])) {\n      this.remove(arr[i]);\n    }\n  }\n  return this;\n};\n\n/**\n * Toggle class `name`, can force state via `force`.\n *\n * For browsers that support classList, but do not support `force` yet,\n * the mistake will be detected and corrected.\n *\n * @param {String} name\n * @param {Boolean} force\n * @return {ClassList}\n * @api public\n */\n\nClassList.prototype.toggle = function(name, force){\n  // classList\n  if (this.list) {\n    if (\"undefined\" !== typeof force) {\n      if (force !== this.list.toggle(name, force)) {\n        this.list.toggle(name); // toggle again to correct\n      }\n    } else {\n      this.list.toggle(name);\n    }\n    return this;\n  }\n\n  // fallback\n  if (\"undefined\" !== typeof force) {\n    if (!force) {\n      this.remove(name);\n    } else {\n      this.add(name);\n    }\n  } else {\n    if (this.has(name)) {\n      this.remove(name);\n    } else {\n      this.add(name);\n    }\n  }\n\n  return this;\n};\n\n/**\n * Return an array of classes.\n *\n * @return {Array}\n * @api public\n */\n\nClassList.prototype.array = function(){\n  var className = this.el.getAttribute('class') || '';\n  var str = className.replace(/^/s+|/s+$/g, '');\n  var arr = str.split(re);\n  if ('' === arr[0]) arr.shift();\n  return arr;\n};\n\n/**\n * Check if class `name` is present.\n *\n * @param {String} name\n * @return {ClassList}\n * @api public\n */\n\nClassList.prototype.has =\nClassList.prototype.contains = function(name){\n  return this.list\n    ? this.list.contains(name)\n    : !! ~index(this.array(), name);\n};\n","module.exports = function(arr, obj){\n  if (arr.indexOf) return arr.indexOf(obj);\n  for (var i = 0; i < arr.length; ++i) {\n    if (arr[i] === obj) return i;\n  }\n  return -1;\n};","var matches = require(438)\n\nmodule.exports = function (element, selector, checkYoSelf, root) {\n  element = checkYoSelf ? {parentNode: element} : element\n\n  root = root || document\n\n  // Make sure `element !== document` and `element != null`\n  // otherwise we get an illegal invocation\n  while ((element = element.parentNode) && element !== document) {\n    if (matches(element, selector))\n      return element\n    // After `matches` on the edge case that\n    // the selector matches the root\n    // (when the root is not the document)\n    if (element === root)\n      return\n  }\n}\n","/**\n * Module dependencies.\n */\n\ntry {\n  var closest = require(435);\n} catch(err) {\n  var closest = require(435);\n}\n\ntry {\n  var event = require(437);\n} catch(err) {\n  var event = require(437);\n}\n\n/**\n * Delegate event `type` to `selector`\n * and invoke `fn(e)`. A callback function\n * is returned which may be passed to `.unbind()`.\n *\n * @param {Element} el\n * @param {String} selector\n * @param {String} type\n * @param {Function} fn\n * @param {Boolean} capture\n * @return {Function}\n * @api public\n */\n\nexports.bind = function(el, selector, type, fn, capture){\n  return event.bind(el, type, function(e){\n    var target = e.target || e.srcElement;\n    e.delegateTarget = closest(target, selector, true, el);\n    if (e.delegateTarget) fn.call(el, e);\n  }, capture);\n};\n\n/**\n * Unbind event `type`'s callback `fn`.\n *\n * @param {Element} el\n * @param {String} type\n * @param {Function} fn\n * @param {Boolean} capture\n * @api public\n */\n\nexports.unbind = function(el, type, fn, capture){\n  event.unbind(el, type, fn, capture);\n};\n","var bind = window.addEventListener ? 'addEventListener' : 'attachEvent',\n    unbind = window.removeEventListener ? 'removeEventListener' : 'detachEvent',\n    prefix = bind !== 'addEventListener' ? 'on' : '';\n\n/**\n * Bind `el` event `type` to `fn`.\n *\n * @param {Element} el\n * @param {String} type\n * @param {Function} fn\n * @param {Boolean} capture\n * @return {Function}\n * @api public\n */\n\nexports.bind = function(el, type, fn, capture){\n  el[bind](prefix + type, fn, capture || false);\n  return fn;\n};\n\n/**\n * Unbind `el` event `type`'s callback `fn`.\n *\n * @param {Element} el\n * @param {String} type\n * @param {Function} fn\n * @param {Boolean} capture\n * @return {Function}\n * @api public\n */\n\nexports.unbind = function(el, type, fn, capture){\n  el[unbind](prefix + type, fn, capture || false);\n  return fn;\n};","/**\n * Module dependencies.\n */\n\ntry {\n  var query = require(439);\n} catch (err) {\n  var query = require(439);\n}\n\n/**\n * Element prototype.\n */\n\nvar proto = Element.prototype;\n\n/**\n * Vendor function.\n */\n\nvar vendor = proto.matches\n  || proto.webkitMatchesSelector\n  || proto.mozMatchesSelector\n  || proto.msMatchesSelector\n  || proto.oMatchesSelector;\n\n/**\n * Expose `match()`.\n */\n\nmodule.exports = match;\n\n/**\n * Match `el` to `selector`.\n *\n * @param {Element} el\n * @param {String} selector\n * @return {Boolean}\n * @api public\n */\n\nfunction match(el, selector) {\n  if (!el || el.nodeType !== 1) return false;\n  if (vendor) return vendor.call(el, selector);\n  var nodes = query.all(selector, el.parentNode);\n  for (var i = 0; i < nodes.length; ++i) {\n    if (nodes[i] == el) return true;\n  }\n  return false;\n}\n","function one(selector, el) {\n  return el.querySelector(selector);\n}\n\nexports = module.exports = function(selector, el){\n  el = el || document;\n  return one(selector, el);\n};\n\nexports.all = function(selector, el){\n  el = el || document;\n  return el.querySelectorAll(selector);\n};\n\nexports.engine = function(obj){\n  if (!obj.one) throw new Error('.one callback required');\n  if (!obj.all) throw new Error('.all callback required');\n  one = obj.one;\n  exports.all = obj.all;\n  return exports;\n};\n","\n/**\n * Expose `parse`.\n */\n\nmodule.exports = parse;\n\n/**\n * Tests for browser support.\n */\n\nvar innerHTMLBug = false;\nvar bugTestDiv;\nif (typeof document !== 'undefined') {\n  bugTestDiv = document.createElement('div');\n  // Setup\n  bugTestDiv.innerHTML = '  <link/><table></table><a href=\"/a\">a</a><input type=\"checkbox\"/>';\n  // Make sure that link elements get serialized correctly by innerHTML\n  // This requires a wrapper element in IE\n  innerHTMLBug = !bugTestDiv.getElementsByTagName('link').length;\n  bugTestDiv = undefined;\n}\n\n/**\n * Wrap map from jquery.\n */\n\nvar map = {\n  legend: [1, '<fieldset>', '</fieldset>'],\n  tr: [2, '<table><tbody>', '</tbody></table>'],\n  col: [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],\n  // for script/link/style tags to work in IE6-8, you have to wrap\n  // in a div with a non-whitespace character in front, ha!\n  _default: innerHTMLBug ? [1, 'X<div>', '</div>'] : [0, '', '']\n};\n\nmap.td =\nmap.th = [3, '<table><tbody><tr>', '</tr></tbody></table>'];\n\nmap.option =\nmap.optgroup = [1, '<select multiple=\"multiple\">', '</select>'];\n\nmap.thead =\nmap.tbody =\nmap.colgroup =\nmap.caption =\nmap.tfoot = [1, '<table>', '</table>'];\n\nmap.polyline =\nmap.ellipse =\nmap.polygon =\nmap.circle =\nmap.text =\nmap.line =\nmap.path =\nmap.rect =\nmap.g = [1, '<svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\">','</svg>'];\n\n/**\n * Parse `html` and return a DOM Node instance, which could be a TextNode,\n * HTML DOM Node of some kind (<div> for example), or a DocumentFragment\n * instance, depending on the contents of the `html` string.\n *\n * @param {String} html - HTML string to \"domify\"\n * @param {Document} doc - The `document` instance to create the Node for\n * @return {DOMNode} the TextNode, DOM Node, or DocumentFragment instance\n * @api private\n */\n\nfunction parse(html, doc) {\n  if ('string' != typeof html) throw new TypeError('String expected');\n\n  // default to the global `document` object\n  if (!doc) doc = document;\n\n  // tag name\n  var m = /<([/w:]+)/.exec(html);\n  if (!m) return doc.createTextNode(html);\n\n  html = html.replace(/^/s+|/s+$/g, ''); // Remove leading/trailing whitespace\n\n  var tag = m[1];\n\n  // body support\n  if (tag == 'body') {\n    var el = doc.createElement('html');\n    el.innerHTML = html;\n    return el.removeChild(el.lastChild);\n  }\n\n  // wrap map\n  var wrap = map[tag] || map._default;\n  var depth = wrap[0];\n  var prefix = wrap[1];\n  var suffix = wrap[2];\n  var el = doc.createElement('div');\n  el.innerHTML = prefix + html + suffix;\n  while (depth--) el = el.lastChild;\n\n  // one element\n  if (el.firstChild == el.lastChild) {\n    return el.removeChild(el.firstChild);\n  }\n\n  // several elements\n  var fragment = doc.createDocumentFragment();\n  while (el.firstChild) {\n    fragment.appendChild(el.removeChild(el.firstChild));\n  }\n\n  return fragment;\n}\n","module.exports = require(443);\n\nmodule.exports.Collection = require(442);","'use strict';\n\n/**\n * An empty collection stub. Use {@link RefsCollection.extend} to extend a\n * collection with ref semantics.\n *\n * @class RefsCollection\n */\n\n/**\n * Extends a collection with {@link Refs} aware methods\n *\n * @memberof RefsCollection\n * @static\n *\n * @param  {Array<Object>} collection\n * @param  {Refs} refs instance\n * @param  {Object} property represented by the collection\n * @param  {Object} target object the collection is attached to\n *\n * @return {RefsCollection<Object>} the extended array\n */\nfunction extend(collection, refs, property, target) {\n\n  var inverseProperty = property.inverse;\n\n  /**\n   * Removes the given element from the array and returns it.\n   *\n   * @method RefsCollection#remove\n   *\n   * @param {Object} element the element to remove\n   */\n  Object.defineProperty(collection, 'remove', {\n    value: function(element) {\n      var idx = this.indexOf(element);\n      if (idx !== -1) {\n        this.splice(idx, 1);\n\n        // unset inverse\n        refs.unset(element, inverseProperty, target);\n      }\n\n      return element;\n    }\n  });\n\n  /**\n   * Returns true if the collection contains the given element\n   *\n   * @method RefsCollection#contains\n   *\n   * @param {Object} element the element to check for\n   */\n  Object.defineProperty(collection, 'contains', {\n    value: function(element) {\n      return this.indexOf(element) !== -1;\n    }\n  });\n\n  /**\n   * Adds an element to the array, unless it exists already (set semantics).\n   *\n   * @method RefsCollection#add\n   *\n   * @param {Object} element the element to add\n   */\n  Object.defineProperty(collection, 'add', {\n    value: function(element) {\n\n      if (!this.contains(element)) {\n        this.push(element);\n\n        // set inverse\n        refs.set(element, inverseProperty, target);\n      }\n    }\n  });\n\n  // a simple marker, identifying this element\n  // as being a refs collection\n  Object.defineProperty(collection, '__refs_collection', {\n    value: true\n  });\n\n  return collection;\n}\n\n\nfunction isExtended(collection) {\n  return collection.__refs_collection === true;\n}\n\nmodule.exports.extend = extend;\n\nmodule.exports.isExtended = isExtended;","'use strict';\n\nvar Collection = require(442);\n\nfunction hasOwnProperty(e, property) {\n  return Object.prototype.hasOwnProperty.call(e, property.name || property);\n}\n\nfunction defineCollectionProperty(ref, property, target) {\n  Object.defineProperty(target, property.name, {\n    enumerable: property.enumerable,\n    value: Collection.extend(target[property.name] || [], ref, property, target)\n  });\n}\n\n\nfunction defineProperty(ref, property, target) {\n\n  var inverseProperty = property.inverse;\n\n  var _value = target[property.name];\n\n  Object.defineProperty(target, property.name, {\n    enumerable: property.enumerable,\n\n    get: function() {\n      return _value;\n    },\n\n    set: function(value) {\n\n      // return if we already performed all changes\n      if (value === _value) {\n        return;\n      }\n\n      var old = _value;\n\n      // temporary set null\n      _value = null;\n\n      if (old) {\n        ref.unset(old, inverseProperty, target);\n      }\n\n      // set new value\n      _value = value;\n\n      // set inverse value\n      ref.set(_value, inverseProperty, target);\n    }\n  });\n\n}\n\n/**\n * Creates a new references object defining two inversly related\n * attribute descriptors a and b.\n *\n * <p>\n *   When bound to an object using {@link Refs#bind} the references\n *   get activated and ensure that add and remove operations are applied\n *   reversely, too.\n * </p>\n *\n * <p>\n *   For attributes represented as collections {@link Refs} provides the\n *   {@link RefsCollection#add}, {@link RefsCollection#remove} and {@link RefsCollection#contains} extensions\n *   that must be used to properly hook into the inverse change mechanism.\n * </p>\n *\n * @class Refs\n *\n * @classdesc A bi-directional reference between two attributes.\n *\n * @param {Refs.AttributeDescriptor} a property descriptor\n * @param {Refs.AttributeDescriptor} b property descriptor\n *\n * @example\n *\n * var refs = Refs({ name: 'wheels', collection: true, enumerable: true }, { name: 'car' });\n *\n * var car = { name: 'toyota' };\n * var wheels = [{ pos: 'front-left' }, { pos: 'front-right' }];\n *\n * refs.bind(car, 'wheels');\n *\n * car.wheels // []\n * car.wheels.add(wheels[0]);\n * car.wheels.add(wheels[1]);\n *\n * car.wheels // [{ pos: 'front-left' }, { pos: 'front-right' }]\n *\n * wheels[0].car // { name: 'toyota' };\n * car.wheels.remove(wheels[0]);\n *\n * wheels[0].car // undefined\n */\nfunction Refs(a, b) {\n\n  if (!(this instanceof Refs)) {\n    return new Refs(a, b);\n  }\n\n  // link\n  a.inverse = b;\n  b.inverse = a;\n\n  this.props = {};\n  this.props[a.name] = a;\n  this.props[b.name] = b;\n}\n\n/**\n * Binds one side of a bi-directional reference to a\n * target object.\n *\n * @memberOf Refs\n *\n * @param  {Object} target\n * @param  {String} property\n */\nRefs.prototype.bind = function(target, property) {\n  if (typeof property === 'string') {\n    if (!this.props[property]) {\n      throw new Error('no property <' + property + '> in ref');\n    }\n    property = this.props[property];\n  }\n\n  if (property.collection) {\n    defineCollectionProperty(this, property, target);\n  } else {\n    defineProperty(this, property, target);\n  }\n};\n\nRefs.prototype.ensureRefsCollection = function(target, property) {\n\n  var collection = target[property.name];\n\n  if (!Collection.isExtended(collection)) {\n    defineCollectionProperty(this, property, target);\n  }\n\n  return collection;\n};\n\nRefs.prototype.ensureBound = function(target, property) {\n  if (!hasOwnProperty(target, property)) {\n    this.bind(target, property);\n  }\n};\n\nRefs.prototype.unset = function(target, property, value) {\n\n  if (target) {\n    this.ensureBound(target, property);\n\n    if (property.collection) {\n      this.ensureRefsCollection(target, property).remove(value);\n    } else {\n      target[property.name] = undefined;\n    }\n  }\n};\n\nRefs.prototype.set = function(target, property, value) {\n\n  if (target) {\n    this.ensureBound(target, property);\n\n    if (property.collection) {\n      this.ensureRefsCollection(target, property).add(value);\n    } else {\n      target[property.name] = value;\n    }\n  }\n};\n\nmodule.exports = Refs;\n\n\n/**\n * An attribute descriptor to be used specify an attribute in a {@link Refs} instance\n *\n * @typedef {Object} Refs.AttributeDescriptor\n * @property {String} name\n * @property {boolean} [collection=false]\n * @property {boolean} [enumerable=false]\n */","module.exports = require(445);","'use strict';\n\nvar assign = require(518);\n\nvar VdmlModdle = require(446);\n\nvar packages = {\n  vdml: require(541),\n  vdmldi: require(542),\n  dc: require(539),\n  di: require(540)\n};\n\nmodule.exports = function(additionalPackages, options) {\n  return new VdmlModdle(assign({}, packages, additionalPackages), options);\n};","'use strict';\n\nvar isString = require(516),\n    isFunction = require(513),\n    assign = require(518);\n\nvar Moddle = require(530),\n    XmlReader = require(526),\n    XmlWriter = require(527);\n\n/**\n * A sub class of {@link Moddle} with support for import and export of CMMN 1.1 xml files.\n *\n * @class VdmlModdle\n * @extends Moddle\n *\n * @param {Object|Array} packages to use for instantiating the model\n * @param {Object} [options] additional options to pass over\n */\nfunction VdmlModdle(packages, options) {\n  Moddle.call(this, packages, options);\n}\n\nVdmlModdle.prototype = Object.create(Moddle.prototype);\n\nmodule.exports = VdmlModdle;\n\n\n/**\n * Instantiates a CMMN model tree from a given xml string.\n *\n * @param {String}   xmlStr\n * @param {String}   [typeName='vdml:Definitions'] name of the root element\n * @param {Object}   [options]  options to pass to the underlying reader\n * @param {Function} done       callback that is invoked with (err, result, parseContext)\n *                              once the import completes\n */\nVdmlModdle.prototype.fromXML = function(xmlStr, typeName, options, done) {\n\n  if (!isString(typeName)) {\n    done = options;\n    options = typeName;\n    typeName = 'vdml:Definitions';\n  }\n\n  if (isFunction(options)) {\n    done = options;\n    options = {};\n  }\n\n  var reader = new XmlReader(assign({ model: this, lax: true }, options));\n  var rootHandler = reader.handler(typeName);\n\n  reader.fromXML(xmlStr, rootHandler, done);\n};\n\n\n/**\n * Serializes a CMMN 1.1 object tree to XML.\n *\n * @param {String}   element    the root element, typically an instance of `vdml:Definitions`\n * @param {Object}   [options]  to pass to the underlying writer\n * @param {Function} done       callback invoked with (err, xmlStr) once the import completes\n */\nVdmlModdle.prototype.toXML = function(element, options, done) {\n\n  if (isFunction(options)) {\n    done = options;\n    options = {};\n  }\n\n  var writer = new XmlWriter(options);\n  try {\n    var result = writer.toXML(element);\n    done(null, result);\n  } catch (e) {\n    done(e);\n  }\n};\n","var baseDelay = require(465),\n    restParam = require(454);\n\n/**\n * Defers invoking the `func` until the current call stack has cleared. Any\n * additional arguments are provided to `func` when it's invoked.\n *\n * @static\n * @memberOf _\n * @category Function\n * @param {Function} func The function to defer.\n * @param {...*} [args] The arguments to invoke the function with.\n * @returns {number} Returns the timer id.\n * @example\n *\n * _.defer(function(text) {\n *   console.log(text);\n * }, 'deferred');\n * // logs 'deferred' after one or more milliseconds\n */\nvar defer = restParam(function(func, args) {\n  return baseDelay(func, 1, args);\n});\n\nmodule.exports = defer;\n","/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/**\n * The base implementation of `_.delay` and `_.defer` which accepts an index\n * of where to slice the arguments to provide to `func`.\n *\n * @private\n * @param {Function} func The function to delay.\n * @param {number} wait The number of milliseconds to delay invocation.\n * @param {Object} args The arguments provide to `func`.\n * @returns {number} Returns the timer id.\n */\nfunction baseDelay(func, wait, args) {\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  return setTimeout(function() { func.apply(undefined, args); }, wait);\n}\n\nmodule.exports = baseDelay;\n","'use strict';\n\nfunction capitalize(string) {\n  return string.charAt(0).toUpperCase() + string.slice(1);\n}\n\nfunction lower(string) {\n  return string.charAt(0).toLowerCase() + string.slice(1);\n}\n\nfunction hasLowerCaseAlias(pkg) {\n  return pkg.xml && pkg.xml.tagAlias === 'lowerCase';\n}\n\n\nmodule.exports.aliasToName = function(alias, pkg) {\n  if (hasLowerCaseAlias(pkg)) {\n    return capitalize(alias);\n  } else {\n    return alias;\n  }\n};\n\nmodule.exports.nameToAlias = function(name, pkg) {\n  if (hasLowerCaseAlias(pkg)) {\n    return lower(name);\n  } else {\n    return name;\n  }\n};\n\nmodule.exports.DEFAULT_NS_MAP = {\n  'xsi': 'http://www.w3.org/2001/XMLSchema-instance'\n};\n\nvar XSI_TYPE = module.exports.XSI_TYPE = 'xsi:type';\n\nfunction serializeFormat(element) {\n  return element.xml && element.xml.serialize;\n}\n\nmodule.exports.serializeAsType = function(element) {\n  return serializeFormat(element) === XSI_TYPE;\n};\n\nmodule.exports.serializeAsProperty = function(element) {\n  return serializeFormat(element) === 'property';\n};","'use strict';\n\nvar reduce = require(452),\n    forEach = require(450),\n    find = require(449),\n    assign = require(518),\n    defer = require(453);\n\nvar Stack = require(529),\n    SaxParser = require(528).parser,\n    Moddle = require(530),\n    parseNameNs = require(535).parseName,\n    Types = require(538),\n    coerceType = Types.coerceType,\n    isSimpleType = Types.isSimple,\n    common = require(525),\n    XSI_TYPE = common.XSI_TYPE,\n    XSI_URI = common.DEFAULT_NS_MAP.xsi,\n    serializeAsType = common.serializeAsType,\n    aliasToName = common.aliasToName;\n\nfunction parseNodeAttributes(node) {\n  var nodeAttrs = node.attributes;\n\n  return reduce(nodeAttrs, function(result, v, k) {\n    var name, ns;\n\n    if (!v.local) {\n      name = v.prefix;\n    } else {\n      ns = parseNameNs(v.name, v.prefix);\n      name = ns.name;\n    }\n\n    result[name] = v.value;\n    return result;\n  }, {});\n}\n\nfunction normalizeType(node, attr, model) {\n  var nameNs = parseNameNs(attr.value);\n\n  var uri = node.ns[nameNs.prefix || ''],\n      localName = nameNs.localName,\n      pkg = uri && model.getPackage(uri),\n      typePrefix;\n\n  if (pkg) {\n    typePrefix = pkg.xml && pkg.xml.typePrefix;\n\n    if (typePrefix && localName.indexOf(typePrefix) === 0) {\n      localName = localName.slice(typePrefix.length);\n    }\n\n    attr.value = pkg.prefix + ':' + localName;\n  }\n}\n\n/**\n * Normalizes namespaces for a node given an optional default namespace and a\n * number of mappings from uris to default prefixes.\n *\n * @param  {XmlNode} node\n * @param  {Model} model the model containing all registered namespaces\n * @param  {Uri} defaultNsUri\n */\nfunction normalizeNamespaces(node, model, defaultNsUri) {\n  var uri, prefix;\n\n  uri = node.uri || defaultNsUri;\n\n  if (uri) {\n    var pkg = model.getPackage(uri);\n\n    if (pkg) {\n      prefix = pkg.prefix;\n    } else {\n      prefix = node.prefix;\n    }\n\n    node.prefix = prefix;\n    node.uri = uri;\n  }\n\n  forEach(node.attributes, function(attr) {\n\n    // normalize xsi:type attributes because the\n    // assigned type may or may not be namespace prefixed\n    if (attr.uri === XSI_URI && attr.local === 'type') {\n      normalizeType(node, attr, model);\n    }\n\n    normalizeNamespaces(attr, model, null);\n  });\n}\n\n\nfunction error(message) {\n  return new Error(message);\n}\n\n/**\n * Get the moddle descriptor for a given instance or type.\n *\n * @param  {ModdleElement|Function} element\n *\n * @return {Object} the moddle descriptor\n */\nfunction getModdleDescriptor(element) {\n  return element.$descriptor;\n}\n\n/**\n * A parse context.\n *\n * @class\n *\n * @param {Object} options\n * @param {ElementHandler} options.rootHandler the root handler for parsing a document\n * @param {boolean} [options.lax=false] whether or not to ignore invalid elements\n */\nfunction Context(options) {\n\n  /**\n   * @property {ElementHandler} rootHandler\n   */\n\n  /**\n   * @property {Boolean} lax\n   */\n\n  assign(this, options);\n\n  this.elementsById = {};\n  this.references = [];\n  this.warnings = [];\n\n  /**\n   * Add an unresolved reference.\n   *\n   * @param {Object} reference\n   */\n  this.addReference = function(reference) {\n    this.references.push(reference);\n  };\n\n  /**\n   * Add a processed element.\n   *\n   * @param {ModdleElement} element\n   */\n  this.addElement = function(element) {\n\n    if (!element) {\n      throw error('expected element');\n    }\n\n    var elementsById = this.elementsById;\n\n    var descriptor = getModdleDescriptor(element);\n\n    var idProperty = descriptor.idProperty,\n        id;\n\n    if (idProperty) {\n      id = element.get(idProperty.name);\n\n      if (id) {\n\n        if (elementsById[id]) {\n          throw error('duplicate ID <' + id + '>');\n        }\n\n        elementsById[id] = element;\n      }\n    }\n  };\n\n  /**\n   * Add an import warning.\n   *\n   * @param {Object} warning\n   * @param {String} warning.message\n   * @param {Error} [warning.error]\n   */\n  this.addWarning = function(warning) {\n    this.warnings.push(warning);\n  };\n}\n\nfunction BaseHandler() {}\n\nBaseHandler.prototype.handleEnd = function() {};\nBaseHandler.prototype.handleText = function() {};\nBaseHandler.prototype.handleNode = function() {};\n\n\n/**\n * A simple pass through handler that does nothing except for\n * ignoring all input it receives.\n *\n * This is used to ignore unknown elements and\n * attributes.\n */\nfunction NoopHandler() { }\n\nNoopHandler.prototype = new BaseHandler();\n\nNoopHandler.prototype.handleNode = function() {\n  return this;\n};\n\nfunction BodyHandler() {}\n\nBodyHandler.prototype = new BaseHandler();\n\nBodyHandler.prototype.handleText = function(text) {\n  this.body = (this.body || '') + text;\n};\n\nfunction ReferenceHandler(property, context) {\n  this.property = property;\n  this.context = context;\n}\n\nReferenceHandler.prototype = new BodyHandler();\n\nReferenceHandler.prototype.handleNode = function(node) {\n\n  if (this.element) {\n    throw error('expected no sub nodes');\n  } else {\n    this.element = this.createReference(node);\n  }\n\n  return this;\n};\n\nReferenceHandler.prototype.handleEnd = function() {\n  this.element.id = this.body;\n};\n\nReferenceHandler.prototype.createReference = function(node) {\n  return {\n    property: this.property.ns.name,\n    id: ''\n  };\n};\n\nfunction ValueHandler(propertyDesc, element) {\n  this.element = element;\n  this.propertyDesc = propertyDesc;\n}\n\nValueHandler.prototype = new BodyHandler();\n\nValueHandler.prototype.handleEnd = function() {\n\n  var value = this.body,\n      element = this.element,\n      propertyDesc = this.propertyDesc;\n\n  value = coerceType(propertyDesc.type, value);\n\n  if (propertyDesc.isMany) {\n    element.get(propertyDesc.name).push(value);\n  } else {\n    element.set(propertyDesc.name, value);\n  }\n};\n\n\nfunction BaseElementHandler() {}\n\nBaseElementHandler.prototype = Object.create(BodyHandler.prototype);\n\nBaseElementHandler.prototype.handleNode = function(node) {\n  var parser = this,\n      element = this.element;\n\n  if (!element) {\n    element = this.element = this.createElement(node);\n\n    this.context.addElement(element);\n  } else {\n    parser = this.handleChild(node);\n  }\n\n  return parser;\n};\n\n/**\n * @class XMLReader.ElementHandler\n *\n */\nfunction ElementHandler(model, type, context) {\n  this.model = model;\n  this.type = model.getType(type);\n  this.context = context;\n}\n\nElementHandler.prototype = new BaseElementHandler();\n\nElementHandler.prototype.addReference = function(reference) {\n  this.context.addReference(reference);\n};\n\nElementHandler.prototype.handleEnd = function() {\n\n  var value = this.body,\n      element = this.element,\n      descriptor = getModdleDescriptor(element),\n      bodyProperty = descriptor.bodyProperty;\n\n  if (bodyProperty && value !== undefined) {\n    value = coerceType(bodyProperty.type, value);\n    element.set(bodyProperty.name, value);\n  }\n};\n\n/**\n * Create an instance of the model from the given node.\n *\n * @param  {Element} node the xml node\n */\nElementHandler.prototype.createElement = function(node) {\n  var attributes = parseNodeAttributes(node),\n      Type = this.type,\n      descriptor = getModdleDescriptor(Type),\n      context = this.context,\n      instance = new Type({});\n\n  forEach(attributes, function(value, name) {\n\n    var prop = descriptor.propertiesByName[name],\n        values;\n\n    if (prop && prop.isReference) {\n\n      if (!prop.isMany) {\n        context.addReference({\n          element: instance,\n          property: prop.ns.name,\n          id: value\n        });\n      } else {\n        // IDREFS: parse references as whitespace-separated list\n        values = value.split(' ');\n\n        forEach(values, function(v) {\n          context.addReference({\n            element: instance,\n            property: prop.ns.name,\n            id: v\n          });\n        });\n      }\n\n    } else {\n      if (prop) {\n        value = coerceType(prop.type, value);\n      }\n\n      instance.set(name, value);\n    }\n  });\n\n  return instance;\n};\n\nElementHandler.prototype.getPropertyForNode = function(node) {\n\n  var nameNs = parseNameNs(node.local, node.prefix);\n\n  var type = this.type,\n      model = this.model,\n      descriptor = getModdleDescriptor(type);\n\n  var propertyName = nameNs.name,\n      property = descriptor.propertiesByName[propertyName],\n      elementTypeName,\n      elementType,\n      typeAnnotation;\n\n  // search for properties by name first\n\n  if (property) {\n\n    if (serializeAsType(property)) {\n      typeAnnotation = node.attributes[XSI_TYPE];\n\n      // xsi type is optional, if it does not exists the\n      // default type is assumed\n      if (typeAnnotation) {\n\n        elementTypeName = typeAnnotation.value;\n\n        // TODO: extract real name from attribute\n        elementType = model.getType(elementTypeName);\n\n        return assign({}, property, { effectiveType: getModdleDescriptor(elementType).name });\n      }\n    }\n\n    // search for properties by name first\n    return property;\n  }\n\n\n  var pkg = model.getPackage(nameNs.prefix);\n\n  if (pkg) {\n    elementTypeName = nameNs.prefix + ':' + aliasToName(nameNs.localName, descriptor.$pkg);\n    elementType = model.getType(elementTypeName);\n\n    // search for collection members later\n    property = find(descriptor.properties, function(p) {\n      return !p.isVirtual && !p.isReference && !p.isAttribute && elementType.hasType(p.type);\n    });\n\n    if (property) {\n      return assign({}, property, { effectiveType: getModdleDescriptor(elementType).name });\n    }\n  } else {\n    // parse unknown element (maybe extension)\n    property = find(descriptor.properties, function(p) {\n      return !p.isReference && !p.isAttribute && p.type === 'Element';\n    });\n\n    if (property) {\n      return property;\n    }\n  }\n\n  throw error('unrecognized element <' + nameNs.name + '>');\n};\n\nElementHandler.prototype.toString = function() {\n  return 'ElementDescriptor[' + getModdleDescriptor(this.type).name + ']';\n};\n\nElementHandler.prototype.valueHandler = function(propertyDesc, element) {\n  return new ValueHandler(propertyDesc, element);\n};\n\nElementHandler.prototype.referenceHandler = function(propertyDesc) {\n  return new ReferenceHandler(propertyDesc, this.context);\n};\n\nElementHandler.prototype.handler = function(type) {\n  if (type === 'Element') {\n    return new GenericElementHandler(this.model, type, this.context);\n  } else {\n    return new ElementHandler(this.model, type, this.context);\n  }\n};\n\n/**\n * Handle the child element parsing\n *\n * @param  {Element} node the xml node\n */\nElementHandler.prototype.handleChild = function(node) {\n  var propertyDesc, type, element, childHandler;\n\n  propertyDesc = this.getPropertyForNode(node);\n  element = this.element;\n\n  type = propertyDesc.effectiveType || propertyDesc.type;\n\n  if (isSimpleType(type)) {\n    return this.valueHandler(propertyDesc, element);\n  }\n\n  if (propertyDesc.isReference) {\n    childHandler = this.referenceHandler(propertyDesc).handleNode(node);\n  } else {\n    childHandler = this.handler(type).handleNode(node);\n  }\n\n  var newElement = childHandler.element;\n\n  // child handles may decide to skip elements\n  // by not returning anything\n  if (newElement !== undefined) {\n\n    if (propertyDesc.isMany) {\n      element.get(propertyDesc.name).push(newElement);\n    } else {\n      element.set(propertyDesc.name, newElement);\n    }\n\n    if (propertyDesc.isReference) {\n      assign(newElement, {\n        element: element\n      });\n\n      this.context.addReference(newElement);\n    } else {\n      // establish child -> parent relationship\n      newElement.$parent = element;\n    }\n  }\n\n  return childHandler;\n};\n\n\nfunction GenericElementHandler(model, type, context) {\n  this.model = model;\n  this.context = context;\n}\n\nGenericElementHandler.prototype = Object.create(BaseElementHandler.prototype);\n\nGenericElementHandler.prototype.createElement = function(node) {\n\n  var name = node.name,\n      prefix = node.prefix,\n      uri = node.ns[prefix],\n      attributes = node.attributes;\n\n  return this.model.createAny(name, uri, attributes);\n};\n\nGenericElementHandler.prototype.handleChild = function(node) {\n\n  var handler = new GenericElementHandler(this.model, 'Element', this.context).handleNode(node),\n      element = this.element;\n\n  var newElement = handler.element,\n      children;\n\n  if (newElement !== undefined) {\n    children = element.$children = element.$children || [];\n    children.push(newElement);\n\n    // establish child -> parent relationship\n    newElement.$parent = element;\n  }\n\n  return handler;\n};\n\nGenericElementHandler.prototype.handleText = function(text) {\n  this.body = this.body || '' + text;\n};\n\nGenericElementHandler.prototype.handleEnd = function() {\n  if (this.body) {\n    this.element.$body = this.body;\n  }\n};\n\n/**\n * A reader for a meta-model\n *\n * @param {Object} options\n * @param {Model} options.model used to read xml files\n * @param {Boolean} options.lax whether to make parse errors warnings\n */\nfunction XMLReader(options) {\n\n  if (options instanceof Moddle) {\n    options = {\n      model: options\n    };\n  }\n\n  assign(this, { lax: false }, options);\n}\n\n\n/**\n * Parse the given XML into a moddle document tree.\n *\n * @param {String} xml\n * @param {ElementHandler|Object} options or rootHandler\n * @param  {Function} done\n */\nXMLReader.prototype.fromXML = function(xml, options, done) {\n\n  var rootHandler = options.rootHandler;\n\n  if (options instanceof ElementHandler) {\n    // root handler passed via (xml, { rootHandler: ElementHandler }, ...)\n    rootHandler = options;\n    options = {};\n  } else {\n    if (typeof options === 'string') {\n      // rootHandler passed via (xml, 'someString', ...)\n      rootHandler = this.handler(options);\n      options = {};\n    } else if (typeof rootHandler === 'string') {\n      // rootHandler passed via (xml, { rootHandler: 'someString' }, ...)\n      rootHandler = this.handler(rootHandler);\n    }\n  }\n\n  var model = this.model,\n      lax = this.lax;\n\n  var context = new Context(assign({}, options, { rootHandler: rootHandler })),\n      parser = new SaxParser(true, { xmlns: true, trim: true }),\n      stack = new Stack();\n\n  rootHandler.context = context;\n\n  // push root handler\n  stack.push(rootHandler);\n\n\n  function resolveReferences() {\n\n    var elementsById = context.elementsById;\n    var references = context.references;\n\n    var i, r;\n\n    for (i = 0; !!(r = references[i]); i++) {\n      var element = r.element;\n      var reference = elementsById[r.id];\n      var property = getModdleDescriptor(element).propertiesByName[r.property];\n\n      if (!reference) {\n        context.addWarning({\n          message: 'unresolved reference <' + r.id + '>',\n          element: r.element,\n          property: r.property,\n          value: r.id\n        });\n      }\n\n      if (property.isMany) {\n        var collection = element.get(property.name),\n            idx = collection.indexOf(r);\n\n        // we replace an existing place holder (idx != -1) or\n        // append to the collection instead\n        if (idx === -1) {\n          idx = collection.length;\n        }\n\n        if (!reference) {\n          // remove unresolvable reference\n          collection.splice(idx, 1);\n        } else {\n          // add or update reference in collection\n          collection[idx] = reference;\n        }\n      } else {\n        element.set(property.name, reference);\n      }\n    }\n  }\n\n  function handleClose(tagName) {\n    stack.pop().handleEnd();\n  }\n\n  function handleOpen(node) {\n    var handler = stack.peek();\n\n    normalizeNamespaces(node, model);\n\n    try {\n      stack.push(handler.handleNode(node));\n    } catch (e) {\n\n      var line = this.line,\n          column = this.column;\n\n      var message =\n        'unparsable content <' + node.name + '> detected/n/t' +\n          'line: ' + line + '/n/t' +\n          'column: ' + column + '/n/t' +\n          'nested error: ' + e.message;\n\n      if (lax) {\n        context.addWarning({\n          message: message,\n          error: e\n        });\n\n        console.warn('could not parse node');\n        console.warn(e);\n\n        stack.push(new NoopHandler());\n      } else {\n        console.error('could not parse document');\n        console.error(e);\n\n        throw error(message);\n      }\n    }\n  }\n\n  function handleText(text) {\n    stack.peek().handleText(text);\n  }\n\n  parser.onopentag = handleOpen;\n  parser.oncdata = parser.ontext = handleText;\n  parser.onclosetag = handleClose;\n  parser.onend = resolveReferences;\n\n  // deferred parse XML to make loading really ascnchronous\n  // this ensures the execution environment (node or browser)\n  // is kept responsive and that certain optimization strategies\n  // can kick in\n  defer(function() {\n    var error;\n\n    try {\n      parser.write(xml).close();\n    } catch (e) {\n      error = e;\n    }\n\n    done(error, error ? undefined : rootHandler.element, context);\n  });\n};\n\nXMLReader.prototype.handler = function(name) {\n  return new ElementHandler(this.model, name);\n};\n\nmodule.exports = XMLReader;\nmodule.exports.ElementHandler = ElementHandler;","'use strict';\n\nvar map = require(451),\n    forEach = require(450),\n    isString = require(516),\n    filter = require(448),\n    assign = require(518);\n\nvar Types = require(538),\n    parseNameNs = require(535).parseName,\n    common = require(525),\n    nameToAlias = common.nameToAlias,\n    serializeAsType = common.serializeAsType,\n    serializeAsProperty = common.serializeAsProperty;\n\nvar XML_PREAMBLE = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>/n',\n    ESCAPE_CHARS = /(<|>|'|\"|&|/n/r|/n)/g,\n    DEFAULT_NS_MAP = common.DEFAULT_NS_MAP,\n    XSI_TYPE = common.XSI_TYPE;\n\n\nfunction nsName(ns) {\n  if (isString(ns)) {\n    return ns;\n  } else {\n    return (ns.prefix ? ns.prefix + ':' : '') + ns.localName;\n  }\n}\n\nfunction getNsAttrs(namespaces) {\n\n  function isUsed(ns) {\n    return namespaces.used[ns.uri];\n  }\n\n  function toAttr(ns) {\n    var name = 'xmlns' + (ns.prefix ? ':' + ns.prefix : '');\n    return { name: name, value: ns.uri };\n  }\n\n  var allNs = [].concat(namespaces.wellknown, namespaces.custom);\n\n  return map(filter(allNs, isUsed), toAttr);\n}\n\nfunction getElementNs(ns, descriptor) {\n  if (descriptor.isGeneric) {\n    return descriptor.name;\n  } else {\n    return assign({ localName: nameToAlias(descriptor.ns.localName, descriptor.$pkg) }, ns);\n  }\n}\n\nfunction getPropertyNs(ns, descriptor) {\n  return assign({ localName: descriptor.ns.localName }, ns);\n}\n\nfunction getSerializableProperties(element) {\n  var descriptor = element.$descriptor;\n\n  return filter(descriptor.properties, function(p) {\n    var name = p.name;\n\n    if (p.isVirtual) {\n      return false;\n    }\n\n    // do not serialize defaults\n    if (!element.hasOwnProperty(name)) {\n      return false;\n    }\n\n    var value = element[name];\n\n    // do not serialize default equals\n    if (value === p.default) {\n      return false;\n    }\n\n    // do not serialize null properties\n    if (value === null) {\n      return false;\n    }\n\n    return p.isMany ? value.length : true;\n  });\n}\n\nvar ESCAPE_MAP = {\n  '/n': '10',\n  '/n/r': '10',\n  '\"': '34',\n  '/'': '39',\n  '<': '60',\n  '>': '62',\n  '&': '38'\n};\n\n/**\n * Escape a string attribute to not contain any bad values (line breaks, '\"', ...)\n *\n * @param {String} str the string to escape\n * @return {String} the escaped string\n */\nfunction escapeAttr(str) {\n\n  // ensure we are handling strings here\n  str = isString(str) ? str : '' + str;\n\n  return str.replace(ESCAPE_CHARS, function(str) {\n    return '&#' + ESCAPE_MAP[str] + ';';\n  });\n}\n\nfunction filterAttributes(props) {\n  return filter(props, function(p) { return p.isAttr; });\n}\n\nfunction filterContained(props) {\n  return filter(props, function(p) { return !p.isAttr; });\n}\n\n\nfunction ReferenceSerializer(parent, ns) {\n  this.ns = ns;\n}\n\nReferenceSerializer.prototype.build = function(element) {\n  this.element = element;\n  return this;\n};\n\nReferenceSerializer.prototype.serializeTo = function(writer) {\n  writer\n    .appendIndent()\n    .append('<' + nsName(this.ns) + '>' + this.element.id + '</' + nsName(this.ns) + '>')\n    .appendNewLine();\n};\n\nfunction BodySerializer() {}\n\nBodySerializer.prototype.serializeValue = BodySerializer.prototype.serializeTo = function(writer) {\n  var escape = this.escape;\n\n  if (escape) {\n    writer.append('<![CDATA[');\n  }\n\n  writer.append(this.value);\n\n  if (escape) {\n    writer.append(']]>');\n  }\n};\n\nBodySerializer.prototype.build = function(prop, value) {\n  this.value = value;\n\n  if (prop.type === 'String' && value.search(ESCAPE_CHARS) !== -1) {\n    this.escape = true;\n  }\n\n  return this;\n};\n\nfunction ValueSerializer(ns) {\n  this.ns = ns;\n}\n\nValueSerializer.prototype = new BodySerializer();\n\nValueSerializer.prototype.serializeTo = function(writer) {\n\n  writer\n    .appendIndent()\n    .append('<' + nsName(this.ns) + '>');\n\n  this.serializeValue(writer);\n\n  writer\n    .append( '</' + nsName(this.ns) + '>')\n    .appendNewLine();\n};\n\nfunction ElementSerializer(parent, ns) {\n  this.body = [];\n  this.attrs = [];\n\n  this.parent = parent;\n  this.ns = ns;\n}\n\nElementSerializer.prototype.build = function(element) {\n  this.element = element;\n\n  var otherAttrs = this.parseNsAttributes(element);\n\n  if (!this.ns) {\n    this.ns = this.nsTagName(element.$descriptor);\n  }\n\n  if (element.$descriptor.isGeneric) {\n    this.parseGeneric(element);\n  } else {\n    var properties = getSerializableProperties(element);\n\n    this.parseAttributes(filterAttributes(properties));\n    this.parseContainments(filterContained(properties));\n\n    this.parseGenericAttributes(element, otherAttrs);\n  }\n\n  return this;\n};\n\nElementSerializer.prototype.nsTagName = function(descriptor) {\n  var effectiveNs = this.logNamespaceUsed(descriptor.ns);\n  return getElementNs(effectiveNs, descriptor);\n};\n\nElementSerializer.prototype.nsPropertyTagName = function(descriptor) {\n  var effectiveNs = this.logNamespaceUsed(descriptor.ns);\n  return getPropertyNs(effectiveNs, descriptor);\n};\n\nElementSerializer.prototype.isLocalNs = function(ns) {\n  return ns.uri === this.ns.uri;\n};\n\n/**\n * Get the actual ns attribute name for the given element.\n *\n * @param {Object} element\n * @param {Boolean} [inherited=false]\n *\n * @return {Object} nsName\n */\nElementSerializer.prototype.nsAttributeName = function(element) {\n\n  var ns;\n\n  if (isString(element)) {\n    ns = parseNameNs(element);\n  } else {\n    ns = element.ns;\n  }\n\n  // return just local name for inherited attributes\n  if (element.inherited) {\n    return { localName: ns.localName };\n  }\n\n  // parse + log effective ns\n  var effectiveNs = this.logNamespaceUsed(ns);\n\n  // strip prefix if same namespace like parent\n  if (this.isLocalNs(effectiveNs)) {\n    return { localName: ns.localName };\n  } else {\n    return assign({ localName: ns.localName }, effectiveNs);\n  }\n};\n\nElementSerializer.prototype.parseGeneric = function(element) {\n\n  var self = this,\n      body = this.body,\n      attrs = this.attrs;\n\n  forEach(element, function(val, key) {\n\n    if (key === '$body') {\n      body.push(new BodySerializer().build({ type: 'String' }, val));\n    } else\n    if (key === '$children') {\n      forEach(val, function(child) {\n        body.push(new ElementSerializer(self).build(child));\n      });\n    } else\n    if (key.indexOf('$') !== 0) {\n      attrs.push({ name: key, value: escapeAttr(val) });\n    }\n  });\n};\n\n/**\n * Parse namespaces and return a list of left over generic attributes\n *\n * @param  {Object} element\n * @return {Array<Object>}\n */\nElementSerializer.prototype.parseNsAttributes = function(element) {\n  var self = this;\n\n  var genericAttrs = element.$attrs;\n\n  var model = element.$model;\n\n  var attributes = [];\n\n  // parse namespace attributes first\n  // and log them. push non namespace attributes to a list\n  // and process them later\n  forEach(genericAttrs, function(value, name) {\n    var nameNs = parseNameNs(name);\n\n    var ns;\n\n    // parse xmlns:foo=\"http://foo.bar\"\n    if (nameNs.prefix === 'xmlns') {\n      ns = { prefix: nameNs.localName, uri: value };\n    }\n\n    // parse xmlns=\"http://foo.bar\"\n    if (!nameNs.prefix && nameNs.localName === 'xmlns') {\n      ns = { uri: value };\n    }\n\n    if (ns) {\n      if (model.getPackage(value)) {\n        // register well known namespace\n        self.logNamespace(ns, true);\n      } else {\n        // log custom namespace directly as used\n        self.logNamespaceUsed(ns);\n      }\n    } else {\n      attributes.push({ name: name, value: value });\n    }\n  });\n\n  return attributes;\n};\n\nElementSerializer.prototype.parseGenericAttributes = function(element, attributes) {\n\n  var self = this;\n\n  forEach(attributes, function(attr) {\n\n    // do not serialize xsi:type attribute\n    // it is set manually based on the actual implementation type\n    if (attr.name === XSI_TYPE) {\n      return;\n    }\n\n    try {\n      self.addAttribute(self.nsAttributeName(attr.name), attr.value);\n    } catch (e) {\n      console.warn(\n        'missing namespace information for ',\n        attr.name, '=', attr.value, 'on', element,\n        e);\n    }\n  });\n};\n\nElementSerializer.prototype.parseContainments = function(properties) {\n\n  var self = this,\n      body = this.body,\n      element = this.element;\n\n  forEach(properties, function(p) {\n    var value = element.get(p.name),\n        isReference = p.isReference,\n        isMany = p.isMany;\n\n    var ns = self.nsPropertyTagName(p);\n\n    if (!isMany) {\n      value = [ value ];\n    }\n\n    if (p.isBody) {\n      body.push(new BodySerializer().build(p, value[0]));\n    } else\n    if (Types.isSimple(p.type)) {\n      forEach(value, function(v) {\n        body.push(new ValueSerializer(ns).build(p, v));\n      });\n    } else\n    if (isReference) {\n      forEach(value, function(v) {\n        body.push(new ReferenceSerializer(self, ns).build(v));\n      });\n    } else {\n      // allow serialization via type\n      // rather than element name\n      var asType = serializeAsType(p),\n          asProperty = serializeAsProperty(p);\n\n      forEach(value, function(v) {\n        var serializer;\n\n        if (asType) {\n          serializer = new TypeSerializer(self, ns);\n        } else\n        if (asProperty) {\n          serializer = new ElementSerializer(self, ns);\n        } else {\n          serializer = new ElementSerializer(self);\n        }\n\n        body.push(serializer.build(v));\n      });\n    }\n  });\n};\n\nElementSerializer.prototype.getNamespaces = function() {\n\n  var namespaces = this.namespaces,\n      parent = this.parent;\n\n  if (!namespaces) {\n    namespaces = this.namespaces = parent ? parent.getNamespaces() : {\n      prefixMap: {},\n      uriMap: {},\n      used: {},\n      wellknown: [],\n      custom: []\n    };\n  }\n\n  return namespaces;\n};\n\nElementSerializer.prototype.logNamespace = function(ns, wellknown) {\n  var namespaces = this.getNamespaces();\n\n  var nsUri = ns.uri;\n\n  var existing = namespaces.uriMap[nsUri];\n\n  if (!existing) {\n    namespaces.uriMap[nsUri] = ns;\n\n    if (wellknown) {\n      namespaces.wellknown.push(ns);\n    } else {\n      namespaces.custom.push(ns);\n    }\n  }\n\n  namespaces.prefixMap[ns.prefix] = nsUri;\n\n  return ns;\n};\n\nElementSerializer.prototype.logNamespaceUsed = function(ns) {\n  var element = this.element,\n      model = element.$model,\n      namespaces = this.getNamespaces();\n\n  // ns may be\n  //\n  //   * prefix only\n  //   * prefix:uri\n\n  var prefix = ns.prefix;\n\n  var wellknownUri = DEFAULT_NS_MAP[prefix] || model && (model.getPackage(prefix) || {}).uri;\n\n  var uri = ns.uri || namespaces.prefixMap[prefix] || wellknownUri;\n\n  if (!uri) {\n    throw new Error('no namespace uri given for prefix <' + ns.prefix + '>');\n  }\n\n  ns = namespaces.uriMap[uri];\n\n  if (!ns) {\n    ns = this.logNamespace({ prefix: prefix, uri: uri }, wellknownUri);\n  }\n\n  if (!namespaces.used[ns.uri]) {\n    namespaces.used[ns.uri] = ns;\n  }\n\n  return ns;\n};\n\nElementSerializer.prototype.parseAttributes = function(properties) {\n  var self = this,\n      element = this.element;\n\n  forEach(properties, function(p) {\n\n    var value = element.get(p.name);\n\n    if (p.isReference) {\n\n      if (!p.isMany) {\n        value = value.id;\n      }\n      else {\n        var values = [];\n        forEach(value, function(v) {\n          values.push(v.id);\n        });\n        // IDREFS is a whitespace-separated list of references.\n        value = values.join(' ');\n      }\n\n    }\n\n    self.addAttribute(self.nsAttributeName(p), value);\n  });\n};\n\nElementSerializer.prototype.addAttribute = function(name, value) {\n  var attrs = this.attrs;\n\n  if (isString(value)) {\n    value = escapeAttr(value);\n  }\n\n  attrs.push({ name: name, value: value });\n};\n\nElementSerializer.prototype.serializeAttributes = function(writer) {\n  var attrs = this.attrs,\n      root = !this.parent;\n\n  if (root) {\n    attrs = getNsAttrs(this.namespaces).concat(attrs);\n  }\n\n  forEach(attrs, function(a) {\n    writer\n      .append(' ')\n      .append(nsName(a.name)).append('=\"').append(a.value).append('\"');\n  });\n};\n\nElementSerializer.prototype.serializeTo = function(writer) {\n  var hasBody = this.body.length,\n      indent = !(this.body.length === 1 && this.body[0] instanceof BodySerializer);\n\n  writer\n    .appendIndent()\n    .append('<' + nsName(this.ns));\n\n  this.serializeAttributes(writer);\n\n  writer.append(hasBody ? '>' : ' />');\n\n  if (hasBody) {\n\n    if (indent) {\n      writer\n        .appendNewLine()\n        .indent();\n    }\n\n    forEach(this.body, function(b) {\n      b.serializeTo(writer);\n    });\n\n    if (indent) {\n      writer\n        .unindent()\n        .appendIndent();\n    }\n\n    writer.append('</' + nsName(this.ns) + '>');\n  }\n\n  writer.appendNewLine();\n};\n\n/**\n * A serializer for types that handles serialization of data types\n */\nfunction TypeSerializer(parent, ns) {\n  ElementSerializer.call(this, parent, ns);\n}\n\nTypeSerializer.prototype = new ElementSerializer();\n\nTypeSerializer.prototype.build = function(element) {\n  var descriptor = element.$descriptor;\n\n  this.element = element;\n\n  this.typeNs = this.nsTagName(descriptor);\n\n  // add xsi:type attribute to represent the elements\n  // actual type\n\n  var typeNs = this.typeNs,\n      pkg = element.$model.getPackage(typeNs.uri),\n      typePrefix = (pkg.xml && pkg.xml.typePrefix) || '';\n\n  this.addAttribute(this.nsAttributeName(XSI_TYPE),\n    (typeNs.prefix ? typeNs.prefix + ':' : '') +\n    typePrefix + descriptor.ns.localName);\n\n  // do the usual stuff\n  return ElementSerializer.prototype.build.call(this, element);\n};\n\nTypeSerializer.prototype.isLocalNs = function(ns) {\n  return ns.uri === this.typeNs.uri;\n};\n\nfunction SavingWriter() {\n  this.value = '';\n\n  this.write = function(str) {\n    this.value += str;\n  };\n}\n\nfunction FormatingWriter(out, format) {\n\n  var indent = [''];\n\n  this.append = function(str) {\n    out.write(str);\n\n    return this;\n  };\n\n  this.appendNewLine = function() {\n    if (format) {\n      out.write('/n');\n    }\n\n    return this;\n  };\n\n  this.appendIndent = function() {\n    if (format) {\n      out.write(indent.join('  '));\n    }\n\n    return this;\n  };\n\n  this.indent = function() {\n    indent.push('');\n    return this;\n  };\n\n  this.unindent = function() {\n    indent.pop();\n    return this;\n  };\n}\n\n/**\n * A writer for meta-model backed document trees\n *\n * @param {Object} options output options to pass into the writer\n */\nfunction XMLWriter(options) {\n\n  options = assign({ format: false, preamble: true }, options || {});\n\n  function toXML(tree, writer) {\n    var internalWriter = writer || new SavingWriter();\n    var formatingWriter = new FormatingWriter(internalWriter, options.format);\n\n    if (options.preamble) {\n      formatingWriter.append(XML_PREAMBLE);\n    }\n\n    new ElementSerializer().build(tree).serializeTo(formatingWriter);\n\n    if (!writer) {\n      return internalWriter.value;\n    }\n  }\n\n  return {\n    toXML: toXML\n  };\n}\n\nmodule.exports = XMLWriter;\n","// wrapper for non-node envs\n;(function (sax) {\n\nsax.parser = function (strict, opt) { return new SAXParser(strict, opt) }\nsax.SAXParser = SAXParser\nsax.SAXStream = SAXStream\nsax.createStream = createStream\n\n// When we pass the MAX_BUFFER_LENGTH position, start checking for buffer overruns.\n// When we check, schedule the next check for MAX_BUFFER_LENGTH - (max(buffer lengths)),\n// since that's the earliest that a buffer overrun could occur.  This way, checks are\n// as rare as required, but as often as necessary to ensure never crossing this bound.\n// Furthermore, buffers are only tested at most once per write(), so passing a very\n// large string into write() might have undesirable effects, but this is manageable by\n// the caller, so it is assumed to be safe.  Thus, a call to write() may, in the extreme\n// edge case, result in creating at most one complete copy of the string passed in.\n// Set to Infinity to have unlimited buffers.\nsax.MAX_BUFFER_LENGTH = 64 * 1024\n\nvar buffers = [\n  \"comment\", \"sgmlDecl\", \"textNode\", \"tagName\", \"doctype\",\n  \"procInstName\", \"procInstBody\", \"entity\", \"attribName\",\n  \"attribValue\", \"cdata\", \"script\"\n]\n\nsax.EVENTS = // for discoverability.\n  [ \"text\"\n  , \"processinginstruction\"\n  , \"sgmldeclaration\"\n  , \"doctype\"\n  , \"comment\"\n  , \"attribute\"\n  , \"opentag\"\n  , \"closetag\"\n  , \"opencdata\"\n  , \"cdata\"\n  , \"closecdata\"\n  , \"error\"\n  , \"end\"\n  , \"ready\"\n  , \"script\"\n  , \"opennamespace\"\n  , \"closenamespace\"\n  ]\n\nfunction SAXParser (strict, opt) {\n  if (!(this instanceof SAXParser)) return new SAXParser(strict, opt)\n\n  var parser = this\n  clearBuffers(parser)\n  parser.q = parser.c = \"\"\n  parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH\n  parser.opt = opt || {}\n  parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags\n  parser.looseCase = parser.opt.lowercase ? \"toLowerCase\" : \"toUpperCase\"\n  parser.tags = []\n  parser.closed = parser.closedRoot = parser.sawRoot = false\n  parser.tag = parser.error = null\n  parser.strict = !!strict\n  parser.noscript = !!(strict || parser.opt.noscript)\n  parser.state = S.BEGIN\n  parser.ENTITIES = Object.create(sax.ENTITIES)\n  parser.attribList = []\n\n  // namespaces form a prototype chain.\n  // it always points at the current tag,\n  // which protos to its parent tag.\n  if (parser.opt.xmlns) parser.ns = Object.create(rootNS)\n\n  // mostly just for error reporting\n  parser.trackPosition = parser.opt.position !== false\n  if (parser.trackPosition) {\n    parser.position = parser.line = parser.column = 0\n  }\n  emit(parser, \"onready\")\n}\n\nif (!Object.create) Object.create = function (o) {\n  function f () { this.__proto__ = o }\n  f.prototype = o\n  return new f\n}\n\nif (!Object.getPrototypeOf) Object.getPrototypeOf = function (o) {\n  return o.__proto__\n}\n\nif (!Object.keys) Object.keys = function (o) {\n  var a = []\n  for (var i in o) if (o.hasOwnProperty(i)) a.push(i)\n  return a\n}\n\nfunction checkBufferLength (parser) {\n  var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10)\n    , maxActual = 0\n  for (var i = 0, l = buffers.length; i < l; i ++) {\n    var len = parser[buffers[i]].length\n    if (len > maxAllowed) {\n      // Text/cdata nodes can get big, and since they're buffered,\n      // we can get here under normal conditions.\n      // Avoid issues by emitting the text node now,\n      // so at least it won't get any bigger.\n      switch (buffers[i]) {\n        case \"textNode\":\n          closeText(parser)\n        break\n\n        case \"cdata\":\n          emitNode(parser, \"oncdata\", parser.cdata)\n          parser.cdata = \"\"\n        break\n\n        case \"script\":\n          emitNode(parser, \"onscript\", parser.script)\n          parser.script = \"\"\n        break\n\n        default:\n          error(parser, \"Max buffer length exceeded: \"+buffers[i])\n      }\n    }\n    maxActual = Math.max(maxActual, len)\n  }\n  // schedule the next check for the earliest possible buffer overrun.\n  parser.bufferCheckPosition = (sax.MAX_BUFFER_LENGTH - maxActual)\n                             + parser.position\n}\n\nfunction clearBuffers (parser) {\n  for (var i = 0, l = buffers.length; i < l; i ++) {\n    parser[buffers[i]] = \"\"\n  }\n}\n\nfunction flushBuffers (parser) {\n  closeText(parser)\n  if (parser.cdata !== \"\") {\n    emitNode(parser, \"oncdata\", parser.cdata)\n    parser.cdata = \"\"\n  }\n  if (parser.script !== \"\") {\n    emitNode(parser, \"onscript\", parser.script)\n    parser.script = \"\"\n  }\n}\n\nSAXParser.prototype =\n  { end: function () { end(this) }\n  , write: write\n  , resume: function () { this.error = null; return this }\n  , close: function () { return this.write(null) }\n  , flush: function () { flushBuffers(this) }\n  }\n\ntry {\n  var Stream = require(\"stream\").Stream\n} catch (ex) {\n  var Stream = function () {}\n}\n\n\nvar streamWraps = sax.EVENTS.filter(function (ev) {\n  return ev !== \"error\" && ev !== \"end\"\n})\n\nfunction createStream (strict, opt) {\n  return new SAXStream(strict, opt)\n}\n\nfunction SAXStream (strict, opt) {\n  if (!(this instanceof SAXStream)) return new SAXStream(strict, opt)\n\n  Stream.apply(this)\n\n  this._parser = new SAXParser(strict, opt)\n  this.writable = true\n  this.readable = true\n\n\n  var me = this\n\n  this._parser.onend = function () {\n    me.emit(\"end\")\n  }\n\n  this._parser.onerror = function (er) {\n    me.emit(\"error\", er)\n\n    // if didn't throw, then means error was handled.\n    // go ahead and clear error, so we can write again.\n    me._parser.error = null\n  }\n\n  this._decoder = null;\n\n  streamWraps.forEach(function (ev) {\n    Object.defineProperty(me, \"on\" + ev, {\n      get: function () { return me._parser[\"on\" + ev] },\n      set: function (h) {\n        if (!h) {\n          me.removeAllListeners(ev)\n          return me._parser[\"on\"+ev] = h\n        }\n        me.on(ev, h)\n      },\n      enumerable: true,\n      configurable: false\n    })\n  })\n}\n\nSAXStream.prototype = Object.create(Stream.prototype,\n  { constructor: { value: SAXStream } })\n\nSAXStream.prototype.write = function (data) {\n  if (typeof Buffer === 'function' &&\n      typeof Buffer.isBuffer === 'function' &&\n      Buffer.isBuffer(data)) {\n    if (!this._decoder) {\n      var SD = require('string_decoder').StringDecoder\n      this._decoder = new SD('utf8')\n    }\n    data = this._decoder.write(data);\n  }\n\n  this._parser.write(data.toString())\n  this.emit(\"data\", data)\n  return true\n}\n\nSAXStream.prototype.end = function (chunk) {\n  if (chunk && chunk.length) this.write(chunk)\n  this._parser.end()\n  return true\n}\n\nSAXStream.prototype.on = function (ev, handler) {\n  var me = this\n  if (!me._parser[\"on\"+ev] && streamWraps.indexOf(ev) !== -1) {\n    me._parser[\"on\"+ev] = function () {\n      var args = arguments.length === 1 ? [arguments[0]]\n               : Array.apply(null, arguments)\n      args.splice(0, 0, ev)\n      me.emit.apply(me, args)\n    }\n  }\n\n  return Stream.prototype.on.call(me, ev, handler)\n}\n\n\n\n// character classes and tokens\nvar whitespace = \"/r/n/t \"\n  // this really needs to be replaced with character classes.\n  // XML allows all manner of ridiculous numbers and digits.\n  , number = \"0124356789\"\n  , letter = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  // (Letter | \"_\" | \":\")\n  , quote = \"'/\"\"\n  , entity = number+letter+\"#\"\n  , attribEnd = whitespace + \">\"\n  , CDATA = \"[CDATA[\"\n  , DOCTYPE = \"DOCTYPE\"\n  , XML_NAMESPACE = \"http://www.w3.org/XML/1998/namespace\"\n  , XMLNS_NAMESPACE = \"http://www.w3.org/2000/xmlns/\"\n  , rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE }\n\n// turn all the string character sets into character class objects.\nwhitespace = charClass(whitespace)\nnumber = charClass(number)\nletter = charClass(letter)\n\n// http://www.w3.org/TR/REC-xml/#NT-NameStartChar\n// This implementation works on strings, a single character at a time\n// as such, it cannot ever support astral-plane characters (10000-EFFFF)\n// without a significant breaking change to either this  parser, or the\n// JavaScript language.  Implementation of an emoji-capable xml parser\n// is left as an exercise for the reader.\nvar nameStart = /[:_A-Za-z/u00C0-/u00D6/u00D8-/u00F6/u00F8-/u02FF/u0370-/u037D/u037F-/u1FFF/u200C-/u200D/u2070-/u218F/u2C00-/u2FEF/u3001-/uD7FF/uF900-/uFDCF/uFDF0-/uFFFD]/\n\nvar nameBody = /[:_A-Za-z/u00C0-/u00D6/u00D8-/u00F6/u00F8-/u02FF/u0370-/u037D/u037F-/u1FFF/u200C-/u200D/u2070-/u218F/u2C00-/u2FEF/u3001-/uD7FF/uF900-/uFDCF/uFDF0-/uFFFD/u00B7/u0300-/u036F/u203F-/u2040/./d-]/\n\nquote = charClass(quote)\nentity = charClass(entity)\nattribEnd = charClass(attribEnd)\n\nfunction charClass (str) {\n  return str.split(\"\").reduce(function (s, c) {\n    s[c] = true\n    return s\n  }, {})\n}\n\nfunction isRegExp (c) {\n  return Object.prototype.toString.call(c) === '[object RegExp]'\n}\n\nfunction is (charclass, c) {\n  return isRegExp(charclass) ? !!c.match(charclass) : charclass[c]\n}\n\nfunction not (charclass, c) {\n  return !is(charclass, c)\n}\n\nvar S = 0\nsax.STATE =\n{ BEGIN                     : S++\n, TEXT                      : S++ // general stuff\n, TEXT_ENTITY               : S++ // &amp and such.\n, OPEN_WAKA                 : S++ // <\n, SGML_DECL                 : S++ // <!BLARG\n, SGML_DECL_QUOTED          : S++ // <!BLARG foo \"bar\n, DOCTYPE                   : S++ // <!DOCTYPE\n, DOCTYPE_QUOTED            : S++ // <!DOCTYPE \"//blah\n, DOCTYPE_DTD               : S++ // <!DOCTYPE \"//blah\" [ ...\n, DOCTYPE_DTD_QUOTED        : S++ // <!DOCTYPE \"//blah\" [ \"foo\n, COMMENT_STARTING          : S++ // <!-\n, COMMENT                   : S++ // <!--\n, COMMENT_ENDING            : S++ // <!-- blah -\n, COMMENT_ENDED             : S++ // <!-- blah --\n, CDATA                     : S++ // <![CDATA[ something\n, CDATA_ENDING              : S++ // ]\n, CDATA_ENDING_2            : S++ // ]]\n, PROC_INST                 : S++ // <?hi\n, PROC_INST_BODY            : S++ // <?hi there\n, PROC_INST_ENDING          : S++ // <?hi \"there\" ?\n, OPEN_TAG                  : S++ // <strong\n, OPEN_TAG_SLASH            : S++ // <strong /\n, ATTRIB                    : S++ // <a\n, ATTRIB_NAME               : S++ // <a foo\n, ATTRIB_NAME_SAW_WHITE     : S++ // <a foo _\n, ATTRIB_VALUE              : S++ // <a foo=\n, ATTRIB_VALUE_QUOTED       : S++ // <a foo=\"bar\n, ATTRIB_VALUE_CLOSED       : S++ // <a foo=\"bar\"\n, ATTRIB_VALUE_UNQUOTED     : S++ // <a foo=bar\n, ATTRIB_VALUE_ENTITY_Q     : S++ // <foo bar=\"&quot;\"\n, ATTRIB_VALUE_ENTITY_U     : S++ // <foo bar=&quot;\n, CLOSE_TAG                 : S++ // </a\n, CLOSE_TAG_SAW_WHITE       : S++ // </a   >\n, SCRIPT                    : S++ // <script> ...\n, SCRIPT_ENDING             : S++ // <script> ... <\n}\n\nsax.ENTITIES =\n{ \"amp\" : \"&\"\n, \"gt\" : \">\"\n, \"lt\" : \"<\"\n, \"quot\" : \"/\"\"\n, \"apos\" : \"'\"\n, \"AElig\" : 198\n, \"Aacute\" : 193\n, \"Acirc\" : 194\n, \"Agrave\" : 192\n, \"Aring\" : 197\n, \"Atilde\" : 195\n, \"Auml\" : 196\n, \"Ccedil\" : 199\n, \"ETH\" : 208\n, \"Eacute\" : 201\n, \"Ecirc\" : 202\n, \"Egrave\" : 200\n, \"Euml\" : 203\n, \"Iacute\" : 205\n, \"Icirc\" : 206\n, \"Igrave\" : 204\n, \"Iuml\" : 207\n, \"Ntilde\" : 209\n, \"Oacute\" : 211\n, \"Ocirc\" : 212\n, \"Ograve\" : 210\n, \"Oslash\" : 216\n, \"Otilde\" : 213\n, \"Ouml\" : 214\n, \"THORN\" : 222\n, \"Uacute\" : 218\n, \"Ucirc\" : 219\n, \"Ugrave\" : 217\n, \"Uuml\" : 220\n, \"Yacute\" : 221\n, \"aacute\" : 225\n, \"acirc\" : 226\n, \"aelig\" : 230\n, \"agrave\" : 224\n, \"aring\" : 229\n, \"atilde\" : 227\n, \"auml\" : 228\n, \"ccedil\" : 231\n, \"eacute\" : 233\n, \"ecirc\" : 234\n, \"egrave\" : 232\n, \"eth\" : 240\n, \"euml\" : 235\n, \"iacute\" : 237\n, \"icirc\" : 238\n, \"igrave\" : 236\n, \"iuml\" : 239\n, \"ntilde\" : 241\n, \"oacute\" : 243\n, \"ocirc\" : 244\n, \"ograve\" : 242\n, \"oslash\" : 248\n, \"otilde\" : 245\n, \"ouml\" : 246\n, \"szlig\" : 223\n, \"thorn\" : 254\n, \"uacute\" : 250\n, \"ucirc\" : 251\n, \"ugrave\" : 249\n, \"uuml\" : 252\n, \"yacute\" : 253\n, \"yuml\" : 255\n, \"copy\" : 169\n, \"reg\" : 174\n, \"nbsp\" : 160\n, \"iexcl\" : 161\n, \"cent\" : 162\n, \"pound\" : 163\n, \"curren\" : 164\n, \"yen\" : 165\n, \"brvbar\" : 166\n, \"sect\" : 167\n, \"uml\" : 168\n, \"ordf\" : 170\n, \"laquo\" : 171\n, \"not\" : 172\n, \"shy\" : 173\n, \"macr\" : 175\n, \"deg\" : 176\n, \"plusmn\" : 177\n, \"sup1\" : 185\n, \"sup2\" : 178\n, \"sup3\" : 179\n, \"acute\" : 180\n, \"micro\" : 181\n, \"para\" : 182\n, \"middot\" : 183\n, \"cedil\" : 184\n, \"ordm\" : 186\n, \"raquo\" : 187\n, \"frac14\" : 188\n, \"frac12\" : 189\n, \"frac34\" : 190\n, \"iquest\" : 191\n, \"times\" : 215\n, \"divide\" : 247\n, \"OElig\" : 338\n, \"oelig\" : 339\n, \"Scaron\" : 352\n, \"scaron\" : 353\n, \"Yuml\" : 376\n, \"fnof\" : 402\n, \"circ\" : 710\n, \"tilde\" : 732\n, \"Alpha\" : 913\n, \"Beta\" : 914\n, \"Gamma\" : 915\n, \"Delta\" : 916\n, \"Epsilon\" : 917\n, \"Zeta\" : 918\n, \"Eta\" : 919\n, \"Theta\" : 920\n, \"Iota\" : 921\n, \"Kappa\" : 922\n, \"Lambda\" : 923\n, \"Mu\" : 924\n, \"Nu\" : 925\n, \"Xi\" : 926\n, \"Omicron\" : 927\n, \"Pi\" : 928\n, \"Rho\" : 929\n, \"Sigma\" : 931\n, \"Tau\" : 932\n, \"Upsilon\" : 933\n, \"Phi\" : 934\n, \"Chi\" : 935\n, \"Psi\" : 936\n, \"Omega\" : 937\n, \"alpha\" : 945\n, \"beta\" : 946\n, \"gamma\" : 947\n, \"delta\" : 948\n, \"epsilon\" : 949\n, \"zeta\" : 950\n, \"eta\" : 951\n, \"theta\" : 952\n, \"iota\" : 953\n, \"kappa\" : 954\n, \"lambda\" : 955\n, \"mu\" : 956\n, \"nu\" : 957\n, \"xi\" : 958\n, \"omicron\" : 959\n, \"pi\" : 960\n, \"rho\" : 961\n, \"sigmaf\" : 962\n, \"sigma\" : 963\n, \"tau\" : 964\n, \"upsilon\" : 965\n, \"phi\" : 966\n, \"chi\" : 967\n, \"psi\" : 968\n, \"omega\" : 969\n, \"thetasym\" : 977\n, \"upsih\" : 978\n, \"piv\" : 982\n, \"ensp\" : 8194\n, \"emsp\" : 8195\n, \"thinsp\" : 8201\n, \"zwnj\" : 8204\n, \"zwj\" : 8205\n, \"lrm\" : 8206\n, \"rlm\" : 8207\n, \"ndash\" : 8211\n, \"mdash\" : 8212\n, \"lsquo\" : 8216\n, \"rsquo\" : 8217\n, \"sbquo\" : 8218\n, \"ldquo\" : 8220\n, \"rdquo\" : 8221\n, \"bdquo\" : 8222\n, \"dagger\" : 8224\n, \"Dagger\" : 8225\n, \"bull\" : 8226\n, \"hellip\" : 8230\n, \"permil\" : 8240\n, \"prime\" : 8242\n, \"Prime\" : 8243\n, \"lsaquo\" : 8249\n, \"rsaquo\" : 8250\n, \"oline\" : 8254\n, \"frasl\" : 8260\n, \"euro\" : 8364\n, \"image\" : 8465\n, \"weierp\" : 8472\n, \"real\" : 8476\n, \"trade\" : 8482\n, \"alefsym\" : 8501\n, \"larr\" : 8592\n, \"uarr\" : 8593\n, \"rarr\" : 8594\n, \"darr\" : 8595\n, \"harr\" : 8596\n, \"crarr\" : 8629\n, \"lArr\" : 8656\n, \"uArr\" : 8657\n, \"rArr\" : 8658\n, \"dArr\" : 8659\n, \"hArr\" : 8660\n, \"forall\" : 8704\n, \"part\" : 8706\n, \"exist\" : 8707\n, \"empty\" : 8709\n, \"nabla\" : 8711\n, \"isin\" : 8712\n, \"notin\" : 8713\n, \"ni\" : 8715\n, \"prod\" : 8719\n, \"sum\" : 8721\n, \"minus\" : 8722\n, \"lowast\" : 8727\n, \"radic\" : 8730\n, \"prop\" : 8733\n, \"infin\" : 8734\n, \"ang\" : 8736\n, \"and\" : 8743\n, \"or\" : 8744\n, \"cap\" : 8745\n, \"cup\" : 8746\n, \"int\" : 8747\n, \"there4\" : 8756\n, \"sim\" : 8764\n, \"cong\" : 8773\n, \"asymp\" : 8776\n, \"ne\" : 8800\n, \"equiv\" : 8801\n, \"le\" : 8804\n, \"ge\" : 8805\n, \"sub\" : 8834\n, \"sup\" : 8835\n, \"nsub\" : 8836\n, \"sube\" : 8838\n, \"supe\" : 8839\n, \"oplus\" : 8853\n, \"otimes\" : 8855\n, \"perp\" : 8869\n, \"sdot\" : 8901\n, \"lceil\" : 8968\n, \"rceil\" : 8969\n, \"lfloor\" : 8970\n, \"rfloor\" : 8971\n, \"lang\" : 9001\n, \"rang\" : 9002\n, \"loz\" : 9674\n, \"spades\" : 9824\n, \"clubs\" : 9827\n, \"hearts\" : 9829\n, \"diams\" : 9830\n}\n\nObject.keys(sax.ENTITIES).forEach(function (key) {\n    var e = sax.ENTITIES[key]\n    var s = typeof e === 'number' ? String.fromCharCode(e) : e\n    sax.ENTITIES[key] = s\n})\n\nfor (var S in sax.STATE) sax.STATE[sax.STATE[S]] = S\n\n// shorthand\nS = sax.STATE\n\nfunction emit (parser, event, data) {\n  parser[event] && parser[event](data)\n}\n\nfunction emitNode (parser, nodeType, data) {\n  if (parser.textNode) closeText(parser)\n  emit(parser, nodeType, data)\n}\n\nfunction closeText (parser) {\n  parser.textNode = textopts(parser.opt, parser.textNode)\n  if (parser.textNode) emit(parser, \"ontext\", parser.textNode)\n  parser.textNode = \"\"\n}\n\nfunction textopts (opt, text) {\n  if (opt.trim) text = text.trim()\n  if (opt.normalize) text = text.replace(//s+/g, \" \")\n  return text\n}\n\nfunction error (parser, er) {\n  closeText(parser)\n  if (parser.trackPosition) {\n    er += \"/nLine: \"+parser.line+\n          \"/nColumn: \"+parser.column+\n          \"/nChar: \"+parser.c\n  }\n  er = new Error(er)\n  parser.error = er\n  emit(parser, \"onerror\", er)\n  return parser\n}\n\nfunction end (parser) {\n  if (!parser.closedRoot) strictFail(parser, \"Unclosed root tag\")\n  if ((parser.state !== S.BEGIN) && (parser.state !== S.TEXT)) error(parser, \"Unexpected end\")\n  closeText(parser)\n  parser.c = \"\"\n  parser.closed = true\n  emit(parser, \"onend\")\n  SAXParser.call(parser, parser.strict, parser.opt)\n  return parser\n}\n\nfunction strictFail (parser, message) {\n  if (typeof parser !== 'object' || !(parser instanceof SAXParser))\n    throw new Error('bad call to strictFail');\n  if (parser.strict) error(parser, message)\n}\n\nfunction newTag (parser) {\n  if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]()\n  var parent = parser.tags[parser.tags.length - 1] || parser\n    , tag = parser.tag = { name : parser.tagName, attributes : {} }\n\n  // will be overridden if tag contails an xmlns=\"foo\" or xmlns:foo=\"bar\"\n  if (parser.opt.xmlns) tag.ns = parent.ns\n  parser.attribList.length = 0\n}\n\nfunction qname (name, attribute) {\n  var i = name.indexOf(\":\")\n    , qualName = i < 0 ? [ \"\", name ] : name.split(\":\")\n    , prefix = qualName[0]\n    , local = qualName[1]\n\n  // <x \"xmlns\"=\"http://foo\">\n  if (attribute && name === \"xmlns\") {\n    prefix = \"xmlns\"\n    local = \"\"\n  }\n\n  return { prefix: prefix, local: local }\n}\n\nfunction attrib (parser) {\n  if (!parser.strict) parser.attribName = parser.attribName[parser.looseCase]()\n\n  if (parser.attribList.indexOf(parser.attribName) !== -1 ||\n      parser.tag.attributes.hasOwnProperty(parser.attribName)) {\n    return parser.attribName = parser.attribValue = \"\"\n  }\n\n  if (parser.opt.xmlns) {\n    var qn = qname(parser.attribName, true)\n      , prefix = qn.prefix\n      , local = qn.local\n\n    if (prefix === \"xmlns\") {\n      // namespace binding attribute; push the binding into scope\n      if (local === \"xml\" && parser.attribValue !== XML_NAMESPACE) {\n        strictFail( parser\n                  , \"xml: prefix must be bound to \" + XML_NAMESPACE + \"/n\"\n                  + \"Actual: \" + parser.attribValue )\n      } else if (local === \"xmlns\" && parser.attribValue !== XMLNS_NAMESPACE) {\n        strictFail( parser\n                  , \"xmlns: prefix must be bound to \" + XMLNS_NAMESPACE + \"/n\"\n                  + \"Actual: \" + parser.attribValue )\n      } else {\n        var tag = parser.tag\n          , parent = parser.tags[parser.tags.length - 1] || parser\n        if (tag.ns === parent.ns) {\n          tag.ns = Object.create(parent.ns)\n        }\n        tag.ns[local] = parser.attribValue\n      }\n    }\n\n    // defer onattribute events until all attributes have been seen\n    // so any new bindings can take effect; preserve attribute order\n    // so deferred events can be emitted in document order\n    parser.attribList.push([parser.attribName, parser.attribValue])\n  } else {\n    // in non-xmlns mode, we can emit the event right away\n    parser.tag.attributes[parser.attribName] = parser.attribValue\n    emitNode( parser\n            , \"onattribute\"\n            , { name: parser.attribName\n              , value: parser.attribValue } )\n  }\n\n  parser.attribName = parser.attribValue = \"\"\n}\n\nfunction openTag (parser, selfClosing) {\n  if (parser.opt.xmlns) {\n    // emit namespace binding events\n    var tag = parser.tag\n\n    // add namespace info to tag\n    var qn = qname(parser.tagName)\n    tag.prefix = qn.prefix\n    tag.local = qn.local\n    tag.uri = tag.ns[qn.prefix] || \"\"\n\n    if (tag.prefix && !tag.uri) {\n      strictFail(parser, \"Unbound namespace prefix: \"\n                       + JSON.stringify(parser.tagName))\n      tag.uri = qn.prefix\n    }\n\n    var parent = parser.tags[parser.tags.length - 1] || parser\n    if (tag.ns && parent.ns !== tag.ns) {\n      Object.keys(tag.ns).forEach(function (p) {\n        emitNode( parser\n                , \"onopennamespace\"\n                , { prefix: p , uri: tag.ns[p] } )\n      })\n    }\n\n    // handle deferred onattribute events\n    // Note: do not apply default ns to attributes:\n    //   http://www.w3.org/TR/REC-xml-names/#defaulting\n    for (var i = 0, l = parser.attribList.length; i < l; i ++) {\n      var nv = parser.attribList[i]\n      var name = nv[0]\n        , value = nv[1]\n        , qualName = qname(name, true)\n        , prefix = qualName.prefix\n        , local = qualName.local\n        , uri = prefix == \"\" ? \"\" : (tag.ns[prefix] || \"\")\n        , a = { name: name\n              , value: value\n              , prefix: prefix\n              , local: local\n              , uri: uri\n              }\n\n      // if there's any attributes with an undefined namespace,\n      // then fail on them now.\n      if (prefix && prefix != \"xmlns\" && !uri) {\n        strictFail(parser, \"Unbound namespace prefix: \"\n                         + JSON.stringify(prefix))\n        a.uri = prefix\n      }\n      parser.tag.attributes[name] = a\n      emitNode(parser, \"onattribute\", a)\n    }\n    parser.attribList.length = 0\n  }\n\n  parser.tag.isSelfClosing = !!selfClosing\n\n  // process the tag\n  parser.sawRoot = true\n  parser.tags.push(parser.tag)\n  emitNode(parser, \"onopentag\", parser.tag)\n  if (!selfClosing) {\n    // special case for <script> in non-strict mode.\n    if (!parser.noscript && parser.tagName.toLowerCase() === \"script\") {\n      parser.state = S.SCRIPT\n    } else {\n      parser.state = S.TEXT\n    }\n    parser.tag = null\n    parser.tagName = \"\"\n  }\n  parser.attribName = parser.attribValue = \"\"\n  parser.attribList.length = 0\n}\n\nfunction closeTag (parser) {\n  if (!parser.tagName) {\n    strictFail(parser, \"Weird empty close tag.\")\n    parser.textNode += \"</>\"\n    parser.state = S.TEXT\n    return\n  }\n\n  if (parser.script) {\n    if (parser.tagName !== \"script\") {\n      parser.script += \"</\" + parser.tagName + \">\"\n      parser.tagName = \"\"\n      parser.state = S.SCRIPT\n      return\n    }\n    emitNode(parser, \"onscript\", parser.script)\n    parser.script = \"\"\n  }\n\n  // first make sure that the closing tag actually exists.\n  // <a><b></c></b></a> will close everything, otherwise.\n  var t = parser.tags.length\n  var tagName = parser.tagName\n  if (!parser.strict) tagName = tagName[parser.looseCase]()\n  var closeTo = tagName\n  while (t --) {\n    var close = parser.tags[t]\n    if (close.name !== closeTo) {\n      // fail the first time in strict mode\n      strictFail(parser, \"Unexpected close tag\")\n    } else break\n  }\n\n  // didn't find it.  we already failed for strict, so just abort.\n  if (t < 0) {\n    strictFail(parser, \"Unmatched closing tag: \"+parser.tagName)\n    parser.textNode += \"</\" + parser.tagName + \">\"\n    parser.state = S.TEXT\n    return\n  }\n  parser.tagName = tagName\n  var s = parser.tags.length\n  while (s --> t) {\n    var tag = parser.tag = parser.tags.pop()\n    parser.tagName = parser.tag.name\n    emitNode(parser, \"onclosetag\", parser.tagName)\n\n    var x = {}\n    for (var i in tag.ns) x[i] = tag.ns[i]\n\n    var parent = parser.tags[parser.tags.length - 1] || parser\n    if (parser.opt.xmlns && tag.ns !== parent.ns) {\n      // remove namespace bindings introduced by tag\n      Object.keys(tag.ns).forEach(function (p) {\n        var n = tag.ns[p]\n        emitNode(parser, \"onclosenamespace\", { prefix: p, uri: n })\n      })\n    }\n  }\n  if (t === 0) parser.closedRoot = true\n  parser.tagName = parser.attribValue = parser.attribName = \"\"\n  parser.attribList.length = 0\n  parser.state = S.TEXT\n}\n\nfunction parseEntity (parser) {\n  var entity = parser.entity\n    , entityLC = entity.toLowerCase()\n    , num\n    , numStr = \"\"\n  if (parser.ENTITIES[entity])\n    return parser.ENTITIES[entity]\n  if (parser.ENTITIES[entityLC])\n    return parser.ENTITIES[entityLC]\n  entity = entityLC\n  if (entity.charAt(0) === \"#\") {\n    if (entity.charAt(1) === \"x\") {\n      entity = entity.slice(2)\n      num = parseInt(entity, 16)\n      numStr = num.toString(16)\n    } else {\n      entity = entity.slice(1)\n      num = parseInt(entity, 10)\n      numStr = num.toString(10)\n    }\n  }\n  entity = entity.replace(/^0+/, \"\")\n  if (numStr.toLowerCase() !== entity) {\n    strictFail(parser, \"Invalid character entity\")\n    return \"&\"+parser.entity + \";\"\n  }\n\n  return String.fromCodePoint(num)\n}\n\nfunction write (chunk) {\n  var parser = this\n  if (this.error) throw this.error\n  if (parser.closed) return error(parser,\n    \"Cannot write after close. Assign an onready handler.\")\n  if (chunk === null) return end(parser)\n  var i = 0, c = \"\"\n  while (parser.c = c = chunk.charAt(i++)) {\n    if (parser.trackPosition) {\n      parser.position ++\n      if (c === \"/n\") {\n        parser.line ++\n        parser.column = 0\n      } else parser.column ++\n    }\n    switch (parser.state) {\n\n      case S.BEGIN:\n        if (c === \"<\") {\n          parser.state = S.OPEN_WAKA\n          parser.startTagPosition = parser.position\n        } else if (not(whitespace,c)) {\n          // have to process this as a text node.\n          // weird, but happens.\n          strictFail(parser, \"Non-whitespace before first tag.\")\n          parser.textNode = c\n          parser.state = S.TEXT\n        }\n      continue\n\n      case S.TEXT:\n        if (parser.sawRoot && !parser.closedRoot) {\n          var starti = i-1\n          while (c && c!==\"<\" && c!==\"&\") {\n            c = chunk.charAt(i++)\n            if (c && parser.trackPosition) {\n              parser.position ++\n              if (c === \"/n\") {\n                parser.line ++\n                parser.column = 0\n              } else parser.column ++\n            }\n          }\n          parser.textNode += chunk.substring(starti, i-1)\n        }\n        if (c === \"<\") {\n          parser.state = S.OPEN_WAKA\n          parser.startTagPosition = parser.position\n        } else {\n          if (not(whitespace, c) && (!parser.sawRoot || parser.closedRoot))\n            strictFail(parser, \"Text data outside of root node.\")\n          if (c === \"&\") parser.state = S.TEXT_ENTITY\n          else parser.textNode += c\n        }\n      continue\n\n      case S.SCRIPT:\n        // only non-strict\n        if (c === \"<\") {\n          parser.state = S.SCRIPT_ENDING\n        } else parser.script += c\n      continue\n\n      case S.SCRIPT_ENDING:\n        if (c === \"/\") {\n          parser.state = S.CLOSE_TAG\n        } else {\n          parser.script += \"<\" + c\n          parser.state = S.SCRIPT\n        }\n      continue\n\n      case S.OPEN_WAKA:\n        // either a /, ?, !, or text is coming next.\n        if (c === \"!\") {\n          parser.state = S.SGML_DECL\n          parser.sgmlDecl = \"\"\n        } else if (is(whitespace, c)) {\n          // wait for it...\n        } else if (is(nameStart,c)) {\n          parser.state = S.OPEN_TAG\n          parser.tagName = c\n        } else if (c === \"/\") {\n          parser.state = S.CLOSE_TAG\n          parser.tagName = \"\"\n        } else if (c === \"?\") {\n          parser.state = S.PROC_INST\n          parser.procInstName = parser.procInstBody = \"\"\n        } else {\n          strictFail(parser, \"Unencoded <\")\n          // if there was some whitespace, then add that in.\n          if (parser.startTagPosition + 1 < parser.position) {\n            var pad = parser.position - parser.startTagPosition\n            c = new Array(pad).join(\" \") + c\n          }\n          parser.textNode += \"<\" + c\n          parser.state = S.TEXT\n        }\n      continue\n\n      case S.SGML_DECL:\n        if ((parser.sgmlDecl+c).toUpperCase() === CDATA) {\n          emitNode(parser, \"onopencdata\")\n          parser.state = S.CDATA\n          parser.sgmlDecl = \"\"\n          parser.cdata = \"\"\n        } else if (parser.sgmlDecl+c === \"--\") {\n          parser.state = S.COMMENT\n          parser.comment = \"\"\n          parser.sgmlDecl = \"\"\n        } else if ((parser.sgmlDecl+c).toUpperCase() === DOCTYPE) {\n          parser.state = S.DOCTYPE\n          if (parser.doctype || parser.sawRoot) strictFail(parser,\n            \"Inappropriately located doctype declaration\")\n          parser.doctype = \"\"\n          parser.sgmlDecl = \"\"\n        } else if (c === \">\") {\n          emitNode(parser, \"onsgmldeclaration\", parser.sgmlDecl)\n          parser.sgmlDecl = \"\"\n          parser.state = S.TEXT\n        } else if (is(quote, c)) {\n          parser.state = S.SGML_DECL_QUOTED\n          parser.sgmlDecl += c\n        } else parser.sgmlDecl += c\n      continue\n\n      case S.SGML_DECL_QUOTED:\n        if (c === parser.q) {\n          parser.state = S.SGML_DECL\n          parser.q = \"\"\n        }\n        parser.sgmlDecl += c\n      continue\n\n      case S.DOCTYPE:\n        if (c === \">\") {\n          parser.state = S.TEXT\n          emitNode(parser, \"ondoctype\", parser.doctype)\n          parser.doctype = true // just remember that we saw it.\n        } else {\n          parser.doctype += c\n          if (c === \"[\") parser.state = S.DOCTYPE_DTD\n          else if (is(quote, c)) {\n            parser.state = S.DOCTYPE_QUOTED\n            parser.q = c\n          }\n        }\n      continue\n\n      case S.DOCTYPE_QUOTED:\n        parser.doctype += c\n        if (c === parser.q) {\n          parser.q = \"\"\n          parser.state = S.DOCTYPE\n        }\n      continue\n\n      case S.DOCTYPE_DTD:\n        parser.doctype += c\n        if (c === \"]\") parser.state = S.DOCTYPE\n        else if (is(quote,c)) {\n          parser.state = S.DOCTYPE_DTD_QUOTED\n          parser.q = c\n        }\n      continue\n\n      case S.DOCTYPE_DTD_QUOTED:\n        parser.doctype += c\n        if (c === parser.q) {\n          parser.state = S.DOCTYPE_DTD\n          parser.q = \"\"\n        }\n      continue\n\n      case S.COMMENT:\n        if (c === \"-\") parser.state = S.COMMENT_ENDING\n        else parser.comment += c\n      continue\n\n      case S.COMMENT_ENDING:\n        if (c === \"-\") {\n          parser.state = S.COMMENT_ENDED\n          parser.comment = textopts(parser.opt, parser.comment)\n          if (parser.comment) emitNode(parser, \"oncomment\", parser.comment)\n          parser.comment = \"\"\n        } else {\n          parser.comment += \"-\" + c\n          parser.state = S.COMMENT\n        }\n      continue\n\n      case S.COMMENT_ENDED:\n        if (c !== \">\") {\n          strictFail(parser, \"Malformed comment\")\n          // allow <!-- blah -- bloo --> in non-strict mode,\n          // which is a comment of \" blah -- bloo \"\n          parser.comment += \"--\" + c\n          parser.state = S.COMMENT\n        } else parser.state = S.TEXT\n      continue\n\n      case S.CDATA:\n        if (c === \"]\") parser.state = S.CDATA_ENDING\n        else parser.cdata += c\n      continue\n\n      case S.CDATA_ENDING:\n        if (c === \"]\") parser.state = S.CDATA_ENDING_2\n        else {\n          parser.cdata += \"]\" + c\n          parser.state = S.CDATA\n        }\n      continue\n\n      case S.CDATA_ENDING_2:\n        if (c === \">\") {\n          if (parser.cdata) emitNode(parser, \"oncdata\", parser.cdata)\n          emitNode(parser, \"onclosecdata\")\n          parser.cdata = \"\"\n          parser.state = S.TEXT\n        } else if (c === \"]\") {\n          parser.cdata += \"]\"\n        } else {\n          parser.cdata += \"]]\" + c\n          parser.state = S.CDATA\n        }\n      continue\n\n      case S.PROC_INST:\n        if (c === \"?\") parser.state = S.PROC_INST_ENDING\n        else if (is(whitespace, c)) parser.state = S.PROC_INST_BODY\n        else parser.procInstName += c\n      continue\n\n      case S.PROC_INST_BODY:\n        if (!parser.procInstBody && is(whitespace, c)) continue\n        else if (c === \"?\") parser.state = S.PROC_INST_ENDING\n        else parser.procInstBody += c\n      continue\n\n      case S.PROC_INST_ENDING:\n        if (c === \">\") {\n          emitNode(parser, \"onprocessinginstruction\", {\n            name : parser.procInstName,\n            body : parser.procInstBody\n          })\n          parser.procInstName = parser.procInstBody = \"\"\n          parser.state = S.TEXT\n        } else {\n          parser.procInstBody += \"?\" + c\n          parser.state = S.PROC_INST_BODY\n        }\n      continue\n\n      case S.OPEN_TAG:\n        if (is(nameBody, c)) parser.tagName += c\n        else {\n          newTag(parser)\n          if (c === \">\") openTag(parser)\n          else if (c === \"/\") parser.state = S.OPEN_TAG_SLASH\n          else {\n            if (not(whitespace, c)) strictFail(\n              parser, \"Invalid character in tag name\")\n            parser.state = S.ATTRIB\n          }\n        }\n      continue\n\n      case S.OPEN_TAG_SLASH:\n        if (c === \">\") {\n          openTag(parser, true)\n          closeTag(parser)\n        } else {\n          strictFail(parser, \"Forward-slash in opening tag not followed by >\")\n          parser.state = S.ATTRIB\n        }\n      continue\n\n      case S.ATTRIB:\n        // haven't read the attribute name yet.\n        if (is(whitespace, c)) continue\n        else if (c === \">\") openTag(parser)\n        else if (c === \"/\") parser.state = S.OPEN_TAG_SLASH\n        else if (is(nameStart, c)) {\n          parser.attribName = c\n          parser.attribValue = \"\"\n          parser.state = S.ATTRIB_NAME\n        } else strictFail(parser, \"Invalid attribute name\")\n      continue\n\n      case S.ATTRIB_NAME:\n        if (c === \"=\") parser.state = S.ATTRIB_VALUE\n        else if (c === \">\") {\n          strictFail(parser, \"Attribute without value\")\n          parser.attribValue = parser.attribName\n          attrib(parser)\n          openTag(parser)\n        }\n        else if (is(whitespace, c)) parser.state = S.ATTRIB_NAME_SAW_WHITE\n        else if (is(nameBody, c)) parser.attribName += c\n        else strictFail(parser, \"Invalid attribute name\")\n      continue\n\n      case S.ATTRIB_NAME_SAW_WHITE:\n        if (c === \"=\") parser.state = S.ATTRIB_VALUE\n        else if (is(whitespace, c)) continue\n        else {\n          strictFail(parser, \"Attribute without value\")\n          parser.tag.attributes[parser.attribName] = \"\"\n          parser.attribValue = \"\"\n          emitNode(parser, \"onattribute\",\n                   { name : parser.attribName, value : \"\" })\n          parser.attribName = \"\"\n          if (c === \">\") openTag(parser)\n          else if (is(nameStart, c)) {\n            parser.attribName = c\n            parser.state = S.ATTRIB_NAME\n          } else {\n            strictFail(parser, \"Invalid attribute name\")\n            parser.state = S.ATTRIB\n          }\n        }\n      continue\n\n      case S.ATTRIB_VALUE:\n        if (is(whitespace, c)) continue\n        else if (is(quote, c)) {\n          parser.q = c\n          parser.state = S.ATTRIB_VALUE_QUOTED\n        } else {\n          strictFail(parser, \"Unquoted attribute value\")\n          parser.state = S.ATTRIB_VALUE_UNQUOTED\n          parser.attribValue = c\n        }\n      continue\n\n      case S.ATTRIB_VALUE_QUOTED:\n        if (c !== parser.q) {\n          if (c === \"&\") parser.state = S.ATTRIB_VALUE_ENTITY_Q\n          else parser.attribValue += c\n          continue\n        }\n        attrib(parser)\n        parser.q = \"\"\n        parser.state = S.ATTRIB_VALUE_CLOSED\n      continue\n\n      case S.ATTRIB_VALUE_CLOSED:\n        if (is(whitespace, c)) {\n          parser.state = S.ATTRIB\n        } else if (c === \">\") openTag(parser)\n        else if (c === \"/\") parser.state = S.OPEN_TAG_SLASH\n        else if (is(nameStart, c)) {\n          strictFail(parser, \"No whitespace between attributes\")\n          parser.attribName = c\n          parser.attribValue = \"\"\n          parser.state = S.ATTRIB_NAME\n        } else strictFail(parser, \"Invalid attribute name\")\n      continue\n\n      case S.ATTRIB_VALUE_UNQUOTED:\n        if (not(attribEnd,c)) {\n          if (c === \"&\") parser.state = S.ATTRIB_VALUE_ENTITY_U\n          else parser.attribValue += c\n          continue\n        }\n        attrib(parser)\n        if (c === \">\") openTag(parser)\n        else parser.state = S.ATTRIB\n      continue\n\n      case S.CLOSE_TAG:\n        if (!parser.tagName) {\n          if (is(whitespace, c)) continue\n          else if (not(nameStart, c)) {\n            if (parser.script) {\n              parser.script += \"</\" + c\n              parser.state = S.SCRIPT\n            } else {\n              strictFail(parser, \"Invalid tagname in closing tag.\")\n            }\n          } else parser.tagName = c\n        }\n        else if (c === \">\") closeTag(parser)\n        else if (is(nameBody, c)) parser.tagName += c\n        else if (parser.script) {\n          parser.script += \"</\" + parser.tagName\n          parser.tagName = \"\"\n          parser.state = S.SCRIPT\n        } else {\n          if (not(whitespace, c)) strictFail(parser,\n            \"Invalid tagname in closing tag\")\n          parser.state = S.CLOSE_TAG_SAW_WHITE\n        }\n      continue\n\n      case S.CLOSE_TAG_SAW_WHITE:\n        if (is(whitespace, c)) continue\n        if (c === \">\") closeTag(parser)\n        else strictFail(parser, \"Invalid characters in closing tag\")\n      continue\n\n      case S.TEXT_ENTITY:\n      case S.ATTRIB_VALUE_ENTITY_Q:\n      case S.ATTRIB_VALUE_ENTITY_U:\n        switch(parser.state) {\n          case S.TEXT_ENTITY:\n            var returnState = S.TEXT, buffer = \"textNode\"\n          break\n\n          case S.ATTRIB_VALUE_ENTITY_Q:\n            var returnState = S.ATTRIB_VALUE_QUOTED, buffer = \"attribValue\"\n          break\n\n          case S.ATTRIB_VALUE_ENTITY_U:\n            var returnState = S.ATTRIB_VALUE_UNQUOTED, buffer = \"attribValue\"\n          break\n        }\n        if (c === \";\") {\n          parser[buffer] += parseEntity(parser)\n          parser.entity = \"\"\n          parser.state = returnState\n        }\n        else if (is(entity, c)) parser.entity += c\n        else {\n          strictFail(parser, \"Invalid character entity\")\n          parser[buffer] += \"&\" + parser.entity + c\n          parser.entity = \"\"\n          parser.state = returnState\n        }\n      continue\n\n      default:\n        throw new Error(parser, \"Unknown state: \" + parser.state)\n    }\n  } // while\n  // cdata blocks can get very big under normal conditions. emit and move on.\n  // if (parser.state === S.CDATA && parser.cdata) {\n  //   emitNode(parser, \"oncdata\", parser.cdata)\n  //   parser.cdata = \"\"\n  // }\n  if (parser.position >= parser.bufferCheckPosition) checkBufferLength(parser)\n  return parser\n}\n\n/*! http://mths.be/fromcodepoint v0.1.0 by @mathias */\nif (!String.fromCodePoint) {\n        (function() {\n                var stringFromCharCode = String.fromCharCode;\n                var floor = Math.floor;\n                var fromCodePoint = function() {\n                        var MAX_SIZE = 0x4000;\n                        var codeUnits = [];\n                        var highSurrogate;\n                        var lowSurrogate;\n                        var index = -1;\n                        var length = arguments.length;\n                        if (!length) {\n                                return '';\n                        }\n                        var result = '';\n                        while (++index < length) {\n                                var codePoint = Number(arguments[index]);\n                                if (\n                                        !isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`\n                                        codePoint < 0 || // not a valid Unicode code point\n                                        codePoint > 0x10FFFF || // not a valid Unicode code point\n                                        floor(codePoint) != codePoint // not an integer\n                                ) {\n                                        throw RangeError('Invalid code point: ' + codePoint);\n                                }\n                                if (codePoint <= 0xFFFF) { // BMP code point\n                                        codeUnits.push(codePoint);\n                                } else { // Astral code point; split in surrogate halves\n                                        // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n                                        codePoint -= 0x10000;\n                                        highSurrogate = (codePoint >> 10) + 0xD800;\n                                        lowSurrogate = (codePoint % 0x400) + 0xDC00;\n                                        codeUnits.push(highSurrogate, lowSurrogate);\n                                }\n                                if (index + 1 == length || codeUnits.length > MAX_SIZE) {\n                                        result += stringFromCharCode.apply(null, codeUnits);\n                                        codeUnits.length = 0;\n                                }\n                        }\n                        return result;\n                };\n                if (Object.defineProperty) {\n                        Object.defineProperty(String, 'fromCodePoint', {\n                                'value': fromCodePoint,\n                                'configurable': true,\n                                'writable': true\n                        });\n                } else {\n                        String.fromCodePoint = fromCodePoint;\n                }\n        }());\n}\n\n})(typeof exports === \"undefined\" ? sax = {} : exports);\n","/**\n * Tiny stack for browser or server\n *\n * @author Jason Mulligan <jason.mulligan@avoidwork.com>\n * @copyright 2014 Jason Mulligan\n * @license BSD-3 <https://raw.github.com/avoidwork/tiny-stack/master/LICENSE>\n * @link http://avoidwork.github.io/tiny-stack\n * @module tiny-stack\n * @version 0.1.0\n */\n\n( function ( global ) {\n\n\"use strict\";\n\n/**\n * TinyStack\n *\n * @constructor\n */\nfunction TinyStack () {\n\tthis.data = [null];\n\tthis.top  = 0;\n}\n\n/**\n * Clears the stack\n *\n * @method clear\n * @memberOf TinyStack\n * @return {Object} {@link TinyStack}\n */\nTinyStack.prototype.clear = function clear () {\n\tthis.data = [null];\n\tthis.top  = 0;\n\n\treturn this;\n};\n\n/**\n * Gets the size of the stack\n *\n * @method length\n * @memberOf TinyStack\n * @return {Number} Size of stack\n */\nTinyStack.prototype.length = function length () {\n\treturn this.top;\n};\n\n/**\n * Gets the item at the top of the stack\n *\n * @method peek\n * @memberOf TinyStack\n * @return {Mixed} Item at the top of the stack\n */\nTinyStack.prototype.peek = function peek () {\n\treturn this.data[this.top];\n};\n\n/**\n * Gets & removes the item at the top of the stack\n *\n * @method pop\n * @memberOf TinyStack\n * @return {Mixed} Item at the top of the stack\n */\nTinyStack.prototype.pop = function pop () {\n\tif ( this.top > 0 ) {\n\t\tthis.top--;\n\n\t\treturn this.data.pop();\n\t}\n\telse {\n\t\treturn undefined;\n\t}\n};\n\n/**\n * Pushes an item onto the stack\n *\n * @method push\n * @memberOf TinyStack\n * @return {Object} {@link TinyStack}\n */\nTinyStack.prototype.push = function push ( arg ) {\n\tthis.data[++this.top] = arg;\n\n\treturn this;\n};\n\n/**\n * TinyStack factory\n *\n * @method factory\n * @return {Object} {@link TinyStack}\n */\nfunction factory () {\n\treturn new TinyStack();\n}\n\n// Node, AMD & window supported\nif ( typeof exports != \"undefined\" ) {\n\tmodule.exports = factory;\n}\nelse if ( typeof define == \"function\" ) {\n\tdefine( function () {\n\t\treturn factory;\n\t} );\n}\nelse {\n\tglobal.stack = factory;\n}\n} )( this );\n","module.exports = require(534);","'use strict';\n\nfunction Base() { }\n\nBase.prototype.get = function(name) {\n  return this.$model.properties.get(this, name);\n};\n\nBase.prototype.set = function(name, value) {\n  this.$model.properties.set(this, name, value);\n};\n\n\nmodule.exports = Base;","'use strict';\n\nvar pick = require(522),\n    assign = require(518),\n    forEach = require(450);\n\nvar parseNameNs = require(535).parseName;\n\n\nfunction DescriptorBuilder(nameNs) {\n  this.ns = nameNs;\n  this.name = nameNs.name;\n  this.allTypes = [];\n  this.properties = [];\n  this.propertiesByName = {};\n}\n\nmodule.exports = DescriptorBuilder;\n\n\nDescriptorBuilder.prototype.build = function() {\n  return pick(this, [\n    'ns',\n    'name',\n    'allTypes',\n    'properties',\n    'propertiesByName',\n    'bodyProperty',\n    'idProperty'\n  ]);\n};\n\n/**\n * Add property at given index.\n *\n * @param {Object} p\n * @param {Number} [idx]\n * @param {Boolean} [validate=true]\n */\nDescriptorBuilder.prototype.addProperty = function(p, idx, validate) {\n\n  if (typeof idx === 'boolean') {\n    validate = idx;\n    idx = undefined;\n  }\n\n  this.addNamedProperty(p, validate !== false);\n\n  var properties = this.properties;\n\n  if (idx !== undefined) {\n    properties.splice(idx, 0, p);\n  } else {\n    properties.push(p);\n  }\n};\n\n\nDescriptorBuilder.prototype.replaceProperty = function(oldProperty, newProperty, replace) {\n  var oldNameNs = oldProperty.ns;\n\n  var props = this.properties,\n      propertiesByName = this.propertiesByName,\n      rename = oldProperty.name !== newProperty.name;\n\n  if (oldProperty.isId) {\n    if (!newProperty.isId) {\n      throw new Error(\n        'property <' + newProperty.ns.name + '> must be id property ' +\n        'to refine <' + oldProperty.ns.name + '>');\n    }\n\n    this.setIdProperty(newProperty, false);\n  }\n\n  if (oldProperty.isBody) {\n\n    if (!newProperty.isBody) {\n      throw new Error(\n        'property <' + newProperty.ns.name + '> must be body property ' +\n        'to refine <' + oldProperty.ns.name + '>');\n    }\n\n    // TODO: Check compatibility\n    this.setBodyProperty(newProperty, false);\n  }\n\n  // validate existence and get location of old property\n  var idx = props.indexOf(oldProperty);\n  if (idx === -1) {\n    throw new Error('property <' + oldNameNs.name + '> not found in property list');\n  }\n\n  // remove old property\n  props.splice(idx, 1);\n\n  // replacing the named property is intentional\n  //\n  //  * validate only if this is a \"rename\" operation\n  //  * add at specific index unless we \"replace\"\n  //\n  this.addProperty(newProperty, replace ? undefined : idx, rename);\n\n  // make new property available under old name\n  propertiesByName[oldNameNs.name] = propertiesByName[oldNameNs.localName] = newProperty;\n};\n\n\nDescriptorBuilder.prototype.redefineProperty = function(p, targetPropertyName, replace) {\n\n  var nsPrefix = p.ns.prefix;\n  var parts = targetPropertyName.split('#');\n\n  var name = parseNameNs(parts[0], nsPrefix);\n  var attrName = parseNameNs(parts[1], name.prefix).name;\n\n  var redefinedProperty = this.propertiesByName[attrName];\n  if (!redefinedProperty) {\n    throw new Error('refined property <' + attrName + '> not found');\n  } else {\n    this.replaceProperty(redefinedProperty, p, replace);\n  }\n\n  delete p.redefines;\n};\n\nDescriptorBuilder.prototype.addNamedProperty = function(p, validate) {\n  var ns = p.ns,\n      propsByName = this.propertiesByName;\n\n  if (validate) {\n    this.assertNotDefined(p, ns.name);\n    this.assertNotDefined(p, ns.localName);\n  }\n\n  propsByName[ns.name] = propsByName[ns.localName] = p;\n};\n\nDescriptorBuilder.prototype.removeNamedProperty = function(p) {\n  var ns = p.ns,\n      propsByName = this.propertiesByName;\n\n  delete propsByName[ns.name];\n  delete propsByName[ns.localName];\n};\n\nDescriptorBuilder.prototype.setBodyProperty = function(p, validate) {\n\n  if (validate && this.bodyProperty) {\n    throw new Error(\n      'body property defined multiple times ' +\n      '(<' + this.bodyProperty.ns.name + '>, <' + p.ns.name + '>)');\n  }\n\n  this.bodyProperty = p;\n};\n\nDescriptorBuilder.prototype.setIdProperty = function(p, validate) {\n\n  if (validate && this.idProperty) {\n    throw new Error(\n      'id property defined multiple times ' +\n      '(<' + this.idProperty.ns.name + '>, <' + p.ns.name + '>)');\n  }\n\n  this.idProperty = p;\n};\n\nDescriptorBuilder.prototype.assertNotDefined = function(p, name) {\n  var propertyName = p.name,\n      definedProperty = this.propertiesByName[propertyName];\n\n  if (definedProperty) {\n    throw new Error(\n      'property <' + propertyName + '> already defined; ' +\n      'override of <' + definedProperty.definedBy.ns.name + '#' + definedProperty.ns.name + '> by ' +\n      '<' + p.definedBy.ns.name + '#' + p.ns.name + '> not allowed without redefines');\n  }\n};\n\nDescriptorBuilder.prototype.hasProperty = function(name) {\n  return this.propertiesByName[name];\n};\n\nDescriptorBuilder.prototype.addTrait = function(t, inherited) {\n\n  var allTypes = this.allTypes;\n\n  if (allTypes.indexOf(t) !== -1) {\n    return;\n  }\n\n  forEach(t.properties, function(p) {\n\n    // clone property to allow extensions\n    p = assign({}, p, {\n      name: p.ns.localName,\n      inherited: inherited\n    });\n\n    Object.defineProperty(p, 'definedBy', {\n      value: t\n    });\n\n    var replaces = p.replaces,\n        redefines = p.redefines;\n\n    // add replace/redefine support\n    if (replaces || redefines) {\n      this.redefineProperty(p, replaces || redefines, replaces);\n    } else {\n      if (p.isBody) {\n        this.setBodyProperty(p);\n      }\n      if (p.isId) {\n        this.setIdProperty(p);\n      }\n      this.addProperty(p);\n    }\n  }, this);\n\n  allTypes.push(t);\n};\n","'use strict';\n\nvar forEach = require(450);\n\nvar Base = require(531);\n\n\nfunction Factory(model, properties) {\n  this.model = model;\n  this.properties = properties;\n}\n\nmodule.exports = Factory;\n\n\nFactory.prototype.createType = function(descriptor) {\n\n  var model = this.model;\n\n  var props = this.properties,\n      prototype = Object.create(Base.prototype);\n\n  // initialize default values\n  forEach(descriptor.properties, function(p) {\n    if (!p.isMany && p.default !== undefined) {\n      prototype[p.name] = p.default;\n    }\n  });\n\n  props.defineModel(prototype, model);\n  props.defineDescriptor(prototype, descriptor);\n\n  var name = descriptor.ns.name;\n\n  /**\n   * The new type constructor\n   */\n  function ModdleElement(attrs) {\n    props.define(this, '$type', { value: name, enumerable: true });\n    props.define(this, '$attrs', { value: {} });\n    props.define(this, '$parent', { writable: true });\n\n    forEach(attrs, function(val, key) {\n      this.set(key, val);\n    }, this);\n  }\n\n  ModdleElement.prototype = prototype;\n\n  ModdleElement.hasType = prototype.$instanceOf = this.model.hasType;\n\n  // static links\n  props.defineModel(ModdleElement, model);\n  props.defineDescriptor(ModdleElement, descriptor);\n\n  return ModdleElement;\n};","'use strict';\n\nvar isString = require(516),\n    isObject = require(515),\n    forEach = require(450),\n    find = require(449);\n\n\nvar Factory = require(533),\n    Registry = require(537),\n    Properties = require(536);\n\nvar parseNameNs = require(535).parseName;\n\n\n//// Moddle implementation /////////////////////////////////////////////////\n\n/**\n * @class Moddle\n *\n * A model that can be used to create elements of a specific type.\n *\n * @example\n *\n * var Moddle = require('moddle');\n *\n * var pkg = {\n *   name: 'mypackage',\n *   prefix: 'my',\n *   types: [\n *     { name: 'Root' }\n *   ]\n * };\n *\n * var moddle = new Moddle([pkg]);\n *\n * @param {Array<Package>} packages the packages to contain\n */\nfunction Moddle(packages) {\n\n  this.properties = new Properties(this);\n\n  this.factory = new Factory(this, this.properties);\n  this.registry = new Registry(packages, this.properties);\n\n  this.typeCache = {};\n}\n\nmodule.exports = Moddle;\n\n\n/**\n * Create an instance of the specified type.\n *\n * @method Moddle#create\n *\n * @example\n *\n * var foo = moddle.create('my:Foo');\n * var bar = moddle.create('my:Bar', { id: 'BAR_1' });\n *\n * @param  {String|Object} descriptor the type descriptor or name know to the model\n * @param  {Object} attrs   a number of attributes to initialize the model instance with\n * @return {Object}         model instance\n */\nModdle.prototype.create = function(descriptor, attrs) {\n  var Type = this.getType(descriptor);\n\n  if (!Type) {\n    throw new Error('unknown type <' + descriptor + '>');\n  }\n\n  return new Type(attrs);\n};\n\n\n/**\n * Returns the type representing a given descriptor\n *\n * @method Moddle#getType\n *\n * @example\n *\n * var Foo = moddle.getType('my:Foo');\n * var foo = new Foo({ 'id' : 'FOO_1' });\n *\n * @param  {String|Object} descriptor the type descriptor or name know to the model\n * @return {Object}         the type representing the descriptor\n */\nModdle.prototype.getType = function(descriptor) {\n\n  var cache = this.typeCache;\n\n  var name = isString(descriptor) ? descriptor : descriptor.ns.name;\n\n  var type = cache[name];\n\n  if (!type) {\n    descriptor = this.registry.getEffectiveDescriptor(name);\n    type = cache[name] = this.factory.createType(descriptor);\n  }\n\n  return type;\n};\n\n\n/**\n * Creates an any-element type to be used within model instances.\n *\n * This can be used to create custom elements that lie outside the meta-model.\n * The created element contains all the meta-data required to serialize it\n * as part of meta-model elements.\n *\n * @method Moddle#createAny\n *\n * @example\n *\n * var foo = moddle.createAny('vendor:Foo', 'http://vendor', {\n *   value: 'bar'\n * });\n *\n * var container = moddle.create('my:Container', 'http://my', {\n *   any: [ foo ]\n * });\n *\n * // go ahead and serialize the stuff\n *\n *\n * @param  {String} name  the name of the element\n * @param  {String} nsUri the namespace uri of the element\n * @param  {Object} [properties] a map of properties to initialize the instance with\n * @return {Object} the any type instance\n */\nModdle.prototype.createAny = function(name, nsUri, properties) {\n\n  var nameNs = parseNameNs(name);\n\n  var element = {\n    $type: name\n  };\n\n  var descriptor = {\n    name: name,\n    isGeneric: true,\n    ns: {\n      prefix: nameNs.prefix,\n      localName: nameNs.localName,\n      uri: nsUri\n    }\n  };\n\n  this.properties.defineDescriptor(element, descriptor);\n  this.properties.defineModel(element, this);\n  this.properties.define(element, '$parent', { enumerable: false, writable: true });\n\n  forEach(properties, function(a, key) {\n    if (isObject(a) && a.value !== undefined) {\n      element[a.name] = a.value;\n    } else {\n      element[key] = a;\n    }\n  });\n\n  return element;\n};\n\n/**\n * Returns a registered package by uri or prefix\n *\n * @return {Object} the package\n */\nModdle.prototype.getPackage = function(uriOrPrefix) {\n  return this.registry.getPackage(uriOrPrefix);\n};\n\n/**\n * Returns a snapshot of all known packages\n *\n * @return {Object} the package\n */\nModdle.prototype.getPackages = function() {\n  return this.registry.getPackages();\n};\n\n/**\n * Returns the descriptor for an element\n */\nModdle.prototype.getElementDescriptor = function(element) {\n  return element.$descriptor;\n};\n\n/**\n * Returns true if the given descriptor or instance\n * represents the given type.\n *\n * May be applied to this, if element is omitted.\n */\nModdle.prototype.hasType = function(element, type) {\n  if (type === undefined) {\n    type = element;\n    element = this;\n  }\n\n  var descriptor = element.$model.getElementDescriptor(element);\n\n  return !!find(descriptor.allTypes, function(t) {\n    return t.name === type;\n  });\n};\n\n\n/**\n * Returns the descriptor of an elements named property\n */\nModdle.prototype.getPropertyDescriptor = function(element, property) {\n  return this.getElementDescriptor(element).propertiesByName[property];\n};\n","'use strict';\n\n/**\n * Parses a namespaced attribute name of the form (ns:)localName to an object,\n * given a default prefix to assume in case no explicit namespace is given.\n *\n * @param {String} name\n * @param {String} [defaultPrefix] the default prefix to take, if none is present.\n *\n * @return {Object} the parsed name\n */\nmodule.exports.parseName = function(name, defaultPrefix) {\n  var parts = name.split(/:/),\n      localName, prefix;\n\n  // no prefix (i.e. only local name)\n  if (parts.length === 1) {\n    localName = name;\n    prefix = defaultPrefix;\n  } else\n  // prefix + local name\n  if (parts.length === 2) {\n    localName = parts[1];\n    prefix = parts[0];\n  } else {\n    throw new Error('expected <prefix:localName> or <localName>, got ' + name);\n  }\n\n  name = (prefix ? prefix + ':' : '') + localName;\n\n  return {\n    name: name,\n    prefix: prefix,\n    localName: localName\n  };\n};","'use strict';\n\n\n/**\n * A utility that gets and sets properties of model elements.\n *\n * @param {Model} model\n */\nfunction Properties(model) {\n  this.model = model;\n}\n\nmodule.exports = Properties;\n\n\n/**\n * Sets a named property on the target element.\n * If the value is undefined, the property gets deleted.\n *\n * @param {Object} target\n * @param {String} name\n * @param {Object} value\n */\nProperties.prototype.set = function(target, name, value) {\n\n  var property = this.model.getPropertyDescriptor(target, name);\n\n  var propertyName = property && property.name;\n\n  if (isUndefined(value)) {\n    // unset the property, if the specified value is undefined;\n    // delete from $attrs (for extensions) or the target itself\n    if (property) {\n      delete target[propertyName];\n    } else {\n      delete target.$attrs[name];\n    }\n  } else {\n    // set the property, defining well defined properties on the fly\n    // or simply updating them in target.$attrs (for extensions)\n    if (property) {\n      if (propertyName in target) {\n        target[propertyName] = value;\n      } else {\n        defineProperty(target, property, value);\n      }\n    } else {\n      target.$attrs[name] = value;\n    }\n  }\n};\n\n/**\n * Returns the named property of the given element\n *\n * @param  {Object} target\n * @param  {String} name\n *\n * @return {Object}\n */\nProperties.prototype.get = function(target, name) {\n\n  var property = this.model.getPropertyDescriptor(target, name);\n\n  if (!property) {\n    return target.$attrs[name];\n  }\n\n  var propertyName = property.name;\n\n  // check if access to collection property and lazily initialize it\n  if (!target[propertyName] && property.isMany) {\n    defineProperty(target, property, []);\n  }\n\n  return target[propertyName];\n};\n\n\n/**\n * Define a property on the target element\n *\n * @param  {Object} target\n * @param  {String} name\n * @param  {Object} options\n */\nProperties.prototype.define = function(target, name, options) {\n  Object.defineProperty(target, name, options);\n};\n\n\n/**\n * Define the descriptor for an element\n */\nProperties.prototype.defineDescriptor = function(target, descriptor) {\n  this.define(target, '$descriptor', { value: descriptor });\n};\n\n/**\n * Define the model for an element\n */\nProperties.prototype.defineModel = function(target, model) {\n  this.define(target, '$model', { value: model });\n};\n\n\nfunction isUndefined(val) {\n  return typeof val === 'undefined';\n}\n\nfunction defineProperty(target, property, value) {\n  Object.defineProperty(target, property.name, {\n    enumerable: !property.isReference,\n    writable: true,\n    value: value,\n    configurable: true\n  });\n}","'use strict';\n\nvar assign = require(518),\n    forEach = require(450);\n\nvar Types = require(538),\n    DescriptorBuilder = require(532);\n\nvar parseNameNs = require(535).parseName,\n    isBuiltInType = Types.isBuiltIn;\n\n\nfunction Registry(packages, properties) {\n  this.packageMap = {};\n  this.typeMap = {};\n\n  this.packages = [];\n\n  this.properties = properties;\n\n  forEach(packages, this.registerPackage, this);\n}\n\nmodule.exports = Registry;\n\n\nRegistry.prototype.getPackage = function(uriOrPrefix) {\n  return this.packageMap[uriOrPrefix];\n};\n\nRegistry.prototype.getPackages = function() {\n  return this.packages;\n};\n\n\nRegistry.prototype.registerPackage = function(pkg) {\n\n  // copy package\n  pkg = assign({}, pkg);\n\n  // register types\n  forEach(pkg.types, function(descriptor) {\n    this.registerType(descriptor, pkg);\n  }, this);\n\n  this.packageMap[pkg.uri] = this.packageMap[pkg.prefix] = pkg;\n  this.packages.push(pkg);\n};\n\n\n/**\n * Register a type from a specific package with us\n */\nRegistry.prototype.registerType = function(type, pkg) {\n\n  type = assign({}, type, {\n    superClass: (type.superClass || []).slice(),\n    extends: (type.extends || []).slice(),\n    properties: (type.properties || []).slice()\n  });\n\n  var ns = parseNameNs(type.name, pkg.prefix),\n      name = ns.name,\n      propertiesByName = {};\n\n  // parse properties\n  forEach(type.properties, function(p) {\n\n    // namespace property names\n    var propertyNs = parseNameNs(p.name, ns.prefix),\n        propertyName = propertyNs.name;\n\n    // namespace property types\n    if (!isBuiltInType(p.type)) {\n      p.type = parseNameNs(p.type, propertyNs.prefix).name;\n    }\n\n    assign(p, {\n      ns: propertyNs,\n      name: propertyName\n    });\n\n    propertiesByName[propertyName] = p;\n  });\n\n  // update ns + name\n  assign(type, {\n    ns: ns,\n    name: name,\n    propertiesByName: propertiesByName\n  });\n\n  forEach(type.extends, function(extendsName) {\n    var extended = this.typeMap[extendsName];\n\n    extended.traits = extended.traits || [];\n    extended.traits.push(name);\n  }, this);\n\n  // link to package\n  this.definePackage(type, pkg);\n\n  // register\n  this.typeMap[name] = type;\n};\n\n\n/**\n * Traverse the type hierarchy from bottom to top,\n * calling iterator with (type, inherited) for all elements in\n * the inheritance chain.\n *\n * @param {Object} nsName\n * @param {Function} iterator\n * @param {Boolean} [trait=false]\n */\nRegistry.prototype.mapTypes = function(nsName, iterator, trait) {\n\n  var type = isBuiltInType(nsName.name) ? { name: nsName.name } : this.typeMap[nsName.name];\n\n  var self = this;\n\n  /**\n   * Traverse the selected trait.\n   *\n   * @param {String} cls\n   */\n  function traverseTrait(cls) {\n    return traverseSuper(cls, true);\n  }\n\n  /**\n   * Traverse the selected super type or trait\n   *\n   * @param {String} cls\n   * @param {Boolean} [trait=false]\n   */\n  function traverseSuper(cls, trait) {\n    var parentNs = parseNameNs(cls, isBuiltInType(cls) ? '' : nsName.prefix);\n    self.mapTypes(parentNs, iterator, trait);\n  }\n\n  if (!type) {\n    throw new Error('unknown type <' + nsName.name + '>');\n  }\n\n  forEach(type.superClass, trait ? traverseTrait : traverseSuper);\n\n  // call iterator with (type, inherited=!trait)\n  iterator(type, !trait);\n\n  forEach(type.traits, traverseTrait);\n};\n\n\n/**\n * Returns the effective descriptor for a type.\n *\n * @param  {String} type the namespaced name (ns:localName) of the type\n *\n * @return {Descriptor} the resulting effective descriptor\n */\nRegistry.prototype.getEffectiveDescriptor = function(name) {\n\n  var nsName = parseNameNs(name);\n\n  var builder = new DescriptorBuilder(nsName);\n\n  this.mapTypes(nsName, function(type, inherited) {\n    builder.addTrait(type, inherited);\n  });\n\n  var descriptor = builder.build();\n\n  // define package link\n  this.definePackage(descriptor, descriptor.allTypes[descriptor.allTypes.length - 1].$pkg);\n\n  return descriptor;\n};\n\n\nRegistry.prototype.definePackage = function(target, pkg) {\n  this.properties.define(target, '$pkg', { value: pkg });\n};","'use strict';\n\n/**\n * Built-in moddle types\n */\nvar BUILTINS = {\n  String: true,\n  Boolean: true,\n  Integer: true,\n  Real: true,\n  Element: true\n};\n\n/**\n * Converters for built in types from string representations\n */\nvar TYPE_CONVERTERS = {\n  String: function(s) { return s; },\n  Boolean: function(s) { return s === 'true'; },\n  Integer: function(s) { return parseInt(s, 10); },\n  Real: function(s) { return parseFloat(s, 10); }\n};\n\n/**\n * Convert a type to its real representation\n */\nmodule.exports.coerceType = function(type, value) {\n\n  var converter = TYPE_CONVERTERS[type];\n\n  if (converter) {\n    return converter(value);\n  } else {\n    return value;\n  }\n};\n\n/**\n * Return whether the given type is built-in\n */\nmodule.exports.isBuiltIn = function(type) {\n  return !!BUILTINS[type];\n};\n\n/**\n * Return whether the given type is simple\n */\nmodule.exports.isSimple = function(type) {\n  return !!TYPE_CONVERTERS[type];\n};","module.exports={\n  \"name\": \"DC\",\n  \"uri\": \"http://www.omg.org/spec/DD/20100524/DC\",\n  \"types\": [\n    {\n      \"name\": \"Boolean\"\n    },\n    {\n      \"name\": \"Integer\"\n    },\n    {\n      \"name\": \"Real\"\n    },\n    {\n      \"name\": \"String\"\n    },\n    {\n      \"name\": \"Font\",\n      \"properties\": [\n        {\n          \"name\": \"name\",\n          \"type\": \"String\",\n          \"isAttr\": true\n        },\n        {\n          \"name\": \"size\",\n          \"type\": \"Real\",\n          \"isAttr\": true\n        },\n        {\n          \"name\": \"isBold\",\n          \"type\": \"Boolean\",\n          \"isAttr\": true\n        },\n        {\n          \"name\": \"isItalic\",\n          \"type\": \"Boolean\",\n          \"isAttr\": true\n        },\n        {\n          \"name\": \"isUnderline\",\n          \"type\": \"Boolean\",\n          \"isAttr\": true\n        },\n        {\n          \"name\": \"isStrikeThrough\",\n          \"type\": \"Boolean\",\n          \"isAttr\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"Point\",\n      \"properties\": [\n        {\n          \"name\": \"x\",\n          \"type\": \"Real\",\n          \"default\": \"0\",\n          \"isAttr\": true\n        },\n        {\n          \"name\": \"y\",\n          \"type\": \"Real\",\n          \"default\": \"0\",\n          \"isAttr\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"Bounds\",\n      \"properties\": [\n        {\n          \"name\": \"x\",\n          \"type\": \"Real\",\n          \"default\": \"0\",\n          \"isAttr\": true\n        },\n        {\n          \"name\": \"y\",\n          \"type\": \"Real\",\n          \"default\": \"0\",\n          \"isAttr\": true\n        },\n        {\n          \"name\": \"width\",\n          \"type\": \"Real\",\n          \"isAttr\": true\n        },\n        {\n          \"name\": \"height\",\n          \"type\": \"Real\",\n          \"isAttr\": true\n        }\n      ]\n    }\n  ],\n  \"prefix\": \"dc\",\n  \"associations\": []\n}","module.exports={\n  \"name\": \"DI\",\n  \"uri\": \"http://www.omg.org/spec/DD/20100524/DI\",\n  \"types\": [\n    {\n      \"name\": \"DiagramElement\",\n      \"isAbstract\": true,\n      \"properties\": [\n        {\n          \"name\": \"id\",\n          \"type\": \"String\",\n          \"isAttr\": true,\n          \"isId\": true\n        },\n        {\n          \"name\": \"extension\",\n          \"type\": \"Extension\"\n        },\n        {\n          \"name\": \"owningDiagram\",\n          \"type\": \"Diagram\",\n          \"isReadOnly\": true,\n          \"isVirtual\": true,\n          \"isReference\": true\n        },\n        {\n          \"name\": \"owningElement\",\n          \"type\": \"DiagramElement\",\n          \"isReadOnly\": true,\n          \"isVirtual\": true,\n          \"isReference\": true\n        },\n        {\n          \"name\": \"modelElement\",\n          \"isReadOnly\": true,\n          \"isVirtual\": true,\n          \"isReference\": true,\n          \"type\": \"Element\"\n        },\n        {\n          \"name\": \"style\",\n          \"type\": \"Style\",\n          \"isReadOnly\": true,\n          \"isVirtual\": true,\n          \"isReference\": true\n        },\n        {\n          \"name\": \"ownedElement\",\n          \"type\": \"DiagramElement\",\n          \"isReadOnly\": true,\n          \"isVirtual\": true,\n          \"isMany\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"Node\",\n      \"isAbstract\": true,\n      \"superClass\": [\n        \"DiagramElement\"\n      ]\n    },\n    {\n      \"name\": \"Edge\",\n      \"isAbstract\": true,\n      \"superClass\": [\n        \"DiagramElement\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"source\",\n          \"type\": \"DiagramElement\",\n          \"isReadOnly\": true,\n          \"isVirtual\": true,\n          \"isReference\": true\n        },\n        {\n          \"name\": \"target\",\n          \"type\": \"DiagramElement\",\n          \"isReadOnly\": true,\n          \"isVirtual\": true,\n          \"isReference\": true\n        },\n        {\n          \"name\": \"waypoint\",\n          \"isUnique\": false,\n          \"isMany\": true,\n          \"type\": \"dc:Point\",\n          \"xml\": {\n            \"serialize\": \"xsi:type\"\n          }\n        }\n      ]\n    },\n    {\n      \"name\": \"Diagram\",\n      \"isAbstract\": true,\n      \"properties\": [\n        {\n          \"name\": \"id\",\n          \"type\": \"String\",\n          \"isAttr\": true,\n          \"isId\": true\n        },\n        {\n          \"name\": \"rootElement\",\n          \"type\": \"DiagramElement\",\n          \"isReadOnly\": true,\n          \"isVirtual\": true\n        },\n        {\n          \"name\": \"name\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        },\n        {\n          \"name\": \"documentation\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        },\n        {\n          \"name\": \"resolution\",\n          \"isAttr\": true,\n          \"type\": \"Real\"\n        },\n        {\n          \"name\": \"ownedStyle\",\n          \"type\": \"Style\",\n          \"isReadOnly\": true,\n          \"isVirtual\": true,\n          \"isMany\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"Shape\",\n      \"isAbstract\": true,\n      \"superClass\": [\n        \"Node\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"bounds\",\n          \"type\": \"dc:Bounds\"\n        }\n      ]\n    },\n    {\n      \"name\": \"Plane\",\n      \"isAbstract\": true,\n      \"superClass\": [\n        \"Node\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"planeElement\",\n          \"type\": \"DiagramElement\",\n          \"subsettedProperty\": \"DiagramElement-ownedElement\",\n          \"isMany\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"LabeledEdge\",\n      \"isAbstract\": true,\n      \"superClass\": [\n        \"Edge\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"ownedLabel\",\n          \"type\": \"Label\",\n          \"isReadOnly\": true,\n          \"subsettedProperty\": \"DiagramElement-ownedElement\",\n          \"isVirtual\": true,\n          \"isMany\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"LabeledShape\",\n      \"isAbstract\": true,\n      \"superClass\": [\n        \"Shape\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"ownedLabel\",\n          \"type\": \"Label\",\n          \"isReadOnly\": true,\n          \"subsettedProperty\": \"DiagramElement-ownedElement\",\n          \"isVirtual\": true,\n          \"isMany\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"Label\",\n      \"isAbstract\": true,\n      \"superClass\": [\n        \"Node\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"bounds\",\n          \"type\": \"dc:Bounds\"\n        }\n      ]\n    },\n    {\n      \"name\": \"Style\",\n      \"isAbstract\": true,\n      \"properties\": [\n        {\n          \"name\": \"id\",\n          \"type\": \"String\",\n          \"isAttr\": true,\n          \"isId\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"Extension\",\n      \"properties\": [\n        {\n          \"name\": \"values\",\n          \"type\": \"Element\",\n          \"isMany\": true\n        }\n      ]\n    }\n  ],\n  \"associations\": [],\n  \"prefix\": \"di\",\n  \"xml\": {\n    \"tagAlias\": \"lowerCase\"\n  }\n}","module.exports={\n  \"name\": \"VDML\",\n  \"uri\": \"http://www.omg.org/spec/VDML/20100524/MODEL\",\n  \"associations\": [],\n  \"types\": [\n    {\n      \"name\": \"EcoMap\",\n      \"superClass\": [\n        \"FlowElementsContainer\",\n        \"RootElement\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"ecoType\",\n          \"type\": \"EcoType\",\n          \"isAttr\": true\n        },\n        {\n          \"name\": \"properties\",\n          \"type\": \"Property\",\n          \"isMany\": true\n        },\n        {\n          \"name\": \"flowElements\",\n          \"type\": \"FlowElement\",\n          \"isMany\": true,\n          \"replaces\": \"FlowElementsContainer#flowElements\"\n        },\n        {\n          \"name\": \"artifacts\",\n          \"type\": \"Artifact\",\n          \"isMany\": true\n        }\n      ]\n    },\n    {\r\n      \"name\": \"RootElement\",\r\n      \"isAbstract\": true,\r\n      \"superClass\": [\r\n        \"BaseElement\"\r\n      ]\r\n    },\n    {\n      \"name\": \"Relationship\",\n      \"superClass\": [\n        \"BaseElement\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"type\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        },\n        {\n          \"name\": \"direction\",\n          \"type\": \"RelationshipDirection\",\n          \"isAttr\": true\n        },\n        {\n          \"name\": \"source\",\n          \"isMany\": true,\n          \"isReference\": true,\n          \"type\": \"Element\"\n        },\n        {\n          \"name\": \"target\",\n          \"isMany\": true,\n          \"isReference\": true,\n          \"type\": \"Element\"\n        }\n      ]\n    },\n    {\r\n      \"name\": \"RelationshipDirection\",\r\n      \"literalValues\": [\r\n        {\r\n          \"name\": \"None\"\r\n        },\r\n        {\r\n          \"name\": \"Forward\"\r\n        },\r\n        {\r\n          \"name\": \"Backward\"\r\n        },\r\n        {\r\n          \"name\": \"Both\"\r\n        }\r\n      ]\r\n    },\n    {\n      \"name\": \"BaseElement\",\n      \"isAbstract\": true,\n      \"properties\": [\n        {\n          \"name\": \"id\",\n          \"isAttr\": true,\n          \"type\": \"String\",\n          \"isId\": true\n        },\n        {\n          \"name\": \"documentation\",\n          \"type\": \"Documentation\",\n          \"isMany\": true\n        },\n        {\n          \"name\": \"extensionDefinitions\",\n          \"type\": \"ExtensionDefinition\",\n          \"isMany\": true,\n          \"isReference\": true\n        },\n        {\n          \"name\": \"extensionElements\",\n          \"type\": \"ExtensionElements\"\n        }\n      ]\n    },\n    {\n      \"name\": \"Extension\",\n      \"properties\": [\n        {\n          \"name\": \"mustUnderstand\",\n          \"default\": false,\n          \"isAttr\": true,\n          \"type\": \"Boolean\"\n        },\n        {\n          \"name\": \"definition\",\n          \"type\": \"ExtensionDefinition\"\n        }\n      ]\n    },\n    {\n      \"name\": \"ExtensionDefinition\",\n      \"properties\": [\n        {\n          \"name\": \"name\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        },\n        {\n          \"name\": \"extensionAttributeDefinitions\",\n          \"type\": \"ExtensionAttributeDefinition\",\n          \"isMany\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"ExtensionAttributeDefinition\",\n      \"properties\": [\n        {\n          \"name\": \"name\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        },\n        {\n          \"name\": \"type\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        },\n        {\n          \"name\": \"isReference\",\n          \"default\": false,\n          \"isAttr\": true,\n          \"type\": \"Boolean\"\n        },\n        {\n          \"name\": \"extensionDefinition\",\n          \"type\": \"ExtensionDefinition\",\n          \"isAttr\": true,\n          \"isReference\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"ExtensionElements\",\n      \"properties\": [\n        {\n          \"name\": \"valueRef\",\n          \"isAttr\": true,\n          \"isReference\": true,\n          \"type\": \"Element\"\n        },\n        {\n          \"name\": \"values\",\n          \"type\": \"Element\",\n          \"isMany\": true\n        },\n        {\n          \"name\": \"extensionAttributeDefinition\",\n          \"type\": \"ExtensionAttributeDefinition\",\n          \"isAttr\": true,\n          \"isReference\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"Documentation\",\n      \"superClass\": [\n        \"BaseElement\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"text\",\n          \"type\": \"String\",\n          \"isBody\": true\n        },\n        {\n          \"name\": \"textFormat\",\n          \"default\": \"text/plain\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        }\n      ]\n    },\n    {\n      \"name\": \"Property\",\n      \"superClass\": [\n        \"ItemAwareElement\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"name\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        }\n      ]\n    },\n    {\n      \"name\": \"DataObject\",\n      \"superClass\": [\n        \"FlowElement\",\n        \"ItemAwareElement\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"isCollection\",\n          \"default\": false,\n          \"isAttr\": true,\n          \"type\": \"Boolean\"\n        }\n      ]\n    },\n    {\n      \"name\": \"DataObjectReference\",\n      \"superClass\": [\n        \"ItemAwareElement\",\n        \"FlowElement\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"dataObjectRef\",\n          \"type\": \"DataObject\",\n          \"isAttr\": true,\n          \"isReference\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"Error\",\n      \"superClass\": [\n        \"RootElement\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"structureRef\",\n          \"type\": \"ItemDefinition\",\n          \"isAttr\": true,\n          \"isReference\": true\n        },\n        {\n          \"name\": \"name\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        },\n        {\n          \"name\": \"errorCode\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        }\n      ]\n    },\n    {\n      \"name\": \"Message\",\n      \"superClass\": [\n        \"RootElement\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"name\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        },\n        {\n          \"name\": \"itemRef\",\n          \"type\": \"ItemDefinition\",\n          \"isAttr\": true,\n          \"isReference\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"ItemDefinition\",\n      \"superClass\": [\n        \"RootElement\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"itemKind\",\n          \"type\": \"ItemKind\",\n          \"isAttr\": true\n        },\n        {\n          \"name\": \"structureRef\",\n          \"type\": \"String\",\n          \"isAttr\": true\n        },\n        {\n          \"name\": \"isCollection\",\n          \"default\": false,\n          \"isAttr\": true,\n          \"type\": \"Boolean\"\n        }\n      ]\n    },\n    {\n      \"name\": \"FlowElement\",\n      \"isAbstract\": true,\n      \"superClass\": [\n        \"BaseElement\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"name\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        },\n        {\n          \"name\": \"categoryValueRef\",\n          \"type\": \"CategoryValue\",\n          \"isMany\": true,\n          \"isReference\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"SequenceFlow\",\n      \"superClass\": [\n        \"FlowElement\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"isImmediate\",\n          \"isAttr\": true,\n          \"type\": \"Boolean\"\n        },\n        {\n          \"name\": \"sourceRef\",\n          \"type\": \"FlowNode\",\n          \"isAttr\": true,\n          \"isReference\": true\n        },\n        {\n          \"name\": \"targetRef\",\n          \"type\": \"FlowNode\",\n          \"isAttr\": true,\n          \"isReference\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"FlowElementsContainer\",\n      \"isAbstract\": true,\n      \"superClass\": [\n        \"BaseElement\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"flowElements\",\n          \"type\": \"FlowElement\",\n          \"isMany\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"FlowNode\",\n      \"isAbstract\": true,\n      \"superClass\": [\n        \"FlowElement\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"incoming\",\n          \"type\": \"SequenceFlow\",\n          \"isMany\": true,\n          \"isReference\": true\n        },\n        {\n          \"name\": \"outgoing\",\n          \"type\": \"SequenceFlow\",\n          \"isMany\": true,\n          \"isReference\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"Resource\",\n      \"superClass\": [\n        \"RootElement\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"name\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        },\n        {\n          \"name\": \"resourceParameters\",\n          \"type\": \"ResourceParameter\",\n          \"isMany\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"ResourceParameter\",\n      \"superClass\": [\n        \"BaseElement\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"name\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        },\n        {\n          \"name\": \"isRequired\",\n          \"isAttr\": true,\n          \"type\": \"Boolean\"\n        },\n        {\n          \"name\": \"type\",\n          \"type\": \"ItemDefinition\",\n          \"isAttr\": true,\n          \"isReference\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"CorrelationSubscription\",\n      \"superClass\": [\n        \"BaseElement\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"correlationKeyRef\",\n          \"type\": \"CorrelationKey\",\n          \"isAttr\": true,\n          \"isReference\": true\n        },\n        {\n          \"name\": \"correlationPropertyBinding\",\n          \"type\": \"CorrelationPropertyBinding\",\n          \"isMany\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"MessageFlow\",\n      \"superClass\": [\n        \"BaseElement\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"name\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        },\n        {\n          \"name\": \"sourceRef\",\n          \"type\": \"InteractionNode\",\n          \"isAttr\": true,\n          \"isReference\": true\n        },\n        {\n          \"name\": \"targetRef\",\n          \"type\": \"InteractionNode\",\n          \"isAttr\": true,\n          \"isReference\": true\n        },\n        {\n          \"name\": \"messageRef\",\n          \"type\": \"Message\",\n          \"isAttr\": true,\n          \"isReference\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"MessageFlowAssociation\",\n      \"superClass\": [\n        \"BaseElement\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"innerMessageFlowRef\",\n          \"type\": \"MessageFlow\",\n          \"isAttr\": true,\n          \"isReference\": true\n        },\n        {\n          \"name\": \"outerMessageFlowRef\",\n          \"type\": \"MessageFlow\",\n          \"isAttr\": true,\n          \"isReference\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"InteractionNode\",\n      \"isAbstract\": true,\n      \"properties\": [\n        {\n          \"name\": \"incomingConversationLinks\",\n          \"type\": \"ConversationLink\",\n          \"isVirtual\": true,\n          \"isMany\": true,\n          \"isReference\": true\n        },\n        {\n          \"name\": \"outgoingConversationLinks\",\n          \"type\": \"ConversationLink\",\n          \"isVirtual\": true,\n          \"isMany\": true,\n          \"isReference\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"Participant\",\n      \"superClass\": [\n        \"InteractionNode\",\n        \"BaseElement\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"name\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        },\n        {\n          \"name\": \"participantMultiplicity\",\n          \"type\": \"ParticipantMultiplicity\"\n        },\n        {\n          \"name\": \"processRef\",\n          \"type\": \"Process\",\n          \"isAttr\": true,\n          \"isReference\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"ParticipantAssociation\",\n      \"superClass\": [\n        \"BaseElement\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"innerParticipantRef\",\n          \"type\": \"Participant\",\n          \"isAttr\": true,\n          \"isReference\": true\n        },\n        {\n          \"name\": \"outerParticipantRef\",\n          \"type\": \"Participant\",\n          \"isAttr\": true,\n          \"isReference\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"ParticipantMultiplicity\",\n      \"properties\": [\n        {\n          \"name\": \"minimum\",\n          \"default\": 0,\n          \"isAttr\": true,\n          \"type\": \"Integer\"\n        },\n        {\n          \"name\": \"maximum\",\n          \"default\": 1,\n          \"isAttr\": true,\n          \"type\": \"Integer\"\n        }\n      ]\n    },\n    {\n      \"name\": \"TextAnnotation\",\n      \"superClass\": [\n        \"Artifact\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"text\",\n          \"type\": \"String\"\n        },\n        {\n          \"name\": \"textFormat\",\n          \"default\": \"text/plain\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        }\n      ]\n    },\n    {\n      \"name\": \"Group\",\n      \"superClass\": [\n        \"Artifact\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"categoryValueRef\",\n          \"type\": \"CategoryValue\",\n          \"isAttr\": true,\n          \"isReference\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"Association\",\n      \"superClass\": [\n        \"Artifact\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"associationDirection\",\n          \"type\": \"AssociationDirection\",\n          \"isAttr\": true\n        },\n        {\n          \"name\": \"sourceRef\",\n          \"type\": \"BaseElement\",\n          \"isAttr\": true,\n          \"isReference\": true\n        },\n        {\n          \"name\": \"targetRef\",\n          \"type\": \"BaseElement\",\n          \"isAttr\": true,\n          \"isReference\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"Category\",\n      \"superClass\": [\n        \"RootElement\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"categoryValue\",\n          \"type\": \"CategoryValue\",\n          \"isMany\": true\n        },\n        {\n          \"name\": \"name\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        }\n      ]\n    },\n    {\n      \"name\": \"Artifact\",\n      \"isAbstract\": true,\n      \"superClass\": [\n        \"BaseElement\"\n      ]\n    },\n    {\n      \"name\": \"CategoryValue\",\n      \"superClass\": [\n        \"BaseElement\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"categorizedFlowElements\",\n          \"type\": \"FlowElement\",\n          \"isVirtual\": true,\n          \"isMany\": true,\n          \"isReference\": true\n        },\n        {\n          \"name\": \"value\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        }\n      ]\n    },\n    {\n      \"name\": \"Participant\",\n      \"isAbstract\": true,\n      \"superClass\": [\n        \"FlowNode\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"isClosed\",\n          \"isAttr\": true,\n          \"type\": \"Boolean\"\n        },\n        {\n          \"name\": \"participants\",\n          \"type\": \"Participant\",\n          \"isMany\": true\n        },\n        {\n          \"name\": \"messageFlows\",\n          \"type\": \"MessageFlow\",\n          \"isMany\": true\n        },\n        {\n          \"name\": \"artifacts\",\n          \"type\": \"Artifact\",\n          \"isMany\": true\n        },\n        {\n          \"name\": \"conversations\",\n          \"type\": \"ConversationNode\",\n          \"isMany\": true\n        },\n        {\n          \"name\": \"conversationAssociations\",\n          \"type\": \"ConversationAssociation\"\n        },\n        {\n          \"name\": \"participantAssociations\",\n          \"type\": \"ParticipantAssociation\",\n          \"isMany\": true\n        },\n        {\n          \"name\": \"messageFlowAssociations\",\n          \"type\": \"MessageFlowAssociation\",\n          \"isMany\": true\n        },\n        {\n          \"name\": \"correlationKeys\",\n          \"type\": \"CorrelationKey\",\n          \"isMany\": true\n        },\n        {\n          \"name\": \"choreographyRef\",\n          \"type\": \"Choreography\",\n          \"isMany\": true,\n          \"isReference\": true\n        },\n        {\n          \"name\": \"conversationLinks\",\n          \"type\": \"ConversationLink\",\n          \"isMany\": true\n        }       \n      ]\n    },\n    {\n      \"name\": \"Role\",\n      \"superClass\": [\n        \"Participant\",\n        \"InteractionNode\"\n      ]\n    },\n    {\n      \"name\": \"Collaboration\",\n      \"superClass\": [\n        \"Participant\",\n        \"InteractionNode\"\n      ],\n      \"properties\": [\n\n      ]\n    }, \n    {\n      \"name\": \"Actor\",\n      \"superClass\": [\n        \"Participant\",\n        \"InteractionNode\"\n      ]\n    },    \n    {\n      \"name\": \"Definitions\",\n      \"superClass\": [\n        \"BaseElement\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"name\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        },\n        {\n          \"name\": \"targetNamespace\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        },\n        {\n          \"name\": \"expressionLanguage\",\n          \"default\": \"http://www.w3.org/1999/XPath\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        },\n        {\n          \"name\": \"typeLanguage\",\n          \"default\": \"http://www.w3.org/2001/XMLSchema\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        },\n        {\n          \"name\": \"rootElements\",\n          \"type\": \"RootElement\",\n          \"isMany\": true\n        },\n        {\n          \"name\": \"diagrams\",\n          \"isMany\": true,\n          \"type\": \"vdmldi:VDMLDiagram\"\n        },\n        {\n          \"name\": \"exporter\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        },\n        {\n          \"name\": \"relationships\",\n          \"type\": \"Relationship\",\n          \"isMany\": true\n        },\n        {\n          \"name\": \"exporterVersion\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        }\n      ]\n    }\n  ],\n  \"emumerations\": [\n    {\n      \"name\": \"EcoType\",\n      \"literalValues\": [\n        {\n          \"name\": \"Business\"\n        },\n        {\n          \"name\": \"Role\"\n        },\n        {\n          \"name\": \"BusinessModel\"\n        }\n      ]\n    }\n  ],\n  \"prefix\": \"vdml\",\n  \"xml\": {\n    \"tagAlias\": \"lowerCase\",\n    \"typePrefix\": \"t\"\n  }\n}","module.exports={\n  \"name\": \"VDMLDI\",\n  \"uri\": \"http://www.omg.org/spec/VDML/20100524/DI\",\n  \"types\": [\n    {\n      \"name\": \"VDMLDiagram\",\n      \"properties\": [\n        {\n          \"name\": \"plane\",\n          \"type\": \"VDMLPlane\",\n          \"redefines\": \"di:Diagram#rootElement\"\n        },\n        {\n          \"name\": \"labelStyle\",\n          \"type\": \"VDMLLabelStyle\",\n          \"isMany\": true\n        }\n      ],\n      \"superClass\": [\n        \"di:Diagram\"\n      ]\n    },\n    {\n      \"name\": \"VDMLPlane\",\n      \"properties\": [\n        {\n          \"name\": \"vdmlElement\",\n          \"isAttr\": true,\n          \"isReference\": true,\n          \"type\": \"vdml:BaseElement\",\n          \"redefines\": \"di:DiagramElement#modelElement\"\n        }\n      ],\n      \"superClass\": [\n        \"di:Plane\"\n      ]\n    },\n    {\n      \"name\": \"VDMLShape\",\n      \"properties\": [\n        {\n          \"name\": \"vdmlElement\",\n          \"isAttr\": true,\n          \"isReference\": true,\n          \"type\": \"vdml:BaseElement\",\n          \"redefines\": \"di:DiagramElement#modelElement\"\n        },\n        {\n          \"name\": \"isHorizontal\",\n          \"isAttr\": true,\n          \"type\": \"Boolean\"\n        },\n        {\n          \"name\": \"isExpanded\",\n          \"isAttr\": true,\n          \"type\": \"Boolean\"\n        },\n        {\n          \"name\": \"isMarkerVisible\",\n          \"isAttr\": true,\n          \"type\": \"Boolean\"\n        },\n        {\n          \"name\": \"label\",\n          \"type\": \"VDMLLabel\"\n        },\n        {\n          \"name\": \"isMessageVisible\",\n          \"isAttr\": true,\n          \"type\": \"Boolean\"\n        },\n        {\n          \"name\": \"participantBandKind\",\n          \"type\": \"ParticipantBandKind\",\n          \"isAttr\": true\n        },\n        {\n          \"name\": \"choreographyActivityShape\",\n          \"type\": \"VDMLShape\",\n          \"isAttr\": true,\n          \"isReference\": true\n        }\n      ],\n      \"superClass\": [\n        \"di:LabeledShape\"\n      ]\n    },\n    {\n      \"name\": \"VDMLEdge\",\n      \"properties\": [\n        {\n          \"name\": \"label\",\n          \"type\": \"VDMLLabel\"\n        },\n        {\n          \"name\": \"vdmlElement\",\n          \"isAttr\": true,\n          \"isReference\": true,\n          \"type\": \"vdml:BaseElement\",\n          \"redefines\": \"di:DiagramElement#modelElement\"\n        },\n        {\n          \"name\": \"sourceElement\",\n          \"isAttr\": true,\n          \"isReference\": true,\n          \"type\": \"di:DiagramElement\",\n          \"redefines\": \"di:Edge#source\"\n        },\n        {\n          \"name\": \"targetElement\",\n          \"isAttr\": true,\n          \"isReference\": true,\n          \"type\": \"di:DiagramElement\",\n          \"redefines\": \"di:Edge#target\"\n        },\n        {\n          \"name\": \"messageVisibleKind\",\n          \"type\": \"MessageVisibleKind\",\n          \"isAttr\": true,\n          \"default\": \"initiating\"\n        }\n      ],\n      \"superClass\": [\n        \"di:LabeledEdge\"\n      ]\n    },\n    {\n      \"name\": \"VDMLLabel\",\n      \"properties\": [\n        {\n          \"name\": \"labelStyle\",\n          \"type\": \"VDMLLabelStyle\",\n          \"isAttr\": true,\n          \"isReference\": true,\n          \"redefines\": \"di:DiagramElement#style\"\n        }\n      ],\n      \"superClass\": [\n        \"di:Label\"\n      ]\n    },\n    {\n      \"name\": \"VDMLLabelStyle\",\n      \"properties\": [\n        {\n          \"name\": \"font\",\n          \"type\": \"dc:Font\"\n        }\n      ],\n      \"superClass\": [\n        \"di:Style\"\n      ]\n    }\n  ],\n  \"emumerations\": [\n    {\n      \"name\": \"ParticipantBandKind\",\n      \"literalValues\": [\n        {\n          \"name\": \"top_initiating\"\n        },\n        {\n          \"name\": \"middle_initiating\"\n        },\n        {\n          \"name\": \"bottom_initiating\"\n        },\n        {\n          \"name\": \"top_non_initiating\"\n        },\n        {\n          \"name\": \"middle_non_initiating\"\n        },\n        {\n          \"name\": \"bottom_non_initiating\"\n        }\n      ]\n    },\n    {\n      \"name\": \"MessageVisibleKind\",\n      \"literalValues\": [\n        {\n          \"name\": \"initiating\"\n        },\n        {\n          \"name\": \"non_initiating\"\n        }\n      ]\n    }\n  ],\n  \"associations\": [],\n  \"prefix\": \"vdmldi\"\n}"]}